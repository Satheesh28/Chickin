/*! jQuery v1.11.1 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */
!function (a, b) { "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function (a) { if (!a.document) throw new Error("jQuery requires a window with a document"); return b(a) } : b(a) }("undefined" != typeof window ? window : this, function (a, b) {
    var c = [], d = c.slice, e = c.concat, f = c.push, g = c.indexOf, h = {}, i = h.toString, j = h.hasOwnProperty, k = {}, l = "1.11.1", m = function (a, b) { return new m.fn.init(a, b) }, n = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, o = /^-ms-/, p = /-([\da-z])/gi, q = function (a, b) { return b.toUpperCase() }; m.fn = m.prototype = { jquery: l, constructor: m, selector: "", length: 0, toArray: function () { return d.call(this) }, get: function (a) { return null != a ? 0 > a ? this[a + this.length] : this[a] : d.call(this) }, pushStack: function (a) { var b = m.merge(this.constructor(), a); return b.prevObject = this, b.context = this.context, b }, each: function (a, b) { return m.each(this, a, b) }, map: function (a) { return this.pushStack(m.map(this, function (b, c) { return a.call(b, c, b) })) }, slice: function () { return this.pushStack(d.apply(this, arguments)) }, first: function () { return this.eq(0) }, last: function () { return this.eq(-1) }, eq: function (a) { var b = this.length, c = +a + (0 > a ? b : 0); return this.pushStack(c >= 0 && b > c ? [this[c]] : []) }, end: function () { return this.prevObject || this.constructor(null) }, push: f, sort: c.sort, splice: c.splice }, m.extend = m.fn.extend = function () { var a, b, c, d, e, f, g = arguments[0] || {}, h = 1, i = arguments.length, j = !1; for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || m.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++)if (null != (e = arguments[h])) for (d in e) a = g[d], c = e[d], g !== c && (j && c && (m.isPlainObject(c) || (b = m.isArray(c))) ? (b ? (b = !1, f = a && m.isArray(a) ? a : []) : f = a && m.isPlainObject(a) ? a : {}, g[d] = m.extend(j, f, c)) : void 0 !== c && (g[d] = c)); return g }, m.extend({ expando: "jQuery" + (l + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (a) { throw new Error(a) }, noop: function () { }, isFunction: function (a) { return "function" === m.type(a) }, isArray: Array.isArray || function (a) { return "array" === m.type(a) }, isWindow: function (a) { return null != a && a == a.window }, isNumeric: function (a) { return !m.isArray(a) && a - parseFloat(a) >= 0 }, isEmptyObject: function (a) { var b; for (b in a) return !1; return !0 }, isPlainObject: function (a) { var b; if (!a || "object" !== m.type(a) || a.nodeType || m.isWindow(a)) return !1; try { if (a.constructor && !j.call(a, "constructor") && !j.call(a.constructor.prototype, "isPrototypeOf")) return !1 } catch (c) { return !1 } if (k.ownLast) for (b in a) return j.call(a, b); for (b in a); return void 0 === b || j.call(a, b) }, type: function (a) { return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? h[i.call(a)] || "object" : typeof a }, globalEval: function (b) { b && m.trim(b) && (a.execScript || function (b) { a.eval.call(a, b) })(b) }, camelCase: function (a) { return a.replace(o, "ms-").replace(p, q) }, nodeName: function (a, b) { return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase() }, each: function (a, b, c) { var d, e = 0, f = a.length, g = r(a); if (c) { if (g) { for (; f > e; e++)if (d = b.apply(a[e], c), d === !1) break } else for (e in a) if (d = b.apply(a[e], c), d === !1) break } else if (g) { for (; f > e; e++)if (d = b.call(a[e], e, a[e]), d === !1) break } else for (e in a) if (d = b.call(a[e], e, a[e]), d === !1) break; return a }, trim: function (a) { return null == a ? "" : (a + "").replace(n, "") }, makeArray: function (a, b) { var c = b || []; return null != a && (r(Object(a)) ? m.merge(c, "string" == typeof a ? [a] : a) : f.call(c, a)), c }, inArray: function (a, b, c) { var d; if (b) { if (g) return g.call(b, a, c); for (d = b.length, c = c ? 0 > c ? Math.max(0, d + c) : c : 0; d > c; c++)if (c in b && b[c] === a) return c } return -1 }, merge: function (a, b) { var c = +b.length, d = 0, e = a.length; while (c > d) a[e++] = b[d++]; if (c !== c) while (void 0 !== b[d]) a[e++] = b[d++]; return a.length = e, a }, grep: function (a, b, c) { for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++)d = !b(a[f], f), d !== h && e.push(a[f]); return e }, map: function (a, b, c) { var d, f = 0, g = a.length, h = r(a), i = []; if (h) for (; g > f; f++)d = b(a[f], f, c), null != d && i.push(d); else for (f in a) d = b(a[f], f, c), null != d && i.push(d); return e.apply([], i) }, guid: 1, proxy: function (a, b) { var c, e, f; return "string" == typeof b && (f = a[b], b = a, a = f), m.isFunction(a) ? (c = d.call(arguments, 2), e = function () { return a.apply(b || this, c.concat(d.call(arguments))) }, e.guid = a.guid = a.guid || m.guid++ , e) : void 0 }, now: function () { return +new Date }, support: k }), m.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (a, b) { h["[object " + b + "]"] = b.toLowerCase() }); function r(a) { var b = a.length, c = m.type(a); return "function" === c || m.isWindow(a) ? !1 : 1 === a.nodeType && b ? !0 : "array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a } var s = function (a) { var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle" + -new Date, v = a.document, w = 0, x = 0, y = gb(), z = gb(), A = gb(), B = function (a, b) { return a === b && (l = !0), 0 }, C = "undefined", D = 1 << 31, E = {}.hasOwnProperty, F = [], G = F.pop, H = F.push, I = F.push, J = F.slice, K = F.indexOf || function (a) { for (var b = 0, c = this.length; c > b; b++)if (this[b] === a) return b; return -1 }, L = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", M = "[\\x20\\t\\r\\n\\f]", N = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", O = N.replace("w", "w#"), P = "\\[" + M + "*(" + N + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + O + "))|)" + M + "*\\]", Q = ":(" + N + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + P + ")*)|.*)\\)|)", R = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"), S = new RegExp("^" + M + "*," + M + "*"), T = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"), U = new RegExp("=" + M + "*([^\\]'\"]*?)" + M + "*\\]", "g"), V = new RegExp(Q), W = new RegExp("^" + O + "$"), X = { ID: new RegExp("^#(" + N + ")"), CLASS: new RegExp("^\\.(" + N + ")"), TAG: new RegExp("^(" + N.replace("w", "w*") + ")"), ATTR: new RegExp("^" + P), PSEUDO: new RegExp("^" + Q), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"), bool: new RegExp("^(?:" + L + ")$", "i"), needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i") }, Y = /^(?:input|select|textarea|button)$/i, Z = /^h\d$/i, $ = /^[^{]+\{\s*\[native \w/, _ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, ab = /[+~]/, bb = /'|\\/g, cb = new RegExp("\\\\([\\da-f]{1,6}" + M + "?|(" + M + ")|.)", "ig"), db = function (a, b, c) { var d = "0x" + b - 65536; return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320) }; try { I.apply(F = J.call(v.childNodes), v.childNodes), F[v.childNodes.length].nodeType } catch (eb) { I = { apply: F.length ? function (a, b) { H.apply(a, J.call(b)) } : function (a, b) { var c = a.length, d = 0; while (a[c++] = b[d++]); a.length = c - 1 } } } function fb(a, b, d, e) { var f, h, j, k, l, o, r, s, w, x; if ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, d = d || [], !a || "string" != typeof a) return d; if (1 !== (k = b.nodeType) && 9 !== k) return []; if (p && !e) { if (f = _.exec(a)) if (j = f[1]) { if (9 === k) { if (h = b.getElementById(j), !h || !h.parentNode) return d; if (h.id === j) return d.push(h), d } else if (b.ownerDocument && (h = b.ownerDocument.getElementById(j)) && t(b, h) && h.id === j) return d.push(h), d } else { if (f[2]) return I.apply(d, b.getElementsByTagName(a)), d; if ((j = f[3]) && c.getElementsByClassName && b.getElementsByClassName) return I.apply(d, b.getElementsByClassName(j)), d } if (c.qsa && (!q || !q.test(a))) { if (s = r = u, w = b, x = 9 === k && a, 1 === k && "object" !== b.nodeName.toLowerCase()) { o = g(a), (r = b.getAttribute("id")) ? s = r.replace(bb, "\\$&") : b.setAttribute("id", s), s = "[id='" + s + "'] ", l = o.length; while (l--) o[l] = s + qb(o[l]); w = ab.test(a) && ob(b.parentNode) || b, x = o.join(",") } if (x) try { return I.apply(d, w.querySelectorAll(x)), d } catch (y) { } finally { r || b.removeAttribute("id") } } } return i(a.replace(R, "$1"), b, d, e) } function gb() { var a = []; function b(c, e) { return a.push(c + " ") > d.cacheLength && delete b[a.shift()], b[c + " "] = e } return b } function hb(a) { return a[u] = !0, a } function ib(a) { var b = n.createElement("div"); try { return !!a(b) } catch (c) { return !1 } finally { b.parentNode && b.parentNode.removeChild(b), b = null } } function jb(a, b) { var c = a.split("|"), e = a.length; while (e--) d.attrHandle[c[e]] = b } function kb(a, b) { var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || D) - (~a.sourceIndex || D); if (d) return d; if (c) while (c = c.nextSibling) if (c === b) return -1; return a ? 1 : -1 } function lb(a) { return function (b) { var c = b.nodeName.toLowerCase(); return "input" === c && b.type === a } } function mb(a) { return function (b) { var c = b.nodeName.toLowerCase(); return ("input" === c || "button" === c) && b.type === a } } function nb(a) { return hb(function (b) { return b = +b, hb(function (c, d) { var e, f = a([], c.length, b), g = f.length; while (g--) c[e = f[g]] && (c[e] = !(d[e] = c[e])) }) }) } function ob(a) { return a && typeof a.getElementsByTagName !== C && a } c = fb.support = {}, f = fb.isXML = function (a) { var b = a && (a.ownerDocument || a).documentElement; return b ? "HTML" !== b.nodeName : !1 }, m = fb.setDocument = function (a) { var b, e = a ? a.ownerDocument || a : v, g = e.defaultView; return e !== n && 9 === e.nodeType && e.documentElement ? (n = e, o = e.documentElement, p = !f(e), g && g !== g.top && (g.addEventListener ? g.addEventListener("unload", function () { m() }, !1) : g.attachEvent && g.attachEvent("onunload", function () { m() })), c.attributes = ib(function (a) { return a.className = "i", !a.getAttribute("className") }), c.getElementsByTagName = ib(function (a) { return a.appendChild(e.createComment("")), !a.getElementsByTagName("*").length }), c.getElementsByClassName = $.test(e.getElementsByClassName) && ib(function (a) { return a.innerHTML = "<div class='a'></div><div class='a i'></div>", a.firstChild.className = "i", 2 === a.getElementsByClassName("i").length }), c.getById = ib(function (a) { return o.appendChild(a).id = u, !e.getElementsByName || !e.getElementsByName(u).length }), c.getById ? (d.find.ID = function (a, b) { if (typeof b.getElementById !== C && p) { var c = b.getElementById(a); return c && c.parentNode ? [c] : [] } }, d.filter.ID = function (a) { var b = a.replace(cb, db); return function (a) { return a.getAttribute("id") === b } }) : (delete d.find.ID, d.filter.ID = function (a) { var b = a.replace(cb, db); return function (a) { var c = typeof a.getAttributeNode !== C && a.getAttributeNode("id"); return c && c.value === b } }), d.find.TAG = c.getElementsByTagName ? function (a, b) { return typeof b.getElementsByTagName !== C ? b.getElementsByTagName(a) : void 0 } : function (a, b) { var c, d = [], e = 0, f = b.getElementsByTagName(a); if ("*" === a) { while (c = f[e++]) 1 === c.nodeType && d.push(c); return d } return f }, d.find.CLASS = c.getElementsByClassName && function (a, b) { return typeof b.getElementsByClassName !== C && p ? b.getElementsByClassName(a) : void 0 }, r = [], q = [], (c.qsa = $.test(e.querySelectorAll)) && (ib(function (a) { a.innerHTML = "<select msallowclip=''><option selected=''></option></select>", a.querySelectorAll("[msallowclip^='']").length && q.push("[*^$]=" + M + "*(?:''|\"\")"), a.querySelectorAll("[selected]").length || q.push("\\[" + M + "*(?:value|" + L + ")"), a.querySelectorAll(":checked").length || q.push(":checked") }), ib(function (a) { var b = e.createElement("input"); b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && q.push("name" + M + "*[*^$|!~]?="), a.querySelectorAll(":enabled").length || q.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), q.push(",.*:") })), (c.matchesSelector = $.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ib(function (a) { c.disconnectedMatch = s.call(a, "div"), s.call(a, "[s!='']:x"), r.push("!=", Q) }), q = q.length && new RegExp(q.join("|")), r = r.length && new RegExp(r.join("|")), b = $.test(o.compareDocumentPosition), t = b || $.test(o.contains) ? function (a, b) { var c = 9 === a.nodeType ? a.documentElement : a, d = b && b.parentNode; return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d))) } : function (a, b) { if (b) while (b = b.parentNode) if (b === a) return !0; return !1 }, B = b ? function (a, b) { if (a === b) return l = !0, 0; var d = !a.compareDocumentPosition - !b.compareDocumentPosition; return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === e || a.ownerDocument === v && t(v, a) ? -1 : b === e || b.ownerDocument === v && t(v, b) ? 1 : k ? K.call(k, a) - K.call(k, b) : 0 : 4 & d ? -1 : 1) } : function (a, b) { if (a === b) return l = !0, 0; var c, d = 0, f = a.parentNode, g = b.parentNode, h = [a], i = [b]; if (!f || !g) return a === e ? -1 : b === e ? 1 : f ? -1 : g ? 1 : k ? K.call(k, a) - K.call(k, b) : 0; if (f === g) return kb(a, b); c = a; while (c = c.parentNode) h.unshift(c); c = b; while (c = c.parentNode) i.unshift(c); while (h[d] === i[d]) d++; return d ? kb(h[d], i[d]) : h[d] === v ? -1 : i[d] === v ? 1 : 0 }, e) : n }, fb.matches = function (a, b) { return fb(a, null, null, b) }, fb.matchesSelector = function (a, b) { if ((a.ownerDocument || a) !== n && m(a), b = b.replace(U, "='$1']"), !(!c.matchesSelector || !p || r && r.test(b) || q && q.test(b))) try { var d = s.call(a, b); if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d } catch (e) { } return fb(b, n, null, [a]).length > 0 }, fb.contains = function (a, b) { return (a.ownerDocument || a) !== n && m(a), t(a, b) }, fb.attr = function (a, b) { (a.ownerDocument || a) !== n && m(a); var e = d.attrHandle[b.toLowerCase()], f = e && E.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0; return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null }, fb.error = function (a) { throw new Error("Syntax error, unrecognized expression: " + a) }, fb.uniqueSort = function (a) { var b, d = [], e = 0, f = 0; if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) { while (b = a[f++]) b === a[f] && (e = d.push(f)); while (e--) a.splice(d[e], 1) } return k = null, a }, e = fb.getText = function (a) { var b, c = "", d = 0, f = a.nodeType; if (f) { if (1 === f || 9 === f || 11 === f) { if ("string" == typeof a.textContent) return a.textContent; for (a = a.firstChild; a; a = a.nextSibling)c += e(a) } else if (3 === f || 4 === f) return a.nodeValue } else while (b = a[d++]) c += e(b); return c }, d = fb.selectors = { cacheLength: 50, createPseudo: hb, match: X, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function (a) { return a[1] = a[1].replace(cb, db), a[3] = (a[3] || a[4] || a[5] || "").replace(cb, db), "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4) }, CHILD: function (a) { return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || fb.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && fb.error(a[0]), a }, PSEUDO: function (a) { var b, c = !a[6] && a[2]; return X.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && V.test(c) && (b = g(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3)) } }, filter: { TAG: function (a) { var b = a.replace(cb, db).toLowerCase(); return "*" === a ? function () { return !0 } : function (a) { return a.nodeName && a.nodeName.toLowerCase() === b } }, CLASS: function (a) { var b = y[a + " "]; return b || (b = new RegExp("(^|" + M + ")" + a + "(" + M + "|$)")) && y(a, function (a) { return b.test("string" == typeof a.className && a.className || typeof a.getAttribute !== C && a.getAttribute("class") || "") }) }, ATTR: function (a, b, c) { return function (d) { var e = fb.attr(d, a); return null == e ? "!=" === b : b ? (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c && 0 === e.indexOf(c) : "*=" === b ? c && e.indexOf(c) > -1 : "$=" === b ? c && e.slice(-c.length) === c : "~=" === b ? (" " + e + " ").indexOf(c) > -1 : "|=" === b ? e === c || e.slice(0, c.length + 1) === c + "-" : !1) : !0 } }, CHILD: function (a, b, c, d, e) { var f = "nth" !== a.slice(0, 3), g = "last" !== a.slice(-4), h = "of-type" === b; return 1 === d && 0 === e ? function (a) { return !!a.parentNode } : function (b, c, i) { var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase(), s = !i && !h; if (q) { if (f) { while (p) { l = b; while (l = l[p]) if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) return !1; o = p = "only" === a && !o && "nextSibling" } return !0 } if (o = [g ? q.firstChild : q.lastChild], g && s) { k = q[u] || (q[u] = {}), j = k[a] || [], n = j[0] === w && j[1], m = j[0] === w && j[2], l = n && q.childNodes[n]; while (l = ++n && l && l[p] || (m = n = 0) || o.pop()) if (1 === l.nodeType && ++m && l === b) { k[a] = [w, n, m]; break } } else if (s && (j = (b[u] || (b[u] = {}))[a]) && j[0] === w) m = j[1]; else while (l = ++n && l && l[p] || (m = n = 0) || o.pop()) if ((h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) && ++m && (s && ((l[u] || (l[u] = {}))[a] = [w, m]), l === b)) break; return m -= e, m === d || m % d === 0 && m / d >= 0 } } }, PSEUDO: function (a, b) { var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || fb.error("unsupported pseudo: " + a); return e[u] ? e(b) : e.length > 1 ? (c = [a, a, "", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? hb(function (a, c) { var d, f = e(a, b), g = f.length; while (g--) d = K.call(a, f[g]), a[d] = !(c[d] = f[g]) }) : function (a) { return e(a, 0, c) }) : e } }, pseudos: { not: hb(function (a) { var b = [], c = [], d = h(a.replace(R, "$1")); return d[u] ? hb(function (a, b, c, e) { var f, g = d(a, null, e, []), h = a.length; while (h--) (f = g[h]) && (a[h] = !(b[h] = f)) }) : function (a, e, f) { return b[0] = a, d(b, null, f, c), !c.pop() } }), has: hb(function (a) { return function (b) { return fb(a, b).length > 0 } }), contains: hb(function (a) { return function (b) { return (b.textContent || b.innerText || e(b)).indexOf(a) > -1 } }), lang: hb(function (a) { return W.test(a || "") || fb.error("unsupported lang: " + a), a = a.replace(cb, db).toLowerCase(), function (b) { var c; do if (c = p ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-"); while ((b = b.parentNode) && 1 === b.nodeType); return !1 } }), target: function (b) { var c = a.location && a.location.hash; return c && c.slice(1) === b.id }, root: function (a) { return a === o }, focus: function (a) { return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex) }, enabled: function (a) { return a.disabled === !1 }, disabled: function (a) { return a.disabled === !0 }, checked: function (a) { var b = a.nodeName.toLowerCase(); return "input" === b && !!a.checked || "option" === b && !!a.selected }, selected: function (a) { return a.parentNode && a.parentNode.selectedIndex, a.selected === !0 }, empty: function (a) { for (a = a.firstChild; a; a = a.nextSibling)if (a.nodeType < 6) return !1; return !0 }, parent: function (a) { return !d.pseudos.empty(a) }, header: function (a) { return Z.test(a.nodeName) }, input: function (a) { return Y.test(a.nodeName) }, button: function (a) { var b = a.nodeName.toLowerCase(); return "input" === b && "button" === a.type || "button" === b }, text: function (a) { var b; return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase()) }, first: nb(function () { return [0] }), last: nb(function (a, b) { return [b - 1] }), eq: nb(function (a, b, c) { return [0 > c ? c + b : c] }), even: nb(function (a, b) { for (var c = 0; b > c; c += 2)a.push(c); return a }), odd: nb(function (a, b) { for (var c = 1; b > c; c += 2)a.push(c); return a }), lt: nb(function (a, b, c) { for (var d = 0 > c ? c + b : c; --d >= 0;)a.push(d); return a }), gt: nb(function (a, b, c) { for (var d = 0 > c ? c + b : c; ++d < b;)a.push(d); return a }) } }, d.pseudos.nth = d.pseudos.eq; for (b in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) d.pseudos[b] = lb(b); for (b in { submit: !0, reset: !0 }) d.pseudos[b] = mb(b); function pb() { } pb.prototype = d.filters = d.pseudos, d.setFilters = new pb, g = fb.tokenize = function (a, b) { var c, e, f, g, h, i, j, k = z[a + " "]; if (k) return b ? 0 : k.slice(0); h = a, i = [], j = d.preFilter; while (h) { (!c || (e = S.exec(h))) && (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = T.exec(h)) && (c = e.shift(), f.push({ value: c, type: e[0].replace(R, " ") }), h = h.slice(c.length)); for (g in d.filter) !(e = X[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({ value: c, type: g, matches: e }), h = h.slice(c.length)); if (!c) break } return b ? h.length : h ? fb.error(a) : z(a, i).slice(0) }; function qb(a) { for (var b = 0, c = a.length, d = ""; c > b; b++)d += a[b].value; return d } function rb(a, b, c) { var d = b.dir, e = c && "parentNode" === d, f = x++; return b.first ? function (b, c, f) { while (b = b[d]) if (1 === b.nodeType || e) return a(b, c, f) } : function (b, c, g) { var h, i, j = [w, f]; if (g) { while (b = b[d]) if ((1 === b.nodeType || e) && a(b, c, g)) return !0 } else while (b = b[d]) if (1 === b.nodeType || e) { if (i = b[u] || (b[u] = {}), (h = i[d]) && h[0] === w && h[1] === f) return j[2] = h[2]; if (i[d] = j, j[2] = a(b, c, g)) return !0 } } } function sb(a) { return a.length > 1 ? function (b, c, d) { var e = a.length; while (e--) if (!a[e](b, c, d)) return !1; return !0 } : a[0] } function tb(a, b, c) { for (var d = 0, e = b.length; e > d; d++)fb(a, b[d], c); return c } function ub(a, b, c, d, e) { for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++)(f = a[h]) && (!c || c(f, d, e)) && (g.push(f), j && b.push(h)); return g } function vb(a, b, c, d, e, f) { return d && !d[u] && (d = vb(d)), e && !e[u] && (e = vb(e, f)), hb(function (f, g, h, i) { var j, k, l, m = [], n = [], o = g.length, p = f || tb(b || "*", h.nodeType ? [h] : h, []), q = !a || !f && b ? p : ub(p, m, a, h, i), r = c ? e || (f ? a : o || d) ? [] : g : q; if (c && c(q, r, h, i), d) { j = ub(r, n), d(j, [], h, i), k = j.length; while (k--) (l = j[k]) && (r[n[k]] = !(q[n[k]] = l)) } if (f) { if (e || a) { if (e) { j = [], k = r.length; while (k--) (l = r[k]) && j.push(q[k] = l); e(null, r = [], j, i) } k = r.length; while (k--) (l = r[k]) && (j = e ? K.call(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l)) } } else r = ub(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : I.apply(g, r) }) } function wb(a) { for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[" "], i = g ? 1 : 0, k = rb(function (a) { return a === b }, h, !0), l = rb(function (a) { return K.call(b, a) > -1 }, h, !0), m = [function (a, c, d) { return !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d)) }]; f > i; i++)if (c = d.relative[a[i].type]) m = [rb(sb(m), c)]; else { if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) { for (e = ++i; f > e; e++)if (d.relative[a[e].type]) break; return vb(i > 1 && sb(m), i > 1 && qb(a.slice(0, i - 1).concat({ value: " " === a[i - 2].type ? "*" : "" })).replace(R, "$1"), c, e > i && wb(a.slice(i, e)), f > e && wb(a = a.slice(e)), f > e && qb(a)) } m.push(c) } return sb(m) } function xb(a, b) { var c = b.length > 0, e = a.length > 0, f = function (f, g, h, i, k) { var l, m, o, p = 0, q = "0", r = f && [], s = [], t = j, u = f || e && d.find.TAG("*", k), v = w += null == t ? 1 : Math.random() || .1, x = u.length; for (k && (j = g !== n && g); q !== x && null != (l = u[q]); q++) { if (e && l) { m = 0; while (o = a[m++]) if (o(l, g, h)) { i.push(l); break } k && (w = v) } c && ((l = !o && l) && p-- , f && r.push(l)) } if (p += q, c && q !== p) { m = 0; while (o = b[m++]) o(r, s, g, h); if (f) { if (p > 0) while (q--) r[q] || s[q] || (s[q] = G.call(i)); s = ub(s) } I.apply(i, s), k && !f && s.length > 0 && p + b.length > 1 && fb.uniqueSort(i) } return k && (w = v, j = t), r }; return c ? hb(f) : f } return h = fb.compile = function (a, b) { var c, d = [], e = [], f = A[a + " "]; if (!f) { b || (b = g(a)), c = b.length; while (c--) f = wb(b[c]), f[u] ? d.push(f) : e.push(f); f = A(a, xb(e, d)), f.selector = a } return f }, i = fb.select = function (a, b, e, f) { var i, j, k, l, m, n = "function" == typeof a && a, o = !f && g(a = n.selector || a); if (e = e || [], 1 === o.length) { if (j = o[0] = o[0].slice(0), j.length > 2 && "ID" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) { if (b = (d.find.ID(k.matches[0].replace(cb, db), b) || [])[0], !b) return e; n && (b = b.parentNode), a = a.slice(j.shift().value.length) } i = X.needsContext.test(a) ? 0 : j.length; while (i--) { if (k = j[i], d.relative[l = k.type]) break; if ((m = d.find[l]) && (f = m(k.matches[0].replace(cb, db), ab.test(j[0].type) && ob(b.parentNode) || b))) { if (j.splice(i, 1), a = f.length && qb(j), !a) return I.apply(e, f), e; break } } } return (n || h(a, o))(f, b, !p, e, ab.test(a) && ob(b.parentNode) || b), e }, c.sortStable = u.split("").sort(B).join("") === u, c.detectDuplicates = !!l, m(), c.sortDetached = ib(function (a) { return 1 & a.compareDocumentPosition(n.createElement("div")) }), ib(function (a) { return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href") }) || jb("type|href|height|width", function (a, b, c) { return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2) }), c.attributes && ib(function (a) { return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value") }) || jb("value", function (a, b, c) { return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue }), ib(function (a) { return null == a.getAttribute("disabled") }) || jb(L, function (a, b, c) { var d; return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null }), fb }(a); m.find = s, m.expr = s.selectors, m.expr[":"] = m.expr.pseudos, m.unique = s.uniqueSort, m.text = s.getText, m.isXMLDoc = s.isXML, m.contains = s.contains; var t = m.expr.match.needsContext, u = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, v = /^.[^:#\[\.,]*$/; function w(a, b, c) { if (m.isFunction(b)) return m.grep(a, function (a, d) { return !!b.call(a, d, a) !== c }); if (b.nodeType) return m.grep(a, function (a) { return a === b !== c }); if ("string" == typeof b) { if (v.test(b)) return m.filter(b, a, c); b = m.filter(b, a) } return m.grep(a, function (a) { return m.inArray(a, b) >= 0 !== c }) } m.filter = function (a, b, c) { var d = b[0]; return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? m.find.matchesSelector(d, a) ? [d] : [] : m.find.matches(a, m.grep(b, function (a) { return 1 === a.nodeType })) }, m.fn.extend({ find: function (a) { var b, c = [], d = this, e = d.length; if ("string" != typeof a) return this.pushStack(m(a).filter(function () { for (b = 0; e > b; b++)if (m.contains(d[b], this)) return !0 })); for (b = 0; e > b; b++)m.find(a, d[b], c); return c = this.pushStack(e > 1 ? m.unique(c) : c), c.selector = this.selector ? this.selector + " " + a : a, c }, filter: function (a) { return this.pushStack(w(this, a || [], !1)) }, not: function (a) { return this.pushStack(w(this, a || [], !0)) }, is: function (a) { return !!w(this, "string" == typeof a && t.test(a) ? m(a) : a || [], !1).length } }); var x, y = a.document, z = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, A = m.fn.init = function (a, b) { var c, d; if (!a) return this; if ("string" == typeof a) { if (c = "<" === a.charAt(0) && ">" === a.charAt(a.length - 1) && a.length >= 3 ? [null, a, null] : z.exec(a), !c || !c[1] && b) return !b || b.jquery ? (b || x).find(a) : this.constructor(b).find(a); if (c[1]) { if (b = b instanceof m ? b[0] : b, m.merge(this, m.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : y, !0)), u.test(c[1]) && m.isPlainObject(b)) for (c in b) m.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]); return this } if (d = y.getElementById(c[2]), d && d.parentNode) { if (d.id !== c[2]) return x.find(a); this.length = 1, this[0] = d } return this.context = y, this.selector = a, this } return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : m.isFunction(a) ? "undefined" != typeof x.ready ? x.ready(a) : a(m) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), m.makeArray(a, this)) }; A.prototype = m.fn, x = m(y); var B = /^(?:parents|prev(?:Until|All))/, C = { children: !0, contents: !0, next: !0, prev: !0 }; m.extend({ dir: function (a, b, c) { var d = [], e = a[b]; while (e && 9 !== e.nodeType && (void 0 === c || 1 !== e.nodeType || !m(e).is(c))) 1 === e.nodeType && d.push(e), e = e[b]; return d }, sibling: function (a, b) { for (var c = []; a; a = a.nextSibling)1 === a.nodeType && a !== b && c.push(a); return c } }), m.fn.extend({ has: function (a) { var b, c = m(a, this), d = c.length; return this.filter(function () { for (b = 0; d > b; b++)if (m.contains(this, c[b])) return !0 }) }, closest: function (a, b) { for (var c, d = 0, e = this.length, f = [], g = t.test(a) || "string" != typeof a ? m(a, b || this.context) : 0; e > d; d++)for (c = this[d]; c && c !== b; c = c.parentNode)if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && m.find.matchesSelector(c, a))) { f.push(c); break } return this.pushStack(f.length > 1 ? m.unique(f) : f) }, index: function (a) { return a ? "string" == typeof a ? m.inArray(this[0], m(a)) : m.inArray(a.jquery ? a[0] : a, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 }, add: function (a, b) { return this.pushStack(m.unique(m.merge(this.get(), m(a, b)))) }, addBack: function (a) { return this.add(null == a ? this.prevObject : this.prevObject.filter(a)) } }); function D(a, b) { do a = a[b]; while (a && 1 !== a.nodeType); return a } m.each({ parent: function (a) { var b = a.parentNode; return b && 11 !== b.nodeType ? b : null }, parents: function (a) { return m.dir(a, "parentNode") }, parentsUntil: function (a, b, c) { return m.dir(a, "parentNode", c) }, next: function (a) { return D(a, "nextSibling") }, prev: function (a) { return D(a, "previousSibling") }, nextAll: function (a) { return m.dir(a, "nextSibling") }, prevAll: function (a) { return m.dir(a, "previousSibling") }, nextUntil: function (a, b, c) { return m.dir(a, "nextSibling", c) }, prevUntil: function (a, b, c) { return m.dir(a, "previousSibling", c) }, siblings: function (a) { return m.sibling((a.parentNode || {}).firstChild, a) }, children: function (a) { return m.sibling(a.firstChild) }, contents: function (a) { return m.nodeName(a, "iframe") ? a.contentDocument || a.contentWindow.document : m.merge([], a.childNodes) } }, function (a, b) { m.fn[a] = function (c, d) { var e = m.map(this, b, c); return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = m.filter(d, e)), this.length > 1 && (C[a] || (e = m.unique(e)), B.test(a) && (e = e.reverse())), this.pushStack(e) } }); var E = /\S+/g, F = {}; function G(a) { var b = F[a] = {}; return m.each(a.match(E) || [], function (a, c) { b[c] = !0 }), b } m.Callbacks = function (a) { a = "string" == typeof a ? F[a] || G(a) : m.extend({}, a); var b, c, d, e, f, g, h = [], i = !a.once && [], j = function (l) { for (c = a.memory && l, d = !0, f = g || 0, g = 0, e = h.length, b = !0; h && e > f; f++)if (h[f].apply(l[0], l[1]) === !1 && a.stopOnFalse) { c = !1; break } b = !1, h && (i ? i.length && j(i.shift()) : c ? h = [] : k.disable()) }, k = { add: function () { if (h) { var d = h.length; !function f(b) { m.each(b, function (b, c) { var d = m.type(c); "function" === d ? a.unique && k.has(c) || h.push(c) : c && c.length && "string" !== d && f(c) }) }(arguments), b ? e = h.length : c && (g = d, j(c)) } return this }, remove: function () { return h && m.each(arguments, function (a, c) { var d; while ((d = m.inArray(c, h, d)) > -1) h.splice(d, 1), b && (e >= d && e-- , f >= d && f--) }), this }, has: function (a) { return a ? m.inArray(a, h) > -1 : !(!h || !h.length) }, empty: function () { return h = [], e = 0, this }, disable: function () { return h = i = c = void 0, this }, disabled: function () { return !h }, lock: function () { return i = void 0, c || k.disable(), this }, locked: function () { return !i }, fireWith: function (a, c) { return !h || d && !i || (c = c || [], c = [a, c.slice ? c.slice() : c], b ? i.push(c) : j(c)), this }, fire: function () { return k.fireWith(this, arguments), this }, fired: function () { return !!d } }; return k }, m.extend({ Deferred: function (a) { var b = [["resolve", "done", m.Callbacks("once memory"), "resolved"], ["reject", "fail", m.Callbacks("once memory"), "rejected"], ["notify", "progress", m.Callbacks("memory")]], c = "pending", d = { state: function () { return c }, always: function () { return e.done(arguments).fail(arguments), this }, then: function () { var a = arguments; return m.Deferred(function (c) { m.each(b, function (b, f) { var g = m.isFunction(a[b]) && a[b]; e[f[1]](function () { var a = g && g.apply(this, arguments); a && m.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [a] : arguments) }) }), a = null }).promise() }, promise: function (a) { return null != a ? m.extend(a, d) : d } }, e = {}; return d.pipe = d.then, m.each(b, function (a, f) { var g = f[2], h = f[3]; d[f[1]] = g.add, h && g.add(function () { c = h }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function () { return e[f[0] + "With"](this === e ? d : this, arguments), this }, e[f[0] + "With"] = g.fireWith }), d.promise(e), a && a.call(e, e), e }, when: function (a) { var b = 0, c = d.call(arguments), e = c.length, f = 1 !== e || a && m.isFunction(a.promise) ? e : 0, g = 1 === f ? a : m.Deferred(), h = function (a, b, c) { return function (e) { b[a] = this, c[a] = arguments.length > 1 ? d.call(arguments) : e, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c) } }, i, j, k; if (e > 1) for (i = new Array(e), j = new Array(e), k = new Array(e); e > b; b++)c[b] && m.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f; return f || g.resolveWith(k, c), g.promise() } }); var H; m.fn.ready = function (a) { return m.ready.promise().done(a), this }, m.extend({ isReady: !1, readyWait: 1, holdReady: function (a) { a ? m.readyWait++ : m.ready(!0) }, ready: function (a) { if (a === !0 ? !--m.readyWait : !m.isReady) { if (!y.body) return setTimeout(m.ready); m.isReady = !0, a !== !0 && --m.readyWait > 0 || (H.resolveWith(y, [m]), m.fn.triggerHandler && (m(y).triggerHandler("ready"), m(y).off("ready"))) } } }); function I() { y.addEventListener ? (y.removeEventListener("DOMContentLoaded", J, !1), a.removeEventListener("load", J, !1)) : (y.detachEvent("onreadystatechange", J), a.detachEvent("onload", J)) } function J() { (y.addEventListener || "load" === event.type || "complete" === y.readyState) && (I(), m.ready()) } m.ready.promise = function (b) { if (!H) if (H = m.Deferred(), "complete" === y.readyState) setTimeout(m.ready); else if (y.addEventListener) y.addEventListener("DOMContentLoaded", J, !1), a.addEventListener("load", J, !1); else { y.attachEvent("onreadystatechange", J), a.attachEvent("onload", J); var c = !1; try { c = null == a.frameElement && y.documentElement } catch (d) { } c && c.doScroll && !function e() { if (!m.isReady) { try { c.doScroll("left") } catch (a) { return setTimeout(e, 50) } I(), m.ready() } }() } return H.promise(b) }; var K = "undefined", L; for (L in m(k)) break; k.ownLast = "0" !== L, k.inlineBlockNeedsLayout = !1, m(function () { var a, b, c, d; c = y.getElementsByTagName("body")[0], c && c.style && (b = y.createElement("div"), d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", c.appendChild(d).appendChild(b), typeof b.style.zoom !== K && (b.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1", k.inlineBlockNeedsLayout = a = 3 === b.offsetWidth, a && (c.style.zoom = 1)), c.removeChild(d)) }), function () { var a = y.createElement("div"); if (null == k.deleteExpando) { k.deleteExpando = !0; try { delete a.test } catch (b) { k.deleteExpando = !1 } } a = null }(), m.acceptData = function (a) { var b = m.noData[(a.nodeName + " ").toLowerCase()], c = +a.nodeType || 1; return 1 !== c && 9 !== c ? !1 : !b || b !== !0 && a.getAttribute("classid") === b }; var M = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, N = /([A-Z])/g; function O(a, b, c) { if (void 0 === c && 1 === a.nodeType) { var d = "data-" + b.replace(N, "-$1").toLowerCase(); if (c = a.getAttribute(d), "string" == typeof c) { try { c = "true" === c ? !0 : "false" === c ? !1 : "null" === c ? null : +c + "" === c ? +c : M.test(c) ? m.parseJSON(c) : c } catch (e) { } m.data(a, b, c) } else c = void 0 } return c } function P(a) { var b; for (b in a) if (("data" !== b || !m.isEmptyObject(a[b])) && "toJSON" !== b) return !1; return !0 } function Q(a, b, d, e) {
        if (m.acceptData(a)) {
            var f, g, h = m.expando, i = a.nodeType, j = i ? m.cache : a, k = i ? a[h] : a[h] && h;
            if (k && j[k] && (e || j[k].data) || void 0 !== d || "string" != typeof b) return k || (k = i ? a[h] = c.pop() || m.guid++ : h), j[k] || (j[k] = i ? {} : { toJSON: m.noop }), ("object" == typeof b || "function" == typeof b) && (e ? j[k] = m.extend(j[k], b) : j[k].data = m.extend(j[k].data, b)), g = j[k], e || (g.data || (g.data = {}), g = g.data), void 0 !== d && (g[m.camelCase(b)] = d), "string" == typeof b ? (f = g[b], null == f && (f = g[m.camelCase(b)])) : f = g, f
        }
    } function R(a, b, c) { if (m.acceptData(a)) { var d, e, f = a.nodeType, g = f ? m.cache : a, h = f ? a[m.expando] : m.expando; if (g[h]) { if (b && (d = c ? g[h] : g[h].data)) { m.isArray(b) ? b = b.concat(m.map(b, m.camelCase)) : b in d ? b = [b] : (b = m.camelCase(b), b = b in d ? [b] : b.split(" ")), e = b.length; while (e--) delete d[b[e]]; if (c ? !P(d) : !m.isEmptyObject(d)) return } (c || (delete g[h].data, P(g[h]))) && (f ? m.cleanData([a], !0) : k.deleteExpando || g != g.window ? delete g[h] : g[h] = null) } } } m.extend({ cache: {}, noData: { "applet ": !0, "embed ": !0, "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" }, hasData: function (a) { return a = a.nodeType ? m.cache[a[m.expando]] : a[m.expando], !!a && !P(a) }, data: function (a, b, c) { return Q(a, b, c) }, removeData: function (a, b) { return R(a, b) }, _data: function (a, b, c) { return Q(a, b, c, !0) }, _removeData: function (a, b) { return R(a, b, !0) } }), m.fn.extend({ data: function (a, b) { var c, d, e, f = this[0], g = f && f.attributes; if (void 0 === a) { if (this.length && (e = m.data(f), 1 === f.nodeType && !m._data(f, "parsedAttrs"))) { c = g.length; while (c--) g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = m.camelCase(d.slice(5)), O(f, d, e[d]))); m._data(f, "parsedAttrs", !0) } return e } return "object" == typeof a ? this.each(function () { m.data(this, a) }) : arguments.length > 1 ? this.each(function () { m.data(this, a, b) }) : f ? O(f, a, m.data(f, a)) : void 0 }, removeData: function (a) { return this.each(function () { m.removeData(this, a) }) } }), m.extend({ queue: function (a, b, c) { var d; return a ? (b = (b || "fx") + "queue", d = m._data(a, b), c && (!d || m.isArray(c) ? d = m._data(a, b, m.makeArray(c)) : d.push(c)), d || []) : void 0 }, dequeue: function (a, b) { b = b || "fx"; var c = m.queue(a, b), d = c.length, e = c.shift(), f = m._queueHooks(a, b), g = function () { m.dequeue(a, b) }; "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire() }, _queueHooks: function (a, b) { var c = b + "queueHooks"; return m._data(a, c) || m._data(a, c, { empty: m.Callbacks("once memory").add(function () { m._removeData(a, b + "queue"), m._removeData(a, c) }) }) } }), m.fn.extend({ queue: function (a, b) { var c = 2; return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? m.queue(this[0], a) : void 0 === b ? this : this.each(function () { var c = m.queue(this, a, b); m._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && m.dequeue(this, a) }) }, dequeue: function (a) { return this.each(function () { m.dequeue(this, a) }) }, clearQueue: function (a) { return this.queue(a || "fx", []) }, promise: function (a, b) { var c, d = 1, e = m.Deferred(), f = this, g = this.length, h = function () { --d || e.resolveWith(f, [f]) }; "string" != typeof a && (b = a, a = void 0), a = a || "fx"; while (g--) c = m._data(f[g], a + "queueHooks"), c && c.empty && (d++ , c.empty.add(h)); return h(), e.promise(b) } }); var S = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, T = ["Top", "Right", "Bottom", "Left"], U = function (a, b) { return a = b || a, "none" === m.css(a, "display") || !m.contains(a.ownerDocument, a) }, V = m.access = function (a, b, c, d, e, f, g) { var h = 0, i = a.length, j = null == c; if ("object" === m.type(c)) { e = !0; for (h in c) m.access(a, b, h, c[h], !0, f, g) } else if (void 0 !== d && (e = !0, m.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function (a, b, c) { return j.call(m(a), c) })), b)) for (; i > h; h++)b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c))); return e ? a : j ? b.call(a) : i ? b(a[0], c) : f }, W = /^(?:checkbox|radio)$/i; !function () { var a = y.createElement("input"), b = y.createElement("div"), c = y.createDocumentFragment(); if (b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", k.leadingWhitespace = 3 === b.firstChild.nodeType, k.tbody = !b.getElementsByTagName("tbody").length, k.htmlSerialize = !!b.getElementsByTagName("link").length, k.html5Clone = "<:nav></:nav>" !== y.createElement("nav").cloneNode(!0).outerHTML, a.type = "checkbox", a.checked = !0, c.appendChild(a), k.appendChecked = a.checked, b.innerHTML = "<textarea>x</textarea>", k.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue, c.appendChild(b), b.innerHTML = "<input type='radio' checked='checked' name='t'/>", k.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, k.noCloneEvent = !0, b.attachEvent && (b.attachEvent("onclick", function () { k.noCloneEvent = !1 }), b.cloneNode(!0).click()), null == k.deleteExpando) { k.deleteExpando = !0; try { delete b.test } catch (d) { k.deleteExpando = !1 } } }(), function () { var b, c, d = y.createElement("div"); for (b in { submit: !0, change: !0, focusin: !0 }) c = "on" + b, (k[b + "Bubbles"] = c in a) || (d.setAttribute(c, "t"), k[b + "Bubbles"] = d.attributes[c].expando === !1); d = null }(); var X = /^(?:input|select|textarea)$/i, Y = /^key/, Z = /^(?:mouse|pointer|contextmenu)|click/, $ = /^(?:focusinfocus|focusoutblur)$/, _ = /^([^.]*)(?:\.(.+)|)$/; function ab() { return !0 } function bb() { return !1 } function cb() { try { return y.activeElement } catch (a) { } } m.event = { global: {}, add: function (a, b, c, d, e) { var f, g, h, i, j, k, l, n, o, p, q, r = m._data(a); if (r) { c.handler && (i = c, c = i.handler, e = i.selector), c.guid || (c.guid = m.guid++), (g = r.events) || (g = r.events = {}), (k = r.handle) || (k = r.handle = function (a) { return typeof m === K || a && m.event.triggered === a.type ? void 0 : m.event.dispatch.apply(k.elem, arguments) }, k.elem = a), b = (b || "").match(E) || [""], h = b.length; while (h--) f = _.exec(b[h]) || [], o = q = f[1], p = (f[2] || "").split(".").sort(), o && (j = m.event.special[o] || {}, o = (e ? j.delegateType : j.bindType) || o, j = m.event.special[o] || {}, l = m.extend({ type: o, origType: q, data: d, handler: c, guid: c.guid, selector: e, needsContext: e && m.expr.match.needsContext.test(e), namespace: p.join(".") }, i), (n = g[o]) || (n = g[o] = [], n.delegateCount = 0, j.setup && j.setup.call(a, d, p, k) !== !1 || (a.addEventListener ? a.addEventListener(o, k, !1) : a.attachEvent && a.attachEvent("on" + o, k))), j.add && (j.add.call(a, l), l.handler.guid || (l.handler.guid = c.guid)), e ? n.splice(n.delegateCount++, 0, l) : n.push(l), m.event.global[o] = !0); a = null } }, remove: function (a, b, c, d, e) { var f, g, h, i, j, k, l, n, o, p, q, r = m.hasData(a) && m._data(a); if (r && (k = r.events)) { b = (b || "").match(E) || [""], j = b.length; while (j--) if (h = _.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o) { l = m.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, n = k[o] || [], h = h[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), i = f = n.length; while (f--) g = n[f], !e && q !== g.origType || c && c.guid !== g.guid || h && !h.test(g.namespace) || d && d !== g.selector && ("**" !== d || !g.selector) || (n.splice(f, 1), g.selector && n.delegateCount-- , l.remove && l.remove.call(a, g)); i && !n.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || m.removeEvent(a, o, r.handle), delete k[o]) } else for (o in k) m.event.remove(a, o + b[j], c, d, !0); m.isEmptyObject(k) && (delete r.handle, m._removeData(a, "events")) } }, trigger: function (b, c, d, e) { var f, g, h, i, k, l, n, o = [d || y], p = j.call(b, "type") ? b.type : b, q = j.call(b, "namespace") ? b.namespace.split(".") : []; if (h = l = d = d || y, 3 !== d.nodeType && 8 !== d.nodeType && !$.test(p + m.event.triggered) && (p.indexOf(".") >= 0 && (q = p.split("."), p = q.shift(), q.sort()), g = p.indexOf(":") < 0 && "on" + p, b = b[m.expando] ? b : new m.Event(p, "object" == typeof b && b), b.isTrigger = e ? 2 : 3, b.namespace = q.join("."), b.namespace_re = b.namespace ? new RegExp("(^|\\.)" + q.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = d), c = null == c ? [b] : m.makeArray(c, [b]), k = m.event.special[p] || {}, e || !k.trigger || k.trigger.apply(d, c) !== !1)) { if (!e && !k.noBubble && !m.isWindow(d)) { for (i = k.delegateType || p, $.test(i + p) || (h = h.parentNode); h; h = h.parentNode)o.push(h), l = h; l === (d.ownerDocument || y) && o.push(l.defaultView || l.parentWindow || a) } n = 0; while ((h = o[n++]) && !b.isPropagationStopped()) b.type = n > 1 ? i : k.bindType || p, f = (m._data(h, "events") || {})[b.type] && m._data(h, "handle"), f && f.apply(h, c), f = g && h[g], f && f.apply && m.acceptData(h) && (b.result = f.apply(h, c), b.result === !1 && b.preventDefault()); if (b.type = p, !e && !b.isDefaultPrevented() && (!k._default || k._default.apply(o.pop(), c) === !1) && m.acceptData(d) && g && d[p] && !m.isWindow(d)) { l = d[g], l && (d[g] = null), m.event.triggered = p; try { d[p]() } catch (r) { } m.event.triggered = void 0, l && (d[g] = l) } return b.result } }, dispatch: function (a) { a = m.event.fix(a); var b, c, e, f, g, h = [], i = d.call(arguments), j = (m._data(this, "events") || {})[a.type] || [], k = m.event.special[a.type] || {}; if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) { h = m.event.handlers.call(this, a, j), b = 0; while ((f = h[b++]) && !a.isPropagationStopped()) { a.currentTarget = f.elem, g = 0; while ((e = f.handlers[g++]) && !a.isImmediatePropagationStopped()) (!a.namespace_re || a.namespace_re.test(e.namespace)) && (a.handleObj = e, a.data = e.data, c = ((m.event.special[e.origType] || {}).handle || e.handler).apply(f.elem, i), void 0 !== c && (a.result = c) === !1 && (a.preventDefault(), a.stopPropagation())) } return k.postDispatch && k.postDispatch.call(this, a), a.result } }, handlers: function (a, b) { var c, d, e, f, g = [], h = b.delegateCount, i = a.target; if (h && i.nodeType && (!a.button || "click" !== a.type)) for (; i != this; i = i.parentNode || this)if (1 === i.nodeType && (i.disabled !== !0 || "click" !== a.type)) { for (e = [], f = 0; h > f; f++)d = b[f], c = d.selector + " ", void 0 === e[c] && (e[c] = d.needsContext ? m(c, this).index(i) >= 0 : m.find(c, this, null, [i]).length), e[c] && e.push(d); e.length && g.push({ elem: i, handlers: e }) } return h < b.length && g.push({ elem: this, handlers: b.slice(h) }), g }, fix: function (a) { if (a[m.expando]) return a; var b, c, d, e = a.type, f = a, g = this.fixHooks[e]; g || (this.fixHooks[e] = g = Z.test(e) ? this.mouseHooks : Y.test(e) ? this.keyHooks : {}), d = g.props ? this.props.concat(g.props) : this.props, a = new m.Event(f), b = d.length; while (b--) c = d[b], a[c] = f[c]; return a.target || (a.target = f.srcElement || y), 3 === a.target.nodeType && (a.target = a.target.parentNode), a.metaKey = !!a.metaKey, g.filter ? g.filter(a, f) : a }, props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "), fixHooks: {}, keyHooks: { props: "char charCode key keyCode".split(" "), filter: function (a, b) { return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a } }, mouseHooks: { props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "), filter: function (a, b) { var c, d, e, f = b.button, g = b.fromElement; return null == a.pageX && null != b.clientX && (d = a.target.ownerDocument || y, e = d.documentElement, c = d.body, a.pageX = b.clientX + (e && e.scrollLeft || c && c.scrollLeft || 0) - (e && e.clientLeft || c && c.clientLeft || 0), a.pageY = b.clientY + (e && e.scrollTop || c && c.scrollTop || 0) - (e && e.clientTop || c && c.clientTop || 0)), !a.relatedTarget && g && (a.relatedTarget = g === a.target ? b.toElement : g), a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0), a } }, special: { load: { noBubble: !0 }, focus: { trigger: function () { if (this !== cb() && this.focus) try { return this.focus(), !1 } catch (a) { } }, delegateType: "focusin" }, blur: { trigger: function () { return this === cb() && this.blur ? (this.blur(), !1) : void 0 }, delegateType: "focusout" }, click: { trigger: function () { return m.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(), !1) : void 0 }, _default: function (a) { return m.nodeName(a.target, "a") } }, beforeunload: { postDispatch: function (a) { void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result) } } }, simulate: function (a, b, c, d) { var e = m.extend(new m.Event, c, { type: a, isSimulated: !0, originalEvent: {} }); d ? m.event.trigger(e, null, b) : m.event.dispatch.call(b, e), e.isDefaultPrevented() && c.preventDefault() } }, m.removeEvent = y.removeEventListener ? function (a, b, c) { a.removeEventListener && a.removeEventListener(b, c, !1) } : function (a, b, c) { var d = "on" + b; a.detachEvent && (typeof a[d] === K && (a[d] = null), a.detachEvent(d, c)) }, m.Event = function (a, b) { return this instanceof m.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? ab : bb) : this.type = a, b && m.extend(this, b), this.timeStamp = a && a.timeStamp || m.now(), void (this[m.expando] = !0)) : new m.Event(a, b) }, m.Event.prototype = { isDefaultPrevented: bb, isPropagationStopped: bb, isImmediatePropagationStopped: bb, preventDefault: function () { var a = this.originalEvent; this.isDefaultPrevented = ab, a && (a.preventDefault ? a.preventDefault() : a.returnValue = !1) }, stopPropagation: function () { var a = this.originalEvent; this.isPropagationStopped = ab, a && (a.stopPropagation && a.stopPropagation(), a.cancelBubble = !0) }, stopImmediatePropagation: function () { var a = this.originalEvent; this.isImmediatePropagationStopped = ab, a && a.stopImmediatePropagation && a.stopImmediatePropagation(), this.stopPropagation() } }, m.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function (a, b) { m.event.special[a] = { delegateType: b, bindType: b, handle: function (a) { var c, d = this, e = a.relatedTarget, f = a.handleObj; return (!e || e !== d && !m.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c } } }), k.submitBubbles || (m.event.special.submit = { setup: function () { return m.nodeName(this, "form") ? !1 : void m.event.add(this, "click._submit keypress._submit", function (a) { var b = a.target, c = m.nodeName(b, "input") || m.nodeName(b, "button") ? b.form : void 0; c && !m._data(c, "submitBubbles") && (m.event.add(c, "submit._submit", function (a) { a._submit_bubble = !0 }), m._data(c, "submitBubbles", !0)) }) }, postDispatch: function (a) { a._submit_bubble && (delete a._submit_bubble, this.parentNode && !a.isTrigger && m.event.simulate("submit", this.parentNode, a, !0)) }, teardown: function () { return m.nodeName(this, "form") ? !1 : void m.event.remove(this, "._submit") } }), k.changeBubbles || (m.event.special.change = { setup: function () { return X.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) && (m.event.add(this, "propertychange._change", function (a) { "checked" === a.originalEvent.propertyName && (this._just_changed = !0) }), m.event.add(this, "click._change", function (a) { this._just_changed && !a.isTrigger && (this._just_changed = !1), m.event.simulate("change", this, a, !0) })), !1) : void m.event.add(this, "beforeactivate._change", function (a) { var b = a.target; X.test(b.nodeName) && !m._data(b, "changeBubbles") && (m.event.add(b, "change._change", function (a) { !this.parentNode || a.isSimulated || a.isTrigger || m.event.simulate("change", this.parentNode, a, !0) }), m._data(b, "changeBubbles", !0)) }) }, handle: function (a) { var b = a.target; return this !== b || a.isSimulated || a.isTrigger || "radio" !== b.type && "checkbox" !== b.type ? a.handleObj.handler.apply(this, arguments) : void 0 }, teardown: function () { return m.event.remove(this, "._change"), !X.test(this.nodeName) } }), k.focusinBubbles || m.each({ focus: "focusin", blur: "focusout" }, function (a, b) { var c = function (a) { m.event.simulate(b, a.target, m.event.fix(a), !0) }; m.event.special[b] = { setup: function () { var d = this.ownerDocument || this, e = m._data(d, b); e || d.addEventListener(a, c, !0), m._data(d, b, (e || 0) + 1) }, teardown: function () { var d = this.ownerDocument || this, e = m._data(d, b) - 1; e ? m._data(d, b, e) : (d.removeEventListener(a, c, !0), m._removeData(d, b)) } } }), m.fn.extend({ on: function (a, b, c, d, e) { var f, g; if ("object" == typeof a) { "string" != typeof b && (c = c || b, b = void 0); for (f in a) this.on(f, b, c, a[f], e); return this } if (null == c && null == d ? (d = b, c = b = void 0) : null == d && ("string" == typeof b ? (d = c, c = void 0) : (d = c, c = b, b = void 0)), d === !1) d = bb; else if (!d) return this; return 1 === e && (g = d, d = function (a) { return m().off(a), g.apply(this, arguments) }, d.guid = g.guid || (g.guid = m.guid++)), this.each(function () { m.event.add(this, a, d, c, b) }) }, one: function (a, b, c, d) { return this.on(a, b, c, d, 1) }, off: function (a, b, c) { var d, e; if (a && a.preventDefault && a.handleObj) return d = a.handleObj, m(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this; if ("object" == typeof a) { for (e in a) this.off(e, b, a[e]); return this } return (b === !1 || "function" == typeof b) && (c = b, b = void 0), c === !1 && (c = bb), this.each(function () { m.event.remove(this, a, c, b) }) }, trigger: function (a, b) { return this.each(function () { m.event.trigger(a, b, this) }) }, triggerHandler: function (a, b) { var c = this[0]; return c ? m.event.trigger(a, b, c, !0) : void 0 } }); function db(a) { var b = eb.split("|"), c = a.createDocumentFragment(); if (c.createElement) while (b.length) c.createElement(b.pop()); return c } var eb = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video", fb = / jQuery\d+="(?:null|\d+)"/g, gb = new RegExp("<(?:" + eb + ")[\\s/>]", "i"), hb = /^\s+/, ib = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, jb = /<([\w:]+)/, kb = /<tbody/i, lb = /<|&#?\w+;/, mb = /<(?:script|style|link)/i, nb = /checked\s*(?:[^=]|=\s*.checked.)/i, ob = /^$|\/(?:java|ecma)script/i, pb = /^true\/(.*)/, qb = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, rb = { option: [1, "<select multiple='multiple'>", "</select>"], legend: [1, "<fieldset>", "</fieldset>"], area: [1, "<map>", "</map>"], param: [1, "<object>", "</object>"], thead: [1, "<table>", "</table>"], tr: [2, "<table><tbody>", "</tbody></table>"], col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: k.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"] }, sb = db(y), tb = sb.appendChild(y.createElement("div")); rb.optgroup = rb.option, rb.tbody = rb.tfoot = rb.colgroup = rb.caption = rb.thead, rb.th = rb.td; function ub(a, b) { var c, d, e = 0, f = typeof a.getElementsByTagName !== K ? a.getElementsByTagName(b || "*") : typeof a.querySelectorAll !== K ? a.querySelectorAll(b || "*") : void 0; if (!f) for (f = [], c = a.childNodes || a; null != (d = c[e]); e++)!b || m.nodeName(d, b) ? f.push(d) : m.merge(f, ub(d, b)); return void 0 === b || b && m.nodeName(a, b) ? m.merge([a], f) : f } function vb(a) { W.test(a.type) && (a.defaultChecked = a.checked) } function wb(a, b) { return m.nodeName(a, "table") && m.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a } function xb(a) { return a.type = (null !== m.find.attr(a, "type")) + "/" + a.type, a } function yb(a) { var b = pb.exec(a.type); return b ? a.type = b[1] : a.removeAttribute("type"), a } function zb(a, b) { for (var c, d = 0; null != (c = a[d]); d++)m._data(c, "globalEval", !b || m._data(b[d], "globalEval")) } function Ab(a, b) { if (1 === b.nodeType && m.hasData(a)) { var c, d, e, f = m._data(a), g = m._data(b, f), h = f.events; if (h) { delete g.handle, g.events = {}; for (c in h) for (d = 0, e = h[c].length; e > d; d++)m.event.add(b, c, h[c][d]) } g.data && (g.data = m.extend({}, g.data)) } } function Bb(a, b) { var c, d, e; if (1 === b.nodeType) { if (c = b.nodeName.toLowerCase(), !k.noCloneEvent && b[m.expando]) { e = m._data(b); for (d in e.events) m.removeEvent(b, d, e.handle); b.removeAttribute(m.expando) } "script" === c && b.text !== a.text ? (xb(b).text = a.text, yb(b)) : "object" === c ? (b.parentNode && (b.outerHTML = a.outerHTML), k.html5Clone && a.innerHTML && !m.trim(b.innerHTML) && (b.innerHTML = a.innerHTML)) : "input" === c && W.test(a.type) ? (b.defaultChecked = b.checked = a.checked, b.value !== a.value && (b.value = a.value)) : "option" === c ? b.defaultSelected = b.selected = a.defaultSelected : ("input" === c || "textarea" === c) && (b.defaultValue = a.defaultValue) } } m.extend({ clone: function (a, b, c) { var d, e, f, g, h, i = m.contains(a.ownerDocument, a); if (k.html5Clone || m.isXMLDoc(a) || !gb.test("<" + a.nodeName + ">") ? f = a.cloneNode(!0) : (tb.innerHTML = a.outerHTML, tb.removeChild(f = tb.firstChild)), !(k.noCloneEvent && k.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || m.isXMLDoc(a))) for (d = ub(f), h = ub(a), g = 0; null != (e = h[g]); ++g)d[g] && Bb(e, d[g]); if (b) if (c) for (h = h || ub(a), d = d || ub(f), g = 0; null != (e = h[g]); g++)Ab(e, d[g]); else Ab(a, f); return d = ub(f, "script"), d.length > 0 && zb(d, !i && ub(a, "script")), d = h = e = null, f }, buildFragment: function (a, b, c, d) { for (var e, f, g, h, i, j, l, n = a.length, o = db(b), p = [], q = 0; n > q; q++)if (f = a[q], f || 0 === f) if ("object" === m.type(f)) m.merge(p, f.nodeType ? [f] : f); else if (lb.test(f)) { h = h || o.appendChild(b.createElement("div")), i = (jb.exec(f) || ["", ""])[1].toLowerCase(), l = rb[i] || rb._default, h.innerHTML = l[1] + f.replace(ib, "<$1></$2>") + l[2], e = l[0]; while (e--) h = h.lastChild; if (!k.leadingWhitespace && hb.test(f) && p.push(b.createTextNode(hb.exec(f)[0])), !k.tbody) { f = "table" !== i || kb.test(f) ? "<table>" !== l[1] || kb.test(f) ? 0 : h : h.firstChild, e = f && f.childNodes.length; while (e--) m.nodeName(j = f.childNodes[e], "tbody") && !j.childNodes.length && f.removeChild(j) } m.merge(p, h.childNodes), h.textContent = ""; while (h.firstChild) h.removeChild(h.firstChild); h = o.lastChild } else p.push(b.createTextNode(f)); h && o.removeChild(h), k.appendChecked || m.grep(ub(p, "input"), vb), q = 0; while (f = p[q++]) if ((!d || -1 === m.inArray(f, d)) && (g = m.contains(f.ownerDocument, f), h = ub(o.appendChild(f), "script"), g && zb(h), c)) { e = 0; while (f = h[e++]) ob.test(f.type || "") && c.push(f) } return h = null, o }, cleanData: function (a, b) { for (var d, e, f, g, h = 0, i = m.expando, j = m.cache, l = k.deleteExpando, n = m.event.special; null != (d = a[h]); h++)if ((b || m.acceptData(d)) && (f = d[i], g = f && j[f])) { if (g.events) for (e in g.events) n[e] ? m.event.remove(d, e) : m.removeEvent(d, e, g.handle); j[f] && (delete j[f], l ? delete d[i] : typeof d.removeAttribute !== K ? d.removeAttribute(i) : d[i] = null, c.push(f)) } } }), m.fn.extend({ text: function (a) { return V(this, function (a) { return void 0 === a ? m.text(this) : this.empty().append((this[0] && this[0].ownerDocument || y).createTextNode(a)) }, null, a, arguments.length) }, append: function () { return this.domManip(arguments, function (a) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var b = wb(this, a); b.appendChild(a) } }) }, prepend: function () { return this.domManip(arguments, function (a) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var b = wb(this, a); b.insertBefore(a, b.firstChild) } }) }, before: function () { return this.domManip(arguments, function (a) { this.parentNode && this.parentNode.insertBefore(a, this) }) }, after: function () { return this.domManip(arguments, function (a) { this.parentNode && this.parentNode.insertBefore(a, this.nextSibling) }) }, remove: function (a, b) { for (var c, d = a ? m.filter(a, this) : this, e = 0; null != (c = d[e]); e++)b || 1 !== c.nodeType || m.cleanData(ub(c)), c.parentNode && (b && m.contains(c.ownerDocument, c) && zb(ub(c, "script")), c.parentNode.removeChild(c)); return this }, empty: function () { for (var a, b = 0; null != (a = this[b]); b++) { 1 === a.nodeType && m.cleanData(ub(a, !1)); while (a.firstChild) a.removeChild(a.firstChild); a.options && m.nodeName(a, "select") && (a.options.length = 0) } return this }, clone: function (a, b) { return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function () { return m.clone(this, a, b) }) }, html: function (a) { return V(this, function (a) { var b = this[0] || {}, c = 0, d = this.length; if (void 0 === a) return 1 === b.nodeType ? b.innerHTML.replace(fb, "") : void 0; if (!("string" != typeof a || mb.test(a) || !k.htmlSerialize && gb.test(a) || !k.leadingWhitespace && hb.test(a) || rb[(jb.exec(a) || ["", ""])[1].toLowerCase()])) { a = a.replace(ib, "<$1></$2>"); try { for (; d > c; c++)b = this[c] || {}, 1 === b.nodeType && (m.cleanData(ub(b, !1)), b.innerHTML = a); b = 0 } catch (e) { } } b && this.empty().append(a) }, null, a, arguments.length) }, replaceWith: function () { var a = arguments[0]; return this.domManip(arguments, function (b) { a = this.parentNode, m.cleanData(ub(this)), a && a.replaceChild(b, this) }), a && (a.length || a.nodeType) ? this : this.remove() }, detach: function (a) { return this.remove(a, !0) }, domManip: function (a, b) { a = e.apply([], a); var c, d, f, g, h, i, j = 0, l = this.length, n = this, o = l - 1, p = a[0], q = m.isFunction(p); if (q || l > 1 && "string" == typeof p && !k.checkClone && nb.test(p)) return this.each(function (c) { var d = n.eq(c); q && (a[0] = p.call(this, c, d.html())), d.domManip(a, b) }); if (l && (i = m.buildFragment(a, this[0].ownerDocument, !1, this), c = i.firstChild, 1 === i.childNodes.length && (i = c), c)) { for (g = m.map(ub(i, "script"), xb), f = g.length; l > j; j++)d = i, j !== o && (d = m.clone(d, !0, !0), f && m.merge(g, ub(d, "script"))), b.call(this[j], d, j); if (f) for (h = g[g.length - 1].ownerDocument, m.map(g, yb), j = 0; f > j; j++)d = g[j], ob.test(d.type || "") && !m._data(d, "globalEval") && m.contains(h, d) && (d.src ? m._evalUrl && m._evalUrl(d.src) : m.globalEval((d.text || d.textContent || d.innerHTML || "").replace(qb, ""))); i = c = null } return this } }), m.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function (a, b) { m.fn[a] = function (a) { for (var c, d = 0, e = [], g = m(a), h = g.length - 1; h >= d; d++)c = d === h ? this : this.clone(!0), m(g[d])[b](c), f.apply(e, c.get()); return this.pushStack(e) } }); var Cb, Db = {}; function Eb(b, c) { var d, e = m(c.createElement(b)).appendTo(c.body), f = a.getDefaultComputedStyle && (d = a.getDefaultComputedStyle(e[0])) ? d.display : m.css(e[0], "display"); return e.detach(), f } function Fb(a) { var b = y, c = Db[a]; return c || (c = Eb(a, b), "none" !== c && c || (Cb = (Cb || m("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement), b = (Cb[0].contentWindow || Cb[0].contentDocument).document, b.write(), b.close(), c = Eb(a, b), Cb.detach()), Db[a] = c), c } !function () { var a; k.shrinkWrapBlocks = function () { if (null != a) return a; a = !1; var b, c, d; return c = y.getElementsByTagName("body")[0], c && c.style ? (b = y.createElement("div"), d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", c.appendChild(d).appendChild(b), typeof b.style.zoom !== K && (b.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1", b.appendChild(y.createElement("div")).style.width = "5px", a = 3 !== b.offsetWidth), c.removeChild(d), a) : void 0 } }(); var Gb = /^margin/, Hb = new RegExp("^(" + S + ")(?!px)[a-z%]+$", "i"), Ib, Jb, Kb = /^(top|right|bottom|left)$/; a.getComputedStyle ? (Ib = function (a) { return a.ownerDocument.defaultView.getComputedStyle(a, null) }, Jb = function (a, b, c) { var d, e, f, g, h = a.style; return c = c || Ib(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, c && ("" !== g || m.contains(a.ownerDocument, a) || (g = m.style(a, b)), Hb.test(g) && Gb.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 === g ? g : g + "" }) : y.documentElement.currentStyle && (Ib = function (a) { return a.currentStyle }, Jb = function (a, b, c) { var d, e, f, g, h = a.style; return c = c || Ib(a), g = c ? c[b] : void 0, null == g && h && h[b] && (g = h[b]), Hb.test(g) && !Kb.test(b) && (d = h.left, e = a.runtimeStyle, f = e && e.left, f && (e.left = a.currentStyle.left), h.left = "fontSize" === b ? "1em" : g, g = h.pixelLeft + "px", h.left = d, f && (e.left = f)), void 0 === g ? g : g + "" || "auto" }); function Lb(a, b) { return { get: function () { var c = a(); if (null != c) return c ? void delete this.get : (this.get = b).apply(this, arguments) } } } !function () { var b, c, d, e, f, g, h; if (b = y.createElement("div"), b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", d = b.getElementsByTagName("a")[0], c = d && d.style) { c.cssText = "float:left;opacity:.5", k.opacity = "0.5" === c.opacity, k.cssFloat = !!c.cssFloat, b.style.backgroundClip = "content-box", b.cloneNode(!0).style.backgroundClip = "", k.clearCloneStyle = "content-box" === b.style.backgroundClip, k.boxSizing = "" === c.boxSizing || "" === c.MozBoxSizing || "" === c.WebkitBoxSizing, m.extend(k, { reliableHiddenOffsets: function () { return null == g && i(), g }, boxSizingReliable: function () { return null == f && i(), f }, pixelPosition: function () { return null == e && i(), e }, reliableMarginRight: function () { return null == h && i(), h } }); function i() { var b, c, d, i; c = y.getElementsByTagName("body")[0], c && c.style && (b = y.createElement("div"), d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", c.appendChild(d).appendChild(b), b.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", e = f = !1, h = !0, a.getComputedStyle && (e = "1%" !== (a.getComputedStyle(b, null) || {}).top, f = "4px" === (a.getComputedStyle(b, null) || { width: "4px" }).width, i = b.appendChild(y.createElement("div")), i.style.cssText = b.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", i.style.marginRight = i.style.width = "0", b.style.width = "1px", h = !parseFloat((a.getComputedStyle(i, null) || {}).marginRight)), b.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", i = b.getElementsByTagName("td"), i[0].style.cssText = "margin:0;border:0;padding:0;display:none", g = 0 === i[0].offsetHeight, g && (i[0].style.display = "", i[1].style.display = "none", g = 0 === i[0].offsetHeight), c.removeChild(d)) } } }(), m.swap = function (a, b, c, d) { var e, f, g = {}; for (f in b) g[f] = a.style[f], a.style[f] = b[f]; e = c.apply(a, d || []); for (f in b) a.style[f] = g[f]; return e }; var Mb = /alpha\([^)]*\)/i, Nb = /opacity\s*=\s*([^)]*)/, Ob = /^(none|table(?!-c[ea]).+)/, Pb = new RegExp("^(" + S + ")(.*)$", "i"), Qb = new RegExp("^([+-])=(" + S + ")", "i"), Rb = { position: "absolute", visibility: "hidden", display: "block" }, Sb = { letterSpacing: "0", fontWeight: "400" }, Tb = ["Webkit", "O", "Moz", "ms"]; function Ub(a, b) { if (b in a) return b; var c = b.charAt(0).toUpperCase() + b.slice(1), d = b, e = Tb.length; while (e--) if (b = Tb[e] + c, b in a) return b; return d } function Vb(a, b) { for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++)d = a[g], d.style && (f[g] = m._data(d, "olddisplay"), c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && U(d) && (f[g] = m._data(d, "olddisplay", Fb(d.nodeName)))) : (e = U(d), (c && "none" !== c || !e) && m._data(d, "olddisplay", e ? c : m.css(d, "display")))); for (g = 0; h > g; g++)d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none")); return a } function Wb(a, b, c) { var d = Pb.exec(b); return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b } function Xb(a, b, c, d, e) { for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2)"margin" === c && (g += m.css(a, c + T[f], !0, e)), d ? ("content" === c && (g -= m.css(a, "padding" + T[f], !0, e)), "margin" !== c && (g -= m.css(a, "border" + T[f] + "Width", !0, e))) : (g += m.css(a, "padding" + T[f], !0, e), "padding" !== c && (g += m.css(a, "border" + T[f] + "Width", !0, e))); return g } function Yb(a, b, c) { var d = !0, e = "width" === b ? a.offsetWidth : a.offsetHeight, f = Ib(a), g = k.boxSizing && "border-box" === m.css(a, "boxSizing", !1, f); if (0 >= e || null == e) { if (e = Jb(a, b, f), (0 > e || null == e) && (e = a.style[b]), Hb.test(e)) return e; d = g && (k.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0 } return e + Xb(a, b, c || (g ? "border" : "content"), d, f) + "px" } m.extend({ cssHooks: { opacity: { get: function (a, b) { if (b) { var c = Jb(a, "opacity"); return "" === c ? "1" : c } } } }, cssNumber: { columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: { "float": k.cssFloat ? "cssFloat" : "styleFloat" }, style: function (a, b, c, d) { if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) { var e, f, g, h = m.camelCase(b), i = a.style; if (b = m.cssProps[h] || (m.cssProps[h] = Ub(i, h)), g = m.cssHooks[b] || m.cssHooks[h], void 0 === c) return g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b]; if (f = typeof c, "string" === f && (e = Qb.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(m.css(a, b)), f = "number"), null != c && c === c && ("number" !== f || m.cssNumber[h] || (c += "px"), k.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), !(g && "set" in g && void 0 === (c = g.set(a, c, d))))) try { i[b] = c } catch (j) { } } }, css: function (a, b, c, d) { var e, f, g, h = m.camelCase(b); return b = m.cssProps[h] || (m.cssProps[h] = Ub(a.style, h)), g = m.cssHooks[b] || m.cssHooks[h], g && "get" in g && (f = g.get(a, !0, c)), void 0 === f && (f = Jb(a, b, d)), "normal" === f && b in Sb && (f = Sb[b]), "" === c || c ? (e = parseFloat(f), c === !0 || m.isNumeric(e) ? e || 0 : f) : f } }), m.each(["height", "width"], function (a, b) { m.cssHooks[b] = { get: function (a, c, d) { return c ? Ob.test(m.css(a, "display")) && 0 === a.offsetWidth ? m.swap(a, Rb, function () { return Yb(a, b, d) }) : Yb(a, b, d) : void 0 }, set: function (a, c, d) { var e = d && Ib(a); return Wb(a, c, d ? Xb(a, b, d, k.boxSizing && "border-box" === m.css(a, "boxSizing", !1, e), e) : 0) } } }), k.opacity || (m.cssHooks.opacity = { get: function (a, b) { return Nb.test((b && a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : b ? "1" : "" }, set: function (a, b) { var c = a.style, d = a.currentStyle, e = m.isNumeric(b) ? "alpha(opacity=" + 100 * b + ")" : "", f = d && d.filter || c.filter || ""; c.zoom = 1, (b >= 1 || "" === b) && "" === m.trim(f.replace(Mb, "")) && c.removeAttribute && (c.removeAttribute("filter"), "" === b || d && !d.filter) || (c.filter = Mb.test(f) ? f.replace(Mb, e) : f + " " + e) } }), m.cssHooks.marginRight = Lb(k.reliableMarginRight, function (a, b) { return b ? m.swap(a, { display: "inline-block" }, Jb, [a, "marginRight"]) : void 0 }), m.each({ margin: "", padding: "", border: "Width" }, function (a, b) { m.cssHooks[a + b] = { expand: function (c) { for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; 4 > d; d++)e[a + T[d] + b] = f[d] || f[d - 2] || f[0]; return e } }, Gb.test(a) || (m.cssHooks[a + b].set = Wb) }), m.fn.extend({ css: function (a, b) { return V(this, function (a, b, c) { var d, e, f = {}, g = 0; if (m.isArray(b)) { for (d = Ib(a), e = b.length; e > g; g++)f[b[g]] = m.css(a, b[g], !1, d); return f } return void 0 !== c ? m.style(a, b, c) : m.css(a, b) }, a, b, arguments.length > 1) }, show: function () { return Vb(this, !0) }, hide: function () { return Vb(this) }, toggle: function (a) { return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function () { U(this) ? m(this).show() : m(this).hide() }) } }); function Zb(a, b, c, d, e) { return new Zb.prototype.init(a, b, c, d, e) } m.Tween = Zb, Zb.prototype = {
        constructor: Zb, init: function (a, b, c, d, e, f) {
            this.elem = a, this.prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (m.cssNumber[c] ? "" : "px")
        }, cur: function () { var a = Zb.propHooks[this.prop]; return a && a.get ? a.get(this) : Zb.propHooks._default.get(this) }, run: function (a) { var b, c = Zb.propHooks[this.prop]; return this.pos = b = this.options.duration ? m.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Zb.propHooks._default.set(this), this }
    }, Zb.prototype.init.prototype = Zb.prototype, Zb.propHooks = { _default: { get: function (a) { var b; return null == a.elem[a.prop] || a.elem.style && null != a.elem.style[a.prop] ? (b = m.css(a.elem, a.prop, ""), b && "auto" !== b ? b : 0) : a.elem[a.prop] }, set: function (a) { m.fx.step[a.prop] ? m.fx.step[a.prop](a) : a.elem.style && (null != a.elem.style[m.cssProps[a.prop]] || m.cssHooks[a.prop]) ? m.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now } } }, Zb.propHooks.scrollTop = Zb.propHooks.scrollLeft = { set: function (a) { a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now) } }, m.easing = { linear: function (a) { return a }, swing: function (a) { return .5 - Math.cos(a * Math.PI) / 2 } }, m.fx = Zb.prototype.init, m.fx.step = {}; var $b, _b, ac = /^(?:toggle|show|hide)$/, bc = new RegExp("^(?:([+-])=|)(" + S + ")([a-z%]*)$", "i"), cc = /queueHooks$/, dc = [ic], ec = { "*": [function (a, b) { var c = this.createTween(a, b), d = c.cur(), e = bc.exec(b), f = e && e[3] || (m.cssNumber[a] ? "" : "px"), g = (m.cssNumber[a] || "px" !== f && +d) && bc.exec(m.css(c.elem, a)), h = 1, i = 20; if (g && g[3] !== f) { f = f || g[3], e = e || [], g = +d || 1; do h = h || ".5", g /= h, m.style(c.elem, a, g + f); while (h !== (h = c.cur() / d) && 1 !== h && --i) } return e && (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]), c }] }; function fc() { return setTimeout(function () { $b = void 0 }), $b = m.now() } function gc(a, b) { var c, d = { height: a }, e = 0; for (b = b ? 1 : 0; 4 > e; e += 2 - b)c = T[e], d["margin" + c] = d["padding" + c] = a; return b && (d.opacity = d.width = a), d } function hc(a, b, c) { for (var d, e = (ec[b] || []).concat(ec["*"]), f = 0, g = e.length; g > f; f++)if (d = e[f].call(c, b, a)) return d } function ic(a, b, c) { var d, e, f, g, h, i, j, l, n = this, o = {}, p = a.style, q = a.nodeType && U(a), r = m._data(a, "fxshow"); c.queue || (h = m._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () { h.unqueued || i() }), h.unqueued++ , n.always(function () { n.always(function () { h.unqueued-- , m.queue(a, "fx").length || h.empty.fire() }) })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [p.overflow, p.overflowX, p.overflowY], j = m.css(a, "display"), l = "none" === j ? m._data(a, "olddisplay") || Fb(a.nodeName) : j, "inline" === l && "none" === m.css(a, "float") && (k.inlineBlockNeedsLayout && "inline" !== Fb(a.nodeName) ? p.zoom = 1 : p.display = "inline-block")), c.overflow && (p.overflow = "hidden", k.shrinkWrapBlocks() || n.always(function () { p.overflow = c.overflow[0], p.overflowX = c.overflow[1], p.overflowY = c.overflow[2] })); for (d in b) if (e = b[d], ac.exec(e)) { if (delete b[d], f = f || "toggle" === e, e === (q ? "hide" : "show")) { if ("show" !== e || !r || void 0 === r[d]) continue; q = !0 } o[d] = r && r[d] || m.style(a, d) } else j = void 0; if (m.isEmptyObject(o)) "inline" === ("none" === j ? Fb(a.nodeName) : j) && (p.display = j); else { r ? "hidden" in r && (q = r.hidden) : r = m._data(a, "fxshow", {}), f && (r.hidden = !q), q ? m(a).show() : n.done(function () { m(a).hide() }), n.done(function () { var b; m._removeData(a, "fxshow"); for (b in o) m.style(a, b, o[b]) }); for (d in o) g = hc(q ? r[d] : 0, d, n), d in r || (r[d] = g.start, q && (g.end = g.start, g.start = "width" === d || "height" === d ? 1 : 0)) } } function jc(a, b) { var c, d, e, f, g; for (c in a) if (d = m.camelCase(c), e = b[d], f = a[c], m.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = m.cssHooks[d], g && "expand" in g) { f = g.expand(f), delete a[d]; for (c in f) c in a || (a[c] = f[c], b[c] = e) } else b[d] = e } function kc(a, b, c) { var d, e, f = 0, g = dc.length, h = m.Deferred().always(function () { delete i.elem }), i = function () { if (e) return !1; for (var b = $b || fc(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++)j.tweens[g].run(f); return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1) }, j = h.promise({ elem: a, props: m.extend({}, b), opts: m.extend(!0, { specialEasing: {} }, c), originalProperties: b, originalOptions: c, startTime: $b || fc(), duration: c.duration, tweens: [], createTween: function (b, c) { var d = m.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing); return j.tweens.push(d), d }, stop: function (b) { var c = 0, d = b ? j.tweens.length : 0; if (e) return this; for (e = !0; d > c; c++)j.tweens[c].run(1); return b ? h.resolveWith(a, [j, b]) : h.rejectWith(a, [j, b]), this } }), k = j.props; for (jc(k, j.opts.specialEasing); g > f; f++)if (d = dc[f].call(j, a, k, j.opts)) return d; return m.map(k, hc, j), m.isFunction(j.opts.start) && j.opts.start.call(a, j), m.fx.timer(m.extend(i, { elem: a, anim: j, queue: j.opts.queue })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always) } m.Animation = m.extend(kc, { tweener: function (a, b) { m.isFunction(a) ? (b = a, a = ["*"]) : a = a.split(" "); for (var c, d = 0, e = a.length; e > d; d++)c = a[d], ec[c] = ec[c] || [], ec[c].unshift(b) }, prefilter: function (a, b) { b ? dc.unshift(a) : dc.push(a) } }), m.speed = function (a, b, c) { var d = a && "object" == typeof a ? m.extend({}, a) : { complete: c || !c && b || m.isFunction(a) && a, duration: a, easing: c && b || b && !m.isFunction(b) && b }; return d.duration = m.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in m.fx.speeds ? m.fx.speeds[d.duration] : m.fx.speeds._default, (null == d.queue || d.queue === !0) && (d.queue = "fx"), d.old = d.complete, d.complete = function () { m.isFunction(d.old) && d.old.call(this), d.queue && m.dequeue(this, d.queue) }, d }, m.fn.extend({ fadeTo: function (a, b, c, d) { return this.filter(U).css("opacity", 0).show().end().animate({ opacity: b }, a, c, d) }, animate: function (a, b, c, d) { var e = m.isEmptyObject(a), f = m.speed(b, c, d), g = function () { var b = kc(this, m.extend({}, a), f); (e || m._data(this, "finish")) && b.stop(!0) }; return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g) }, stop: function (a, b, c) { var d = function (a) { var b = a.stop; delete a.stop, b(c) }; return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), this.each(function () { var b = !0, e = null != a && a + "queueHooks", f = m.timers, g = m._data(this); if (e) g[e] && g[e].stop && d(g[e]); else for (e in g) g[e] && g[e].stop && cc.test(e) && d(g[e]); for (e = f.length; e--;)f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1)); (b || !c) && m.dequeue(this, a) }) }, finish: function (a) { return a !== !1 && (a = a || "fx"), this.each(function () { var b, c = m._data(this), d = c[a + "queue"], e = c[a + "queueHooks"], f = m.timers, g = d ? d.length : 0; for (c.finish = !0, m.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;)f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1)); for (b = 0; g > b; b++)d[b] && d[b].finish && d[b].finish.call(this); delete c.finish }) } }), m.each(["toggle", "show", "hide"], function (a, b) { var c = m.fn[b]; m.fn[b] = function (a, d, e) { return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(gc(b, !0), a, d, e) } }), m.each({ slideDown: gc("show"), slideUp: gc("hide"), slideToggle: gc("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function (a, b) { m.fn[a] = function (a, c, d) { return this.animate(b, a, c, d) } }), m.timers = [], m.fx.tick = function () { var a, b = m.timers, c = 0; for ($b = m.now(); c < b.length; c++)a = b[c], a() || b[c] !== a || b.splice(c--, 1); b.length || m.fx.stop(), $b = void 0 }, m.fx.timer = function (a) { m.timers.push(a), a() ? m.fx.start() : m.timers.pop() }, m.fx.interval = 13, m.fx.start = function () { _b || (_b = setInterval(m.fx.tick, m.fx.interval)) }, m.fx.stop = function () { clearInterval(_b), _b = null }, m.fx.speeds = { slow: 600, fast: 200, _default: 400 }, m.fn.delay = function (a, b) { return a = m.fx ? m.fx.speeds[a] || a : a, b = b || "fx", this.queue(b, function (b, c) { var d = setTimeout(b, a); c.stop = function () { clearTimeout(d) } }) }, function () { var a, b, c, d, e; b = y.createElement("div"), b.setAttribute("className", "t"), b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", d = b.getElementsByTagName("a")[0], c = y.createElement("select"), e = c.appendChild(y.createElement("option")), a = b.getElementsByTagName("input")[0], d.style.cssText = "top:1px", k.getSetAttribute = "t" !== b.className, k.style = /top/.test(d.getAttribute("style")), k.hrefNormalized = "/a" === d.getAttribute("href"), k.checkOn = !!a.value, k.optSelected = e.selected, k.enctype = !!y.createElement("form").enctype, c.disabled = !0, k.optDisabled = !e.disabled, a = y.createElement("input"), a.setAttribute("value", ""), k.input = "" === a.getAttribute("value"), a.value = "t", a.setAttribute("type", "radio"), k.radioValue = "t" === a.value }(); var lc = /\r/g; m.fn.extend({ val: function (a) { var b, c, d, e = this[0]; { if (arguments.length) return d = m.isFunction(a), this.each(function (c) { var e; 1 === this.nodeType && (e = d ? a.call(this, c, m(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : m.isArray(e) && (e = m.map(e, function (a) { return null == a ? "" : a + "" })), b = m.valHooks[this.type] || m.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e)) }); if (e) return b = m.valHooks[e.type] || m.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(lc, "") : null == c ? "" : c) } } }), m.extend({ valHooks: { option: { get: function (a) { var b = m.find.attr(a, "value"); return null != b ? b : m.trim(m.text(a)) } }, select: { get: function (a) { for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++)if (c = d[i], !(!c.selected && i !== e || (k.optDisabled ? c.disabled : null !== c.getAttribute("disabled")) || c.parentNode.disabled && m.nodeName(c.parentNode, "optgroup"))) { if (b = m(c).val(), f) return b; g.push(b) } return g }, set: function (a, b) { var c, d, e = a.options, f = m.makeArray(b), g = e.length; while (g--) if (d = e[g], m.inArray(m.valHooks.option.get(d), f) >= 0) try { d.selected = c = !0 } catch (h) { d.scrollHeight } else d.selected = !1; return c || (a.selectedIndex = -1), e } } } }), m.each(["radio", "checkbox"], function () { m.valHooks[this] = { set: function (a, b) { return m.isArray(b) ? a.checked = m.inArray(m(a).val(), b) >= 0 : void 0 } }, k.checkOn || (m.valHooks[this].get = function (a) { return null === a.getAttribute("value") ? "on" : a.value }) }); var mc, nc, oc = m.expr.attrHandle, pc = /^(?:checked|selected)$/i, qc = k.getSetAttribute, rc = k.input; m.fn.extend({ attr: function (a, b) { return V(this, m.attr, a, b, arguments.length > 1) }, removeAttr: function (a) { return this.each(function () { m.removeAttr(this, a) }) } }), m.extend({ attr: function (a, b, c) { var d, e, f = a.nodeType; if (a && 3 !== f && 8 !== f && 2 !== f) return typeof a.getAttribute === K ? m.prop(a, b, c) : (1 === f && m.isXMLDoc(a) || (b = b.toLowerCase(), d = m.attrHooks[b] || (m.expr.match.bool.test(b) ? nc : mc)), void 0 === c ? d && "get" in d && null !== (e = d.get(a, b)) ? e : (e = m.find.attr(a, b), null == e ? void 0 : e) : null !== c ? d && "set" in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + ""), c) : void m.removeAttr(a, b)) }, removeAttr: function (a, b) { var c, d, e = 0, f = b && b.match(E); if (f && 1 === a.nodeType) while (c = f[e++]) d = m.propFix[c] || c, m.expr.match.bool.test(c) ? rc && qc || !pc.test(c) ? a[d] = !1 : a[m.camelCase("default-" + c)] = a[d] = !1 : m.attr(a, c, ""), a.removeAttribute(qc ? c : d) }, attrHooks: { type: { set: function (a, b) { if (!k.radioValue && "radio" === b && m.nodeName(a, "input")) { var c = a.value; return a.setAttribute("type", b), c && (a.value = c), b } } } } }), nc = { set: function (a, b, c) { return b === !1 ? m.removeAttr(a, c) : rc && qc || !pc.test(c) ? a.setAttribute(!qc && m.propFix[c] || c, c) : a[m.camelCase("default-" + c)] = a[c] = !0, c } }, m.each(m.expr.match.bool.source.match(/\w+/g), function (a, b) { var c = oc[b] || m.find.attr; oc[b] = rc && qc || !pc.test(b) ? function (a, b, d) { var e, f; return d || (f = oc[b], oc[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, oc[b] = f), e } : function (a, b, c) { return c ? void 0 : a[m.camelCase("default-" + b)] ? b.toLowerCase() : null } }), rc && qc || (m.attrHooks.value = { set: function (a, b, c) { return m.nodeName(a, "input") ? void (a.defaultValue = b) : mc && mc.set(a, b, c) } }), qc || (mc = { set: function (a, b, c) { var d = a.getAttributeNode(c); return d || a.setAttributeNode(d = a.ownerDocument.createAttribute(c)), d.value = b += "", "value" === c || b === a.getAttribute(c) ? b : void 0 } }, oc.id = oc.name = oc.coords = function (a, b, c) { var d; return c ? void 0 : (d = a.getAttributeNode(b)) && "" !== d.value ? d.value : null }, m.valHooks.button = { get: function (a, b) { var c = a.getAttributeNode(b); return c && c.specified ? c.value : void 0 }, set: mc.set }, m.attrHooks.contenteditable = { set: function (a, b, c) { mc.set(a, "" === b ? !1 : b, c) } }, m.each(["width", "height"], function (a, b) { m.attrHooks[b] = { set: function (a, c) { return "" === c ? (a.setAttribute(b, "auto"), c) : void 0 } } })), k.style || (m.attrHooks.style = { get: function (a) { return a.style.cssText || void 0 }, set: function (a, b) { return a.style.cssText = b + "" } }); var sc = /^(?:input|select|textarea|button|object)$/i, tc = /^(?:a|area)$/i; m.fn.extend({ prop: function (a, b) { return V(this, m.prop, a, b, arguments.length > 1) }, removeProp: function (a) { return a = m.propFix[a] || a, this.each(function () { try { this[a] = void 0, delete this[a] } catch (b) { } }) } }), m.extend({ propFix: { "for": "htmlFor", "class": "className" }, prop: function (a, b, c) { var d, e, f, g = a.nodeType; if (a && 3 !== g && 8 !== g && 2 !== g) return f = 1 !== g || !m.isXMLDoc(a), f && (b = m.propFix[b] || b, e = m.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b] }, propHooks: { tabIndex: { get: function (a) { var b = m.find.attr(a, "tabindex"); return b ? parseInt(b, 10) : sc.test(a.nodeName) || tc.test(a.nodeName) && a.href ? 0 : -1 } } } }), k.hrefNormalized || m.each(["href", "src"], function (a, b) { m.propHooks[b] = { get: function (a) { return a.getAttribute(b, 4) } } }), k.optSelected || (m.propHooks.selected = { get: function (a) { var b = a.parentNode; return b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex), null } }), m.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () { m.propFix[this.toLowerCase()] = this }), k.enctype || (m.propFix.enctype = "encoding"); var uc = /[\t\r\n\f]/g; m.fn.extend({ addClass: function (a) { var b, c, d, e, f, g, h = 0, i = this.length, j = "string" == typeof a && a; if (m.isFunction(a)) return this.each(function (b) { m(this).addClass(a.call(this, b, this.className)) }); if (j) for (b = (a || "").match(E) || []; i > h; h++)if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(uc, " ") : " ")) { f = 0; while (e = b[f++]) d.indexOf(" " + e + " ") < 0 && (d += e + " "); g = m.trim(d), c.className !== g && (c.className = g) } return this }, removeClass: function (a) { var b, c, d, e, f, g, h = 0, i = this.length, j = 0 === arguments.length || "string" == typeof a && a; if (m.isFunction(a)) return this.each(function (b) { m(this).removeClass(a.call(this, b, this.className)) }); if (j) for (b = (a || "").match(E) || []; i > h; h++)if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(uc, " ") : "")) { f = 0; while (e = b[f++]) while (d.indexOf(" " + e + " ") >= 0) d = d.replace(" " + e + " ", " "); g = a ? m.trim(d) : "", c.className !== g && (c.className = g) } return this }, toggleClass: function (a, b) { var c = typeof a; return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(m.isFunction(a) ? function (c) { m(this).toggleClass(a.call(this, c, this.className, b), b) } : function () { if ("string" === c) { var b, d = 0, e = m(this), f = a.match(E) || []; while (b = f[d++]) e.hasClass(b) ? e.removeClass(b) : e.addClass(b) } else (c === K || "boolean" === c) && (this.className && m._data(this, "__className__", this.className), this.className = this.className || a === !1 ? "" : m._data(this, "__className__") || "") }) }, hasClass: function (a) { for (var b = " " + a + " ", c = 0, d = this.length; d > c; c++)if (1 === this[c].nodeType && (" " + this[c].className + " ").replace(uc, " ").indexOf(b) >= 0) return !0; return !1 } }), m.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (a, b) { m.fn[b] = function (a, c) { return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b) } }), m.fn.extend({ hover: function (a, b) { return this.mouseenter(a).mouseleave(b || a) }, bind: function (a, b, c) { return this.on(a, null, b, c) }, unbind: function (a, b) { return this.off(a, null, b) }, delegate: function (a, b, c, d) { return this.on(b, a, c, d) }, undelegate: function (a, b, c) { return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c) } }); var vc = m.now(), wc = /\?/, xc = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g; m.parseJSON = function (b) { if (a.JSON && a.JSON.parse) return a.JSON.parse(b + ""); var c, d = null, e = m.trim(b + ""); return e && !m.trim(e.replace(xc, function (a, b, e, f) { return c && b && (d = 0), 0 === d ? a : (c = e || b, d += !f - !e, "") })) ? Function("return " + e)() : m.error("Invalid JSON: " + b) }, m.parseXML = function (b) { var c, d; if (!b || "string" != typeof b) return null; try { a.DOMParser ? (d = new DOMParser, c = d.parseFromString(b, "text/xml")) : (c = new ActiveXObject("Microsoft.XMLDOM"), c.async = "false", c.loadXML(b)) } catch (e) { c = void 0 } return c && c.documentElement && !c.getElementsByTagName("parsererror").length || m.error("Invalid XML: " + b), c }; var yc, zc, Ac = /#.*$/, Bc = /([?&])_=[^&]*/, Cc = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, Dc = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Ec = /^(?:GET|HEAD)$/, Fc = /^\/\//, Gc = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, Hc = {}, Ic = {}, Jc = "*/".concat("*"); try { zc = location.href } catch (Kc) { zc = y.createElement("a"), zc.href = "", zc = zc.href } yc = Gc.exec(zc.toLowerCase()) || []; function Lc(a) { return function (b, c) { "string" != typeof b && (c = b, b = "*"); var d, e = 0, f = b.toLowerCase().match(E) || []; if (m.isFunction(c)) while (d = f[e++]) "+" === d.charAt(0) ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c) } } function Mc(a, b, c, d) { var e = {}, f = a === Ic; function g(h) { var i; return e[h] = !0, m.each(a[h] || [], function (a, h) { var j = h(b, c, d); return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1) }), i } return g(b.dataTypes[0]) || !e["*"] && g("*") } function Nc(a, b) { var c, d, e = m.ajaxSettings.flatOptions || {}; for (d in b) void 0 !== b[d] && ((e[d] ? a : c || (c = {}))[d] = b[d]); return c && m.extend(!0, a, c), a } function Oc(a, b, c) { var d, e, f, g, h = a.contents, i = a.dataTypes; while ("*" === i[0]) i.shift(), void 0 === e && (e = a.mimeType || b.getResponseHeader("Content-Type")); if (e) for (g in h) if (h[g] && h[g].test(e)) { i.unshift(g); break } if (i[0] in c) f = i[0]; else { for (g in c) { if (!i[0] || a.converters[g + " " + i[0]]) { f = g; break } d || (d = g) } f = f || d } return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0 } function Pc(a, b, c, d) { var e, f, g, h, i, j = {}, k = a.dataTypes.slice(); if (k[1]) for (g in a.converters) j[g.toLowerCase()] = a.converters[g]; f = k.shift(); while (f) if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift()) if ("*" === f) f = i; else if ("*" !== i && i !== f) { if (g = j[i + " " + f] || j["* " + f], !g) for (e in j) if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) { g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1])); break } if (g !== !0) if (g && a["throws"]) b = g(b); else try { b = g(b) } catch (l) { return { state: "parsererror", error: g ? l : "No conversion from " + i + " to " + f } } } return { state: "success", data: b } } m.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: zc, type: "GET", isLocal: Dc.test(yc[1]), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": Jc, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /xml/, html: /html/, json: /json/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": m.parseJSON, "text xml": m.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function (a, b) { return b ? Nc(Nc(a, m.ajaxSettings), b) : Nc(m.ajaxSettings, a) }, ajaxPrefilter: Lc(Hc), ajaxTransport: Lc(Ic), ajax: function (a, b) { "object" == typeof a && (b = a, a = void 0), b = b || {}; var c, d, e, f, g, h, i, j, k = m.ajaxSetup({}, b), l = k.context || k, n = k.context && (l.nodeType || l.jquery) ? m(l) : m.event, o = m.Deferred(), p = m.Callbacks("once memory"), q = k.statusCode || {}, r = {}, s = {}, t = 0, u = "canceled", v = { readyState: 0, getResponseHeader: function (a) { var b; if (2 === t) { if (!j) { j = {}; while (b = Cc.exec(f)) j[b[1].toLowerCase()] = b[2] } b = j[a.toLowerCase()] } return null == b ? null : b }, getAllResponseHeaders: function () { return 2 === t ? f : null }, setRequestHeader: function (a, b) { var c = a.toLowerCase(); return t || (a = s[c] = s[c] || a, r[a] = b), this }, overrideMimeType: function (a) { return t || (k.mimeType = a), this }, statusCode: function (a) { var b; if (a) if (2 > t) for (b in a) q[b] = [q[b], a[b]]; else v.always(a[v.status]); return this }, abort: function (a) { var b = a || u; return i && i.abort(b), x(0, b), this } }; if (o.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || zc) + "").replace(Ac, "").replace(Fc, yc[1] + "//"), k.type = b.method || b.type || k.method || k.type, k.dataTypes = m.trim(k.dataType || "*").toLowerCase().match(E) || [""], null == k.crossDomain && (c = Gc.exec(k.url.toLowerCase()), k.crossDomain = !(!c || c[1] === yc[1] && c[2] === yc[2] && (c[3] || ("http:" === c[1] ? "80" : "443")) === (yc[3] || ("http:" === yc[1] ? "80" : "443")))), k.data && k.processData && "string" != typeof k.data && (k.data = m.param(k.data, k.traditional)), Mc(Hc, k, b, v), 2 === t) return v; h = k.global, h && 0 === m.active++ && m.event.trigger("ajaxStart"), k.type = k.type.toUpperCase(), k.hasContent = !Ec.test(k.type), e = k.url, k.hasContent || (k.data && (e = k.url += (wc.test(e) ? "&" : "?") + k.data, delete k.data), k.cache === !1 && (k.url = Bc.test(e) ? e.replace(Bc, "$1_=" + vc++) : e + (wc.test(e) ? "&" : "?") + "_=" + vc++)), k.ifModified && (m.lastModified[e] && v.setRequestHeader("If-Modified-Since", m.lastModified[e]), m.etag[e] && v.setRequestHeader("If-None-Match", m.etag[e])), (k.data && k.hasContent && k.contentType !== !1 || b.contentType) && v.setRequestHeader("Content-Type", k.contentType), v.setRequestHeader("Accept", k.dataTypes[0] && k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + ("*" !== k.dataTypes[0] ? ", " + Jc + "; q=0.01" : "") : k.accepts["*"]); for (d in k.headers) v.setRequestHeader(d, k.headers[d]); if (k.beforeSend && (k.beforeSend.call(l, v, k) === !1 || 2 === t)) return v.abort(); u = "abort"; for (d in { success: 1, error: 1, complete: 1 }) v[d](k[d]); if (i = Mc(Ic, k, b, v)) { v.readyState = 1, h && n.trigger("ajaxSend", [v, k]), k.async && k.timeout > 0 && (g = setTimeout(function () { v.abort("timeout") }, k.timeout)); try { t = 1, i.send(r, x) } catch (w) { if (!(2 > t)) throw w; x(-1, w) } } else x(-1, "No Transport"); function x(a, b, c, d) { var j, r, s, u, w, x = b; 2 !== t && (t = 2, g && clearTimeout(g), i = void 0, f = d || "", v.readyState = a > 0 ? 4 : 0, j = a >= 200 && 300 > a || 304 === a, c && (u = Oc(k, v, c)), u = Pc(k, u, v, j), j ? (k.ifModified && (w = v.getResponseHeader("Last-Modified"), w && (m.lastModified[e] = w), w = v.getResponseHeader("etag"), w && (m.etag[e] = w)), 204 === a || "HEAD" === k.type ? x = "nocontent" : 304 === a ? x = "notmodified" : (x = u.state, r = u.data, s = u.error, j = !s)) : (s = x, (a || !x) && (x = "error", 0 > a && (a = 0))), v.status = a, v.statusText = (b || x) + "", j ? o.resolveWith(l, [r, x, v]) : o.rejectWith(l, [v, x, s]), v.statusCode(q), q = void 0, h && n.trigger(j ? "ajaxSuccess" : "ajaxError", [v, k, j ? r : s]), p.fireWith(l, [v, x]), h && (n.trigger("ajaxComplete", [v, k]), --m.active || m.event.trigger("ajaxStop"))) } return v }, getJSON: function (a, b, c) { return m.get(a, b, c, "json") }, getScript: function (a, b) { return m.get(a, void 0, b, "script") } }), m.each(["get", "post"], function (a, b) { m[b] = function (a, c, d, e) { return m.isFunction(c) && (e = e || d, d = c, c = void 0), m.ajax({ url: a, type: b, dataType: e, data: c, success: d }) } }), m.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (a, b) { m.fn[b] = function (a) { return this.on(b, a) } }), m._evalUrl = function (a) { return m.ajax({ url: a, type: "GET", dataType: "script", async: !1, global: !1, "throws": !0 }) }, m.fn.extend({ wrapAll: function (a) { if (m.isFunction(a)) return this.each(function (b) { m(this).wrapAll(a.call(this, b)) }); if (this[0]) { var b = m(a, this[0].ownerDocument).eq(0).clone(!0); this[0].parentNode && b.insertBefore(this[0]), b.map(function () { var a = this; while (a.firstChild && 1 === a.firstChild.nodeType) a = a.firstChild; return a }).append(this) } return this }, wrapInner: function (a) { return this.each(m.isFunction(a) ? function (b) { m(this).wrapInner(a.call(this, b)) } : function () { var b = m(this), c = b.contents(); c.length ? c.wrapAll(a) : b.append(a) }) }, wrap: function (a) { var b = m.isFunction(a); return this.each(function (c) { m(this).wrapAll(b ? a.call(this, c) : a) }) }, unwrap: function () { return this.parent().each(function () { m.nodeName(this, "body") || m(this).replaceWith(this.childNodes) }).end() } }), m.expr.filters.hidden = function (a) { return a.offsetWidth <= 0 && a.offsetHeight <= 0 || !k.reliableHiddenOffsets() && "none" === (a.style && a.style.display || m.css(a, "display")) }, m.expr.filters.visible = function (a) { return !m.expr.filters.hidden(a) }; var Qc = /%20/g, Rc = /\[\]$/, Sc = /\r?\n/g, Tc = /^(?:submit|button|image|reset|file)$/i, Uc = /^(?:input|select|textarea|keygen)/i; function Vc(a, b, c, d) { var e; if (m.isArray(b)) m.each(b, function (b, e) { c || Rc.test(a) ? d(a, e) : Vc(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d) }); else if (c || "object" !== m.type(b)) d(a, b); else for (e in b) Vc(a + "[" + e + "]", b[e], c, d) } m.param = function (a, b) { var c, d = [], e = function (a, b) { b = m.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b) }; if (void 0 === b && (b = m.ajaxSettings && m.ajaxSettings.traditional), m.isArray(a) || a.jquery && !m.isPlainObject(a)) m.each(a, function () { e(this.name, this.value) }); else for (c in a) Vc(c, a[c], b, e); return d.join("&").replace(Qc, "+") }, m.fn.extend({ serialize: function () { return m.param(this.serializeArray()) }, serializeArray: function () { return this.map(function () { var a = m.prop(this, "elements"); return a ? m.makeArray(a) : this }).filter(function () { var a = this.type; return this.name && !m(this).is(":disabled") && Uc.test(this.nodeName) && !Tc.test(a) && (this.checked || !W.test(a)) }).map(function (a, b) { var c = m(this).val(); return null == c ? null : m.isArray(c) ? m.map(c, function (a) { return { name: b.name, value: a.replace(Sc, "\r\n") } }) : { name: b.name, value: c.replace(Sc, "\r\n") } }).get() } }), m.ajaxSettings.xhr = void 0 !== a.ActiveXObject ? function () { return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && Zc() || $c() } : Zc; var Wc = 0, Xc = {}, Yc = m.ajaxSettings.xhr(); a.ActiveXObject && m(a).on("unload", function () { for (var a in Xc) Xc[a](void 0, !0) }), k.cors = !!Yc && "withCredentials" in Yc, Yc = k.ajax = !!Yc, Yc && m.ajaxTransport(function (a) { if (!a.crossDomain || k.cors) { var b; return { send: function (c, d) { var e, f = a.xhr(), g = ++Wc; if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields) for (e in a.xhrFields) f[e] = a.xhrFields[e]; a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType), a.crossDomain || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest"); for (e in c) void 0 !== c[e] && f.setRequestHeader(e, c[e] + ""); f.send(a.hasContent && a.data || null), b = function (c, e) { var h, i, j; if (b && (e || 4 === f.readyState)) if (delete Xc[g], b = void 0, f.onreadystatechange = m.noop, e) 4 !== f.readyState && f.abort(); else { j = {}, h = f.status, "string" == typeof f.responseText && (j.text = f.responseText); try { i = f.statusText } catch (k) { i = "" } h || !a.isLocal || a.crossDomain ? 1223 === h && (h = 204) : h = j.text ? 200 : 404 } j && d(h, i, j, f.getAllResponseHeaders()) }, a.async ? 4 === f.readyState ? setTimeout(b) : f.onreadystatechange = Xc[g] = b : b() }, abort: function () { b && b(void 0, !0) } } } }); function Zc() { try { return new a.XMLHttpRequest } catch (b) { } } function $c() { try { return new a.ActiveXObject("Microsoft.XMLHTTP") } catch (b) { } } m.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /(?:java|ecma)script/ }, converters: { "text script": function (a) { return m.globalEval(a), a } } }), m.ajaxPrefilter("script", function (a) { void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET", a.global = !1) }), m.ajaxTransport("script", function (a) { if (a.crossDomain) { var b, c = y.head || m("head")[0] || y.documentElement; return { send: function (d, e) { b = y.createElement("script"), b.async = !0, a.scriptCharset && (b.charset = a.scriptCharset), b.src = a.url, b.onload = b.onreadystatechange = function (a, c) { (c || !b.readyState || /loaded|complete/.test(b.readyState)) && (b.onload = b.onreadystatechange = null, b.parentNode && b.parentNode.removeChild(b), b = null, c || e(200, "success")) }, c.insertBefore(b, c.firstChild) }, abort: function () { b && b.onload(void 0, !0) } } } }); var _c = [], ad = /(=)\?(?=&|$)|\?\?/; m.ajaxSetup({ jsonp: "callback", jsonpCallback: function () { var a = _c.pop() || m.expando + "_" + vc++; return this[a] = !0, a } }), m.ajaxPrefilter("json jsonp", function (b, c, d) { var e, f, g, h = b.jsonp !== !1 && (ad.test(b.url) ? "url" : "string" == typeof b.data && !(b.contentType || "").indexOf("application/x-www-form-urlencoded") && ad.test(b.data) && "data"); return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = m.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(ad, "$1" + e) : b.jsonp !== !1 && (b.url += (wc.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function () { return g || m.error(e + " was not called"), g[0] }, b.dataTypes[0] = "json", f = a[e], a[e] = function () { g = arguments }, d.always(function () { a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, _c.push(e)), g && m.isFunction(f) && f(g[0]), g = f = void 0 }), "script") : void 0 }), m.parseHTML = function (a, b, c) { if (!a || "string" != typeof a) return null; "boolean" == typeof b && (c = b, b = !1), b = b || y; var d = u.exec(a), e = !c && []; return d ? [b.createElement(d[1])] : (d = m.buildFragment([a], b, e), e && e.length && m(e).remove(), m.merge([], d.childNodes)) }; var bd = m.fn.load; m.fn.load = function (a, b, c) { if ("string" != typeof a && bd) return bd.apply(this, arguments); var d, e, f, g = this, h = a.indexOf(" "); return h >= 0 && (d = m.trim(a.slice(h, a.length)), a = a.slice(0, h)), m.isFunction(b) ? (c = b, b = void 0) : b && "object" == typeof b && (f = "POST"), g.length > 0 && m.ajax({ url: a, type: f, dataType: "html", data: b }).done(function (a) { e = arguments, g.html(d ? m("<div>").append(m.parseHTML(a)).find(d) : a) }).complete(c && function (a, b) { g.each(c, e || [a.responseText, b, a]) }), this }, m.expr.filters.animated = function (a) { return m.grep(m.timers, function (b) { return a === b.elem }).length }; var cd = a.document.documentElement; function dd(a) { return m.isWindow(a) ? a : 9 === a.nodeType ? a.defaultView || a.parentWindow : !1 } m.offset = { setOffset: function (a, b, c) { var d, e, f, g, h, i, j, k = m.css(a, "position"), l = m(a), n = {}; "static" === k && (a.style.position = "relative"), h = l.offset(), f = m.css(a, "top"), i = m.css(a, "left"), j = ("absolute" === k || "fixed" === k) && m.inArray("auto", [f, i]) > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), m.isFunction(b) && (b = b.call(a, c, h)), null != b.top && (n.top = b.top - h.top + g), null != b.left && (n.left = b.left - h.left + e), "using" in b ? b.using.call(a, n) : l.css(n) } }, m.fn.extend({ offset: function (a) { if (arguments.length) return void 0 === a ? this : this.each(function (b) { m.offset.setOffset(this, a, b) }); var b, c, d = { top: 0, left: 0 }, e = this[0], f = e && e.ownerDocument; if (f) return b = f.documentElement, m.contains(b, e) ? (typeof e.getBoundingClientRect !== K && (d = e.getBoundingClientRect()), c = dd(f), { top: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0), left: d.left + (c.pageXOffset || b.scrollLeft) - (b.clientLeft || 0) }) : d }, position: function () { if (this[0]) { var a, b, c = { top: 0, left: 0 }, d = this[0]; return "fixed" === m.css(d, "position") ? b = d.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), m.nodeName(a[0], "html") || (c = a.offset()), c.top += m.css(a[0], "borderTopWidth", !0), c.left += m.css(a[0], "borderLeftWidth", !0)), { top: b.top - c.top - m.css(d, "marginTop", !0), left: b.left - c.left - m.css(d, "marginLeft", !0) } } }, offsetParent: function () { return this.map(function () { var a = this.offsetParent || cd; while (a && !m.nodeName(a, "html") && "static" === m.css(a, "position")) a = a.offsetParent; return a || cd }) } }), m.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (a, b) { var c = /Y/.test(b); m.fn[a] = function (d) { return V(this, function (a, d, e) { var f = dd(a); return void 0 === e ? f ? b in f ? f[b] : f.document.documentElement[d] : a[d] : void (f ? f.scrollTo(c ? m(f).scrollLeft() : e, c ? e : m(f).scrollTop()) : a[d] = e) }, a, d, arguments.length, null) } }), m.each(["top", "left"], function (a, b) { m.cssHooks[b] = Lb(k.pixelPosition, function (a, c) { return c ? (c = Jb(a, b), Hb.test(c) ? m(a).position()[b] + "px" : c) : void 0 }) }), m.each({ Height: "height", Width: "width" }, function (a, b) { m.each({ padding: "inner" + a, content: b, "": "outer" + a }, function (c, d) { m.fn[d] = function (d, e) { var f = arguments.length && (c || "boolean" != typeof d), g = c || (d === !0 || e === !0 ? "margin" : "border"); return V(this, function (b, c, d) { var e; return m.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? m.css(b, c, g) : m.style(b, c, d, g) }, b, f ? d : void 0, f, null) } }) }), m.fn.size = function () { return this.length }, m.fn.andSelf = m.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function () { return m }); var ed = a.jQuery, fd = a.$; return m.noConflict = function (b) { return a.$ === m && (a.$ = fd), b && a.jQuery === m && (a.jQuery = ed), m }, typeof b === K && (a.jQuery = a.$ = m), m
});

/*
 AngularJS v1.6.6
 (c) 2010-2017 Google, Inc. http://angularjs.org
 License: MIT
*/
(function (u) {
    'use strict'; function oe(a) { if (E(a)) t(a.objectMaxDepth) && (Lc.objectMaxDepth = Ub(a.objectMaxDepth) ? a.objectMaxDepth : NaN); else return Lc } function Ub(a) { return Y(a) && 0 < a } function M(a, b) {
        b = b || Error; return function () {
            var d = arguments[0], c; c = "[" + (a ? a + ":" : "") + d + "] http://errors.angularjs.org/1.6.6/" + (a ? a + "/" : "") + d; for (d = 1; d < arguments.length; d++) {
                c = c + (1 == d ? "?" : "&") + "p" + (d - 1) + "="; var e = encodeURIComponent, f; f = arguments[d]; f = "function" == typeof f ? f.toString().replace(/ \{[\s\S]*$/, "") : "undefined" ==
                    typeof f ? "undefined" : "string" != typeof f ? JSON.stringify(f) : f; c += e(f)
            } return new b(c)
        }
    } function xa(a) { if (null == a || $a(a)) return !1; if (I(a) || D(a) || B && a instanceof B) return !0; var b = "length" in Object(a) && a.length; return Y(b) && (0 <= b && (b - 1 in a || a instanceof Array) || "function" === typeof a.item) } function p(a, b, d) {
        var c, e; if (a) if (A(a)) for (c in a) "prototype" !== c && "length" !== c && "name" !== c && a.hasOwnProperty(c) && b.call(d, a[c], c, a); else if (I(a) || xa(a)) {
            var f = "object" !== typeof a; c = 0; for (e = a.length; c < e; c++)(f || c in
                a) && b.call(d, a[c], c, a)
        } else if (a.forEach && a.forEach !== p) a.forEach(b, d, a); else if (Mc(a)) for (c in a) b.call(d, a[c], c, a); else if ("function" === typeof a.hasOwnProperty) for (c in a) a.hasOwnProperty(c) && b.call(d, a[c], c, a); else for (c in a) ra.call(a, c) && b.call(d, a[c], c, a); return a
    } function Nc(a, b, d) { for (var c = Object.keys(a).sort(), e = 0; e < c.length; e++)b.call(d, a[c[e]], c[e]); return c } function Vb(a) { return function (b, d) { a(d, b) } } function pe() { return ++sb } function Wb(a, b, d) {
        for (var c = a.$$hashKey, e = 0, f = b.length; e < f; ++e) {
            var g =
                b[e]; if (E(g) || A(g)) for (var k = Object.keys(g), h = 0, l = k.length; h < l; h++) { var m = k[h], n = g[m]; d && E(n) ? ea(n) ? a[m] = new Date(n.valueOf()) : ab(n) ? a[m] = new RegExp(n) : n.nodeName ? a[m] = n.cloneNode(!0) : Xb(n) ? a[m] = n.clone() : (E(a[m]) || (a[m] = I(n) ? [] : {}), Wb(a[m], [n], !0)) : a[m] = n }
        } c ? a.$$hashKey = c : delete a.$$hashKey; return a
    } function P(a) { return Wb(a, ya.call(arguments, 1), !1) } function qe(a) { return Wb(a, ya.call(arguments, 1), !0) } function Z(a) { return parseInt(a, 10) } function Yb(a, b) { return P(Object.create(a), b) } function C() { }
    function bb(a) { return a } function ka(a) { return function () { return a } } function Zb(a) { return A(a.toString) && a.toString !== ha } function w(a) { return "undefined" === typeof a } function t(a) { return "undefined" !== typeof a } function E(a) { return null !== a && "object" === typeof a } function Mc(a) { return null !== a && "object" === typeof a && !Oc(a) } function D(a) { return "string" === typeof a } function Y(a) { return "number" === typeof a } function ea(a) { return "[object Date]" === ha.call(a) } function $b(a) {
        switch (ha.call(a)) {
            case "[object Error]": return !0;
            case "[object Exception]": return !0; case "[object DOMException]": return !0; default: return a instanceof Error
        }
    } function A(a) { return "function" === typeof a } function ab(a) { return "[object RegExp]" === ha.call(a) } function $a(a) { return a && a.window === a } function cb(a) { return a && a.$evalAsync && a.$watch } function Na(a) { return "boolean" === typeof a } function re(a) { return a && Y(a.length) && se.test(ha.call(a)) } function Xb(a) { return !(!a || !(a.nodeName || a.prop && a.attr && a.find)) } function te(a) {
        var b = {}; a = a.split(","); var d; for (d =
            0; d < a.length; d++)b[a[d]] = !0; return b
    } function za(a) { return N(a.nodeName || a[0] && a[0].nodeName) } function db(a, b) { var d = a.indexOf(b); 0 <= d && a.splice(d, 1); return d } function pa(a, b, d) {
        function c(a, b, c) {
            c--; if (0 > c) return "..."; var d = b.$$hashKey, g; if (I(a)) { g = 0; for (var f = a.length; g < f; g++)b.push(e(a[g], c)) } else if (Mc(a)) for (g in a) b[g] = e(a[g], c); else if (a && "function" === typeof a.hasOwnProperty) for (g in a) a.hasOwnProperty(g) && (b[g] = e(a[g], c)); else for (g in a) ra.call(a, g) && (b[g] = e(a[g], c)); d ? b.$$hashKey = d : delete b.$$hashKey;
            return b
        } function e(a, b) { if (!E(a)) return a; var d = g.indexOf(a); if (-1 !== d) return k[d]; if ($a(a) || cb(a)) throw qa("cpws"); var d = !1, e = f(a); void 0 === e && (e = I(a) ? [] : Object.create(Oc(a)), d = !0); g.push(a); k.push(e); return d ? c(a, e, b) : e } function f(a) {
            switch (ha.call(a)) {
                case "[object Int8Array]": case "[object Int16Array]": case "[object Int32Array]": case "[object Float32Array]": case "[object Float64Array]": case "[object Uint8Array]": case "[object Uint8ClampedArray]": case "[object Uint16Array]": case "[object Uint32Array]": return new a.constructor(e(a.buffer),
                    a.byteOffset, a.length); case "[object ArrayBuffer]": if (!a.slice) { var b = new ArrayBuffer(a.byteLength); (new Uint8Array(b)).set(new Uint8Array(a)); return b } return a.slice(0); case "[object Boolean]": case "[object Number]": case "[object String]": case "[object Date]": return new a.constructor(a.valueOf()); case "[object RegExp]": return b = new RegExp(a.source, a.toString().match(/[^/]*$/)[0]), b.lastIndex = a.lastIndex, b; case "[object Blob]": return new a.constructor([a], { type: a.type })
            }if (A(a.cloneNode)) return a.cloneNode(!0)
        }
        var g = [], k = []; d = Ub(d) ? d : NaN; if (b) { if (re(b) || "[object ArrayBuffer]" === ha.call(b)) throw qa("cpta"); if (a === b) throw qa("cpi"); I(b) ? b.length = 0 : p(b, function (a, c) { "$$hashKey" !== c && delete b[c] }); g.push(a); k.push(b); return c(a, b, d) } return e(a, d)
    } function ac(a, b) { return a === b || a !== a && b !== b } function sa(a, b) {
        if (a === b) return !0; if (null === a || null === b) return !1; if (a !== a && b !== b) return !0; var d = typeof a, c; if (d === typeof b && "object" === d) if (I(a)) {
            if (!I(b)) return !1; if ((d = a.length) === b.length) {
                for (c = 0; c < d; c++)if (!sa(a[c],
                    b[c])) return !1; return !0
            }
        } else { if (ea(a)) return ea(b) ? ac(a.getTime(), b.getTime()) : !1; if (ab(a)) return ab(b) ? a.toString() === b.toString() : !1; if (cb(a) || cb(b) || $a(a) || $a(b) || I(b) || ea(b) || ab(b)) return !1; d = S(); for (c in a) if ("$" !== c.charAt(0) && !A(a[c])) { if (!sa(a[c], b[c])) return !1; d[c] = !0 } for (c in b) if (!(c in d) && "$" !== c.charAt(0) && t(b[c]) && !A(b[c])) return !1; return !0 } return !1
    } function eb(a, b, d) { return a.concat(ya.call(b, d)) } function Ra(a, b) {
        var d = 2 < arguments.length ? ya.call(arguments, 2) : []; return !A(b) || b instanceof
            RegExp ? b : d.length ? function () { return arguments.length ? b.apply(a, eb(d, arguments, 0)) : b.apply(a, d) } : function () { return arguments.length ? b.apply(a, arguments) : b.call(a) }
    } function Pc(a, b) { var d = b; "string" === typeof a && "$" === a.charAt(0) && "$" === a.charAt(1) ? d = void 0 : $a(b) ? d = "$WINDOW" : b && u.document === b ? d = "$DOCUMENT" : cb(b) && (d = "$SCOPE"); return d } function fb(a, b) { if (!w(a)) return Y(b) || (b = b ? 2 : null), JSON.stringify(a, Pc, b) } function Qc(a) { return D(a) ? JSON.parse(a) : a } function Rc(a, b) {
        a = a.replace(ue, ""); var d = Date.parse("Jan 01, 1970 00:00:00 " +
            a) / 6E4; return T(d) ? b : d
    } function bc(a, b, d) { d = d ? -1 : 1; var c = a.getTimezoneOffset(); b = Rc(b, c); d *= b - c; a = new Date(a.getTime()); a.setMinutes(a.getMinutes() + d); return a } function Aa(a) { a = B(a).clone().empty(); var b = B("<div>").append(a).html(); try { return a[0].nodeType === Oa ? N(b) : b.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, function (a, b) { return "<" + N(b) }) } catch (d) { return N(b) } } function Sc(a) { try { return decodeURIComponent(a) } catch (b) { } } function Tc(a) {
        var b = {}; p((a || "").split("&"), function (a) {
            var c, e, f; a && (e = a = a.replace(/\+/g,
                "%20"), c = a.indexOf("="), -1 !== c && (e = a.substring(0, c), f = a.substring(c + 1)), e = Sc(e), t(e) && (f = t(f) ? Sc(f) : !0, ra.call(b, e) ? I(b[e]) ? b[e].push(f) : b[e] = [b[e], f] : b[e] = f))
        }); return b
    } function cc(a) { var b = []; p(a, function (a, c) { I(a) ? p(a, function (a) { b.push(ia(c, !0) + (!0 === a ? "" : "=" + ia(a, !0))) }) : b.push(ia(c, !0) + (!0 === a ? "" : "=" + ia(a, !0))) }); return b.length ? b.join("&") : "" } function gb(a) { return ia(a, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+") } function ia(a, b) {
        return encodeURIComponent(a).replace(/%40/gi,
            "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, b ? "%20" : "+")
    } function ve(a, b) { var d, c, e = Ha.length; for (c = 0; c < e; ++c)if (d = Ha[c] + b, D(d = a.getAttribute(d))) return d; return null } function we(a, b) {
        var d, c, e = {}; p(Ha, function (b) { b += "app"; !d && a.hasAttribute && a.hasAttribute(b) && (d = a, c = a.getAttribute(b)) }); p(Ha, function (b) { b += "app"; var e; !d && (e = a.querySelector("[" + b.replace(":", "\\:") + "]")) && (d = e, c = e.getAttribute(b)) }); d && (xe ? (e.strictDi = null !== ve(d, "strict-di"),
            b(d, c ? [c] : [], e)) : u.console.error("Angular: disabling automatic bootstrap. <script> protocol indicates an extension, document.location.href does not match."))
    } function Uc(a, b, d) {
        E(d) || (d = {}); d = P({ strictDi: !1 }, d); var c = function () {
            a = B(a); if (a.injector()) { var c = a[0] === u.document ? "document" : Aa(a); throw qa("btstrpd", c.replace(/</, "&lt;").replace(/>/, "&gt;")); } b = b || []; b.unshift(["$provide", function (b) { b.value("$rootElement", a) }]); d.debugInfoEnabled && b.push(["$compileProvider", function (a) { a.debugInfoEnabled(!0) }]);
            b.unshift("ng"); c = hb(b, d.strictDi); c.invoke(["$rootScope", "$rootElement", "$compile", "$injector", function (a, b, c, d) { a.$apply(function () { b.data("$injector", d); c(b)(a) }) }]); return c
        }, e = /^NG_ENABLE_DEBUG_INFO!/, f = /^NG_DEFER_BOOTSTRAP!/; u && e.test(u.name) && (d.debugInfoEnabled = !0, u.name = u.name.replace(e, "")); if (u && !f.test(u.name)) return c(); u.name = u.name.replace(f, ""); $.resumeBootstrap = function (a) { p(a, function (a) { b.push(a) }); return c() }; A($.resumeDeferredBootstrap) && $.resumeDeferredBootstrap()
    } function ye() {
        u.name =
            "NG_ENABLE_DEBUG_INFO!" + u.name; u.location.reload()
    } function ze(a) { a = $.element(a).injector(); if (!a) throw qa("test"); return a.get("$$testability") } function Vc(a, b) { b = b || "_"; return a.replace(Ae, function (a, c) { return (c ? b : "") + a.toLowerCase() }) } function Be() {
        var a; if (!Wc) {
            var b = tb(); (la = w(b) ? u.jQuery : b ? u[b] : void 0) && la.fn.on ? (B = la, P(la.fn, { scope: Sa.scope, isolateScope: Sa.isolateScope, controller: Sa.controller, injector: Sa.injector, inheritedData: Sa.inheritedData }), a = la.cleanData, la.cleanData = function (b) {
                for (var c,
                    e = 0, f; null != (f = b[e]); e++)(c = la._data(f, "events")) && c.$destroy && la(f).triggerHandler("$destroy"); a(b)
            }) : B = U; $.element = B; Wc = !0
        }
    } function ib(a, b, d) { if (!a) throw qa("areq", b || "?", d || "required"); return a } function ub(a, b, d) { d && I(a) && (a = a[a.length - 1]); ib(A(a), b, "not a function, got " + (a && "object" === typeof a ? a.constructor.name || "Object" : typeof a)); return a } function Ia(a, b) { if ("hasOwnProperty" === a) throw qa("badname", b); } function Xc(a, b, d) {
        if (!b) return a; b = b.split("."); for (var c, e = a, f = b.length, g = 0; g < f; g++)c =
            b[g], a && (a = (e = a)[c]); return !d && A(a) ? Ra(e, a) : a
    } function vb(a) { for (var b = a[0], d = a[a.length - 1], c, e = 1; b !== d && (b = b.nextSibling); e++)if (c || a[e] !== b) c || (c = B(ya.call(a, 0, e))), c.push(b); return c || a } function S() { return Object.create(null) } function dc(a) { if (null == a) return ""; switch (typeof a) { case "string": break; case "number": a = "" + a; break; default: a = !Zb(a) || I(a) || ea(a) ? fb(a) : a.toString() }return a } function Ce(a) {
        function b(a, b, c) { return a[b] || (a[b] = c()) } var d = M("$injector"), c = M("ng"); a = b(a, "angular", Object); a.$$minErr =
            a.$$minErr || M; return b(a, "module", function () {
                var a = {}; return function (f, g, k) {
                    var h = {}; if ("hasOwnProperty" === f) throw c("badname", "module"); g && a.hasOwnProperty(f) && (a[f] = null); return b(a, f, function () {
                        function a(b, c, d, g) { g || (g = e); return function () { g[d || "push"]([b, c, arguments]); return p } } function b(a, c, d) { d || (d = e); return function (b, e) { e && A(e) && (e.$$moduleName = f); d.push([a, c, arguments]); return p } } if (!g) throw d("nomod", f); var e = [], q = [], G = [], L = a("$injector", "invoke", "push", q), p = {
                            _invokeQueue: e, _configBlocks: q,
                            _runBlocks: G, info: function (a) { if (t(a)) { if (!E(a)) throw c("aobj", "value"); h = a; return this } return h }, requires: g, name: f, provider: b("$provide", "provider"), factory: b("$provide", "factory"), service: b("$provide", "service"), value: a("$provide", "value"), constant: a("$provide", "constant", "unshift"), decorator: b("$provide", "decorator", q), animation: b("$animateProvider", "register"), filter: b("$filterProvider", "register"), controller: b("$controllerProvider", "register"), directive: b("$compileProvider", "directive"), component: b("$compileProvider",
                                "component"), config: L, run: function (a) { G.push(a); return this }
                        }; k && L(k); return p
                    })
                }
            })
    } function ja(a, b) { if (I(a)) { b = b || []; for (var d = 0, c = a.length; d < c; d++)b[d] = a[d] } else if (E(a)) for (d in b = b || {}, a) if ("$" !== d.charAt(0) || "$" !== d.charAt(1)) b[d] = a[d]; return b || a } function De(a, b) { var d = []; Ub(b) && (a = $.copy(a, null, b)); return JSON.stringify(a, function (a, b) { b = Pc(a, b); if (E(b)) { if (0 <= d.indexOf(b)) return "..."; d.push(b) } return b }) } function Ee(a) {
        P(a, {
            errorHandlingConfig: oe, bootstrap: Uc, copy: pa, extend: P, merge: qe, equals: sa,
            element: B, forEach: p, injector: hb, noop: C, bind: Ra, toJson: fb, fromJson: Qc, identity: bb, isUndefined: w, isDefined: t, isString: D, isFunction: A, isObject: E, isNumber: Y, isElement: Xb, isArray: I, version: Fe, isDate: ea, lowercase: N, uppercase: wb, callbacks: { $$counter: 0 }, getTestability: ze, reloadWithDebugInfo: ye, $$minErr: M, $$csp: Ja, $$encodeUriSegment: gb, $$encodeUriQuery: ia, $$stringify: dc
        }); ec = Ce(u); ec("ng", ["ngLocale"], ["$provide", function (a) {
            a.provider({ $$sanitizeUri: Ge }); a.provider("$compile", Yc).directive({
                a: He, input: Zc,
                textarea: Zc, form: Ie, script: Je, select: Ke, option: Le, ngBind: Me, ngBindHtml: Ne, ngBindTemplate: Oe, ngClass: Pe, ngClassEven: Qe, ngClassOdd: Re, ngCloak: Se, ngController: Te, ngForm: Ue, ngHide: Ve, ngIf: We, ngInclude: Xe, ngInit: Ye, ngNonBindable: Ze, ngPluralize: $e, ngRepeat: af, ngShow: bf, ngStyle: cf, ngSwitch: df, ngSwitchWhen: ef, ngSwitchDefault: ff, ngOptions: gf, ngTransclude: hf, ngModel: jf, ngList: kf, ngChange: lf, pattern: $c, ngPattern: $c, required: ad, ngRequired: ad, minlength: bd, ngMinlength: bd, maxlength: cd, ngMaxlength: cd, ngValue: mf,
                ngModelOptions: nf
            }).directive({ ngInclude: of }).directive(xb).directive(dd); a.provider({
                $anchorScroll: pf, $animate: qf, $animateCss: rf, $$animateJs: sf, $$animateQueue: tf, $$AnimateRunner: uf, $$animateAsyncRun: vf, $browser: wf, $cacheFactory: xf, $controller: yf, $document: zf, $$isDocumentHidden: Af, $exceptionHandler: Bf, $filter: ed, $$forceReflow: Cf, $interpolate: Df, $interval: Ef, $http: Ff, $httpParamSerializer: Gf, $httpParamSerializerJQLike: Hf, $httpBackend: If, $xhrFactory: Jf, $jsonpCallbacks: Kf, $location: Lf, $log: Mf, $parse: Nf,
                $rootScope: Of, $q: Pf, $$q: Qf, $sce: Rf, $sceDelegate: Sf, $sniffer: Tf, $templateCache: Uf, $templateRequest: Vf, $$testability: Wf, $timeout: Xf, $window: Yf, $$rAF: Zf, $$jqLite: $f, $$Map: ag, $$cookieReader: bg
            })
        }]).info({ angularVersion: "1.6.6" })
    } function jb(a, b) { return b.toUpperCase() } function yb(a) { return a.replace(cg, jb) } function fc(a) { a = a.nodeType; return 1 === a || !a || 9 === a } function fd(a, b) {
        var d, c, e = b.createDocumentFragment(), f = []; if (gc.test(a)) {
            d = e.appendChild(b.createElement("div")); c = (dg.exec(a) || ["", ""])[1].toLowerCase();
            c = aa[c] || aa._default; d.innerHTML = c[1] + a.replace(eg, "<$1></$2>") + c[2]; for (c = c[0]; c--;)d = d.lastChild; f = eb(f, d.childNodes); d = e.firstChild; d.textContent = ""
        } else f.push(b.createTextNode(a)); e.textContent = ""; e.innerHTML = ""; p(f, function (a) { e.appendChild(a) }); return e
    } function U(a) {
        if (a instanceof U) return a; var b; D(a) && (a = Q(a), b = !0); if (!(this instanceof U)) { if (b && "<" !== a.charAt(0)) throw hc("nosel"); return new U(a) } if (b) {
            b = u.document; var d; a = (d = fg.exec(a)) ? [b.createElement(d[1])] : (d = fd(a, b)) ? d.childNodes :
                []; ic(this, a)
        } else A(a) ? gd(a) : ic(this, a)
    } function jc(a) { return a.cloneNode(!0) } function zb(a, b) { !b && fc(a) && B.cleanData([a]); a.querySelectorAll && B.cleanData(a.querySelectorAll("*")) } function hd(a, b, d, c) { if (t(c)) throw hc("offargs"); var e = (c = Ab(a)) && c.events, f = c && c.handle; if (f) if (b) { var g = function (b) { var c = e[b]; t(d) && db(c || [], d); t(d) && c && 0 < c.length || (a.removeEventListener(b, f), delete e[b]) }; p(b.split(" "), function (a) { g(a); Bb[a] && g(Bb[a]) }) } else for (b in e) "$destroy" !== b && a.removeEventListener(b, f), delete e[b] }
    function kc(a, b) { var d = a.ng339, c = d && kb[d]; c && (b ? delete c.data[b] : (c.handle && (c.events.$destroy && c.handle({}, "$destroy"), hd(a)), delete kb[d], a.ng339 = void 0)) } function Ab(a, b) { var d = a.ng339, d = d && kb[d]; b && !d && (a.ng339 = d = ++gg, d = kb[d] = { events: {}, data: {}, handle: void 0 }); return d } function lc(a, b, d) { if (fc(a)) { var c, e = t(d), f = !e && b && !E(b), g = !b; a = (a = Ab(a, !f)) && a.data; if (e) a[yb(b)] = d; else { if (g) return a; if (f) return a && a[yb(b)]; for (c in b) a[yb(c)] = b[c] } } } function Cb(a, b) {
        return a.getAttribute ? -1 < (" " + (a.getAttribute("class") ||
            "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + b + " ") : !1
    } function Db(a, b) { b && a.setAttribute && p(b.split(" "), function (b) { a.setAttribute("class", Q((" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + Q(b) + " ", " "))) }) } function Eb(a, b) { if (b && a.setAttribute) { var d = (" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "); p(b.split(" "), function (a) { a = Q(a); -1 === d.indexOf(" " + a + " ") && (d += a + " ") }); a.setAttribute("class", Q(d)) } } function ic(a, b) {
        if (b) if (b.nodeType) a[a.length++] = b; else {
            var d =
                b.length; if ("number" === typeof d && b.window !== b) { if (d) for (var c = 0; c < d; c++)a[a.length++] = b[c] } else a[a.length++] = b
        }
    } function id(a, b) { return Fb(a, "$" + (b || "ngController") + "Controller") } function Fb(a, b, d) { 9 === a.nodeType && (a = a.documentElement); for (b = I(b) ? b : [b]; a;) { for (var c = 0, e = b.length; c < e; c++)if (t(d = B.data(a, b[c]))) return d; a = a.parentNode || 11 === a.nodeType && a.host } } function jd(a) { for (zb(a, !0); a.firstChild;)a.removeChild(a.firstChild) } function Gb(a, b) { b || zb(a); var d = a.parentNode; d && d.removeChild(a) } function hg(a,
        b) { b = b || u; if ("complete" === b.document.readyState) b.setTimeout(a); else B(b).on("load", a) } function gd(a) { function b() { u.document.removeEventListener("DOMContentLoaded", b); u.removeEventListener("load", b); a() } "complete" === u.document.readyState ? u.setTimeout(a) : (u.document.addEventListener("DOMContentLoaded", b), u.addEventListener("load", b)) } function kd(a, b) { var d = Hb[b.toLowerCase()]; return d && ld[za(a)] && d } function ig(a, b) {
            var d = function (c, d) {
                c.isDefaultPrevented = function () { return c.defaultPrevented }; var f =
                    b[d || c.type], g = f ? f.length : 0; if (g) { if (w(c.immediatePropagationStopped)) { var k = c.stopImmediatePropagation; c.stopImmediatePropagation = function () { c.immediatePropagationStopped = !0; c.stopPropagation && c.stopPropagation(); k && k.call(c) } } c.isImmediatePropagationStopped = function () { return !0 === c.immediatePropagationStopped }; var h = f.specialHandlerWrapper || jg; 1 < g && (f = ja(f)); for (var l = 0; l < g; l++)c.isImmediatePropagationStopped() || h(a, c, f[l]) }
            }; d.elem = a; return d
        } function jg(a, b, d) { d.call(a, b) } function kg(a, b, d) {
            var c =
                b.relatedTarget; c && (c === a || lg.call(a, c)) || d.call(a, b)
        } function $f() { this.$get = function () { return P(U, { hasClass: function (a, b) { a.attr && (a = a[0]); return Cb(a, b) }, addClass: function (a, b) { a.attr && (a = a[0]); return Eb(a, b) }, removeClass: function (a, b) { a.attr && (a = a[0]); return Db(a, b) } }) } } function Pa(a, b) { var d = a && a.$$hashKey; if (d) return "function" === typeof d && (d = a.$$hashKey()), d; d = typeof a; return d = "function" === d || "object" === d && null !== a ? a.$$hashKey = d + ":" + (b || pe)() : d + ":" + a } function md() {
            this._keys = []; this._values =
                []; this._lastKey = NaN; this._lastIndex = -1
        } function nd(a) { a = Function.prototype.toString.call(a).replace(mg, ""); return a.match(ng) || a.match(og) } function pg(a) { return (a = nd(a)) ? "function(" + (a[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn" } function hb(a, b) {
            function d(a) { return function (b, c) { if (E(b)) p(b, Vb(a)); else return a(b, c) } } function c(a, b) { Ia(a, "service"); if (A(b) || I(b)) b = q.instantiate(b); if (!b.$get) throw Ba("pget", a); return n[a + "Provider"] = b } function e(a, b) {
                return function () {
                    var c = z.invoke(b, this); if (w(c)) throw Ba("undef",
                        a); return c
                }
            } function f(a, b, d) { return c(a, { $get: !1 !== d ? e(a, b) : b }) } function g(a) {
                ib(w(a) || I(a), "modulesToLoad", "not an array"); var b = [], c; p(a, function (a) {
                    function d(a) { var b, c; b = 0; for (c = a.length; b < c; b++) { var e = a[b], g = q.get(e[0]); g[e[1]].apply(g, e[2]) } } if (!m.get(a)) {
                        m.set(a, !0); try { D(a) ? (c = ec(a), z.modules[a] = c, b = b.concat(g(c.requires)).concat(c._runBlocks), d(c._invokeQueue), d(c._configBlocks)) : A(a) ? b.push(q.invoke(a)) : I(a) ? b.push(q.invoke(a)) : ub(a, "module") } catch (e) {
                            throw I(a) && (a = a[a.length - 1]), e.message &&
                            e.stack && -1 === e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), Ba("modulerr", a, e.stack || e.message || e);
                        }
                    }
                }); return b
            } function k(a, c) {
                function d(b, e) { if (a.hasOwnProperty(b)) { if (a[b] === h) throw Ba("cdep", b + " <- " + l.join(" <- ")); return a[b] } try { return l.unshift(b), a[b] = h, a[b] = c(b, e), a[b] } catch (g) { throw a[b] === h && delete a[b], g; } finally { l.shift() } } function e(a, c, g) {
                    var f = []; a = hb.$$annotate(a, b, g); for (var h = 0, k = a.length; h < k; h++) {
                        var l = a[h]; if ("string" !== typeof l) throw Ba("itkn", l); f.push(c && c.hasOwnProperty(l) ?
                            c[l] : d(l, g))
                    } return f
                } return {
                    invoke: function (a, b, c, d) { "string" === typeof c && (d = c, c = null); c = e(a, c, d); I(a) && (a = a[a.length - 1]); d = a; if (Ca || "function" !== typeof d) d = !1; else { var g = d.$$ngIsClass; Na(g) || (g = d.$$ngIsClass = /^(?:class\b|constructor\()/.test(Function.prototype.toString.call(d))); d = g } return d ? (c.unshift(null), new (Function.prototype.bind.apply(a, c))) : a.apply(b, c) }, instantiate: function (a, b, c) { var d = I(a) ? a[a.length - 1] : a; a = e(a, b, c); a.unshift(null); return new (Function.prototype.bind.apply(d, a)) }, get: d,
                    annotate: hb.$$annotate, has: function (b) { return n.hasOwnProperty(b + "Provider") || a.hasOwnProperty(b) }
                }
            } b = !0 === b; var h = {}, l = [], m = new Ib, n = { $provide: { provider: d(c), factory: d(f), service: d(function (a, b) { return f(a, ["$injector", function (a) { return a.instantiate(b) }]) }), value: d(function (a, b) { return f(a, ka(b), !1) }), constant: d(function (a, b) { Ia(a, "constant"); n[a] = b; G[a] = b }), decorator: function (a, b) { var c = q.get(a + "Provider"), d = c.$get; c.$get = function () { var a = z.invoke(d, c); return z.invoke(b, null, { $delegate: a }) } } } },
                q = n.$injector = k(n, function (a, b) { $.isString(b) && l.push(b); throw Ba("unpr", l.join(" <- ")); }), G = {}, L = k(G, function (a, b) { var c = q.get(a + "Provider", b); return z.invoke(c.$get, c, void 0, a) }), z = L; n.$injectorProvider = { $get: ka(L) }; z.modules = q.modules = S(); var v = g(a), z = L.get("$injector"); z.strictDi = b; p(v, function (a) { a && z.invoke(a) }); return z
        } function pf() {
            var a = !0; this.disableAutoScrolling = function () { a = !1 }; this.$get = ["$window", "$location", "$rootScope", function (b, d, c) {
                function e(a) {
                    var b = null; Array.prototype.some.call(a,
                        function (a) { if ("a" === za(a)) return b = a, !0 }); return b
                } function f(a) { if (a) { a.scrollIntoView(); var c; c = g.yOffset; A(c) ? c = c() : Xb(c) ? (c = c[0], c = "fixed" !== b.getComputedStyle(c).position ? 0 : c.getBoundingClientRect().bottom) : Y(c) || (c = 0); c && (a = a.getBoundingClientRect().top, b.scrollBy(0, a - c)) } else b.scrollTo(0, 0) } function g(a) { a = D(a) ? a : Y(a) ? a.toString() : d.hash(); var b; a ? (b = k.getElementById(a)) ? f(b) : (b = e(k.getElementsByName(a))) ? f(b) : "top" === a && f(null) : f(null) } var k = b.document; a && c.$watch(function () { return d.hash() },
                    function (a, b) { a === b && "" === a || hg(function () { c.$evalAsync(g) }) }); return g
            }]
        } function lb(a, b) { if (!a && !b) return ""; if (!a) return b; if (!b) return a; I(a) && (a = a.join(" ")); I(b) && (b = b.join(" ")); return a + " " + b } function qg(a) { D(a) && (a = a.split(" ")); var b = S(); p(a, function (a) { a.length && (b[a] = !0) }); return b } function Ka(a) { return E(a) ? a : {} } function rg(a, b, d, c) {
            function e(a) { try { a.apply(null, ya.call(arguments, 1)) } finally { if (L-- , 0 === L) for (; z.length;)try { z.pop()() } catch (b) { d.error(b) } } } function f() { y = null; k() } function g() {
                v =
                    J(); v = w(v) ? null : v; sa(v, K) && (v = K); s = K = v
            } function k() { var a = s; g(); if (Ta !== h.url() || a !== v) Ta = h.url(), s = v, p(H, function (a) { a(h.url(), v) }) } var h = this, l = a.location, m = a.history, n = a.setTimeout, q = a.clearTimeout, G = {}; h.isMock = !1; var L = 0, z = []; h.$$completeOutstandingRequest = e; h.$$incOutstandingRequestCount = function () { L++ }; h.notifyWhenNoOutstandingRequests = function (a) { 0 === L ? a() : z.push(a) }; var v, s, Ta = l.href, ma = b.find("base"), y = null, J = c.history ? function () { try { return m.state } catch (a) { } } : C; g(); h.url = function (b, d, e) {
                w(e) &&
                    (e = null); l !== a.location && (l = a.location); m !== a.history && (m = a.history); if (b) { var f = s === e; if (Ta === b && (!c.history || f)) return h; var k = Ta && La(Ta) === La(b); Ta = b; s = e; !c.history || k && f ? (k || (y = b), d ? l.replace(b) : k ? (d = l, e = b.indexOf("#"), e = -1 === e ? "" : b.substr(e), d.hash = e) : l.href = b, l.href !== b && (y = b)) : (m[d ? "replaceState" : "pushState"](e, "", b), g()); y && (y = b); return h } return y || l.href.replace(/%27/g, "'")
            }; h.state = function () { return v }; var H = [], ta = !1, K = null; h.onUrlChange = function (b) {
                if (!ta) {
                    if (c.history) B(a).on("popstate",
                        f); B(a).on("hashchange", f); ta = !0
                } H.push(b); return b
            }; h.$$applicationDestroyed = function () { B(a).off("hashchange popstate", f) }; h.$$checkUrlChange = k; h.baseHref = function () { var a = ma.attr("href"); return a ? a.replace(/^(https?:)?\/\/[^/]*/, "") : "" }; h.defer = function (a, b) { var c; L++; c = n(function () { delete G[c]; e(a) }, b || 0); G[c] = !0; return c }; h.defer.cancel = function (a) { return G[a] ? (delete G[a], q(a), e(C), !0) : !1 }
        } function wf() {
            this.$get = ["$window", "$log", "$sniffer", "$document", function (a, b, d, c) {
                return new rg(a, c, b,
                    d)
            }]
        } function xf() {
            this.$get = function () {
                function a(a, c) {
                    function e(a) { a !== n && (q ? q === a && (q = a.n) : q = a, f(a.n, a.p), f(a, n), n = a, n.n = null) } function f(a, b) { a !== b && (a && (a.p = b), b && (b.n = a)) } if (a in b) throw M("$cacheFactory")("iid", a); var g = 0, k = P({}, c, { id: a }), h = S(), l = c && c.capacity || Number.MAX_VALUE, m = S(), n = null, q = null; return b[a] = {
                        put: function (a, b) { if (!w(b)) { if (l < Number.MAX_VALUE) { var c = m[a] || (m[a] = { key: a }); e(c) } a in h || g++; h[a] = b; g > l && this.remove(q.key); return b } }, get: function (a) {
                            if (l < Number.MAX_VALUE) {
                                var b =
                                    m[a]; if (!b) return; e(b)
                            } return h[a]
                        }, remove: function (a) { if (l < Number.MAX_VALUE) { var b = m[a]; if (!b) return; b === n && (n = b.p); b === q && (q = b.n); f(b.n, b.p); delete m[a] } a in h && (delete h[a], g--) }, removeAll: function () { h = S(); g = 0; m = S(); n = q = null }, destroy: function () { m = k = h = null; delete b[a] }, info: function () { return P({}, k, { size: g }) }
                    }
                } var b = {}; a.info = function () { var a = {}; p(b, function (b, e) { a[e] = b.info() }); return a }; a.get = function (a) { return b[a] }; return a
            }
        } function Uf() { this.$get = ["$cacheFactory", function (a) { return a("templates") }] }
    function Yc(a, b) {
        function d(a, b, c) { var d = /^\s*([@&<]|=(\*?))(\??)\s*([\w$]*)\s*$/, e = S(); p(a, function (a, g) { if (a in n) e[g] = n[a]; else { var f = a.match(d); if (!f) throw ba("iscp", b, g, a, c ? "controller bindings definition" : "isolate scope definition"); e[g] = { mode: f[1][0], collection: "*" === f[2], optional: "?" === f[3], attrName: f[4] || g }; f[4] && (n[a] = e[g]) } }); return e } function c(a) { var b = a.charAt(0); if (!b || b !== N(b)) throw ba("baddir", a); if (a !== a.trim()) throw ba("baddir", a); } function e(a) {
            var b = a.require || a.controller && a.name;
            !I(b) && E(b) && p(b, function (a, c) { var d = a.match(l); a.substring(d[0].length) || (b[c] = d[0] + c) }); return b
        } var f = {}, g = /^\s*directive:\s*([\w-]+)\s+(.*)$/, k = /(([\w-]+)(?::([^;]+))?;?)/, h = te("ngSrc,ngSrcset,src,srcset"), l = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/, m = /^(on[a-z]+|formaction)$/, n = S(); this.directive = function ma(b, d) {
            ib(b, "name"); Ia(b, "directive"); D(b) ? (c(b), ib(d, "directiveFactory"), f.hasOwnProperty(b) || (f[b] = [], a.factory(b + "Directive", ["$injector", "$exceptionHandler", function (a, c) {
                var d = []; p(f[b], function (g,
                    f) { try { var h = a.invoke(g); A(h) ? h = { compile: ka(h) } : !h.compile && h.link && (h.compile = ka(h.link)); h.priority = h.priority || 0; h.index = f; h.name = h.name || b; h.require = e(h); var k = h, l = h.restrict; if (l && (!D(l) || !/[EACM]/.test(l))) throw ba("badrestrict", l, b); k.restrict = l || "EA"; h.$$moduleName = g.$$moduleName; d.push(h) } catch (m) { c(m) } }); return d
            }])), f[b].push(d)) : p(b, Vb(ma)); return this
        }; this.component = function y(a, b) {
            function c(a) {
                function e(b) {
                    return A(b) || I(b) ? function (c, d) { return a.invoke(b, this, { $element: c, $attrs: d }) } :
                        b
                } var g = b.template || b.templateUrl ? b.template : "", f = { controller: d, controllerAs: sg(b.controller) || b.controllerAs || "$ctrl", template: e(g), templateUrl: e(b.templateUrl), transclude: b.transclude, scope: {}, bindToController: b.bindings || {}, restrict: "E", require: b.require }; p(b, function (a, b) { "$" === b.charAt(0) && (f[b] = a) }); return f
            } if (!D(a)) return p(a, Vb(Ra(this, y))), this; var d = b.controller || function () { }; p(b, function (a, b) { "$" === b.charAt(0) && (c[b] = a, A(d) && (d[b] = a)) }); c.$inject = ["$injector"]; return this.directive(a,
                c)
        }; this.aHrefSanitizationWhitelist = function (a) { return t(a) ? (b.aHrefSanitizationWhitelist(a), this) : b.aHrefSanitizationWhitelist() }; this.imgSrcSanitizationWhitelist = function (a) { return t(a) ? (b.imgSrcSanitizationWhitelist(a), this) : b.imgSrcSanitizationWhitelist() }; var q = !0; this.debugInfoEnabled = function (a) { return t(a) ? (q = a, this) : q }; var G = !1; this.preAssignBindingsEnabled = function (a) { return t(a) ? (G = a, this) : G }; var L = !1; this.strictComponentBindingsEnabled = function (a) { return t(a) ? (L = a, this) : L }; var z = 10; this.onChangesTtl =
            function (a) { return arguments.length ? (z = a, this) : z }; var v = !0; this.commentDirectivesEnabled = function (a) { return arguments.length ? (v = a, this) : v }; var s = !0; this.cssClassDirectivesEnabled = function (a) { return arguments.length ? (s = a, this) : s }; this.$get = ["$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$sce", "$animate", "$$sanitizeUri", function (a, b, c, e, n, F, R, x, W, r) {
                function O() {
                    try {
                        if (!--Fa) throw ga = void 0, ba("infchng", z); R.$apply(function () {
                            for (var a = [], b = 0,
                                c = ga.length; b < c; ++b)try { ga[b]() } catch (d) { a.push(d) } ga = void 0; if (a.length) throw a;
                        })
                    } finally { Fa++ }
                } function mc(a, b) { if (b) { var c = Object.keys(b), d, e, g; d = 0; for (e = c.length; d < e; d++)g = c[d], this[g] = b[g] } else this.$attr = {}; this.$$element = a } function Ua(a, b, c) { Ba.innerHTML = "<span " + b + ">"; b = Ba.firstChild.attributes; var d = b[0]; b.removeNamedItem(d.name); d.value = c; a.attributes.setNamedItem(d) } function na(a, b) { try { a.addClass(b) } catch (c) { } } function ca(a, b, c, d, e) {
                    a instanceof B || (a = B(a)); var g = Va(a, b, a, c, d, e); ca.$$addScopeClass(a);
                    var f = null; return function (b, c, d) {
                        if (!a) throw ba("multilink"); ib(b, "scope"); e && e.needsNewScope && (b = b.$parent.$new()); d = d || {}; var h = d.parentBoundTranscludeFn, k = d.transcludeControllers; d = d.futureParentElement; h && h.$$boundTransclude && (h = h.$$boundTransclude); f || (f = (d = d && d[0]) ? "foreignobject" !== za(d) && ha.call(d).match(/SVG/) ? "svg" : "html" : "html"); d = "html" !== f ? B(ja(f, B("<div>").append(a).html())) : c ? Sa.clone.call(a) : a; if (k) for (var l in k) d.data("$" + l + "Controller", k[l].instance); ca.$$addScopeInfo(d, b); c &&
                            c(d, b); g && g(b, d, d, h); c || (a = g = null); return d
                    }
                } function Va(a, b, c, d, e, g) {
                    function f(a, c, d, e) { var g, k, l, m, q, n, H; if (s) for (H = Array(c.length), m = 0; m < h.length; m += 3)g = h[m], H[g] = c[g]; else H = c; m = 0; for (q = h.length; m < q;)k = H[h[m++]], c = h[m++], g = h[m++], c ? (c.scope ? (l = a.$new(), ca.$$addScopeInfo(B(k), l)) : l = a, n = c.transcludeOnThisElement ? Ma(a, c.transclude, e) : !c.templateOnThisElement && e ? e : !e && b ? Ma(a, b) : null, c(g, l, k, d, n)) : g && g(a, k.childNodes, void 0, e) } for (var h = [], k = I(a) || a instanceof B, l, m, q, n, s, H = 0; H < a.length; H++) {
                        l = new mc;
                        11 === Ca && Da(a, H, k); m = M(a[H], [], l, 0 === H ? d : void 0, e); (g = m.length ? Y(m, a[H], l, b, c, null, [], [], g) : null) && g.scope && ca.$$addScopeClass(l.$$element); l = g && g.terminal || !(q = a[H].childNodes) || !q.length ? null : Va(q, g ? (g.transcludeOnThisElement || !g.templateOnThisElement) && g.transclude : b); if (g || l) h.push(H, g, l), n = !0, s = s || g; g = null
                    } return n ? f : null
                } function Da(a, b, c) {
                    var d = a[b], e = d.parentNode, g; if (d.nodeType === Oa) for (; ;) {
                        g = e ? d.nextSibling : a[b + 1]; if (!g || g.nodeType !== Oa) break; d.nodeValue += g.nodeValue; g.parentNode && g.parentNode.removeChild(g);
                        c && g === a[b + 1] && a.splice(b + 1, 1)
                    }
                } function Ma(a, b, c) { function d(e, g, f, h, k) { e || (e = a.$new(!1, k), e.$$transcluded = !0); return b(e, g, { parentBoundTranscludeFn: c, transcludeControllers: f, futureParentElement: h }) } var e = d.$$slots = S(), g; for (g in b.$$slots) e[g] = b.$$slots[g] ? Ma(a, b.$$slots[g], c) : null; return d } function M(a, b, c, d, e) {
                    var g = c.$attr, f; switch (a.nodeType) {
                        case 1: f = za(a); T(b, Ea(f), "E", d, e); for (var h, l, m, q, n = a.attributes, s = 0, H = n && n.length; s < H; s++) {
                            var J = !1, G = !1; h = n[s]; l = h.name; m = h.value; h = Ea(l); (q = Pa.test(h)) &&
                                (l = l.replace(od, "").substr(8).replace(/_(.)/g, function (a, b) { return b.toUpperCase() })); (h = h.match(Qa)) && $(h[1]) && (J = l, G = l.substr(0, l.length - 5) + "end", l = l.substr(0, l.length - 6)); h = Ea(l.toLowerCase()); g[h] = l; if (q || !c.hasOwnProperty(h)) c[h] = m, kd(a, h) && (c[h] = !0); xa(a, b, m, h, q); T(b, h, "A", d, e, J, G)
                        } "input" === f && "hidden" === a.getAttribute("type") && a.setAttribute("autocomplete", "off"); if (!La) break; g = a.className; E(g) && (g = g.animVal); if (D(g) && "" !== g) for (; a = k.exec(g);)h = Ea(a[2]), T(b, h, "C", d, e) && (c[h] = Q(a[3])), g = g.substr(a.index +
                            a[0].length); break; case Oa: oa(b, a.nodeValue); break; case 8: if (!Ka) break; nc(a, b, c, d, e)
                    }b.sort(ka); return b
                } function nc(a, b, c, d, e) { try { var f = g.exec(a.nodeValue); if (f) { var h = Ea(f[1]); T(b, h, "M", d, e) && (c[h] = Q(f[2])) } } catch (k) { } } function pd(a, b, c) { var d = [], e = 0; if (b && a.hasAttribute && a.hasAttribute(b)) { do { if (!a) throw ba("uterdir", b, c); 1 === a.nodeType && (a.hasAttribute(b) && e++ , a.hasAttribute(c) && e--); d.push(a); a = a.nextSibling } while (0 < e) } else d.push(a); return B(d) } function U(a, b, c) {
                    return function (d, e, g, f, h) {
                        e =
                            pd(e[0], b, c); return a(d, e, g, f, h)
                    }
                } function V(a, b, c, d, e, g) { var f; return a ? ca(b, c, d, e, g) : function () { f || (f = ca(b, c, d, e, g), b = c = g = null); return f.apply(this, arguments) } } function Y(a, b, d, e, g, f, h, k, l) {
                    function m(a, b, c, d) { if (a) { c && (a = U(a, c, d)); a.require = x.require; a.directiveName = W; if (K === x || x.$$isolateScope) a = ua(a, { isolateScope: !0 }); h.push(a) } if (b) { c && (b = U(b, c, d)); b.require = x.require; b.directiveName = W; if (K === x || x.$$isolateScope) b = ua(b, { isolateScope: !0 }); k.push(b) } } function q(a, e, g, f, l) {
                        function m(a, b, c, d) {
                            var e;
                            cb(a) || (d = c, c = b, b = a, a = void 0); ta && (e = L); c || (c = ta ? fa.parent() : fa); if (d) { var g = l.$$slots[d]; if (g) return g(a, b, e, c, O); if (w(g)) throw ba("noslot", d, Aa(fa)); } else return l(a, b, e, c, O)
                        } var n, x, F, y, R, L, z, fa; b === g ? (f = d, fa = d.$$element) : (fa = B(g), f = new mc(fa, d)); R = e; K ? y = e.$new(!0) : s && (R = e.$parent); l && (z = m, z.$$boundTransclude = l, z.isSlotFilled = function (a) { return !!l.$$slots[a] }); J && (L = da(fa, f, z, J, y, e, K)); K && (ca.$$addScopeInfo(fa, y, !0, !(v && (v === K || v === K.$$originalDirective))), ca.$$addScopeClass(fa, !0), y.$$isolateBindings =
                            K.$$isolateBindings, x = qa(e, f, y, y.$$isolateBindings, K), x.removeWatches && y.$on("$destroy", x.removeWatches)); for (n in L) { x = J[n]; F = L[n]; var W = x.$$bindings.bindToController; if (G) { F.bindingInfo = W ? qa(R, f, F.instance, W, x) : {}; var r = F(); r !== F.instance && (F.instance = r, fa.data("$" + x.name + "Controller", r), F.bindingInfo.removeWatches && F.bindingInfo.removeWatches(), F.bindingInfo = qa(R, f, F.instance, W, x)) } else F.instance = F(), fa.data("$" + x.name + "Controller", F.instance), F.bindingInfo = qa(R, f, F.instance, W, x) } p(J, function (a,
                                b) { var c = a.require; a.bindToController && !I(c) && E(c) && P(L[b].instance, X(b, c, fa, L)) }); p(L, function (a) { var b = a.instance; if (A(b.$onChanges)) try { b.$onChanges(a.bindingInfo.initialChanges) } catch (d) { c(d) } if (A(b.$onInit)) try { b.$onInit() } catch (e) { c(e) } A(b.$doCheck) && (R.$watch(function () { b.$doCheck() }), b.$doCheck()); A(b.$onDestroy) && R.$on("$destroy", function () { b.$onDestroy() }) }); n = 0; for (x = h.length; n < x; n++)F = h[n], wa(F, F.isolateScope ? y : e, fa, f, F.require && X(F.directiveName, F.require, fa, L), z); var O = e; K && (K.template ||
                                    null === K.templateUrl) && (O = y); a && a(O, g.childNodes, void 0, l); for (n = k.length - 1; 0 <= n; n--)F = k[n], wa(F, F.isolateScope ? y : e, fa, f, F.require && X(F.directiveName, F.require, fa, L), z); p(L, function (a) { a = a.instance; A(a.$postLink) && a.$postLink() })
                    } l = l || {}; for (var n = -Number.MAX_VALUE, s = l.newScopeDirective, J = l.controllerDirectives, K = l.newIsolateScopeDirective, v = l.templateDirective, y = l.nonTlbTranscludeDirective, R = !1, L = !1, ta = l.hasElementTranscludeDirective, F = d.$$element = B(b), x, W, z, r = e, O, t = !1, Jb = !1, u, Da = 0, C = a.length; Da <
                        C; Da++) {
                        x = a[Da]; var Ua = x.$$start, D = x.$$end; Ua && (F = pd(b, Ua, D)); z = void 0; if (n > x.priority) break; if (u = x.scope) x.templateUrl || (E(u) ? (aa("new/isolated scope", K || s, x, F), K = x) : aa("new/isolated scope", K, x, F)), s = s || x; W = x.name; if (!t && (x.replace && (x.templateUrl || x.template) || x.transclude && !x.$$tlb)) { for (u = Da + 1; t = a[u++];)if (t.transclude && !t.$$tlb || t.replace && (t.templateUrl || t.template)) { Jb = !0; break } t = !0 } !x.templateUrl && x.controller && (J = J || S(), aa("'" + W + "' controller", J[W], x, F), J[W] = x); if (u = x.transclude) if (R = !0,
                            x.$$tlb || (aa("transclusion", y, x, F), y = x), "element" === u) ta = !0, n = x.priority, z = F, F = d.$$element = B(ca.$$createComment(W, d[W])), b = F[0], la(g, ya.call(z, 0), b), z[0].$$parentNode = z[0].parentNode, r = V(Jb, z, e, n, f && f.name, { nonTlbTranscludeDirective: y }); else {
                            var na = S(); if (E(u)) {
                                z = []; var Va = S(), Ma = S(); p(u, function (a, b) { var c = "?" === a.charAt(0); a = c ? a.substring(1) : a; Va[a] = b; na[b] = null; Ma[b] = c }); p(F.contents(), function (a) { var b = Va[Ea(za(a))]; b ? (Ma[b] = !0, na[b] = na[b] || [], na[b].push(a)) : z.push(a) }); p(Ma, function (a, b) {
                                    if (!a) throw ba("reqslot",
                                        b);
                                }); for (var N in na) na[N] && (na[N] = V(Jb, na[N], e))
                            } else z = B(jc(b)).contents(); F.empty(); r = V(Jb, z, e, void 0, void 0, { needsNewScope: x.$$isolateScope || x.$$newScope }); r.$$slots = na
                        } if (x.template) if (L = !0, aa("template", v, x, F), v = x, u = A(x.template) ? x.template(F, d) : x.template, u = Ia(u), x.replace) {
                            f = x; z = gc.test(u) ? qd(ja(x.templateNamespace, Q(u))) : []; b = z[0]; if (1 !== z.length || 1 !== b.nodeType) throw ba("tplrt", W, ""); la(g, F, b); C = { $attr: {} }; u = M(b, [], C); var nc = a.splice(Da + 1, a.length - (Da + 1)); (K || s) && Z(u, K, s); a = a.concat(u).concat(nc);
                            ea(d, C); C = a.length
                        } else F.html(u); if (x.templateUrl) L = !0, aa("template", v, x, F), v = x, x.replace && (f = x), q = ia(a.splice(Da, a.length - Da), F, d, g, R && r, h, k, { controllerDirectives: J, newScopeDirective: s !== x && s, newIsolateScopeDirective: K, templateDirective: v, nonTlbTranscludeDirective: y }), C = a.length; else if (x.compile) try { O = x.compile(F, d, r); var T = x.$$originalDirective || x; A(O) ? m(null, Ra(T, O), Ua, D) : O && m(Ra(T, O.pre), Ra(T, O.post), Ua, D) } catch ($) { c($, Aa(F)) } x.terminal && (q.terminal = !0, n = Math.max(n, x.priority))
                    } q.scope = s && !0 ===
                        s.scope; q.transcludeOnThisElement = R; q.templateOnThisElement = L; q.transclude = r; l.hasElementTranscludeDirective = ta; return q
                } function X(a, b, c, d) {
                    var e; if (D(b)) { var g = b.match(l); b = b.substring(g[0].length); var f = g[1] || g[3], g = "?" === g[2]; "^^" === f ? c = c.parent() : e = (e = d && d[b]) && e.instance; if (!e) { var h = "$" + b + "Controller"; e = f ? c.inheritedData(h) : c.data(h) } if (!e && !g) throw ba("ctreq", b, a); } else if (I(b)) for (e = [], f = 0, g = b.length; f < g; f++)e[f] = X(a, b[f], c, d); else E(b) && (e = {}, p(b, function (b, g) { e[g] = X(a, b, c, d) })); return e ||
                        null
                } function da(a, b, c, d, e, g, f) { var h = S(), k; for (k in d) { var l = d[k], m = { $scope: l === f || l.$$isolateScope ? e : g, $element: a, $attrs: b, $transclude: c }, n = l.controller; "@" === n && (n = b[l.name]); m = F(n, m, !0, l.controllerAs); h[l.name] = m; a.data("$" + l.name + "Controller", m.instance) } return h } function Z(a, b, c) { for (var d = 0, e = a.length; d < e; d++)a[d] = Yb(a[d], { $$isolateScope: b, $$newScope: c }) } function T(b, c, e, g, h, k, l) {
                    if (c === h) return null; var m = null; if (f.hasOwnProperty(c)) {
                        h = a.get(c + "Directive"); for (var n = 0, q = h.length; n < q; n++)if (c =
                            h[n], (w(g) || g > c.priority) && -1 !== c.restrict.indexOf(e)) {
                            k && (c = Yb(c, { $$start: k, $$end: l })); if (!c.$$bindings) { var s = m = c, H = c.name, J = { isolateScope: null, bindToController: null }; E(s.scope) && (!0 === s.bindToController ? (J.bindToController = d(s.scope, H, !0), J.isolateScope = {}) : J.isolateScope = d(s.scope, H, !1)); E(s.bindToController) && (J.bindToController = d(s.bindToController, H, !0)); if (J.bindToController && !s.controller) throw ba("noctrl", H); m = m.$$bindings = J; E(m.isolateScope) && (c.$$isolateBindings = m.isolateScope) } b.push(c);
                            m = c
                        }
                    } return m
                } function $(b) { if (f.hasOwnProperty(b)) for (var c = a.get(b + "Directive"), d = 0, e = c.length; d < e; d++)if (b = c[d], b.multiElement) return !0; return !1 } function ea(a, b) { var c = b.$attr, d = a.$attr; p(a, function (d, e) { "$" !== e.charAt(0) && (b[e] && b[e] !== d && (d = d.length ? d + (("style" === e ? ";" : " ") + b[e]) : b[e]), a.$set(e, d, !0, c[e])) }); p(b, function (b, e) { a.hasOwnProperty(e) || "$" === e.charAt(0) || (a[e] = b, "class" !== e && "style" !== e && (d[e] = c[e])) }) } function ia(a, b, d, g, f, h, k, l) {
                    var m = [], n, q, s = b[0], J = a.shift(), x = Yb(J, {
                        templateUrl: null,
                        transclude: null, replace: null, $$originalDirective: J
                    }), G = A(J.templateUrl) ? J.templateUrl(b, d) : J.templateUrl, F = J.templateNamespace; b.empty(); e(G).then(function (c) {
                        var e, H; c = Ia(c); if (J.replace) { c = gc.test(c) ? qd(ja(F, Q(c))) : []; e = c[0]; if (1 !== c.length || 1 !== e.nodeType) throw ba("tplrt", J.name, G); c = { $attr: {} }; la(g, b, e); var K = M(e, [], c); E(J.scope) && Z(K, !0); a = K.concat(a); ea(d, c) } else e = s, b.html(c); a.unshift(x); n = Y(a, e, d, f, b, J, h, k, l); p(g, function (a, c) { a === e && (g[c] = b[0]) }); for (q = Va(b[0].childNodes, f); m.length;) {
                            c =
                                m.shift(); H = m.shift(); var v = m.shift(), y = m.shift(), K = b[0]; if (!c.$$destroyed) { if (H !== s) { var L = H.className; l.hasElementTranscludeDirective && J.replace || (K = jc(e)); la(v, B(H), K); na(B(K), L) } H = n.transcludeOnThisElement ? Ma(c, n.transclude, y) : y; n(q, c, K, g, H) }
                        } m = null
                    }).catch(function (a) { $b(a) && c(a) }); return function (a, b, c, d, e) { a = e; b.$$destroyed || (m ? m.push(b, c, d, a) : (n.transcludeOnThisElement && (a = Ma(b, n.transclude, e)), n(q, b, c, d, a))) }
                } function ka(a, b) {
                    var c = b.priority - a.priority; return 0 !== c ? c : a.name !== b.name ? a.name <
                        b.name ? -1 : 1 : a.index - b.index
                } function aa(a, b, c, d) { function e(a) { return a ? " (module: " + a + ")" : "" } if (b) throw ba("multidir", b.name, e(b.$$moduleName), c.name, e(c.$$moduleName), a, Aa(d)); } function oa(a, c) { var d = b(c, !0); d && a.push({ priority: 0, compile: function (a) { a = a.parent(); var b = !!a.length; b && ca.$$addBindingClass(a); return function (a, c) { var e = c.parent(); b || ca.$$addBindingClass(e); ca.$$addBindingInfo(e, d.expressions); a.$watch(d, function (a) { c[0].nodeValue = a }) } } }) } function ja(a, b) {
                    a = N(a || "html"); switch (a) {
                        case "svg": case "math": var c =
                            u.document.createElement("div"); c.innerHTML = "<" + a + ">" + b + "</" + a + ">"; return c.childNodes[0].childNodes; default: return b
                    }
                } function va(a, b) { if ("srcdoc" === b) return x.HTML; var c = za(a); if ("src" === b || "ngSrc" === b) { if (-1 === ["img", "video", "audio", "source", "track"].indexOf(c)) return x.RESOURCE_URL } else if ("xlinkHref" === b || "form" === c && "action" === b || "link" === c && "href" === b) return x.RESOURCE_URL } function xa(a, c, d, e, g) {
                    var f = va(a, e), k = h[e] || g, l = b(d, !g, f, k); if (l) {
                        if ("multiple" === e && "select" === za(a)) throw ba("selmulti",
                            Aa(a)); if (m.test(e)) throw ba("nodomevents"); c.push({ priority: 100, compile: function () { return { pre: function (a, c, g) { c = g.$$observers || (g.$$observers = S()); var h = g[e]; h !== d && (l = h && b(h, !0, f, k), d = h); l && (g[e] = l(a), (c[e] || (c[e] = [])).$$inter = !0, (g.$$observers && g.$$observers[e].$$scope || a).$watch(l, function (a, b) { "class" === e && a !== b ? g.$updateClass(a, b) : g.$set(e, a) })) } } } })
                    }
                } function la(a, b, c) {
                    var d = b[0], e = b.length, g = d.parentNode, f, h; if (a) for (f = 0, h = a.length; f < h; f++)if (a[f] === d) {
                        a[f++] = c; h = f + e - 1; for (var k = a.length; f <
                            k; f++ , h++)h < k ? a[f] = a[h] : delete a[f]; a.length -= e - 1; a.context === d && (a.context = c); break
                    } g && g.replaceChild(c, d); a = u.document.createDocumentFragment(); for (f = 0; f < e; f++)a.appendChild(b[f]); B.hasData(d) && (B.data(c, B.data(d)), B(d).off("$destroy")); B.cleanData(a.querySelectorAll("*")); for (f = 1; f < e; f++)delete b[f]; b[0] = c; b.length = 1
                } function ua(a, b) { return P(function () { return a.apply(null, arguments) }, a, b) } function wa(a, b, d, e, g, f) { try { a(b, d, e, g, f) } catch (h) { c(h, Aa(d)) } } function pa(a, b) {
                    if (L) throw ba("missingattr",
                        a, b);
                } function qa(a, c, d, e, g) {
                    function f(b, c, e) { A(d.$onChanges) && !ac(c, e) && (ga || (a.$$postDigest(O), ga = []), m || (m = {}, ga.push(h)), m[b] && (e = m[b].previousValue), m[b] = new Kb(e, c)) } function h() { d.$onChanges(m); m = void 0 } var k = [], l = {}, m; p(e, function (e, h) {
                        var m = e.attrName, q = e.optional, s, H, x, G; switch (e.mode) {
                            case "@": q || ra.call(c, m) || (pa(m, g.name), d[h] = c[m] = void 0); q = c.$observe(m, function (a) { if (D(a) || Na(a)) f(h, a, d[h]), d[h] = a }); c.$$observers[m].$$scope = a; s = c[m]; D(s) ? d[h] = b(s)(a) : Na(s) && (d[h] = s); l[h] = new Kb(oc,
                                d[h]); k.push(q); break; case "=": if (!ra.call(c, m)) { if (q) break; pa(m, g.name); c[m] = void 0 } if (q && !c[m]) break; H = n(c[m]); G = H.literal ? sa : ac; x = H.assign || function () { s = d[h] = H(a); throw ba("nonassign", c[m], m, g.name); }; s = d[h] = H(a); q = function (b) { G(b, d[h]) || (G(b, s) ? x(a, b = d[h]) : d[h] = b); return s = b }; q.$stateful = !0; q = e.collection ? a.$watchCollection(c[m], q) : a.$watch(n(c[m], q), null, H.literal); k.push(q); break; case "<": if (!ra.call(c, m)) { if (q) break; pa(m, g.name); c[m] = void 0 } if (q && !c[m]) break; H = n(c[m]); var F = H.literal, v = d[h] =
                                    H(a); l[h] = new Kb(oc, d[h]); q = a.$watch(H, function (a, b) { if (b === a) { if (b === v || F && sa(b, v)) return; b = v } f(h, a, b); d[h] = a }, F); k.push(q); break; case "&": q || ra.call(c, m) || pa(m, g.name); H = c.hasOwnProperty(m) ? n(c[m]) : C; if (H === C && q) break; d[h] = function (b) { return H(a, b) }
                        }
                    }); return { initialChanges: l, removeWatches: k.length && function () { for (var a = 0, b = k.length; a < b; ++a)k[a]() } }
                } var Ja = /^\w/, Ba = u.document.createElement("div"), Ka = v, La = s, Fa = z, ga; mc.prototype = {
                    $normalize: Ea, $addClass: function (a) {
                        a && 0 < a.length && W.addClass(this.$$element,
                            a)
                    }, $removeClass: function (a) { a && 0 < a.length && W.removeClass(this.$$element, a) }, $updateClass: function (a, b) { var c = rd(a, b); c && c.length && W.addClass(this.$$element, c); (c = rd(b, a)) && c.length && W.removeClass(this.$$element, c) }, $set: function (a, b, d, e) {
                        var g = kd(this.$$element[0], a), f = sd[a], h = a; g ? (this.$$element.prop(a, b), e = g) : f && (this[f] = b, h = f); this[a] = b; e ? this.$attr[a] = e : (e = this.$attr[a]) || (this.$attr[a] = e = Vc(a, "-")); g = za(this.$$element); if ("a" === g && ("href" === a || "xlinkHref" === a) || "img" === g && "src" === a) this[a] =
                            b = r(b, "src" === a); else if ("img" === g && "srcset" === a && t(b)) { for (var g = "", f = Q(b), k = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/, k = /\s/.test(f) ? k : /(,)/, f = f.split(k), k = Math.floor(f.length / 2), l = 0; l < k; l++)var m = 2 * l, g = g + r(Q(f[m]), !0), g = g + (" " + Q(f[m + 1])); f = Q(f[2 * l]).split(/\s/); g += r(Q(f[0]), !0); 2 === f.length && (g += " " + Q(f[1])); this[a] = b = g } !1 !== d && (null === b || w(b) ? this.$$element.removeAttr(e) : Ja.test(e) ? this.$$element.attr(e, b) : Ua(this.$$element[0], e, b)); (a = this.$$observers) && p(a[h], function (a) { try { a(b) } catch (d) { c(d) } })
                    },
                    $observe: function (a, b) { var c = this, d = c.$$observers || (c.$$observers = S()), e = d[a] || (d[a] = []); e.push(b); R.$evalAsync(function () { e.$$inter || !c.hasOwnProperty(a) || w(c[a]) || b(c[a]) }); return function () { db(e, b) } }
                }; var Ga = b.startSymbol(), Ha = b.endSymbol(), Ia = "{{" === Ga && "}}" === Ha ? bb : function (a) { return a.replace(/\{\{/g, Ga).replace(/}}/g, Ha) }, Pa = /^ngAttr[A-Z]/, Qa = /^(.+)Start$/; ca.$$addBindingInfo = q ? function (a, b) { var c = a.data("$binding") || []; I(b) ? c = c.concat(b) : c.push(b); a.data("$binding", c) } : C; ca.$$addBindingClass =
                    q ? function (a) { na(a, "ng-binding") } : C; ca.$$addScopeInfo = q ? function (a, b, c, d) { a.data(c ? d ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope", b) } : C; ca.$$addScopeClass = q ? function (a, b) { na(a, b ? "ng-isolate-scope" : "ng-scope") } : C; ca.$$createComment = function (a, b) { var c = ""; q && (c = " " + (a || "") + ": ", b && (c += b + " ")); return u.document.createComment(c) }; return ca
            }]
    } function Kb(a, b) { this.previousValue = a; this.currentValue = b } function Ea(a) { return a.replace(od, "").replace(tg, jb) } function rd(a, b) {
        var d = "", c = a.split(/\s+/),
            e = b.split(/\s+/), f = 0; a: for (; f < c.length; f++) { for (var g = c[f], k = 0; k < e.length; k++)if (g === e[k]) continue a; d += (0 < d.length ? " " : "") + g } return d
    } function qd(a) { a = B(a); var b = a.length; if (1 >= b) return a; for (; b--;) { var d = a[b]; (8 === d.nodeType || d.nodeType === Oa && "" === d.nodeValue.trim()) && ug.call(a, b, 1) } return a } function sg(a, b) { if (b && D(b)) return b; if (D(a)) { var d = td.exec(a); if (d) return d[3] } } function yf() {
        var a = {}, b = !1; this.has = function (b) { return a.hasOwnProperty(b) }; this.register = function (b, c) {
            Ia(b, "controller"); E(b) ?
                P(a, b) : a[b] = c
        }; this.allowGlobals = function () { b = !0 }; this.$get = ["$injector", "$window", function (d, c) {
            function e(a, b, c, d) { if (!a || !E(a.$scope)) throw M("$controller")("noscp", d, b); a.$scope[b] = c } return function (f, g, k, h) {
                var l, m, n; k = !0 === k; h && D(h) && (n = h); if (D(f)) { h = f.match(td); if (!h) throw ud("ctrlfmt", f); m = h[1]; n = n || h[3]; f = a.hasOwnProperty(m) ? a[m] : Xc(g.$scope, m, !0) || (b ? Xc(c, m, !0) : void 0); if (!f) throw ud("ctrlreg", m); ub(f, m, !0) } if (k) return k = (I(f) ? f[f.length - 1] : f).prototype, l = Object.create(k || null), n && e(g, n,
                    l, m || f.name), P(function () { var a = d.invoke(f, l, g, m); a !== l && (E(a) || A(a)) && (l = a, n && e(g, n, l, m || f.name)); return l }, { instance: l, identifier: n }); l = d.instantiate(f, g, m); n && e(g, n, l, m || f.name); return l
            }
        }]
    } function zf() { this.$get = ["$window", function (a) { return B(a.document) }] } function Af() { this.$get = ["$document", "$rootScope", function (a, b) { function d() { e = c.hidden } var c = a[0], e = c && c.hidden; a.on("visibilitychange", d); b.$on("$destroy", function () { a.off("visibilitychange", d) }); return function () { return e } }] } function Bf() {
        this.$get =
            ["$log", function (a) { return function (b, d) { a.error.apply(a, arguments) } }]
    } function pc(a) { return E(a) ? ea(a) ? a.toISOString() : fb(a) : a } function Gf() { this.$get = function () { return function (a) { if (!a) return ""; var b = []; Nc(a, function (a, c) { null === a || w(a) || A(a) || (I(a) ? p(a, function (a) { b.push(ia(c) + "=" + ia(pc(a))) }) : b.push(ia(c) + "=" + ia(pc(a)))) }); return b.join("&") } } } function Hf() {
        this.$get = function () {
            return function (a) {
                function b(a, e, f) {
                    null === a || w(a) || (I(a) ? p(a, function (a, c) { b(a, e + "[" + (E(a) ? c : "") + "]") }) : E(a) && !ea(a) ?
                        Nc(a, function (a, c) { b(a, e + (f ? "" : "[") + c + (f ? "" : "]")) }) : d.push(ia(e) + "=" + ia(pc(a))))
                } if (!a) return ""; var d = []; b(a, "", !0); return d.join("&")
            }
        }
    } function qc(a, b) { if (D(a)) { var d = a.replace(vg, "").trim(); if (d) { var c = b("Content-Type"), c = c && 0 === c.indexOf(vd), e; (e = c) || (e = (e = d.match(wg)) && xg[e[0]].test(d)); if (e) try { a = Qc(d) } catch (f) { if (!c) return a; throw rc("baddata", a, f); } } } return a } function wd(a) {
        var b = S(), d; D(a) ? p(a.split("\n"), function (a) {
            d = a.indexOf(":"); var e = N(Q(a.substr(0, d))); a = Q(a.substr(d + 1)); e && (b[e] =
                b[e] ? b[e] + ", " + a : a)
        }) : E(a) && p(a, function (a, d) { var f = N(d), g = Q(a); f && (b[f] = b[f] ? b[f] + ", " + g : g) }); return b
    } function xd(a) { var b; return function (d) { b || (b = wd(a)); return d ? (d = b[N(d)], void 0 === d && (d = null), d) : b } } function yd(a, b, d, c) { if (A(c)) return c(a, b, d); p(c, function (c) { a = c(a, b, d) }); return a } function Ff() {
        var a = this.defaults = {
            transformResponse: [qc], transformRequest: [function (a) { return E(a) && "[object File]" !== ha.call(a) && "[object Blob]" !== ha.call(a) && "[object FormData]" !== ha.call(a) ? fb(a) : a }], headers: {
                common: { Accept: "application/json, text/plain, */*" },
                post: ja(sc), put: ja(sc), patch: ja(sc)
            }, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", paramSerializer: "$httpParamSerializer", jsonpCallbackParam: "callback"
        }, b = !1; this.useApplyAsync = function (a) { return t(a) ? (b = !!a, this) : b }; var d = this.interceptors = []; this.$get = ["$browser", "$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", "$sce", function (c, e, f, g, k, h, l, m) {
            function n(b) {
                function d(a, b) { for (var c = 0, e = b.length; c < e;) { var g = b[c++], f = b[c++]; a = a.then(g, f) } b.length = 0; return a }
                function e(a, b) { var c, d = {}; p(a, function (a, e) { A(a) ? (c = a(b), null != c && (d[e] = c)) : d[e] = a }); return d } function g(a) { var b = P({}, a); b.data = yd(a.data, a.headers, a.status, f.transformResponse); a = a.status; return 200 <= a && 300 > a ? b : h.reject(b) } if (!E(b)) throw M("$http")("badreq", b); if (!D(m.valueOf(b.url))) throw M("$http")("badreq", b.url); var f = P({ method: "get", transformRequest: a.transformRequest, transformResponse: a.transformResponse, paramSerializer: a.paramSerializer, jsonpCallbackParam: a.jsonpCallbackParam }, b); f.headers =
                    function (b) { var c = a.headers, d = P({}, b.headers), g, f, h, c = P({}, c.common, c[N(b.method)]); a: for (g in c) { f = N(g); for (h in d) if (N(h) === f) continue a; d[g] = c[g] } return e(d, ja(b)) }(b); f.method = wb(f.method); f.paramSerializer = D(f.paramSerializer) ? l.get(f.paramSerializer) : f.paramSerializer; c.$$incOutstandingRequestCount(); var k = [], n = []; b = h.resolve(f); p(v, function (a) { (a.request || a.requestError) && k.unshift(a.request, a.requestError); (a.response || a.responseError) && n.push(a.response, a.responseError) }); b = d(b, k); b = b.then(function (b) {
                        var c =
                            b.headers, d = yd(b.data, xd(c), void 0, b.transformRequest); w(d) && p(c, function (a, b) { "content-type" === N(b) && delete c[b] }); w(b.withCredentials) && !w(a.withCredentials) && (b.withCredentials = a.withCredentials); return q(b, d).then(g, g)
                    }); b = d(b, n); return b = b.finally(function () { c.$$completeOutstandingRequest(C) })
            } function q(c, d) {
                function g(a) { if (a) { var c = {}; p(a, function (a, d) { c[d] = function (c) { function d() { a(c) } b ? k.$applyAsync(d) : k.$$phase ? d() : k.$apply(d) } }); return c } } function l(a, c, d, e, g) {
                    function f() {
                        q(c, a, d, e,
                            g)
                    } R && (200 <= a && 300 > a ? R.put(O, [a, c, wd(d), e, g]) : R.remove(O)); b ? k.$applyAsync(f) : (f(), k.$$phase || k.$apply())
                } function q(a, b, d, e, g) { b = -1 <= b ? b : 0; (200 <= b && 300 > b ? K.resolve : K.reject)({ data: a, status: b, headers: xd(d), config: c, statusText: e, xhrStatus: g }) } function H(a) { q(a.data, a.status, ja(a.headers()), a.statusText, a.xhrStatus) } function v() { var a = n.pendingRequests.indexOf(c); -1 !== a && n.pendingRequests.splice(a, 1) } var K = h.defer(), F = K.promise, R, x, W = c.headers, r = "jsonp" === N(c.method), O = c.url; r ? O = m.getTrustedResourceUrl(O) :
                    D(O) || (O = m.valueOf(O)); O = G(O, c.paramSerializer(c.params)); r && (O = L(O, c.jsonpCallbackParam)); n.pendingRequests.push(c); F.then(v, v); !c.cache && !a.cache || !1 === c.cache || "GET" !== c.method && "JSONP" !== c.method || (R = E(c.cache) ? c.cache : E(a.cache) ? a.cache : z); R && (x = R.get(O), t(x) ? x && A(x.then) ? x.then(H, H) : I(x) ? q(x[1], x[0], ja(x[2]), x[3], x[4]) : q(x, 200, {}, "OK", "complete") : R.put(O, F)); w(x) && ((x = zd(c.url) ? f()[c.xsrfCookieName || a.xsrfCookieName] : void 0) && (W[c.xsrfHeaderName || a.xsrfHeaderName] = x), e(c.method, O, d, l, W, c.timeout,
                        c.withCredentials, c.responseType, g(c.eventHandlers), g(c.uploadEventHandlers))); return F
            } function G(a, b) { 0 < b.length && (a += (-1 === a.indexOf("?") ? "?" : "&") + b); return a } function L(a, b) { if (/[&?][^=]+=JSON_CALLBACK/.test(a)) throw rc("badjsonp", a); if ((new RegExp("[&?]" + b + "=")).test(a)) throw rc("badjsonp", b, a); return a += (-1 === a.indexOf("?") ? "?" : "&") + b + "=JSON_CALLBACK" } var z = g("$http"); a.paramSerializer = D(a.paramSerializer) ? l.get(a.paramSerializer) : a.paramSerializer; var v = []; p(d, function (a) {
                v.unshift(D(a) ? l.get(a) :
                    l.invoke(a))
            }); n.pendingRequests = []; (function (a) { p(arguments, function (a) { n[a] = function (b, c) { return n(P({}, c || {}, { method: a, url: b })) } }) })("get", "delete", "head", "jsonp"); (function (a) { p(arguments, function (a) { n[a] = function (b, c, d) { return n(P({}, d || {}, { method: a, url: b, data: c })) } }) })("post", "put", "patch"); n.defaults = a; return n
        }]
    } function Jf() { this.$get = function () { return function () { return new u.XMLHttpRequest } } } function If() {
        this.$get = ["$browser", "$jsonpCallbacks", "$document", "$xhrFactory", function (a, b, d, c) {
            return yg(a,
                c, a.defer, b, d[0])
        }]
    } function yg(a, b, d, c, e) {
        function f(a, b, d) { a = a.replace("JSON_CALLBACK", b); var f = e.createElement("script"), m = null; f.type = "text/javascript"; f.src = a; f.async = !0; m = function (a) { f.removeEventListener("load", m); f.removeEventListener("error", m); e.body.removeChild(f); f = null; var g = -1, G = "unknown"; a && ("load" !== a.type || c.wasCalled(b) || (a = { type: "error" }), G = a.type, g = "error" === a.type ? 404 : 200); d && d(g, G) }; f.addEventListener("load", m); f.addEventListener("error", m); e.body.appendChild(f); return m } return function (e,
            k, h, l, m, n, q, G, L, z) {
            function v() { ma && ma(); y && y.abort() } function s(a, b, c, e, g, f) { t(H) && d.cancel(H); ma = y = null; a(b, c, e, g, f) } k = k || a.url(); if ("jsonp" === N(e)) var r = c.createCallback(k), ma = f(k, r, function (a, b) { var d = 200 === a && c.getResponse(r); s(l, a, d, "", b, "complete"); c.removeCallback(r) }); else {
                var y = b(e, k); y.open(e, k, !0); p(m, function (a, b) { t(a) && y.setRequestHeader(b, a) }); y.onload = function () {
                    var a = y.statusText || "", b = "response" in y ? y.response : y.responseText, c = 1223 === y.status ? 204 : y.status; 0 === c && (c = b ? 200 : "file" ===
                        ua(k).protocol ? 404 : 0); s(l, c, b, y.getAllResponseHeaders(), a, "complete")
                }; y.onerror = function () { s(l, -1, null, null, "", "error") }; y.onabort = function () { s(l, -1, null, null, "", "abort") }; y.ontimeout = function () { s(l, -1, null, null, "", "timeout") }; p(L, function (a, b) { y.addEventListener(b, a) }); p(z, function (a, b) { y.upload.addEventListener(b, a) }); q && (y.withCredentials = !0); if (G) try { y.responseType = G } catch (J) { if ("json" !== G) throw J; } y.send(w(h) ? null : h)
            } if (0 < n) var H = d(v, n); else n && A(n.then) && n.then(v)
        }
    } function Df() {
        var a = "{{",
            b = "}}"; this.startSymbol = function (b) { return b ? (a = b, this) : a }; this.endSymbol = function (a) { return a ? (b = a, this) : b }; this.$get = ["$parse", "$exceptionHandler", "$sce", function (d, c, e) {
                function f(a) { return "\\\\\\" + a } function g(c) { return c.replace(n, a).replace(q, b) } function k(a, b, c, d) { var e = a.$watch(function (a) { e(); return d(a) }, b, c); return e } function h(f, h, q, n) {
                    function s(a) { try { var b = a; a = q ? e.getTrusted(q, b) : e.valueOf(b); return n && !t(a) ? a : dc(a) } catch (d) { c(Fa.interr(f, d)) } } if (!f.length || -1 === f.indexOf(a)) {
                        var p;
                        h || (h = g(f), p = ka(h), p.exp = f, p.expressions = [], p.$$watchDelegate = k); return p
                    } n = !!n; var r, y, J = 0, H = [], ta = []; p = f.length; for (var K = [], F = []; J < p;)if (-1 !== (r = f.indexOf(a, J)) && -1 !== (y = f.indexOf(b, r + l))) J !== r && K.push(g(f.substring(J, r))), J = f.substring(r + l, y), H.push(J), ta.push(d(J, s)), J = y + m, F.push(K.length), K.push(""); else { J !== p && K.push(g(f.substring(J))); break } q && 1 < K.length && Fa.throwNoconcat(f); if (!h || H.length) {
                        var R = function (a) { for (var b = 0, c = H.length; b < c; b++) { if (n && w(a[b])) return; K[F[b]] = a[b] } return K.join("") };
                        return P(function (a) { var b = 0, d = H.length, e = Array(d); try { for (; b < d; b++)e[b] = ta[b](a); return R(e) } catch (g) { c(Fa.interr(f, g)) } }, { exp: f, expressions: H, $$watchDelegate: function (a, b) { var c; return a.$watchGroup(ta, function (d, e) { var g = R(d); A(b) && b.call(this, g, d !== e ? c : g, a); c = g }) } })
                    }
                } var l = a.length, m = b.length, n = new RegExp(a.replace(/./g, f), "g"), q = new RegExp(b.replace(/./g, f), "g"); h.startSymbol = function () { return a }; h.endSymbol = function () { return b }; return h
            }]
    } function Ef() {
        this.$get = ["$rootScope", "$window", "$q",
            "$$q", "$browser", function (a, b, d, c, e) {
                function f(f, h, l, m) { function n() { q ? f.apply(null, G) : f(v) } var q = 4 < arguments.length, G = q ? ya.call(arguments, 4) : [], L = b.setInterval, p = b.clearInterval, v = 0, s = t(m) && !m, r = (s ? c : d).defer(), ma = r.promise; l = t(l) ? l : 0; ma.$$intervalId = L(function () { s ? e.defer(n) : a.$evalAsync(n); r.notify(v++); 0 < l && v >= l && (r.resolve(v), p(ma.$$intervalId), delete g[ma.$$intervalId]); s || a.$apply() }, h); g[ma.$$intervalId] = r; return ma } var g = {}; f.cancel = function (a) {
                    return a && a.$$intervalId in g ? (g[a.$$intervalId].promise.$$state.pur =
                        !0, g[a.$$intervalId].reject("canceled"), b.clearInterval(a.$$intervalId), delete g[a.$$intervalId], !0) : !1
                }; return f
            }]
    } function tc(a) { a = a.split("/"); for (var b = a.length; b--;)a[b] = gb(a[b]); return a.join("/") } function Ad(a, b) { var d = ua(a); b.$$protocol = d.protocol; b.$$host = d.hostname; b.$$port = Z(d.port) || zg[d.protocol] || null } function Bd(a, b) {
        if (Ag.test(a)) throw mb("badpath", a); var d = "/" !== a.charAt(0); d && (a = "/" + a); var c = ua(a); b.$$path = decodeURIComponent(d && "/" === c.pathname.charAt(0) ? c.pathname.substring(1) :
            c.pathname); b.$$search = Tc(c.search); b.$$hash = decodeURIComponent(c.hash); b.$$path && "/" !== b.$$path.charAt(0) && (b.$$path = "/" + b.$$path)
    } function uc(a, b) { return a.slice(0, b.length) === b } function va(a, b) { if (uc(b, a)) return b.substr(a.length) } function La(a) { var b = a.indexOf("#"); return -1 === b ? a : a.substr(0, b) } function nb(a) { return a.replace(/(#.+)|#$/, "$1") } function vc(a, b, d) {
        this.$$html5 = !0; d = d || ""; Ad(a, this); this.$$parse = function (a) {
            var d = va(b, a); if (!D(d)) throw mb("ipthprfx", a, b); Bd(d, this); this.$$path || (this.$$path =
                "/"); this.$$compose()
        }; this.$$compose = function () { var a = cc(this.$$search), d = this.$$hash ? "#" + gb(this.$$hash) : ""; this.$$url = tc(this.$$path) + (a ? "?" + a : "") + d; this.$$absUrl = b + this.$$url.substr(1); this.$$urlUpdatedByLocation = !0 }; this.$$parseLinkUrl = function (c, e) { if (e && "#" === e[0]) return this.hash(e.slice(1)), !0; var f, g; t(f = va(a, c)) ? (g = f, g = d && t(f = va(d, f)) ? b + (va("/", f) || f) : a + g) : t(f = va(b, c)) ? g = b + f : b === c + "/" && (g = b); g && this.$$parse(g); return !!g }
    } function wc(a, b, d) {
        Ad(a, this); this.$$parse = function (c) {
            var e = va(a,
                c) || va(b, c), f; w(e) || "#" !== e.charAt(0) ? this.$$html5 ? f = e : (f = "", w(e) && (a = c, this.replace())) : (f = va(d, e), w(f) && (f = e)); Bd(f, this); c = this.$$path; var e = a, g = /^\/[A-Z]:(\/.*)/; uc(f, e) && (f = f.replace(e, "")); g.exec(f) || (c = (f = g.exec(c)) ? f[1] : c); this.$$path = c; this.$$compose()
        }; this.$$compose = function () { var b = cc(this.$$search), e = this.$$hash ? "#" + gb(this.$$hash) : ""; this.$$url = tc(this.$$path) + (b ? "?" + b : "") + e; this.$$absUrl = a + (this.$$url ? d + this.$$url : ""); this.$$urlUpdatedByLocation = !0 }; this.$$parseLinkUrl = function (b, d) {
            return La(a) ===
                La(b) ? (this.$$parse(b), !0) : !1
        }
    } function Cd(a, b, d) { this.$$html5 = !0; wc.apply(this, arguments); this.$$parseLinkUrl = function (c, e) { if (e && "#" === e[0]) return this.hash(e.slice(1)), !0; var f, g; a === La(c) ? f = c : (g = va(b, c)) ? f = a + d + g : b === c + "/" && (f = b); f && this.$$parse(f); return !!f }; this.$$compose = function () { var b = cc(this.$$search), e = this.$$hash ? "#" + gb(this.$$hash) : ""; this.$$url = tc(this.$$path) + (b ? "?" + b : "") + e; this.$$absUrl = a + d + this.$$url; this.$$urlUpdatedByLocation = !0 } } function Lb(a) { return function () { return this[a] } }
    function Dd(a, b) { return function (d) { if (w(d)) return this[a]; this[a] = b(d); this.$$compose(); return this } } function Lf() {
        var a = "!", b = { enabled: !1, requireBase: !0, rewriteLinks: !0 }; this.hashPrefix = function (b) { return t(b) ? (a = b, this) : a }; this.html5Mode = function (a) { if (Na(a)) return b.enabled = a, this; if (E(a)) { Na(a.enabled) && (b.enabled = a.enabled); Na(a.requireBase) && (b.requireBase = a.requireBase); if (Na(a.rewriteLinks) || D(a.rewriteLinks)) b.rewriteLinks = a.rewriteLinks; return this } return b }; this.$get = ["$rootScope", "$browser",
            "$sniffer", "$rootElement", "$window", function (d, c, e, f, g) {
                function k(a, b, d) { var e = l.url(), g = l.$$state; try { c.url(a, b, d), l.$$state = c.state() } catch (f) { throw l.url(e), l.$$state = g, f; } } function h(a, b) { d.$broadcast("$locationChangeSuccess", l.absUrl(), a, l.$$state, b) } var l, m; m = c.baseHref(); var n = c.url(), q; if (b.enabled) { if (!m && b.requireBase) throw mb("nobase"); q = n.substring(0, n.indexOf("/", n.indexOf("//") + 2)) + (m || "/"); m = e.history ? vc : Cd } else q = La(n), m = wc; var G = q.substr(0, La(q).lastIndexOf("/") + 1); l = new m(q, G, "#" +
                    a); l.$$parseLinkUrl(n, n); l.$$state = c.state(); var p = /^\s*(javascript|mailto):/i; f.on("click", function (a) {
                        var e = b.rewriteLinks; if (e && !a.ctrlKey && !a.metaKey && !a.shiftKey && 2 !== a.which && 2 !== a.button) {
                            for (var h = B(a.target); "a" !== za(h[0]);)if (h[0] === f[0] || !(h = h.parent())[0]) return; if (!D(e) || !w(h.attr(e))) {
                                var e = h.prop("href"), k = h.attr("href") || h.attr("xlink:href"); E(e) && "[object SVGAnimatedString]" === e.toString() && (e = ua(e.animVal).href); p.test(e) || !e || h.attr("target") || a.isDefaultPrevented() || !l.$$parseLinkUrl(e,
                                    k) || (a.preventDefault(), l.absUrl() !== c.url() && (d.$apply(), g.angular["ff-684208-preventDefault"] = !0))
                            }
                        }
                    }); nb(l.absUrl()) !== nb(n) && c.url(l.absUrl(), !0); var z = !0; c.onUrlChange(function (a, b) { uc(a, G) ? (d.$evalAsync(function () { var c = l.absUrl(), e = l.$$state, g; a = nb(a); l.$$parse(a); l.$$state = b; g = d.$broadcast("$locationChangeStart", a, c, b, e).defaultPrevented; l.absUrl() === a && (g ? (l.$$parse(c), l.$$state = e, k(c, !1, e)) : (z = !1, h(c, e))) }), d.$$phase || d.$digest()) : g.location.href = a }); d.$watch(function () {
                        if (z || l.$$urlUpdatedByLocation) {
                            l.$$urlUpdatedByLocation =
                                !1; var a = nb(c.url()), b = nb(l.absUrl()), g = c.state(), f = l.$$replace, m = a !== b || l.$$html5 && e.history && g !== l.$$state; if (z || m) z = !1, d.$evalAsync(function () { var b = l.absUrl(), c = d.$broadcast("$locationChangeStart", b, a, l.$$state, g).defaultPrevented; l.absUrl() === b && (c ? (l.$$parse(a), l.$$state = g) : (m && k(b, f, g === l.$$state ? null : l.$$state), h(a, g))) })
                        } l.$$replace = !1
                    }); return l
            }]
    } function Mf() {
        var a = !0, b = this; this.debugEnabled = function (b) { return t(b) ? (a = b, this) : a }; this.$get = ["$window", function (d) {
            function c(a) {
                $b(a) && (a.stack &&
                    f ? a = a.message && -1 === a.stack.indexOf(a.message) ? "Error: " + a.message + "\n" + a.stack : a.stack : a.sourceURL && (a = a.message + "\n" + a.sourceURL + ":" + a.line)); return a
            } function e(a) { var b = d.console || {}, e = b[a] || b.log || C; return function () { var a = []; p(arguments, function (b) { a.push(c(b)) }); return Function.prototype.apply.call(e, b, a) } } var f = Ca || /\bEdge\//.test(d.navigator && d.navigator.userAgent); return {
                log: e("log"), info: e("info"), warn: e("warn"), error: e("error"), debug: function () {
                    var c = e("debug"); return function () {
                        a && c.apply(b,
                            arguments)
                    }
                }()
            }
        }]
    } function Bg(a) { return a + "" } function Cg(a, b) { return "undefined" !== typeof a ? a : b } function Ed(a, b) { return "undefined" === typeof a ? b : "undefined" === typeof b ? a : a + b } function Dg(a, b) { switch (a.type) { case r.MemberExpression: if (a.computed) return !1; break; case r.UnaryExpression: return 1; case r.BinaryExpression: return "+" !== a.operator ? 1 : !1; case r.CallExpression: return !1 }return void 0 === b ? Fd : b } function V(a, b, d) {
        var c, e, f = a.isPure = Dg(a, d); switch (a.type) {
            case r.Program: c = !0; p(a.body, function (a) {
                V(a.expression,
                    b, f); c = c && a.expression.constant
            }); a.constant = c; break; case r.Literal: a.constant = !0; a.toWatch = []; break; case r.UnaryExpression: V(a.argument, b, f); a.constant = a.argument.constant; a.toWatch = a.argument.toWatch; break; case r.BinaryExpression: V(a.left, b, f); V(a.right, b, f); a.constant = a.left.constant && a.right.constant; a.toWatch = a.left.toWatch.concat(a.right.toWatch); break; case r.LogicalExpression: V(a.left, b, f); V(a.right, b, f); a.constant = a.left.constant && a.right.constant; a.toWatch = a.constant ? [] : [a]; break; case r.ConditionalExpression: V(a.test,
                b, f); V(a.alternate, b, f); V(a.consequent, b, f); a.constant = a.test.constant && a.alternate.constant && a.consequent.constant; a.toWatch = a.constant ? [] : [a]; break; case r.Identifier: a.constant = !1; a.toWatch = [a]; break; case r.MemberExpression: V(a.object, b, f); a.computed && V(a.property, b, f); a.constant = a.object.constant && (!a.computed || a.property.constant); a.toWatch = a.constant ? [] : [a]; break; case r.CallExpression: c = d = a.filter ? !b(a.callee.name).$stateful : !1; e = []; p(a.arguments, function (a) {
                    V(a, b, f); c = c && a.constant; e.push.apply(e,
                        a.toWatch)
                }); a.constant = c; a.toWatch = d ? e : [a]; break; case r.AssignmentExpression: V(a.left, b, f); V(a.right, b, f); a.constant = a.left.constant && a.right.constant; a.toWatch = [a]; break; case r.ArrayExpression: c = !0; e = []; p(a.elements, function (a) { V(a, b, f); c = c && a.constant; e.push.apply(e, a.toWatch) }); a.constant = c; a.toWatch = e; break; case r.ObjectExpression: c = !0; e = []; p(a.properties, function (a) {
                    V(a.value, b, f); c = c && a.value.constant; e.push.apply(e, a.value.toWatch); a.computed && (V(a.key, b, !1), c = c && a.key.constant, e.push.apply(e,
                        a.key.toWatch))
                }); a.constant = c; a.toWatch = e; break; case r.ThisExpression: a.constant = !1; a.toWatch = []; break; case r.LocalsExpression: a.constant = !1, a.toWatch = []
        }
    } function Gd(a) { if (1 === a.length) { a = a[0].expression; var b = a.toWatch; return 1 !== b.length ? b : b[0] !== a ? b : void 0 } } function Hd(a) { return a.type === r.Identifier || a.type === r.MemberExpression } function Id(a) { if (1 === a.body.length && Hd(a.body[0].expression)) return { type: r.AssignmentExpression, left: a.body[0].expression, right: { type: r.NGValueParameter }, operator: "=" } }
    function Jd(a) { this.$filter = a } function Kd(a) { this.$filter = a } function xc(a, b, d) { this.ast = new r(a, d); this.astCompiler = d.csp ? new Kd(b) : new Jd(b) } function yc(a) { return A(a.valueOf) ? a.valueOf() : Eg.call(a) } function Nf() {
        var a = S(), b = { "true": !0, "false": !1, "null": null, undefined: void 0 }, d, c; this.addLiteral = function (a, c) { b[a] = c }; this.setIdentifierFns = function (a, b) { d = a; c = b; return this }; this.$get = ["$filter", function (e) {
            function f(a, b, c) {
                return null == a || null == b ? a === b : "object" !== typeof a || (a = yc(a), "object" !== typeof a ||
                    c) ? a === b || a !== a && b !== b : !1
            } function g(a, b, c, d, e) { var g = d.inputs, h; if (1 === g.length) { var k = f, g = g[0]; return a.$watch(function (a) { var b = g(a); f(b, k, g.isPure) || (h = d(a, void 0, void 0, [b]), k = b && yc(b)); return h }, b, c, e) } for (var l = [], m = [], n = 0, p = g.length; n < p; n++)l[n] = f, m[n] = null; return a.$watch(function (a) { for (var b = !1, c = 0, e = g.length; c < e; c++) { var k = g[c](a); if (b || (b = !f(k, l[c], g[c].isPure))) m[c] = k, l[c] = k && yc(k) } b && (h = d(a, void 0, void 0, m)); return h }, b, c, e) } function k(a, b, c, d, e) {
                function f(a) { return d(a) } function h(a,
                    c, d) { l = a; A(b) && b(a, c, d); t(a) && d.$$postDigest(function () { t(l) && k() }) } var k, l; return k = d.inputs ? g(a, h, c, d, e) : a.$watch(f, h, c)
            } function h(a, b, c, d) { function e(a) { var b = !0; p(a, function (a) { t(a) || (b = !1) }); return b } var g, f; return g = a.$watch(function (a) { return d(a) }, function (a, c, d) { f = a; A(b) && b(a, c, d); e(a) && d.$$postDigest(function () { e(f) && g() }) }, c) } function l(a, b, c, d) { var e = a.$watch(function (a) { e(); return d(a) }, b, c); return e } function m(a, b) {
                if (!b) return a; var c = a.$$watchDelegate, d = !1, e = c !== h && c !== k ? function (c,
                    e, g, f) { g = d && f ? f[0] : a(c, e, g, f); return b(g, c, e) } : function (c, d, e, g) { e = a(c, d, e, g); c = b(e, c, d); return t(e) ? c : e }, d = !a.inputs; c && c !== g ? (e.$$watchDelegate = c, e.inputs = a.inputs) : b.$stateful || (e.$$watchDelegate = g, e.inputs = a.inputs ? a.inputs : [a]); e.inputs && (e.inputs = e.inputs.map(function (a) { return a.isPure === Fd ? function (b) { return a(b) } : a })); return e
            } var n = { csp: Ja().noUnsafeEval, literals: pa(b), isIdentifierStart: A(d) && d, isIdentifierContinue: A(c) && c }; return function (b, c) {
                var d, f, p; switch (typeof b) {
                    case "string": return p =
                        b = b.trim(), d = a[p], d || (":" === b.charAt(0) && ":" === b.charAt(1) && (f = !0, b = b.substring(2)), d = new zc(n), d = (new xc(d, e, n)).parse(b), d.constant ? d.$$watchDelegate = l : f ? d.$$watchDelegate = d.literal ? h : k : d.inputs && (d.$$watchDelegate = g), a[p] = d), m(d, c); case "function": return m(b, c); default: return m(C, c)
                }
            }
        }]
    } function Pf() { var a = !0; this.$get = ["$rootScope", "$exceptionHandler", function (b, d) { return Ld(function (a) { b.$evalAsync(a) }, d, a) }]; this.errorOnUnhandledRejections = function (b) { return t(b) ? (a = b, this) : a } } function Qf() {
        var a =
            !0; this.$get = ["$browser", "$exceptionHandler", function (b, d) { return Ld(function (a) { b.defer(a) }, d, a) }]; this.errorOnUnhandledRejections = function (b) { return t(b) ? (a = b, this) : a }
    } function Ld(a, b, d) {
        function c() { return new e } function e() { var a = this.promise = new f; this.resolve = function (b) { h(a, b) }; this.reject = function (b) { m(a, b) }; this.notify = function (b) { q(a, b) } } function f() { this.$$state = { status: 0 } } function g() {
            for (; !t && u.length;) {
                var a = u.shift(); if (!a.pur) {
                    a.pur = !0; var c = a.value, c = "Possibly unhandled rejection: " +
                        ("function" === typeof c ? c.toString().replace(/ \{[\s\S]*$/, "") : w(c) ? "undefined" : "string" !== typeof c ? De(c, void 0) : c); $b(a.value) ? b(a.value, c) : b(c)
                }
            }
        } function k(b) {
            !d || b.pending || 2 !== b.status || b.pur || (0 === t && 0 === u.length && a(g), u.push(b)); !b.processScheduled && b.pending && (b.processScheduled = !0, ++t, a(function () {
                var c, e, f; f = b.pending; b.processScheduled = !1; b.pending = void 0; try {
                    for (var k = 0, l = f.length; k < l; ++k) {
                        b.pur = !0; e = f[k][0]; c = f[k][b.status]; try { A(c) ? h(e, c(b.value)) : 1 === b.status ? h(e, b.value) : m(e, b.value) } catch (n) {
                            m(e,
                                n)
                        }
                    }
                } finally { --t, d && 0 === t && a(g) }
            }))
        } function h(a, b) { a.$$state.status || (b === a ? n(a, s("qcycle", b)) : l(a, b)) } function l(a, b) { function c(b) { f || (f = !0, l(a, b)) } function d(b) { f || (f = !0, n(a, b)) } function e(b) { q(a, b) } var g, f = !1; try { if (E(b) || A(b)) g = b.then; A(g) ? (a.$$state.status = -1, g.call(b, c, d, e)) : (a.$$state.value = b, a.$$state.status = 1, k(a.$$state)) } catch (h) { d(h) } } function m(a, b) { a.$$state.status || n(a, b) } function n(a, b) { a.$$state.value = b; a.$$state.status = 2; k(a.$$state) } function q(c, d) {
            var e = c.$$state.pending; 0 >=
                c.$$state.status && e && e.length && a(function () { for (var a, c, g = 0, f = e.length; g < f; g++) { c = e[g][0]; a = e[g][3]; try { q(c, A(a) ? a(d) : d) } catch (h) { b(h) } } })
        } function G(a) { var b = new f; m(b, a); return b } function r(a, b, c) { var d = null; try { A(c) && (d = c()) } catch (e) { return G(e) } return d && A(d.then) ? d.then(function () { return b(a) }, G) : b(a) } function z(a, b, c, d) { var e = new f; h(e, a); return e.then(b, c, d) } function v(a) { if (!A(a)) throw s("norslvr", a); var b = new f; a(function (a) { h(b, a) }, function (a) { m(b, a) }); return b } var s = M("$q", TypeError), t =
            0, u = []; P(f.prototype, { then: function (a, b, c) { if (w(a) && w(b) && w(c)) return this; var d = new f; this.$$state.pending = this.$$state.pending || []; this.$$state.pending.push([d, a, b, c]); 0 < this.$$state.status && k(this.$$state); return d }, "catch": function (a) { return this.then(null, a) }, "finally": function (a, b) { return this.then(function (b) { return r(b, y, a) }, function (b) { return r(b, G, a) }, b) } }); var y = z; v.prototype = f.prototype; v.defer = c; v.reject = G; v.when = z; v.resolve = y; v.all = function (a) {
                var b = new f, c = 0, d = I(a) ? [] : {}; p(a, function (a,
                    e) { c++; z(a).then(function (a) { d[e] = a; --c || h(b, d) }, function (a) { m(b, a) }) }); 0 === c && h(b, d); return b
            }; v.race = function (a) { var b = c(); p(a, function (a) { z(a).then(b.resolve, b.reject) }); return b.promise }; return v
    } function Zf() {
        this.$get = ["$window", "$timeout", function (a, b) {
            var d = a.requestAnimationFrame || a.webkitRequestAnimationFrame, c = a.cancelAnimationFrame || a.webkitCancelAnimationFrame || a.webkitCancelRequestAnimationFrame, e = !!d, f = e ? function (a) { var b = d(a); return function () { c(b) } } : function (a) {
                var c = b(a, 16.66, !1);
                return function () { b.cancel(c) }
            }; f.supported = e; return f
        }]
    } function Of() {
        function a(a) { function b() { this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null; this.$$listeners = {}; this.$$listenerCount = {}; this.$$watchersCount = 0; this.$id = ++sb; this.$$ChildScope = null } b.prototype = a; return b } var b = 10, d = M("$rootScope"), c = null, e = null; this.digestTtl = function (a) { arguments.length && (b = a); return b }; this.$get = ["$exceptionHandler", "$parse", "$browser", function (f, g, k) {
            function h(a) {
                a.currentScope.$$destroyed =
                    !0
            } function l(a) { 9 === Ca && (a.$$childHead && l(a.$$childHead), a.$$nextSibling && l(a.$$nextSibling)); a.$parent = a.$$nextSibling = a.$$prevSibling = a.$$childHead = a.$$childTail = a.$root = a.$$watchers = null } function m() { this.$id = ++sb; this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null; this.$root = this; this.$$destroyed = !1; this.$$listeners = {}; this.$$listenerCount = {}; this.$$watchersCount = 0; this.$$isolateBindings = null } function n(a) {
                if (s.$$phase) throw d("inprog",
                    s.$$phase); s.$$phase = a
            } function q(a, b) { do a.$$watchersCount += b; while (a = a.$parent) } function G(a, b, c) { do a.$$listenerCount[c] -= b, 0 === a.$$listenerCount[c] && delete a.$$listenerCount[c]; while (a = a.$parent) } function r() { } function z() { for (; y.length;)try { y.shift()() } catch (a) { f(a) } e = null } function v() { null === e && (e = k.defer(function () { s.$apply(z) })) } m.prototype = {
                constructor: m, $new: function (b, c) {
                    var d; c = c || this; b ? (d = new m, d.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = a(this)), d = new this.$$ChildScope);
                    d.$parent = c; d.$$prevSibling = c.$$childTail; c.$$childHead ? (c.$$childTail.$$nextSibling = d, c.$$childTail = d) : c.$$childHead = c.$$childTail = d; (b || c !== this) && d.$on("$destroy", h); return d
                }, $watch: function (a, b, d, e) {
                    var f = g(a); if (f.$$watchDelegate) return f.$$watchDelegate(this, b, d, f, a); var h = this, k = h.$$watchers, l = { fn: b, last: r, get: f, exp: e || a, eq: !!d }; c = null; A(b) || (l.fn = C); k || (k = h.$$watchers = [], k.$$digestWatchIndex = -1); k.unshift(l); k.$$digestWatchIndex++; q(this, 1); return function () {
                        var a = db(k, l); 0 <= a && (q(h, -1),
                            a < k.$$digestWatchIndex && k.$$digestWatchIndex--); c = null
                    }
                }, $watchGroup: function (a, b) { function c() { h = !1; k ? (k = !1, b(e, e, f)) : b(e, d, f) } var d = Array(a.length), e = Array(a.length), g = [], f = this, h = !1, k = !0; if (!a.length) { var l = !0; f.$evalAsync(function () { l && b(e, e, f) }); return function () { l = !1 } } if (1 === a.length) return this.$watch(a[0], function (a, c, g) { e[0] = a; d[0] = c; b(e, a === c ? e : d, g) }); p(a, function (a, b) { var k = f.$watch(a, function (a, g) { e[b] = a; d[b] = g; h || (h = !0, f.$evalAsync(c)) }); g.push(k) }); return function () { for (; g.length;)g.shift()() } },
                $watchCollection: function (a, b) {
                    function c(a) { e = a; var b, d, g, h; if (!w(e)) { if (E(e)) if (xa(e)) for (f !== n && (f = n, p = f.length = 0, l++), a = e.length, p !== a && (l++ , f.length = p = a), b = 0; b < a; b++)h = f[b], g = e[b], d = h !== h && g !== g, d || h === g || (l++ , f[b] = g); else { f !== q && (f = q = {}, p = 0, l++); a = 0; for (b in e) ra.call(e, b) && (a++ , g = e[b], h = f[b], b in f ? (d = h !== h && g !== g, d || h === g || (l++ , f[b] = g)) : (p++ , f[b] = g, l++)); if (p > a) for (b in l++ , f) ra.call(e, b) || (p-- , delete f[b]) } else f !== e && (f = e, l++); return l } } c.$stateful = !0; var d = this, e, f, h, k = 1 < b.length, l = 0, m =
                        g(a, c), n = [], q = {}, s = !0, p = 0; return this.$watch(m, function () { s ? (s = !1, b(e, e, d)) : b(e, h, d); if (k) if (E(e)) if (xa(e)) { h = Array(e.length); for (var a = 0; a < e.length; a++)h[a] = e[a] } else for (a in h = {}, e) ra.call(e, a) && (h[a] = e[a]); else h = e })
                }, $digest: function () {
                    var a, g, h, l, m, q, p, G = b, y, v = [], w, B; n("$digest"); k.$$checkUrlChange(); this === s && null !== e && (k.defer.cancel(e), z()); c = null; do {
                        p = !1; y = this; for (q = 0; q < t.length; q++) { try { B = t[q], l = B.fn, l(B.scope, B.locals) } catch (C) { f(C) } c = null } t.length = 0; a: do {
                            if (q = y.$$watchers) for (q.$$digestWatchIndex =
                                q.length; q.$$digestWatchIndex--;)try { if (a = q[q.$$digestWatchIndex]) if (m = a.get, (g = m(y)) !== (h = a.last) && !(a.eq ? sa(g, h) : T(g) && T(h))) p = !0, c = a, a.last = a.eq ? pa(g, null) : g, l = a.fn, l(g, h === r ? g : h, y), 5 > G && (w = 4 - G, v[w] || (v[w] = []), v[w].push({ msg: A(a.exp) ? "fn: " + (a.exp.name || a.exp.toString()) : a.exp, newVal: g, oldVal: h })); else if (a === c) { p = !1; break a } } catch (E) { f(E) } if (!(q = y.$$watchersCount && y.$$childHead || y !== this && y.$$nextSibling)) for (; y !== this && !(q = y.$$nextSibling);)y = y.$parent
                        } while (y = q); if ((p || t.length) && !G--) throw s.$$phase =
                            null, d("infdig", b, v);
                    } while (p || t.length); for (s.$$phase = null; J < u.length;)try { u[J++]() } catch (D) { f(D) } u.length = J = 0; k.$$checkUrlChange()
                }, $destroy: function () {
                    if (!this.$$destroyed) {
                        var a = this.$parent; this.$broadcast("$destroy"); this.$$destroyed = !0; this === s && k.$$applicationDestroyed(); q(this, -this.$$watchersCount); for (var b in this.$$listenerCount) G(this, this.$$listenerCount[b], b); a && a.$$childHead === this && (a.$$childHead = this.$$nextSibling); a && a.$$childTail === this && (a.$$childTail = this.$$prevSibling); this.$$prevSibling &&
                            (this.$$prevSibling.$$nextSibling = this.$$nextSibling); this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling); this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = C; this.$on = this.$watch = this.$watchGroup = function () { return C }; this.$$listeners = {}; this.$$nextSibling = null; l(this)
                    }
                }, $eval: function (a, b) { return g(a)(this, b) }, $evalAsync: function (a, b) { s.$$phase || t.length || k.defer(function () { t.length && s.$digest() }); t.push({ scope: this, fn: g(a), locals: b }) }, $$postDigest: function (a) { u.push(a) },
                $apply: function (a) { try { n("$apply"); try { return this.$eval(a) } finally { s.$$phase = null } } catch (b) { f(b) } finally { try { s.$digest() } catch (c) { throw f(c), c; } } }, $applyAsync: function (a) { function b() { c.$eval(a) } var c = this; a && y.push(b); a = g(a); v() }, $on: function (a, b) { var c = this.$$listeners[a]; c || (this.$$listeners[a] = c = []); c.push(b); var d = this; do d.$$listenerCount[a] || (d.$$listenerCount[a] = 0), d.$$listenerCount[a]++; while (d = d.$parent); var e = this; return function () { var d = c.indexOf(b); -1 !== d && (c[d] = null, G(e, 1, a)) } }, $emit: function (a,
                    b) { var c = [], d, e = this, g = !1, h = { name: a, targetScope: e, stopPropagation: function () { g = !0 }, preventDefault: function () { h.defaultPrevented = !0 }, defaultPrevented: !1 }, k = eb([h], arguments, 1), l, m; do { d = e.$$listeners[a] || c; h.currentScope = e; l = 0; for (m = d.length; l < m; l++)if (d[l]) try { d[l].apply(null, k) } catch (n) { f(n) } else d.splice(l, 1), l-- , m--; if (g) return h.currentScope = null, h; e = e.$parent } while (e); h.currentScope = null; return h }, $broadcast: function (a, b) {
                        var c = this, d = this, e = {
                            name: a, targetScope: this, preventDefault: function () {
                                e.defaultPrevented =
                                    !0
                            }, defaultPrevented: !1
                        }; if (!this.$$listenerCount[a]) return e; for (var g = eb([e], arguments, 1), h, k; c = d;) { e.currentScope = c; d = c.$$listeners[a] || []; h = 0; for (k = d.length; h < k; h++)if (d[h]) try { d[h].apply(null, g) } catch (l) { f(l) } else d.splice(h, 1), h-- , k--; if (!(d = c.$$listenerCount[a] && c.$$childHead || c !== this && c.$$nextSibling)) for (; c !== this && !(d = c.$$nextSibling);)c = c.$parent } e.currentScope = null; return e
                    }
            }; var s = new m, t = s.$$asyncQueue = [], u = s.$$postDigestQueue = [], y = s.$$applyAsyncQueue = [], J = 0; return s
        }]
    } function Ge() {
        var a =
            /^\s*(https?|ftp|mailto|tel|file):/, b = /^\s*((https?|ftp|file|blob):|data:image\/)/; this.aHrefSanitizationWhitelist = function (b) { return t(b) ? (a = b, this) : a }; this.imgSrcSanitizationWhitelist = function (a) { return t(a) ? (b = a, this) : b }; this.$get = function () { return function (d, c) { var e = c ? b : a, f; f = ua(d).href; return "" === f || f.match(e) ? d : "unsafe:" + f } }
    } function Fg(a) {
        if ("self" === a) return a; if (D(a)) {
            if (-1 < a.indexOf("***")) throw wa("iwcard", a); a = Md(a).replace(/\\\*\\\*/g, ".*").replace(/\\\*/g, "[^:/.?&;]*"); return new RegExp("^" +
                a + "$")
        } if (ab(a)) return new RegExp("^" + a.source + "$"); throw wa("imatcher");
    } function Nd(a) { var b = []; t(a) && p(a, function (a) { b.push(Fg(a)) }); return b } function Sf() {
        this.SCE_CONTEXTS = oa; var a = ["self"], b = []; this.resourceUrlWhitelist = function (b) { arguments.length && (a = Nd(b)); return a }; this.resourceUrlBlacklist = function (a) { arguments.length && (b = Nd(a)); return b }; this.$get = ["$injector", function (d) {
            function c(a, b) { return "self" === a ? zd(b) : !!a.exec(b.href) } function e(a) {
                var b = function (a) {
                    this.$$unwrapTrustedValue =
                        function () { return a }
                }; a && (b.prototype = new a); b.prototype.valueOf = function () { return this.$$unwrapTrustedValue() }; b.prototype.toString = function () { return this.$$unwrapTrustedValue().toString() }; return b
            } var f = function (a) { throw wa("unsafe"); }; d.has("$sanitize") && (f = d.get("$sanitize")); var g = e(), k = {}; k[oa.HTML] = e(g); k[oa.CSS] = e(g); k[oa.URL] = e(g); k[oa.JS] = e(g); k[oa.RESOURCE_URL] = e(k[oa.URL]); return {
                trustAs: function (a, b) {
                    var c = k.hasOwnProperty(a) ? k[a] : null; if (!c) throw wa("icontext", a, b); if (null === b || w(b) ||
                        "" === b) return b; if ("string" !== typeof b) throw wa("itype", a); return new c(b)
                }, getTrusted: function (d, e) { if (null === e || w(e) || "" === e) return e; var g = k.hasOwnProperty(d) ? k[d] : null; if (g && e instanceof g) return e.$$unwrapTrustedValue(); if (d === oa.RESOURCE_URL) { var g = ua(e.toString()), n, q, p = !1; n = 0; for (q = a.length; n < q; n++)if (c(a[n], g)) { p = !0; break } if (p) for (n = 0, q = b.length; n < q; n++)if (c(b[n], g)) { p = !1; break } if (p) return e; throw wa("insecurl", e.toString()); } if (d === oa.HTML) return f(e); throw wa("unsafe"); }, valueOf: function (a) {
                    return a instanceof
                        g ? a.$$unwrapTrustedValue() : a
                }
            }
        }]
    } function Rf() {
        var a = !0; this.enabled = function (b) { arguments.length && (a = !!b); return a }; this.$get = ["$parse", "$sceDelegate", function (b, d) {
            if (a && 8 > Ca) throw wa("iequirks"); var c = ja(oa); c.isEnabled = function () { return a }; c.trustAs = d.trustAs; c.getTrusted = d.getTrusted; c.valueOf = d.valueOf; a || (c.trustAs = c.getTrusted = function (a, b) { return b }, c.valueOf = bb); c.parseAs = function (a, d) { var e = b(d); return e.literal && e.constant ? e : b(d, function (b) { return c.getTrusted(a, b) }) }; var e = c.parseAs,
                f = c.getTrusted, g = c.trustAs; p(oa, function (a, b) { var d = N(b); c[("parse_as_" + d).replace(Ac, jb)] = function (b) { return e(a, b) }; c[("get_trusted_" + d).replace(Ac, jb)] = function (b) { return f(a, b) }; c[("trust_as_" + d).replace(Ac, jb)] = function (b) { return g(a, b) } }); return c
        }]
    } function Tf() {
        this.$get = ["$window", "$document", function (a, b) {
            var d = {}, c = !((!a.nw || !a.nw.process) && a.chrome && (a.chrome.app && a.chrome.app.runtime || !a.chrome.app && a.chrome.runtime && a.chrome.runtime.id)) && a.history && a.history.pushState, e = Z((/android (\d+)/.exec(N((a.navigator ||
                {}).userAgent)) || [])[1]), f = /Boxee/i.test((a.navigator || {}).userAgent), g = b[0] || {}, k = g.body && g.body.style, h = !1, l = !1; k && (h = !!("transition" in k || "webkitTransition" in k), l = !!("animation" in k || "webkitAnimation" in k)); return { history: !(!c || 4 > e || f), hasEvent: function (a) { if ("input" === a && Ca) return !1; if (w(d[a])) { var b = g.createElement("div"); d[a] = "on" + a in b } return d[a] }, csp: Ja(), transitions: h, animations: l, android: e }
        }]
    } function Vf() {
        var a; this.httpOptions = function (b) { return b ? (a = b, this) : a }; this.$get = ["$exceptionHandler",
            "$templateCache", "$http", "$q", "$sce", function (b, d, c, e, f) {
                function g(k, h) { g.totalPendingRequests++; if (!D(k) || w(d.get(k))) k = f.getTrustedResourceUrl(k); var l = c.defaults && c.defaults.transformResponse; I(l) ? l = l.filter(function (a) { return a !== qc }) : l === qc && (l = null); return c.get(k, P({ cache: d, transformResponse: l }, a)).finally(function () { g.totalPendingRequests-- }).then(function (a) { d.put(k, a.data); return a.data }, function (a) { h || (a = Gg("tpload", k, a.status, a.statusText), b(a)); return e.reject(a) }) } g.totalPendingRequests =
                    0; return g
            }]
    } function Wf() {
        this.$get = ["$rootScope", "$browser", "$location", function (a, b, d) {
            return {
                findBindings: function (a, b, d) { a = a.getElementsByClassName("ng-binding"); var g = []; p(a, function (a) { var c = $.element(a).data("$binding"); c && p(c, function (c) { d ? (new RegExp("(^|\\s)" + Md(b) + "(\\s|\\||$)")).test(c) && g.push(a) : -1 !== c.indexOf(b) && g.push(a) }) }); return g }, findModels: function (a, b, d) {
                    for (var g = ["ng-", "data-ng-", "ng\\:"], k = 0; k < g.length; ++k) {
                        var h = a.querySelectorAll("[" + g[k] + "model" + (d ? "=" : "*=") + '"' + b + '"]');
                        if (h.length) return h
                    }
                }, getLocation: function () { return d.url() }, setLocation: function (b) { b !== d.url() && (d.url(b), a.$digest()) }, whenStable: function (a) { b.notifyWhenNoOutstandingRequests(a) }
            }
        }]
    } function Xf() {
        this.$get = ["$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function (a, b, d, c, e) {
            function f(f, h, l) {
                A(f) || (l = h, h = f, f = C); var m = ya.call(arguments, 3), n = t(l) && !l, q = (n ? c : d).defer(), p = q.promise, r; r = b.defer(function () {
                    try { q.resolve(f.apply(null, m)) } catch (b) { q.reject(b), e(b) } finally { delete g[p.$$timeoutId] } n ||
                        a.$apply()
                }, h); p.$$timeoutId = r; g[r] = q; return p
            } var g = {}; f.cancel = function (a) { return a && a.$$timeoutId in g ? (g[a.$$timeoutId].promise.$$state.pur = !0, g[a.$$timeoutId].reject("canceled"), delete g[a.$$timeoutId], b.defer.cancel(a.$$timeoutId)) : !1 }; return f
        }]
    } function ua(a) {
        Ca && (X.setAttribute("href", a), a = X.href); X.setAttribute("href", a); return {
            href: X.href, protocol: X.protocol ? X.protocol.replace(/:$/, "") : "", host: X.host, search: X.search ? X.search.replace(/^\?/, "") : "", hash: X.hash ? X.hash.replace(/^#/, "") : "", hostname: X.hostname,
            port: X.port, pathname: "/" === X.pathname.charAt(0) ? X.pathname : "/" + X.pathname
        }
    } function zd(a) { a = D(a) ? ua(a) : a; return a.protocol === Od.protocol && a.host === Od.host } function Yf() { this.$get = ka(u) } function Pd(a) {
        function b(a) { try { return decodeURIComponent(a) } catch (b) { return a } } var d = a[0] || {}, c = {}, e = ""; return function () {
            var a, g, k, h, l; try { a = d.cookie || "" } catch (m) { a = "" } if (a !== e) for (e = a, a = e.split("; "), c = {}, k = 0; k < a.length; k++)g = a[k], h = g.indexOf("="), 0 < h && (l = b(g.substring(0, h)), w(c[l]) && (c[l] = b(g.substring(h + 1))));
            return c
        }
    } function bg() { this.$get = Pd } function ed(a) { function b(d, c) { if (E(d)) { var e = {}; p(d, function (a, c) { e[c] = b(c, a) }); return e } return a.factory(d + "Filter", c) } this.register = b; this.$get = ["$injector", function (a) { return function (b) { return a.get(b + "Filter") } }]; b("currency", Qd); b("date", Rd); b("filter", Hg); b("json", Ig); b("limitTo", Jg); b("lowercase", Kg); b("number", Sd); b("orderBy", Td); b("uppercase", Lg) } function Hg() {
        return function (a, b, d, c) {
            if (!xa(a)) { if (null == a) return a; throw M("filter")("notarray", a); } c =
                c || "$"; var e; switch (Bc(b)) { case "function": break; case "boolean": case "null": case "number": case "string": e = !0; case "object": b = Mg(b, d, c, e); break; default: return a }return Array.prototype.filter.call(a, b)
        }
    } function Mg(a, b, d, c) { var e = E(a) && d in a; !0 === b ? b = sa : A(b) || (b = function (a, b) { if (w(a)) return !1; if (null === a || null === b) return a === b; if (E(b) || E(a) && !Zb(a)) return !1; a = N("" + a); b = N("" + b); return -1 !== a.indexOf(b) }); return function (f) { return e && !E(f) ? ga(f, a[d], b, d, !1) : ga(f, a, b, d, c) } } function ga(a, b, d, c, e, f) {
        var g =
            Bc(a), k = Bc(b); if ("string" === k && "!" === b.charAt(0)) return !ga(a, b.substring(1), d, c, e); if (I(a)) return a.some(function (a) { return ga(a, b, d, c, e) }); switch (g) { case "object": var h; if (e) { for (h in a) if (h.charAt && "$" !== h.charAt(0) && ga(a[h], b, d, c, !0)) return !0; return f ? !1 : ga(a, b, d, c, !1) } if ("object" === k) { for (h in b) if (f = b[h], !A(f) && !w(f) && (g = h === c, !ga(g ? a : a[h], f, d, c, g, g))) return !1; return !0 } return d(a, b); case "function": return !1; default: return d(a, b) }
    } function Bc(a) { return null === a ? "null" : typeof a } function Qd(a) {
        var b =
            a.NUMBER_FORMATS; return function (a, c, e) { w(c) && (c = b.CURRENCY_SYM); w(e) && (e = b.PATTERNS[1].maxFrac); return null == a ? a : Ud(a, b.PATTERNS[1], b.GROUP_SEP, b.DECIMAL_SEP, e).replace(/\u00A4/g, c) }
    } function Sd(a) { var b = a.NUMBER_FORMATS; return function (a, c) { return null == a ? a : Ud(a, b.PATTERNS[0], b.GROUP_SEP, b.DECIMAL_SEP, c) } } function Ng(a) {
        var b = 0, d, c, e, f, g; -1 < (c = a.indexOf(Vd)) && (a = a.replace(Vd, "")); 0 < (e = a.search(/e/i)) ? (0 > c && (c = e), c += +a.slice(e + 1), a = a.substring(0, e)) : 0 > c && (c = a.length); for (e = 0; a.charAt(e) === Cc; e++);
        if (e === (g = a.length)) d = [0], c = 1; else { for (g--; a.charAt(g) === Cc;)g--; c -= e; d = []; for (f = 0; e <= g; e++ , f++)d[f] = +a.charAt(e) } c > Wd && (d = d.splice(0, Wd - 1), b = c - 1, c = 1); return { d: d, e: b, i: c }
    } function Og(a, b, d, c) {
        var e = a.d, f = e.length - a.i; b = w(b) ? Math.min(Math.max(d, f), c) : +b; d = b + a.i; c = e[d]; if (0 < d) { e.splice(Math.max(a.i, d)); for (var g = d; g < e.length; g++)e[g] = 0 } else for (f = Math.max(0, f), a.i = 1, e.length = Math.max(1, d = b + 1), e[0] = 0, g = 1; g < d; g++)e[g] = 0; if (5 <= c) if (0 > d - 1) { for (c = 0; c > d; c--)e.unshift(0), a.i++; e.unshift(1); a.i++ } else e[d -
            1]++; for (; f < Math.max(0, b); f++)e.push(0); if (b = e.reduceRight(function (a, b, c, d) { b += a; d[c] = b % 10; return Math.floor(b / 10) }, 0)) e.unshift(b), a.i++
    } function Ud(a, b, d, c, e) {
        if (!D(a) && !Y(a) || isNaN(a)) return ""; var f = !isFinite(a), g = !1, k = Math.abs(a) + "", h = ""; if (f) h = "\u221e"; else {
            g = Ng(k); Og(g, e, b.minFrac, b.maxFrac); h = g.d; k = g.i; e = g.e; f = []; for (g = h.reduce(function (a, b) { return a && !b }, !0); 0 > k;)h.unshift(0), k++; 0 < k ? f = h.splice(k, h.length) : (f = h, h = [0]); k = []; for (h.length >= b.lgSize && k.unshift(h.splice(-b.lgSize, h.length).join("")); h.length >
                b.gSize;)k.unshift(h.splice(-b.gSize, h.length).join("")); h.length && k.unshift(h.join("")); h = k.join(d); f.length && (h += c + f.join("")); e && (h += "e+" + e)
        } return 0 > a && !g ? b.negPre + h + b.negSuf : b.posPre + h + b.posSuf
    } function Mb(a, b, d, c) { var e = ""; if (0 > a || c && 0 >= a) c ? a = -a + 1 : (a = -a, e = "-"); for (a = "" + a; a.length < b;)a = Cc + a; d && (a = a.substr(a.length - b)); return e + a } function da(a, b, d, c, e) { d = d || 0; return function (f) { f = f["get" + a](); if (0 < d || f > -d) f += d; 0 === f && -12 === d && (f = 12); return Mb(f, b, c, e) } } function ob(a, b, d) {
        return function (c, e) {
            var f =
                c["get" + a](), g = wb((d ? "STANDALONE" : "") + (b ? "SHORT" : "") + a); return e[g][f]
        }
    } function Xd(a) { var b = (new Date(a, 0, 1)).getDay(); return new Date(a, 0, (4 >= b ? 5 : 12) - b) } function Yd(a) { return function (b) { var d = Xd(b.getFullYear()); b = +new Date(b.getFullYear(), b.getMonth(), b.getDate() + (4 - b.getDay())) - +d; b = 1 + Math.round(b / 6048E5); return Mb(b, a) } } function Dc(a, b) { return 0 >= a.getFullYear() ? b.ERAS[0] : b.ERAS[1] } function Rd(a) {
        function b(a) {
            var b; if (b = a.match(d)) {
                a = new Date(0); var f = 0, g = 0, k = b[8] ? a.setUTCFullYear : a.setFullYear,
                    h = b[8] ? a.setUTCHours : a.setHours; b[9] && (f = Z(b[9] + b[10]), g = Z(b[9] + b[11])); k.call(a, Z(b[1]), Z(b[2]) - 1, Z(b[3])); f = Z(b[4] || 0) - f; g = Z(b[5] || 0) - g; k = Z(b[6] || 0); b = Math.round(1E3 * parseFloat("0." + (b[7] || 0))); h.call(a, f, g, k, b)
            } return a
        } var d = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/; return function (c, d, f) {
            var g = "", k = [], h, l; d = d || "mediumDate"; d = a.DATETIME_FORMATS[d] || d; D(c) && (c = Pg.test(c) ? Z(c) : b(c)); Y(c) && (c = new Date(c)); if (!ea(c) || !isFinite(c.getTime())) return c;
            for (; d;)(l = Qg.exec(d)) ? (k = eb(k, l, 1), d = k.pop()) : (k.push(d), d = null); var m = c.getTimezoneOffset(); f && (m = Rc(f, m), c = bc(c, f, !0)); p(k, function (b) { h = Rg[b]; g += h ? h(c, a.DATETIME_FORMATS, m) : "''" === b ? "'" : b.replace(/(^'|'$)/g, "").replace(/''/g, "'") }); return g
        }
    } function Ig() { return function (a, b) { w(b) && (b = 2); return fb(a, b) } } function Jg() {
        return function (a, b, d) {
            b = Infinity === Math.abs(Number(b)) ? Number(b) : Z(b); if (T(b)) return a; Y(a) && (a = a.toString()); if (!xa(a)) return a; d = !d || isNaN(d) ? 0 : Z(d); d = 0 > d ? Math.max(0, a.length +
                d) : d; return 0 <= b ? Ec(a, d, d + b) : 0 === d ? Ec(a, b, a.length) : Ec(a, Math.max(0, d + b), d)
        }
    } function Ec(a, b, d) { return D(a) ? a.slice(b, d) : ya.call(a, b, d) } function Td(a) {
        function b(b) { return b.map(function (b) { var c = 1, d = bb; if (A(b)) d = b; else if (D(b)) { if ("+" === b.charAt(0) || "-" === b.charAt(0)) c = "-" === b.charAt(0) ? -1 : 1, b = b.substring(1); if ("" !== b && (d = a(b), d.constant)) var e = d(), d = function (a) { return a[e] } } return { get: d, descending: c } }) } function d(a) { switch (typeof a) { case "number": case "boolean": case "string": return !0; default: return !1 } }
        function c(a, b) { var c = 0, d = a.type, h = b.type; if (d === h) { var h = a.value, l = b.value; "string" === d ? (h = h.toLowerCase(), l = l.toLowerCase()) : "object" === d && (E(h) && (h = a.index), E(l) && (l = b.index)); h !== l && (c = h < l ? -1 : 1) } else c = d < h ? -1 : 1; return c } return function (a, f, g, k) {
            if (null == a) return a; if (!xa(a)) throw M("orderBy")("notarray", a); I(f) || (f = [f]); 0 === f.length && (f = ["+"]); var h = b(f), l = g ? -1 : 1, m = A(k) ? k : c; a = Array.prototype.map.call(a, function (a, b) {
                return {
                    value: a, tieBreaker: { value: b, type: "number", index: b }, predicateValues: h.map(function (c) {
                        var e =
                            c.get(a); c = typeof e; if (null === e) c = "string", e = "null"; else if ("object" === c) a: { if (A(e.valueOf) && (e = e.valueOf(), d(e))) break a; Zb(e) && (e = e.toString(), d(e)) } return { value: e, type: c, index: b }
                    })
                }
            }); a.sort(function (a, b) { for (var d = 0, e = h.length; d < e; d++) { var g = m(a.predicateValues[d], b.predicateValues[d]); if (g) return g * h[d].descending * l } return (m(a.tieBreaker, b.tieBreaker) || c(a.tieBreaker, b.tieBreaker)) * l }); return a = a.map(function (a) { return a.value })
        }
    } function Qa(a) {
        A(a) && (a = { link: a }); a.restrict = a.restrict || "AC";
        return ka(a)
    } function Nb(a, b, d, c, e) { this.$$controls = []; this.$error = {}; this.$$success = {}; this.$pending = void 0; this.$name = e(b.name || b.ngForm || "")(d); this.$dirty = !1; this.$valid = this.$pristine = !0; this.$submitted = this.$invalid = !1; this.$$parentForm = Ob; this.$$element = a; this.$$animate = c; Zd(this) } function Zd(a) { a.$$classCache = {}; a.$$classCache[$d] = !(a.$$classCache[pb] = a.$$element.hasClass(pb)) } function ae(a) {
        function b(a, b, c) {
            c && !a.$$classCache[b] ? (a.$$animate.addClass(a.$$element, b), a.$$classCache[b] = !0) :
                !c && a.$$classCache[b] && (a.$$animate.removeClass(a.$$element, b), a.$$classCache[b] = !1)
        } function d(a, c, d) { c = c ? "-" + Vc(c, "-") : ""; b(a, pb + c, !0 === d); b(a, $d + c, !1 === d) } var c = a.set, e = a.unset; a.clazz.prototype.$setValidity = function (a, g, k) {
            w(g) ? (this.$pending || (this.$pending = {}), c(this.$pending, a, k)) : (this.$pending && e(this.$pending, a, k), be(this.$pending) && (this.$pending = void 0)); Na(g) ? g ? (e(this.$error, a, k), c(this.$$success, a, k)) : (c(this.$error, a, k), e(this.$$success, a, k)) : (e(this.$error, a, k), e(this.$$success, a,
                k)); this.$pending ? (b(this, "ng-pending", !0), this.$valid = this.$invalid = void 0, d(this, "", null)) : (b(this, "ng-pending", !1), this.$valid = be(this.$error), this.$invalid = !this.$valid, d(this, "", this.$valid)); g = this.$pending && this.$pending[a] ? void 0 : this.$error[a] ? !1 : this.$$success[a] ? !0 : null; d(this, a, g); this.$$parentForm.$setValidity(a, g, this)
        }
    } function be(a) { if (a) for (var b in a) if (a.hasOwnProperty(b)) return !1; return !0 } function Fc(a) { a.$formatters.push(function (b) { return a.$isEmpty(b) ? b : b.toString() }) } function Wa(a,
        b, d, c, e, f) {
        var g = N(b[0].type); if (!e.android) { var k = !1; b.on("compositionstart", function () { k = !0 }); b.on("compositionend", function () { k = !1; l() }) } var h, l = function (a) { h && (f.defer.cancel(h), h = null); if (!k) { var e = b.val(); a = a && a.type; "password" === g || d.ngTrim && "false" === d.ngTrim || (e = Q(e)); (c.$viewValue !== e || "" === e && c.$$hasNativeValidators) && c.$setViewValue(e, a) } }; if (e.hasEvent("input")) b.on("input", l); else {
            var m = function (a, b, c) { h || (h = f.defer(function () { h = null; b && b.value === c || l(a) })) }; b.on("keydown", function (a) {
                var b =
                    a.keyCode; 91 === b || 15 < b && 19 > b || 37 <= b && 40 >= b || m(a, this, this.value)
            }); if (e.hasEvent("paste")) b.on("paste cut", m)
        } b.on("change", l); if (ce[g] && c.$$hasNativeValidators && g === d.type) b.on("keydown wheel mousedown", function (a) { if (!h) { var b = this.validity, c = b.badInput, d = b.typeMismatch; h = f.defer(function () { h = null; b.badInput === c && b.typeMismatch === d || l(a) }) } }); c.$render = function () { var a = c.$isEmpty(c.$viewValue) ? "" : c.$viewValue; b.val() !== a && b.val(a) }
    } function Pb(a, b) {
        return function (d, c) {
            var e, f; if (ea(d)) return d;
            if (D(d)) { '"' === d.charAt(0) && '"' === d.charAt(d.length - 1) && (d = d.substring(1, d.length - 1)); if (Sg.test(d)) return new Date(d); a.lastIndex = 0; if (e = a.exec(d)) return e.shift(), f = c ? { yyyy: c.getFullYear(), MM: c.getMonth() + 1, dd: c.getDate(), HH: c.getHours(), mm: c.getMinutes(), ss: c.getSeconds(), sss: c.getMilliseconds() / 1E3 } : { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 }, p(e, function (a, c) { c < b.length && (f[b[c]] = +a) }), new Date(f.yyyy, f.MM - 1, f.dd, f.HH, f.mm, f.ss || 0, 1E3 * f.sss || 0) } return NaN
        }
    } function qb(a, b, d, c) {
        return function (e,
            f, g, k, h, l, m) {
            function n(a) { return a && !(a.getTime && a.getTime() !== a.getTime()) } function q(a) { return t(a) && !ea(a) ? d(a) || void 0 : a } Gc(e, f, g, k); Wa(e, f, g, k, h, l); var p = k && k.$options.getOption("timezone"), r; k.$$parserName = a; k.$parsers.push(function (a) { if (k.$isEmpty(a)) return null; if (b.test(a)) return a = d(a, r), p && (a = bc(a, p)), a }); k.$formatters.push(function (a) { if (a && !ea(a)) throw rb("datefmt", a); if (n(a)) return (r = a) && p && (r = bc(r, p, !0)), m("date")(a, c, p); r = null; return "" }); if (t(g.min) || g.ngMin) {
                var z; k.$validators.min =
                    function (a) { return !n(a) || w(z) || d(a) >= z }; g.$observe("min", function (a) { z = q(a); k.$validate() })
            } if (t(g.max) || g.ngMax) { var v; k.$validators.max = function (a) { return !n(a) || w(v) || d(a) <= v }; g.$observe("max", function (a) { v = q(a); k.$validate() }) }
        }
    } function Gc(a, b, d, c) { (c.$$hasNativeValidators = E(b[0].validity)) && c.$parsers.push(function (a) { var c = b.prop("validity") || {}; return c.badInput || c.typeMismatch ? void 0 : a }) } function de(a) {
        a.$$parserName = "number"; a.$parsers.push(function (b) { if (a.$isEmpty(b)) return null; if (Tg.test(b)) return parseFloat(b) });
        a.$formatters.push(function (b) { if (!a.$isEmpty(b)) { if (!Y(b)) throw rb("numfmt", b); b = b.toString() } return b })
    } function Xa(a) { t(a) && !Y(a) && (a = parseFloat(a)); return T(a) ? void 0 : a } function Hc(a) { var b = a.toString(), d = b.indexOf("."); return -1 === d ? -1 < a && 1 > a && (a = /e-(\d+)$/.exec(b)) ? Number(a[1]) : 0 : b.length - d - 1 } function ee(a, b, d) {
        a = Number(a); var c = (a | 0) !== a, e = (b | 0) !== b, f = (d | 0) !== d; if (c || e || f) {
            var g = c ? Hc(a) : 0, k = e ? Hc(b) : 0, h = f ? Hc(d) : 0, g = Math.max(g, k, h), g = Math.pow(10, g); a *= g; b *= g; d *= g; c && (a = Math.round(a)); e && (b = Math.round(b));
            f && (d = Math.round(d))
        } return 0 === (a - b) % d
    } function fe(a, b, d, c, e) { if (t(c)) { a = a(c); if (!a.constant) throw rb("constexpr", d, c); return a(b) } return e } function Ic(a, b) {
        function d(a, b) { if (!a || !a.length) return []; if (!b || !b.length) return a; var c = [], d = 0; a: for (; d < a.length; d++) { for (var e = a[d], f = 0; f < b.length; f++)if (e === b[f]) continue a; c.push(e) } return c } function c(a) { var b = a; I(a) ? b = a.map(c).join(" ") : E(a) && (b = Object.keys(a).filter(function (b) { return a[b] }).join(" ")); return b } function e(a) {
            var b = a; if (I(a)) b = a.map(e);
            else if (E(a)) { var c = !1, b = Object.keys(a).filter(function (b) { b = a[b]; !c && w(b) && (c = !0); return b }); c && b.push(void 0) } return b
        } a = "ngClass" + a; var f; return ["$parse", function (g) {
            return {
                restrict: "AC", link: function (k, h, l) {
                    function m(a, b) { var c = []; p(a, function (a) { if (0 < b || s[a]) s[a] = (s[a] || 0) + b, s[a] === +(0 < b) && c.push(a) }); return c.join(" ") } function n(a) { if (a === b) { var c = w, c = m(c && c.split(" "), 1); l.$addClass(c) } else c = w, c = m(c && c.split(" "), -1), l.$removeClass(c); u = a } function q(a) { a = c(a); a !== w && r(a) } function r(a) {
                        if (u ===
                            b) { var c = w && w.split(" "), e = a && a.split(" "), g = d(c, e), c = d(e, c), g = m(g, -1), c = m(c, 1); l.$addClass(c); l.$removeClass(g) } w = a
                    } var t = l[a].trim(), z = ":" === t.charAt(0) && ":" === t.charAt(1), t = g(t, z ? e : c), v = z ? q : r, s = h.data("$classCounts"), u = !0, w; s || (s = S(), h.data("$classCounts", s)); "ngClass" !== a && (f || (f = g("$index", function (a) { return a & 1 })), k.$watch(f, n)); k.$watch(t, v, z)
                }
            }
        }]
    } function Qb(a, b, d, c, e, f, g, k, h) {
        this.$modelValue = this.$viewValue = Number.NaN; this.$$rawModelValue = void 0; this.$validators = {}; this.$asyncValidators =
            {}; this.$parsers = []; this.$formatters = []; this.$viewChangeListeners = []; this.$untouched = !0; this.$touched = !1; this.$pristine = !0; this.$dirty = !1; this.$valid = !0; this.$invalid = !1; this.$error = {}; this.$$success = {}; this.$pending = void 0; this.$name = h(d.name || "", !1)(a); this.$$parentForm = Ob; this.$options = Rb; this.$$parsedNgModel = e(d.ngModel); this.$$parsedNgModelAssign = this.$$parsedNgModel.assign; this.$$ngModelGet = this.$$parsedNgModel; this.$$ngModelSet = this.$$parsedNgModelAssign; this.$$pendingDebounce = null; this.$$parserValid =
                void 0; this.$$currentValidationRunId = 0; Object.defineProperty(this, "$$scope", { value: a }); this.$$attr = d; this.$$element = c; this.$$animate = f; this.$$timeout = g; this.$$parse = e; this.$$q = k; this.$$exceptionHandler = b; Zd(this); Ug(this)
    } function Ug(a) {
        a.$$scope.$watch(function (b) {
            b = a.$$ngModelGet(b); if (b !== a.$modelValue && (a.$modelValue === a.$modelValue || b === b)) {
                a.$modelValue = a.$$rawModelValue = b; a.$$parserValid = void 0; for (var d = a.$formatters, c = d.length, e = b; c--;)e = d[c](e); a.$viewValue !== e && (a.$$updateEmptyClasses(e),
                    a.$viewValue = a.$$lastCommittedViewValue = e, a.$render(), a.$$runValidators(a.$modelValue, a.$viewValue, C))
            } return b
        })
    } function Jc(a) { this.$$options = a } function ge(a, b) { p(b, function (b, c) { t(a[c]) || (a[c] = b) }) } function Ga(a, b) { a.prop("selected", b); a.attr("selected", b) } var Lc = { objectMaxDepth: 5 }, Vg = /^\/(.+)\/([a-z]*)$/, ra = Object.prototype.hasOwnProperty, N = function (a) { return D(a) ? a.toLowerCase() : a }, wb = function (a) { return D(a) ? a.toUpperCase() : a }, Ca, B, la, ya = [].slice, ug = [].splice, Wg = [].push, ha = Object.prototype.toString,
        Oc = Object.getPrototypeOf, qa = M("ng"), $ = u.angular || (u.angular = {}), ec, sb = 0; Ca = u.document.documentMode; var T = Number.isNaN || function (a) { return a !== a }; C.$inject = []; bb.$inject = []; var I = Array.isArray, se = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/, Q = function (a) { return D(a) ? a.trim() : a }, Md = function (a) { return a.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08") }, Ja = function () {
            if (!t(Ja.rules)) {
                var a = u.document.querySelector("[ng-csp]") || u.document.querySelector("[data-ng-csp]");
                if (a) { var b = a.getAttribute("ng-csp") || a.getAttribute("data-ng-csp"); Ja.rules = { noUnsafeEval: !b || -1 !== b.indexOf("no-unsafe-eval"), noInlineStyle: !b || -1 !== b.indexOf("no-inline-style") } } else { a = Ja; try { new Function(""), b = !1 } catch (d) { b = !0 } a.rules = { noUnsafeEval: b, noInlineStyle: !1 } }
            } return Ja.rules
        }, tb = function () { if (t(tb.name_)) return tb.name_; var a, b, d = Ha.length, c, e; for (b = 0; b < d; ++b)if (c = Ha[b], a = u.document.querySelector("[" + c.replace(":", "\\:") + "jq]")) { e = a.getAttribute(c + "jq"); break } return tb.name_ = e }, ue = /:/g,
            Ha = ["ng-", "data-ng-", "ng:", "x-ng-"], xe = function (a) {
                var b = a.currentScript; if (!b) return !0; if (!(b instanceof u.HTMLScriptElement || b instanceof u.SVGScriptElement)) return !1; b = b.attributes; return [b.getNamedItem("src"), b.getNamedItem("href"), b.getNamedItem("xlink:href")].every(function (b) {
                    if (!b) return !0; if (!b.value) return !1; var c = a.createElement("a"); c.href = b.value; if (a.location.origin === c.origin) return !0; switch (c.protocol) {
                        case "http:": case "https:": case "ftp:": case "blob:": case "file:": case "data:": return !0;
                        default: return !1
                    }
                })
            }(u.document), Ae = /[A-Z]/g, Wc = !1, Oa = 3, Fe = { full: "1.6.6", major: 1, minor: 6, dot: 6, codeName: "interdimensional-cable" }; U.expando = "ng339"; var kb = U.cache = {}, gg = 1; U._data = function (a) { return this.cache[a[this.expando]] || {} }; var cg = /-([a-z])/g, Xg = /^-ms-/, Bb = { mouseleave: "mouseout", mouseenter: "mouseover" }, hc = M("jqLite"), fg = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/, gc = /<|&#?\w+;/, dg = /<([\w:-]+)/, eg = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, aa = {
                option: [1, '<select multiple="multiple">',
                    "</select>"], thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""]
            }; aa.optgroup = aa.option; aa.tbody = aa.tfoot = aa.colgroup = aa.caption = aa.thead; aa.th = aa.td; var lg = u.Node.prototype.contains || function (a) { return !!(this.compareDocumentPosition(a) & 16) }, Sa = U.prototype = {
                ready: gd, toString: function () { var a = []; p(this, function (b) { a.push("" + b) }); return "[" + a.join(", ") + "]" },
                eq: function (a) { return 0 <= a ? B(this[a]) : B(this[this.length + a]) }, length: 0, push: Wg, sort: [].sort, splice: [].splice
            }, Hb = {}; p("multiple selected checked disabled readOnly required open".split(" "), function (a) { Hb[N(a)] = a }); var ld = {}; p("input select option textarea button form details".split(" "), function (a) { ld[a] = !0 }); var sd = { ngMinlength: "minlength", ngMaxlength: "maxlength", ngMin: "min", ngMax: "max", ngPattern: "pattern", ngStep: "step" }; p({
                data: lc, removeData: kc, hasData: function (a) {
                    for (var b in kb[a.ng339]) return !0;
                    return !1
                }, cleanData: function (a) { for (var b = 0, d = a.length; b < d; b++)kc(a[b]) }
            }, function (a, b) { U[b] = a }); p({
                data: lc, inheritedData: Fb, scope: function (a) { return B.data(a, "$scope") || Fb(a.parentNode || a, ["$isolateScope", "$scope"]) }, isolateScope: function (a) { return B.data(a, "$isolateScope") || B.data(a, "$isolateScopeNoTemplate") }, controller: id, injector: function (a) { return Fb(a, "$injector") }, removeAttr: function (a, b) { a.removeAttribute(b) }, hasClass: Cb, css: function (a, b, d) {
                    b = yb(b.replace(Xg, "ms-")); if (t(d)) a.style[b] = d;
                    else return a.style[b]
                }, attr: function (a, b, d) { var c = a.nodeType; if (c !== Oa && 2 !== c && 8 !== c && a.getAttribute) { var c = N(b), e = Hb[c]; if (t(d)) null === d || !1 === d && e ? a.removeAttribute(b) : a.setAttribute(b, e ? c : d); else return a = a.getAttribute(b), e && null !== a && (a = c), null === a ? void 0 : a } }, prop: function (a, b, d) { if (t(d)) a[b] = d; else return a[b] }, text: function () { function a(a, d) { if (w(d)) { var c = a.nodeType; return 1 === c || c === Oa ? a.textContent : "" } a.textContent = d } a.$dv = ""; return a }(), val: function (a, b) {
                    if (w(b)) {
                        if (a.multiple && "select" ===
                            za(a)) { var d = []; p(a.options, function (a) { a.selected && d.push(a.value || a.text) }); return d } return a.value
                    } a.value = b
                }, html: function (a, b) { if (w(b)) return a.innerHTML; zb(a, !0); a.innerHTML = b }, empty: jd
            }, function (a, b) {
                U.prototype[b] = function (b, c) {
                    var e, f, g = this.length; if (a !== jd && w(2 === a.length && a !== Cb && a !== id ? b : c)) { if (E(b)) { for (e = 0; e < g; e++)if (a === lc) a(this[e], b); else for (f in b) a(this[e], f, b[f]); return this } e = a.$dv; g = w(e) ? Math.min(g, 1) : g; for (f = 0; f < g; f++) { var k = a(this[f], b, c); e = e ? e + k : k } return e } for (e = 0; e < g; e++)a(this[e],
                        b, c); return this
                }
            }); p({
                removeData: kc, on: function (a, b, d, c) { if (t(c)) throw hc("onargs"); if (fc(a)) { c = Ab(a, !0); var e = c.events, f = c.handle; f || (f = c.handle = ig(a, e)); c = 0 <= b.indexOf(" ") ? b.split(" ") : [b]; for (var g = c.length, k = function (b, c, g) { var k = e[b]; k || (k = e[b] = [], k.specialHandlerWrapper = c, "$destroy" === b || g || a.addEventListener(b, f)); k.push(d) }; g--;)b = c[g], Bb[b] ? (k(Bb[b], kg), k(b, void 0, !0)) : k(b) } }, off: hd, one: function (a, b, d) { a = B(a); a.on(b, function e() { a.off(b, d); a.off(b, e) }); a.on(b, d) }, replaceWith: function (a,
                    b) { var d, c = a.parentNode; zb(a); p(new U(b), function (b) { d ? c.insertBefore(b, d.nextSibling) : c.replaceChild(b, a); d = b }) }, children: function (a) { var b = []; p(a.childNodes, function (a) { 1 === a.nodeType && b.push(a) }); return b }, contents: function (a) { return a.contentDocument || a.childNodes || [] }, append: function (a, b) { var d = a.nodeType; if (1 === d || 11 === d) { b = new U(b); for (var d = 0, c = b.length; d < c; d++)a.appendChild(b[d]) } }, prepend: function (a, b) { if (1 === a.nodeType) { var d = a.firstChild; p(new U(b), function (b) { a.insertBefore(b, d) }) } },
                wrap: function (a, b) { var d = B(b).eq(0).clone()[0], c = a.parentNode; c && c.replaceChild(d, a); d.appendChild(a) }, remove: Gb, detach: function (a) { Gb(a, !0) }, after: function (a, b) { var d = a, c = a.parentNode; if (c) { b = new U(b); for (var e = 0, f = b.length; e < f; e++) { var g = b[e]; c.insertBefore(g, d.nextSibling); d = g } } }, addClass: Eb, removeClass: Db, toggleClass: function (a, b, d) { b && p(b.split(" "), function (b) { var e = d; w(e) && (e = !Cb(a, b)); (e ? Eb : Db)(a, b) }) }, parent: function (a) { return (a = a.parentNode) && 11 !== a.nodeType ? a : null }, next: function (a) { return a.nextElementSibling },
                find: function (a, b) { return a.getElementsByTagName ? a.getElementsByTagName(b) : [] }, clone: jc, triggerHandler: function (a, b, d) {
                    var c, e, f = b.type || b, g = Ab(a); if (g = (g = g && g.events) && g[f]) c = { preventDefault: function () { this.defaultPrevented = !0 }, isDefaultPrevented: function () { return !0 === this.defaultPrevented }, stopImmediatePropagation: function () { this.immediatePropagationStopped = !0 }, isImmediatePropagationStopped: function () { return !0 === this.immediatePropagationStopped }, stopPropagation: C, type: f, target: a }, b.type && (c = P(c,
                        b)), b = ja(g), e = d ? [c].concat(d) : [c], p(b, function (b) { c.isImmediatePropagationStopped() || b.apply(a, e) })
                }
            }, function (a, b) { U.prototype[b] = function (b, c, e) { for (var f, g = 0, k = this.length; g < k; g++)w(f) ? (f = a(this[g], b, c, e), t(f) && (f = B(f))) : ic(f, a(this[g], b, c, e)); return t(f) ? f : this } }); U.prototype.bind = U.prototype.on; U.prototype.unbind = U.prototype.off; var Yg = Object.create(null); md.prototype = {
                _idx: function (a) { if (a === this._lastKey) return this._lastIndex; this._lastKey = a; return this._lastIndex = this._keys.indexOf(a) }, _transformKey: function (a) {
                    return T(a) ?
                        Yg : a
                }, get: function (a) { a = this._transformKey(a); a = this._idx(a); if (-1 !== a) return this._values[a] }, set: function (a, b) { a = this._transformKey(a); var d = this._idx(a); -1 === d && (d = this._lastIndex = this._keys.length); this._keys[d] = a; this._values[d] = b }, delete: function (a) { a = this._transformKey(a); a = this._idx(a); if (-1 === a) return !1; this._keys.splice(a, 1); this._values.splice(a, 1); this._lastKey = NaN; this._lastIndex = -1; return !0 }
            }; var Ib = md, ag = [function () { this.$get = [function () { return Ib }] }], ng = /^([^(]+?)=>/, og = /^[^(]*\(\s*([^)]*)\)/m,
                Zg = /,/, $g = /^\s*(_?)(\S+?)\1\s*$/, mg = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg, Ba = M("$injector"); hb.$$annotate = function (a, b, d) { var c; if ("function" === typeof a) { if (!(c = a.$inject)) { c = []; if (a.length) { if (b) throw D(d) && d || (d = a.name || pg(a)), Ba("strictdi", d); b = nd(a); p(b[1].split(Zg), function (a) { a.replace($g, function (a, b, d) { c.push(d) }) }) } a.$inject = c } } else I(a) ? (b = a.length - 1, ub(a[b], "fn"), c = a.slice(0, b)) : ub(a, "fn", !0); return c }; var he = M("$animate"), sf = function () { this.$get = C }, tf = function () {
                    var a = new Ib, b = []; this.$get =
                        ["$$AnimateRunner", "$rootScope", function (d, c) {
                            function e(a, b, c) { var d = !1; b && (b = D(b) ? b.split(" ") : I(b) ? b : [], p(b, function (b) { b && (d = !0, a[b] = c) })); return d } function f() { p(b, function (b) { var c = a.get(b); if (c) { var d = qg(b.attr("class")), e = "", f = ""; p(c, function (a, b) { a !== !!d[b] && (a ? e += (e.length ? " " : "") + b : f += (f.length ? " " : "") + b) }); p(b, function (a) { e && Eb(a, e); f && Db(a, f) }); a.delete(b) } }); b.length = 0 } return {
                                enabled: C, on: C, off: C, pin: C, push: function (g, k, h, l) {
                                    l && l(); h = h || {}; h.from && g.css(h.from); h.to && g.css(h.to); if (h.addClass ||
                                        h.removeClass) if (k = h.addClass, l = h.removeClass, h = a.get(g) || {}, k = e(h, k, !0), l = e(h, l, !1), k || l) a.set(g, h), b.push(g), 1 === b.length && c.$$postDigest(f); g = new d; g.complete(); return g
                                }
                            }
                        }]
                }, qf = ["$provide", function (a) {
                    var b = this, d = null, c = null; this.$$registeredAnimations = Object.create(null); this.register = function (c, d) { if (c && "." !== c.charAt(0)) throw he("notcsel", c); var g = c + "-animation"; b.$$registeredAnimations[c.substr(1)] = g; a.factory(g, d) }; this.customFilter = function (a) { 1 === arguments.length && (c = A(a) ? a : null); return c };
                    this.classNameFilter = function (a) { if (1 === arguments.length && (d = a instanceof RegExp ? a : null) && /[(\s|\/)]ng-animate[(\s|\/)]/.test(d.toString())) throw d = null, he("nongcls", "ng-animate"); return d }; this.$get = ["$$animateQueue", function (a) {
                        function b(a, c, d) { if (d) { var e; a: { for (e = 0; e < d.length; e++) { var f = d[e]; if (1 === f.nodeType) { e = f; break a } } e = void 0 } !e || e.parentNode || e.previousElementSibling || (d = null) } d ? d.after(a) : c.prepend(a) } return {
                            on: a.on, off: a.off, pin: a.pin, enabled: a.enabled, cancel: function (a) { a.end && a.end() },
                            enter: function (c, d, h, l) { d = d && B(d); h = h && B(h); d = d || h.parent(); b(c, d, h); return a.push(c, "enter", Ka(l)) }, move: function (c, d, h, l) { d = d && B(d); h = h && B(h); d = d || h.parent(); b(c, d, h); return a.push(c, "move", Ka(l)) }, leave: function (b, c) { return a.push(b, "leave", Ka(c), function () { b.remove() }) }, addClass: function (b, c, d) { d = Ka(d); d.addClass = lb(d.addclass, c); return a.push(b, "addClass", d) }, removeClass: function (b, c, d) { d = Ka(d); d.removeClass = lb(d.removeClass, c); return a.push(b, "removeClass", d) }, setClass: function (b, c, d, f) {
                                f = Ka(f);
                                f.addClass = lb(f.addClass, c); f.removeClass = lb(f.removeClass, d); return a.push(b, "setClass", f)
                            }, animate: function (b, c, d, f, m) { m = Ka(m); m.from = m.from ? P(m.from, c) : c; m.to = m.to ? P(m.to, d) : d; m.tempClasses = lb(m.tempClasses, f || "ng-inline-animate"); return a.push(b, "animate", m) }
                        }
                    }]
                }], vf = function () { this.$get = ["$$rAF", function (a) { function b(b) { d.push(b); 1 < d.length || a(function () { for (var a = 0; a < d.length; a++)d[a](); d = [] }) } var d = []; return function () { var a = !1; b(function () { a = !0 }); return function (d) { a ? d() : b(d) } } }] }, uf = function () {
                    this.$get =
                        ["$q", "$sniffer", "$$animateAsyncRun", "$$isDocumentHidden", "$timeout", function (a, b, d, c, e) {
                            function f(a) { this.setHost(a); var b = d(); this._doneCallbacks = []; this._tick = function (a) { c() ? e(a, 0, !1) : b(a) }; this._state = 0 } f.chain = function (a, b) { function c() { if (d === a.length) b(!0); else a[d](function (a) { !1 === a ? b(!1) : (d++ , c()) }) } var d = 0; c() }; f.all = function (a, b) { function c(f) { e = e && f; ++d === a.length && b(e) } var d = 0, e = !0; p(a, function (a) { a.done(c) }) }; f.prototype = {
                                setHost: function (a) { this.host = a || {} }, done: function (a) {
                                    2 ===
                                        this._state ? a() : this._doneCallbacks.push(a)
                                }, progress: C, getPromise: function () { if (!this.promise) { var b = this; this.promise = a(function (a, c) { b.done(function (b) { !1 === b ? c() : a() }) }) } return this.promise }, then: function (a, b) { return this.getPromise().then(a, b) }, "catch": function (a) { return this.getPromise()["catch"](a) }, "finally": function (a) { return this.getPromise()["finally"](a) }, pause: function () { this.host.pause && this.host.pause() }, resume: function () { this.host.resume && this.host.resume() }, end: function () {
                                    this.host.end &&
                                        this.host.end(); this._resolve(!0)
                                }, cancel: function () { this.host.cancel && this.host.cancel(); this._resolve(!1) }, complete: function (a) { var b = this; 0 === b._state && (b._state = 1, b._tick(function () { b._resolve(a) })) }, _resolve: function (a) { 2 !== this._state && (p(this._doneCallbacks, function (b) { b(a) }), this._doneCallbacks.length = 0, this._state = 2) }
                            }; return f
                        }]
                }, rf = function () {
                    this.$get = ["$$rAF", "$q", "$$AnimateRunner", function (a, b, d) {
                        return function (b, e) {
                            function f() {
                                a(function () {
                                    g.addClass && (b.addClass(g.addClass), g.addClass =
                                        null); g.removeClass && (b.removeClass(g.removeClass), g.removeClass = null); g.to && (b.css(g.to), g.to = null); k || h.complete(); k = !0
                                }); return h
                            } var g = e || {}; g.$$prepared || (g = pa(g)); g.cleanupStyles && (g.from = g.to = null); g.from && (b.css(g.from), g.from = null); var k, h = new d; return { start: f, end: f }
                        }
                    }]
                }, ba = M("$compile"), oc = new function () { }; Yc.$inject = ["$provide", "$$sanitizeUriProvider"]; Kb.prototype.isFirstChange = function () { return this.previousValue === oc }; var od = /^((?:x|data)[:\-_])/i, tg = /[:\-_]+(.)/g, ud = M("$controller"),
                    td = /^(\S+)(\s+as\s+([\w$]+))?$/, Cf = function () { this.$get = ["$document", function (a) { return function (b) { b ? !b.nodeType && b instanceof B && (b = b[0]) : b = a[0].body; return b.offsetWidth + 1 } }] }, vd = "application/json", sc = { "Content-Type": vd + ";charset=utf-8" }, wg = /^\[|^\{(?!\{)/, xg = { "[": /]$/, "{": /}$/ }, vg = /^\)]\}',?\n/, rc = M("$http"), Fa = $.$interpolateMinErr = M("$interpolate"); Fa.throwNoconcat = function (a) { throw Fa("noconcat", a); }; Fa.interr = function (a, b) { return Fa("interr", a, b.toString()) }; var Kf = function () {
                        this.$get = function () {
                            function a(a) {
                                var b =
                                    function (a) { b.data = a; b.called = !0 }; b.id = a; return b
                            } var b = $.callbacks, d = {}; return { createCallback: function (c) { c = "_" + (b.$$counter++).toString(36); var e = "angular.callbacks." + c, f = a(c); d[e] = b[c] = f; return e }, wasCalled: function (a) { return d[a].called }, getResponse: function (a) { return d[a].data }, removeCallback: function (a) { delete b[d[a].id]; delete d[a] } }
                        }
                    }, ah = /^([^?#]*)(\?([^#]*))?(#(.*))?$/, zg = { http: 80, https: 443, ftp: 21 }, mb = M("$location"), Ag = /^\s*[\\/]{2,}/, bh = {
                        $$absUrl: "", $$html5: !1, $$replace: !1, absUrl: Lb("$$absUrl"),
                        url: function (a) { if (w(a)) return this.$$url; var b = ah.exec(a); (b[1] || "" === a) && this.path(decodeURIComponent(b[1])); (b[2] || b[1] || "" === a) && this.search(b[3] || ""); this.hash(b[5] || ""); return this }, protocol: Lb("$$protocol"), host: Lb("$$host"), port: Lb("$$port"), path: Dd("$$path", function (a) { a = null !== a ? a.toString() : ""; return "/" === a.charAt(0) ? a : "/" + a }), search: function (a, b) {
                            switch (arguments.length) {
                                case 0: return this.$$search; case 1: if (D(a) || Y(a)) a = a.toString(), this.$$search = Tc(a); else if (E(a)) a = pa(a, {}), p(a, function (b,
                                    c) { null == b && delete a[c] }), this.$$search = a; else throw mb("isrcharg"); break; default: w(b) || null === b ? delete this.$$search[a] : this.$$search[a] = b
                            }this.$$compose(); return this
                        }, hash: Dd("$$hash", function (a) { return null !== a ? a.toString() : "" }), replace: function () { this.$$replace = !0; return this }
                    }; p([Cd, wc, vc], function (a) {
                        a.prototype = Object.create(bh); a.prototype.state = function (b) {
                            if (!arguments.length) return this.$$state; if (a !== vc || !this.$$html5) throw mb("nostate"); this.$$state = w(b) ? null : b; this.$$urlUpdatedByLocation =
                                !0; return this
                        }
                    }); var Ya = M("$parse"), Eg = {}.constructor.prototype.valueOf, Sb = S(); p("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function (a) { Sb[a] = !0 }); var ch = { n: "\n", f: "\f", r: "\r", t: "\t", v: "\v", "'": "'", '"': '"' }, zc = function (a) { this.options = a }; zc.prototype = {
                        constructor: zc, lex: function (a) {
                            this.text = a; this.index = 0; for (this.tokens = []; this.index < this.text.length;)if (a = this.text.charAt(this.index), '"' === a || "'" === a) this.readString(a); else if (this.isNumber(a) || "." === a && this.isNumber(this.peek())) this.readNumber();
                            else if (this.isIdentifierStart(this.peekMultichar())) this.readIdent(); else if (this.is(a, "(){}[].,;:?")) this.tokens.push({ index: this.index, text: a }), this.index++; else if (this.isWhitespace(a)) this.index++; else { var b = a + this.peek(), d = b + this.peek(2), c = Sb[b], e = Sb[d]; Sb[a] || c || e ? (a = e ? d : c ? b : a, this.tokens.push({ index: this.index, text: a, operator: !0 }), this.index += a.length) : this.throwError("Unexpected next character ", this.index, this.index + 1) } return this.tokens
                        }, is: function (a, b) { return -1 !== b.indexOf(a) }, peek: function (a) {
                            a =
                                a || 1; return this.index + a < this.text.length ? this.text.charAt(this.index + a) : !1
                        }, isNumber: function (a) { return "0" <= a && "9" >= a && "string" === typeof a }, isWhitespace: function (a) { return " " === a || "\r" === a || "\t" === a || "\n" === a || "\v" === a || "\u00a0" === a }, isIdentifierStart: function (a) { return this.options.isIdentifierStart ? this.options.isIdentifierStart(a, this.codePointAt(a)) : this.isValidIdentifierStart(a) }, isValidIdentifierStart: function (a) { return "a" <= a && "z" >= a || "A" <= a && "Z" >= a || "_" === a || "$" === a }, isIdentifierContinue: function (a) {
                            return this.options.isIdentifierContinue ?
                                this.options.isIdentifierContinue(a, this.codePointAt(a)) : this.isValidIdentifierContinue(a)
                        }, isValidIdentifierContinue: function (a, b) { return this.isValidIdentifierStart(a, b) || this.isNumber(a) }, codePointAt: function (a) { return 1 === a.length ? a.charCodeAt(0) : (a.charCodeAt(0) << 10) + a.charCodeAt(1) - 56613888 }, peekMultichar: function () { var a = this.text.charAt(this.index), b = this.peek(); if (!b) return a; var d = a.charCodeAt(0), c = b.charCodeAt(0); return 55296 <= d && 56319 >= d && 56320 <= c && 57343 >= c ? a + b : a }, isExpOperator: function (a) {
                            return "-" ===
                                a || "+" === a || this.isNumber(a)
                        }, throwError: function (a, b, d) { d = d || this.index; b = t(b) ? "s " + b + "-" + this.index + " [" + this.text.substring(b, d) + "]" : " " + d; throw Ya("lexerr", a, b, this.text); }, readNumber: function () {
                            for (var a = "", b = this.index; this.index < this.text.length;) {
                                var d = N(this.text.charAt(this.index)); if ("." === d || this.isNumber(d)) a += d; else {
                                    var c = this.peek(); if ("e" === d && this.isExpOperator(c)) a += d; else if (this.isExpOperator(d) && c && this.isNumber(c) && "e" === a.charAt(a.length - 1)) a += d; else if (!this.isExpOperator(d) ||
                                        c && this.isNumber(c) || "e" !== a.charAt(a.length - 1)) break; else this.throwError("Invalid exponent")
                                } this.index++
                            } this.tokens.push({ index: b, text: a, constant: !0, value: Number(a) })
                        }, readIdent: function () { var a = this.index; for (this.index += this.peekMultichar().length; this.index < this.text.length;) { var b = this.peekMultichar(); if (!this.isIdentifierContinue(b)) break; this.index += b.length } this.tokens.push({ index: a, text: this.text.slice(a, this.index), identifier: !0 }) }, readString: function (a) {
                            var b = this.index; this.index++;
                            for (var d = "", c = a, e = !1; this.index < this.text.length;) { var f = this.text.charAt(this.index), c = c + f; if (e) "u" === f ? (e = this.text.substring(this.index + 1, this.index + 5), e.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + e + "]"), this.index += 4, d += String.fromCharCode(parseInt(e, 16))) : d += ch[f] || f, e = !1; else if ("\\" === f) e = !0; else { if (f === a) { this.index++; this.tokens.push({ index: b, text: c, constant: !0, value: d }); return } d += f } this.index++ } this.throwError("Unterminated quote", b)
                        }
                    }; var r = function (a, b) {
                        this.lexer =
                            a; this.options = b
                    }; r.Program = "Program"; r.ExpressionStatement = "ExpressionStatement"; r.AssignmentExpression = "AssignmentExpression"; r.ConditionalExpression = "ConditionalExpression"; r.LogicalExpression = "LogicalExpression"; r.BinaryExpression = "BinaryExpression"; r.UnaryExpression = "UnaryExpression"; r.CallExpression = "CallExpression"; r.MemberExpression = "MemberExpression"; r.Identifier = "Identifier"; r.Literal = "Literal"; r.ArrayExpression = "ArrayExpression"; r.Property = "Property"; r.ObjectExpression = "ObjectExpression";
    r.ThisExpression = "ThisExpression"; r.LocalsExpression = "LocalsExpression"; r.NGValueParameter = "NGValueParameter"; r.prototype = {
        ast: function (a) { this.text = a; this.tokens = this.lexer.lex(a); a = this.program(); 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]); return a }, program: function () { for (var a = []; ;)if (0 < this.tokens.length && !this.peek("}", ")", ";", "]") && a.push(this.expressionStatement()), !this.expect(";")) return { type: r.Program, body: a } }, expressionStatement: function () {
            return {
                type: r.ExpressionStatement,
                expression: this.filterChain()
            }
        }, filterChain: function () { for (var a = this.expression(); this.expect("|");)a = this.filter(a); return a }, expression: function () { return this.assignment() }, assignment: function () { var a = this.ternary(); if (this.expect("=")) { if (!Hd(a)) throw Ya("lval"); a = { type: r.AssignmentExpression, left: a, right: this.assignment(), operator: "=" } } return a }, ternary: function () {
            var a = this.logicalOR(), b, d; return this.expect("?") && (b = this.expression(), this.consume(":")) ? (d = this.expression(), {
                type: r.ConditionalExpression,
                test: a, alternate: b, consequent: d
            }) : a
        }, logicalOR: function () { for (var a = this.logicalAND(); this.expect("||");)a = { type: r.LogicalExpression, operator: "||", left: a, right: this.logicalAND() }; return a }, logicalAND: function () { for (var a = this.equality(); this.expect("&&");)a = { type: r.LogicalExpression, operator: "&&", left: a, right: this.equality() }; return a }, equality: function () {
            for (var a = this.relational(), b; b = this.expect("==", "!=", "===", "!==");)a = { type: r.BinaryExpression, operator: b.text, left: a, right: this.relational() };
            return a
        }, relational: function () { for (var a = this.additive(), b; b = this.expect("<", ">", "<=", ">=");)a = { type: r.BinaryExpression, operator: b.text, left: a, right: this.additive() }; return a }, additive: function () { for (var a = this.multiplicative(), b; b = this.expect("+", "-");)a = { type: r.BinaryExpression, operator: b.text, left: a, right: this.multiplicative() }; return a }, multiplicative: function () { for (var a = this.unary(), b; b = this.expect("*", "/", "%");)a = { type: r.BinaryExpression, operator: b.text, left: a, right: this.unary() }; return a },
        unary: function () { var a; return (a = this.expect("+", "-", "!")) ? { type: r.UnaryExpression, operator: a.text, prefix: !0, argument: this.unary() } : this.primary() }, primary: function () {
            var a; this.expect("(") ? (a = this.filterChain(), this.consume(")")) : this.expect("[") ? a = this.arrayDeclaration() : this.expect("{") ? a = this.object() : this.selfReferential.hasOwnProperty(this.peek().text) ? a = pa(this.selfReferential[this.consume().text]) : this.options.literals.hasOwnProperty(this.peek().text) ? a = { type: r.Literal, value: this.options.literals[this.consume().text] } :
                this.peek().identifier ? a = this.identifier() : this.peek().constant ? a = this.constant() : this.throwError("not a primary expression", this.peek()); for (var b; b = this.expect("(", "[", ".");)"(" === b.text ? (a = { type: r.CallExpression, callee: a, arguments: this.parseArguments() }, this.consume(")")) : "[" === b.text ? (a = { type: r.MemberExpression, object: a, property: this.expression(), computed: !0 }, this.consume("]")) : "." === b.text ? a = { type: r.MemberExpression, object: a, property: this.identifier(), computed: !1 } : this.throwError("IMPOSSIBLE");
            return a
        }, filter: function (a) { a = [a]; for (var b = { type: r.CallExpression, callee: this.identifier(), arguments: a, filter: !0 }; this.expect(":");)a.push(this.expression()); return b }, parseArguments: function () { var a = []; if (")" !== this.peekToken().text) { do a.push(this.filterChain()); while (this.expect(",")) } return a }, identifier: function () { var a = this.consume(); a.identifier || this.throwError("is not a valid identifier", a); return { type: r.Identifier, name: a.text } }, constant: function () { return { type: r.Literal, value: this.consume().value } },
        arrayDeclaration: function () { var a = []; if ("]" !== this.peekToken().text) { do { if (this.peek("]")) break; a.push(this.expression()) } while (this.expect(",")) } this.consume("]"); return { type: r.ArrayExpression, elements: a } }, object: function () {
            var a = [], b; if ("}" !== this.peekToken().text) {
                do {
                    if (this.peek("}")) break; b = { type: r.Property, kind: "init" }; this.peek().constant ? (b.key = this.constant(), b.computed = !1, this.consume(":"), b.value = this.expression()) : this.peek().identifier ? (b.key = this.identifier(), b.computed = !1, this.peek(":") ?
                        (this.consume(":"), b.value = this.expression()) : b.value = b.key) : this.peek("[") ? (this.consume("["), b.key = this.expression(), this.consume("]"), b.computed = !0, this.consume(":"), b.value = this.expression()) : this.throwError("invalid key", this.peek()); a.push(b)
                } while (this.expect(","))
            } this.consume("}"); return { type: r.ObjectExpression, properties: a }
        }, throwError: function (a, b) { throw Ya("syntax", b.text, a, b.index + 1, this.text, this.text.substring(b.index)); }, consume: function (a) {
            if (0 === this.tokens.length) throw Ya("ueoe",
                this.text); var b = this.expect(a); b || this.throwError("is unexpected, expecting [" + a + "]", this.peek()); return b
        }, peekToken: function () { if (0 === this.tokens.length) throw Ya("ueoe", this.text); return this.tokens[0] }, peek: function (a, b, d, c) { return this.peekAhead(0, a, b, d, c) }, peekAhead: function (a, b, d, c, e) { if (this.tokens.length > a) { a = this.tokens[a]; var f = a.text; if (f === b || f === d || f === c || f === e || !(b || d || c || e)) return a } return !1 }, expect: function (a, b, d, c) { return (a = this.peek(a, b, d, c)) ? (this.tokens.shift(), a) : !1 }, selfReferential: {
            "this": { type: r.ThisExpression },
            $locals: { type: r.LocalsExpression }
        }
    }; var Fd = 2; Jd.prototype = {
        compile: function (a) {
            var b = this; this.state = { nextId: 0, filters: {}, fn: { vars: [], body: [], own: {} }, assign: { vars: [], body: [], own: {} }, inputs: [] }; V(a, b.$filter); var d = "", c; this.stage = "assign"; if (c = Id(a)) this.state.computing = "assign", d = this.nextId(), this.recurse(c, d), this.return_(d), d = "fn.assign=" + this.generateFunction("assign", "s,v,l"); c = Gd(a.body); b.stage = "inputs"; p(c, function (a, c) {
                var d = "fn" + c; b.state[d] = { vars: [], body: [], own: {} }; b.state.computing = d;
                var k = b.nextId(); b.recurse(a, k); b.return_(k); b.state.inputs.push({ name: d, isPure: a.isPure }); a.watchId = c
            }); this.state.computing = "fn"; this.stage = "main"; this.recurse(a); a = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + d + this.watchFns() + "return fn;"; a = (new Function("$filter", "getStringValue", "ifDefined", "plus", a))(this.$filter, Bg, Cg, Ed); this.state = this.stage = void 0; return a
        }, USE: "use", STRICT: "strict", watchFns: function () {
            var a = [], b = this.state.inputs,
                d = this; p(b, function (b) { a.push("var " + b.name + "=" + d.generateFunction(b.name, "s")); b.isPure && a.push(b.name, ".isPure=" + JSON.stringify(b.isPure) + ";") }); b.length && a.push("fn.inputs=[" + b.map(function (a) { return a.name }).join(",") + "];"); return a.join("")
        }, generateFunction: function (a, b) { return "function(" + b + "){" + this.varsPrefix(a) + this.body(a) + "};" }, filterPrefix: function () { var a = [], b = this; p(this.state.filters, function (d, c) { a.push(d + "=$filter(" + b.escape(c) + ")") }); return a.length ? "var " + a.join(",") + ";" : "" }, varsPrefix: function (a) {
            return this.state[a].vars.length ?
                "var " + this.state[a].vars.join(",") + ";" : ""
        }, body: function (a) { return this.state[a].body.join("") }, recurse: function (a, b, d, c, e, f) {
            var g, k, h = this, l, m, n; c = c || C; if (!f && t(a.watchId)) b = b || this.nextId(), this.if_("i", this.lazyAssign(b, this.computedMember("i", a.watchId)), this.lazyRecurse(a, b, d, c, e, !0)); else switch (a.type) {
                case r.Program: p(a.body, function (b, c) { h.recurse(b.expression, void 0, void 0, function (a) { k = a }); c !== a.body.length - 1 ? h.current().body.push(k, ";") : h.return_(k) }); break; case r.Literal: m = this.escape(a.value);
                    this.assign(b, m); c(b || m); break; case r.UnaryExpression: this.recurse(a.argument, void 0, void 0, function (a) { k = a }); m = a.operator + "(" + this.ifDefined(k, 0) + ")"; this.assign(b, m); c(m); break; case r.BinaryExpression: this.recurse(a.left, void 0, void 0, function (a) { g = a }); this.recurse(a.right, void 0, void 0, function (a) { k = a }); m = "+" === a.operator ? this.plus(g, k) : "-" === a.operator ? this.ifDefined(g, 0) + a.operator + this.ifDefined(k, 0) : "(" + g + ")" + a.operator + "(" + k + ")"; this.assign(b, m); c(m); break; case r.LogicalExpression: b = b || this.nextId();
                    h.recurse(a.left, b); h.if_("&&" === a.operator ? b : h.not(b), h.lazyRecurse(a.right, b)); c(b); break; case r.ConditionalExpression: b = b || this.nextId(); h.recurse(a.test, b); h.if_(b, h.lazyRecurse(a.alternate, b), h.lazyRecurse(a.consequent, b)); c(b); break; case r.Identifier: b = b || this.nextId(); d && (d.context = "inputs" === h.stage ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", a.name) + "?l:s"), d.computed = !1, d.name = a.name); h.if_("inputs" === h.stage || h.not(h.getHasOwnProperty("l", a.name)), function () {
                        h.if_("inputs" ===
                            h.stage || "s", function () { e && 1 !== e && h.if_(h.isNull(h.nonComputedMember("s", a.name)), h.lazyAssign(h.nonComputedMember("s", a.name), "{}")); h.assign(b, h.nonComputedMember("s", a.name)) })
                    }, b && h.lazyAssign(b, h.nonComputedMember("l", a.name))); c(b); break; case r.MemberExpression: g = d && (d.context = this.nextId()) || this.nextId(); b = b || this.nextId(); h.recurse(a.object, g, void 0, function () {
                        h.if_(h.notNull(g), function () {
                            a.computed ? (k = h.nextId(), h.recurse(a.property, k), h.getStringValue(k), e && 1 !== e && h.if_(h.not(h.computedMember(g,
                                k)), h.lazyAssign(h.computedMember(g, k), "{}")), m = h.computedMember(g, k), h.assign(b, m), d && (d.computed = !0, d.name = k)) : (e && 1 !== e && h.if_(h.isNull(h.nonComputedMember(g, a.property.name)), h.lazyAssign(h.nonComputedMember(g, a.property.name), "{}")), m = h.nonComputedMember(g, a.property.name), h.assign(b, m), d && (d.computed = !1, d.name = a.property.name))
                        }, function () { h.assign(b, "undefined") }); c(b)
                    }, !!e); break; case r.CallExpression: b = b || this.nextId(); a.filter ? (k = h.filter(a.callee.name), l = [], p(a.arguments, function (a) {
                        var b =
                            h.nextId(); h.recurse(a, b); l.push(b)
                    }), m = k + "(" + l.join(",") + ")", h.assign(b, m), c(b)) : (k = h.nextId(), g = {}, l = [], h.recurse(a.callee, k, g, function () { h.if_(h.notNull(k), function () { p(a.arguments, function (b) { h.recurse(b, a.constant ? void 0 : h.nextId(), void 0, function (a) { l.push(a) }) }); m = g.name ? h.member(g.context, g.name, g.computed) + "(" + l.join(",") + ")" : k + "(" + l.join(",") + ")"; h.assign(b, m) }, function () { h.assign(b, "undefined") }); c(b) })); break; case r.AssignmentExpression: k = this.nextId(); g = {}; this.recurse(a.left, void 0,
                        g, function () { h.if_(h.notNull(g.context), function () { h.recurse(a.right, k); m = h.member(g.context, g.name, g.computed) + a.operator + k; h.assign(b, m); c(b || m) }) }, 1); break; case r.ArrayExpression: l = []; p(a.elements, function (b) { h.recurse(b, a.constant ? void 0 : h.nextId(), void 0, function (a) { l.push(a) }) }); m = "[" + l.join(",") + "]"; this.assign(b, m); c(b || m); break; case r.ObjectExpression: l = []; n = !1; p(a.properties, function (a) { a.computed && (n = !0) }); n ? (b = b || this.nextId(), this.assign(b, "{}"), p(a.properties, function (a) {
                            a.computed ?
                                (g = h.nextId(), h.recurse(a.key, g)) : g = a.key.type === r.Identifier ? a.key.name : "" + a.key.value; k = h.nextId(); h.recurse(a.value, k); h.assign(h.member(b, g, a.computed), k)
                        })) : (p(a.properties, function (b) { h.recurse(b.value, a.constant ? void 0 : h.nextId(), void 0, function (a) { l.push(h.escape(b.key.type === r.Identifier ? b.key.name : "" + b.key.value) + ":" + a) }) }), m = "{" + l.join(",") + "}", this.assign(b, m)); c(b || m); break; case r.ThisExpression: this.assign(b, "s"); c(b || "s"); break; case r.LocalsExpression: this.assign(b, "l"); c(b || "l"); break;
                case r.NGValueParameter: this.assign(b, "v"), c(b || "v")
            }
        }, getHasOwnProperty: function (a, b) { var d = a + "." + b, c = this.current().own; c.hasOwnProperty(d) || (c[d] = this.nextId(!1, a + "&&(" + this.escape(b) + " in " + a + ")")); return c[d] }, assign: function (a, b) { if (a) return this.current().body.push(a, "=", b, ";"), a }, filter: function (a) { this.state.filters.hasOwnProperty(a) || (this.state.filters[a] = this.nextId(!0)); return this.state.filters[a] }, ifDefined: function (a, b) { return "ifDefined(" + a + "," + this.escape(b) + ")" }, plus: function (a,
            b) { return "plus(" + a + "," + b + ")" }, return_: function (a) { this.current().body.push("return ", a, ";") }, if_: function (a, b, d) { if (!0 === a) b(); else { var c = this.current().body; c.push("if(", a, "){"); b(); c.push("}"); d && (c.push("else{"), d(), c.push("}")) } }, not: function (a) { return "!(" + a + ")" }, isNull: function (a) { return a + "==null" }, notNull: function (a) { return a + "!=null" }, nonComputedMember: function (a, b) { var d = /[^$_a-zA-Z0-9]/g; return /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(b) ? a + "." + b : a + '["' + b.replace(d, this.stringEscapeFn) + '"]' }, computedMember: function (a,
                b) { return a + "[" + b + "]" }, member: function (a, b, d) { return d ? this.computedMember(a, b) : this.nonComputedMember(a, b) }, getStringValue: function (a) { this.assign(a, "getStringValue(" + a + ")") }, lazyRecurse: function (a, b, d, c, e, f) { var g = this; return function () { g.recurse(a, b, d, c, e, f) } }, lazyAssign: function (a, b) { var d = this; return function () { d.assign(a, b) } }, stringEscapeRegex: /[^ a-zA-Z0-9]/g, stringEscapeFn: function (a) { return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4) }, escape: function (a) {
                    if (D(a)) return "'" + a.replace(this.stringEscapeRegex,
                        this.stringEscapeFn) + "'"; if (Y(a)) return a.toString(); if (!0 === a) return "true"; if (!1 === a) return "false"; if (null === a) return "null"; if ("undefined" === typeof a) return "undefined"; throw Ya("esc");
                }, nextId: function (a, b) { var d = "v" + this.state.nextId++; a || this.current().vars.push(d + (b ? "=" + b : "")); return d }, current: function () { return this.state[this.state.computing] }
    }; Kd.prototype = {
        compile: function (a) {
            var b = this; V(a, b.$filter); var d, c; if (d = Id(a)) c = this.recurse(d); d = Gd(a.body); var e; d && (e = [], p(d, function (a, c) {
                var d =
                    b.recurse(a); d.isPure = a.isPure; a.input = d; e.push(d); a.watchId = c
            })); var f = []; p(a.body, function (a) { f.push(b.recurse(a.expression)) }); a = 0 === a.body.length ? C : 1 === a.body.length ? f[0] : function (a, b) { var c; p(f, function (d) { c = d(a, b) }); return c }; c && (a.assign = function (a, b, d) { return c(a, d, b) }); e && (a.inputs = e); return a
        }, recurse: function (a, b, d) {
            var c, e, f = this, g; if (a.input) return this.inputs(a.input, a.watchId); switch (a.type) {
                case r.Literal: return this.value(a.value, b); case r.UnaryExpression: return e = this.recurse(a.argument),
                    this["unary" + a.operator](e, b); case r.BinaryExpression: return c = this.recurse(a.left), e = this.recurse(a.right), this["binary" + a.operator](c, e, b); case r.LogicalExpression: return c = this.recurse(a.left), e = this.recurse(a.right), this["binary" + a.operator](c, e, b); case r.ConditionalExpression: return this["ternary?:"](this.recurse(a.test), this.recurse(a.alternate), this.recurse(a.consequent), b); case r.Identifier: return f.identifier(a.name, b, d); case r.MemberExpression: return c = this.recurse(a.object, !1, !!d), a.computed ||
                        (e = a.property.name), a.computed && (e = this.recurse(a.property)), a.computed ? this.computedMember(c, e, b, d) : this.nonComputedMember(c, e, b, d); case r.CallExpression: return g = [], p(a.arguments, function (a) { g.push(f.recurse(a)) }), a.filter && (e = this.$filter(a.callee.name)), a.filter || (e = this.recurse(a.callee, !0)), a.filter ? function (a, c, d, f) { for (var n = [], q = 0; q < g.length; ++q)n.push(g[q](a, c, d, f)); a = e.apply(void 0, n, f); return b ? { context: void 0, name: void 0, value: a } : a } : function (a, c, d, f) {
                            var n = e(a, c, d, f), q; if (null != n.value) {
                                q =
                                    []; for (var p = 0; p < g.length; ++p)q.push(g[p](a, c, d, f)); q = n.value.apply(n.context, q)
                            } return b ? { value: q } : q
                        }; case r.AssignmentExpression: return c = this.recurse(a.left, !0, 1), e = this.recurse(a.right), function (a, d, f, g) { var n = c(a, d, f, g); a = e(a, d, f, g); n.context[n.name] = a; return b ? { value: a } : a }; case r.ArrayExpression: return g = [], p(a.elements, function (a) { g.push(f.recurse(a)) }), function (a, c, d, e) { for (var f = [], q = 0; q < g.length; ++q)f.push(g[q](a, c, d, e)); return b ? { value: f } : f }; case r.ObjectExpression: return g = [], p(a.properties,
                            function (a) { a.computed ? g.push({ key: f.recurse(a.key), computed: !0, value: f.recurse(a.value) }) : g.push({ key: a.key.type === r.Identifier ? a.key.name : "" + a.key.value, computed: !1, value: f.recurse(a.value) }) }), function (a, c, d, e) { for (var f = {}, q = 0; q < g.length; ++q)g[q].computed ? f[g[q].key(a, c, d, e)] = g[q].value(a, c, d, e) : f[g[q].key] = g[q].value(a, c, d, e); return b ? { value: f } : f }; case r.ThisExpression: return function (a) { return b ? { value: a } : a }; case r.LocalsExpression: return function (a, c) { return b ? { value: c } : c }; case r.NGValueParameter: return function (a,
                                c, d) { return b ? { value: d } : d }
            }
        }, "unary+": function (a, b) { return function (d, c, e, f) { d = a(d, c, e, f); d = t(d) ? +d : 0; return b ? { value: d } : d } }, "unary-": function (a, b) { return function (d, c, e, f) { d = a(d, c, e, f); d = t(d) ? -d : -0; return b ? { value: d } : d } }, "unary!": function (a, b) { return function (d, c, e, f) { d = !a(d, c, e, f); return b ? { value: d } : d } }, "binary+": function (a, b, d) { return function (c, e, f, g) { var k = a(c, e, f, g); c = b(c, e, f, g); k = Ed(k, c); return d ? { value: k } : k } }, "binary-": function (a, b, d) {
            return function (c, e, f, g) {
                var k = a(c, e, f, g); c = b(c, e, f, g);
                k = (t(k) ? k : 0) - (t(c) ? c : 0); return d ? { value: k } : k
            }
        }, "binary*": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) * b(c, e, f, g); return d ? { value: c } : c } }, "binary/": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) / b(c, e, f, g); return d ? { value: c } : c } }, "binary%": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) % b(c, e, f, g); return d ? { value: c } : c } }, "binary===": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) === b(c, e, f, g); return d ? { value: c } : c } }, "binary!==": function (a, b, d) {
            return function (c, e, f, g) {
                c = a(c,
                    e, f, g) !== b(c, e, f, g); return d ? { value: c } : c
            }
        }, "binary==": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) == b(c, e, f, g); return d ? { value: c } : c } }, "binary!=": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) != b(c, e, f, g); return d ? { value: c } : c } }, "binary<": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) < b(c, e, f, g); return d ? { value: c } : c } }, "binary>": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) > b(c, e, f, g); return d ? { value: c } : c } }, "binary<=": function (a, b, d) {
            return function (c, e, f, g) {
                c = a(c, e, f,
                    g) <= b(c, e, f, g); return d ? { value: c } : c
            }
        }, "binary>=": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) >= b(c, e, f, g); return d ? { value: c } : c } }, "binary&&": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) && b(c, e, f, g); return d ? { value: c } : c } }, "binary||": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) || b(c, e, f, g); return d ? { value: c } : c } }, "ternary?:": function (a, b, d, c) { return function (e, f, g, k) { e = a(e, f, g, k) ? b(e, f, g, k) : d(e, f, g, k); return c ? { value: e } : e } }, value: function (a, b) {
            return function () {
                return b ? {
                    context: void 0,
                    name: void 0, value: a
                } : a
            }
        }, identifier: function (a, b, d) { return function (c, e, f, g) { c = e && a in e ? e : c; d && 1 !== d && c && null == c[a] && (c[a] = {}); e = c ? c[a] : void 0; return b ? { context: c, name: a, value: e } : e } }, computedMember: function (a, b, d, c) { return function (e, f, g, k) { var h = a(e, f, g, k), l, m; null != h && (l = b(e, f, g, k), l += "", c && 1 !== c && h && !h[l] && (h[l] = {}), m = h[l]); return d ? { context: h, name: l, value: m } : m } }, nonComputedMember: function (a, b, d, c) {
            return function (e, f, g, k) {
                e = a(e, f, g, k); c && 1 !== c && e && null == e[b] && (e[b] = {}); f = null != e ? e[b] : void 0;
                return d ? { context: e, name: b, value: f } : f
            }
        }, inputs: function (a, b) { return function (d, c, e, f) { return f ? f[b] : a(d, c, e) } }
    }; xc.prototype = { constructor: xc, parse: function (a) { a = this.ast.ast(a); var b = this.astCompiler.compile(a); b.literal = 0 === a.body.length || 1 === a.body.length && (a.body[0].expression.type === r.Literal || a.body[0].expression.type === r.ArrayExpression || a.body[0].expression.type === r.ObjectExpression); b.constant = a.constant; return b } }; var wa = M("$sce"), oa = {
        HTML: "html", CSS: "css", URL: "url", RESOURCE_URL: "resourceUrl",
        JS: "js"
    }, Ac = /_([a-z])/g, Gg = M("$compile"), X = u.document.createElement("a"), Od = ua(u.location.href); Pd.$inject = ["$document"]; ed.$inject = ["$provide"]; var Wd = 22, Vd = ".", Cc = "0"; Qd.$inject = ["$locale"]; Sd.$inject = ["$locale"]; var Rg = {
        yyyy: da("FullYear", 4, 0, !1, !0), yy: da("FullYear", 2, 0, !0, !0), y: da("FullYear", 1, 0, !1, !0), MMMM: ob("Month"), MMM: ob("Month", !0), MM: da("Month", 2, 1), M: da("Month", 1, 1), LLLL: ob("Month", !1, !0), dd: da("Date", 2), d: da("Date", 1), HH: da("Hours", 2), H: da("Hours", 1), hh: da("Hours", 2, -12), h: da("Hours",
            1, -12), mm: da("Minutes", 2), m: da("Minutes", 1), ss: da("Seconds", 2), s: da("Seconds", 1), sss: da("Milliseconds", 3), EEEE: ob("Day"), EEE: ob("Day", !0), a: function (a, b) { return 12 > a.getHours() ? b.AMPMS[0] : b.AMPMS[1] }, Z: function (a, b, d) { a = -1 * d; return a = (0 <= a ? "+" : "") + (Mb(Math[0 < a ? "floor" : "ceil"](a / 60), 2) + Mb(Math.abs(a % 60), 2)) }, ww: Yd(2), w: Yd(1), G: Dc, GG: Dc, GGG: Dc, GGGG: function (a, b) { return 0 >= a.getFullYear() ? b.ERANAMES[0] : b.ERANAMES[1] }
    }, Qg = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))([\s\S]*)/,
        Pg = /^-?\d+$/; Rd.$inject = ["$locale"]; var Kg = ka(N), Lg = ka(wb); Td.$inject = ["$parse"]; var He = ka({ restrict: "E", compile: function (a, b) { if (!b.href && !b.xlinkHref) return function (a, b) { if ("a" === b[0].nodeName.toLowerCase()) { var e = "[object SVGAnimatedString]" === ha.call(b.prop("href")) ? "xlink:href" : "href"; b.on("click", function (a) { b.attr(e) || a.preventDefault() }) } } } }), xb = {}; p(Hb, function (a, b) {
            function d(a, d, e) { a.$watch(e[c], function (a) { e.$set(b, !!a) }) } if ("multiple" !== a) {
                var c = Ea("ng-" + b), e = d; "checked" === a && (e = function (a,
                    b, e) { e.ngModel !== e[c] && d(a, b, e) }); xb[c] = function () { return { restrict: "A", priority: 100, link: e } }
            }
        }); p(sd, function (a, b) { xb[b] = function () { return { priority: 100, link: function (a, c, e) { if ("ngPattern" === b && "/" === e.ngPattern.charAt(0) && (c = e.ngPattern.match(Vg))) { e.$set("ngPattern", new RegExp(c[1], c[2])); return } a.$watch(e[b], function (a) { e.$set(b, a) }) } } } }); p(["src", "srcset", "href"], function (a) {
            var b = Ea("ng-" + a); xb[b] = function () {
                return {
                    priority: 99, link: function (d, c, e) {
                        var f = a, g = a; "href" === a && "[object SVGAnimatedString]" ===
                            ha.call(c.prop("href")) && (g = "xlinkHref", e.$attr[g] = "xlink:href", f = null); e.$observe(b, function (b) { b ? (e.$set(g, b), Ca && f && c.prop(f, e[g])) : "href" === a && e.$set(g, null) })
                    }
                }
            }
        }); var Ob = { $addControl: C, $$renameControl: function (a, b) { a.$name = b }, $removeControl: C, $setValidity: C, $setDirty: C, $setPristine: C, $setSubmitted: C }; Nb.$inject = ["$element", "$attrs", "$scope", "$animate", "$interpolate"]; Nb.prototype = {
            $rollbackViewValue: function () { p(this.$$controls, function (a) { a.$rollbackViewValue() }) }, $commitViewValue: function () {
                p(this.$$controls,
                    function (a) { a.$commitViewValue() })
            }, $addControl: function (a) { Ia(a.$name, "input"); this.$$controls.push(a); a.$name && (this[a.$name] = a); a.$$parentForm = this }, $$renameControl: function (a, b) { var d = a.$name; this[d] === a && delete this[d]; this[b] = a; a.$name = b }, $removeControl: function (a) {
                a.$name && this[a.$name] === a && delete this[a.$name]; p(this.$pending, function (b, d) { this.$setValidity(d, null, a) }, this); p(this.$error, function (b, d) { this.$setValidity(d, null, a) }, this); p(this.$$success, function (b, d) {
                    this.$setValidity(d, null,
                        a)
                }, this); db(this.$$controls, a); a.$$parentForm = Ob
            }, $setDirty: function () { this.$$animate.removeClass(this.$$element, Za); this.$$animate.addClass(this.$$element, Tb); this.$dirty = !0; this.$pristine = !1; this.$$parentForm.$setDirty() }, $setPristine: function () { this.$$animate.setClass(this.$$element, Za, Tb + " ng-submitted"); this.$dirty = !1; this.$pristine = !0; this.$submitted = !1; p(this.$$controls, function (a) { a.$setPristine() }) }, $setUntouched: function () { p(this.$$controls, function (a) { a.$setUntouched() }) }, $setSubmitted: function () {
                this.$$animate.addClass(this.$$element,
                    "ng-submitted"); this.$submitted = !0; this.$$parentForm.$setSubmitted()
            }
        }; ae({ clazz: Nb, set: function (a, b, d) { var c = a[b]; c ? -1 === c.indexOf(d) && c.push(d) : a[b] = [d] }, unset: function (a, b, d) { var c = a[b]; c && (db(c, d), 0 === c.length && delete a[b]) } }); var ie = function (a) {
            return ["$timeout", "$parse", function (b, d) {
                function c(a) { return "" === a ? d('this[""]').assign : d(a).assign || C } return {
                    name: "form", restrict: a ? "EAC" : "E", require: ["form", "^^?form"], controller: Nb, compile: function (d, f) {
                        d.addClass(Za).addClass(pb); var g = f.name ? "name" :
                            a && f.ngForm ? "ngForm" : !1; return {
                                pre: function (a, d, e, f) {
                                    var n = f[0]; if (!("action" in e)) { var q = function (b) { a.$apply(function () { n.$commitViewValue(); n.$setSubmitted() }); b.preventDefault() }; d[0].addEventListener("submit", q); d.on("$destroy", function () { b(function () { d[0].removeEventListener("submit", q) }, 0, !1) }) } (f[1] || n.$$parentForm).$addControl(n); var p = g ? c(n.$name) : C; g && (p(a, n), e.$observe(g, function (b) { n.$name !== b && (p(a, void 0), n.$$parentForm.$$renameControl(n, b), p = c(n.$name), p(a, n)) })); d.on("$destroy", function () {
                                        n.$$parentForm.$removeControl(n);
                                        p(a, void 0); P(n, Ob)
                                    })
                                }
                            }
                    }
                }
            }]
        }, Ie = ie(), Ue = ie(!0), Sg = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/, dh = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i, eh = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/, Tg = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/, je = /^(\d{4,})-(\d{2})-(\d{2})$/,
            ke = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, Kc = /^(\d{4,})-W(\d\d)$/, le = /^(\d{4,})-(\d\d)$/, me = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, ce = S(); p(["date", "datetime-local", "month", "time", "week"], function (a) { ce[a] = !0 }); var ne = {
                text: function (a, b, d, c, e, f) { Wa(a, b, d, c, e, f); Fc(c) }, date: qb("date", je, Pb(je, ["yyyy", "MM", "dd"]), "yyyy-MM-dd"), "datetime-local": qb("datetimelocal", ke, Pb(ke, "yyyy MM dd HH mm ss sss".split(" ")), "yyyy-MM-ddTHH:mm:ss.sss"), time: qb("time", me, Pb(me, ["HH", "mm",
                    "ss", "sss"]), "HH:mm:ss.sss"), week: qb("week", Kc, function (a, b) { if (ea(a)) return a; if (D(a)) { Kc.lastIndex = 0; var d = Kc.exec(a); if (d) { var c = +d[1], e = +d[2], f = d = 0, g = 0, k = 0, h = Xd(c), e = 7 * (e - 1); b && (d = b.getHours(), f = b.getMinutes(), g = b.getSeconds(), k = b.getMilliseconds()); return new Date(c, 0, h.getDate() + e, d, f, g, k) } } return NaN }, "yyyy-Www"), month: qb("month", le, Pb(le, ["yyyy", "MM"]), "yyyy-MM"), number: function (a, b, d, c, e, f) {
                        Gc(a, b, d, c); de(c); Wa(a, b, d, c, e, f); var g, k; if (t(d.min) || d.ngMin) c.$validators.min = function (a) {
                            return c.$isEmpty(a) ||
                                w(g) || a >= g
                        }, d.$observe("min", function (a) { g = Xa(a); c.$validate() }); if (t(d.max) || d.ngMax) c.$validators.max = function (a) { return c.$isEmpty(a) || w(k) || a <= k }, d.$observe("max", function (a) { k = Xa(a); c.$validate() }); if (t(d.step) || d.ngStep) { var h; c.$validators.step = function (a, b) { return c.$isEmpty(b) || w(h) || ee(b, g || 0, h) }; d.$observe("step", function (a) { h = Xa(a); c.$validate() }) }
                    }, url: function (a, b, d, c, e, f) { Wa(a, b, d, c, e, f); Fc(c); c.$$parserName = "url"; c.$validators.url = function (a, b) { var d = a || b; return c.$isEmpty(d) || dh.test(d) } },
                email: function (a, b, d, c, e, f) { Wa(a, b, d, c, e, f); Fc(c); c.$$parserName = "email"; c.$validators.email = function (a, b) { var d = a || b; return c.$isEmpty(d) || eh.test(d) } }, radio: function (a, b, d, c) { var e = !d.ngTrim || "false" !== Q(d.ngTrim); w(d.name) && b.attr("name", ++sb); b.on("click", function (a) { var g; b[0].checked && (g = d.value, e && (g = Q(g)), c.$setViewValue(g, a && a.type)) }); c.$render = function () { var a = d.value; e && (a = Q(a)); b[0].checked = a === c.$viewValue }; d.$observe("value", c.$render) }, range: function (a, b, d, c, e, f) {
                    function g(a, c) {
                        b.attr(a,
                            d[a]); d.$observe(a, c)
                    } function k(a) { n = Xa(a); T(c.$modelValue) || (m ? (a = b.val(), n > a && (a = n, b.val(a)), c.$setViewValue(a)) : c.$validate()) } function h(a) { q = Xa(a); T(c.$modelValue) || (m ? (a = b.val(), q < a && (b.val(q), a = q < n ? n : q), c.$setViewValue(a)) : c.$validate()) } function l(a) { p = Xa(a); T(c.$modelValue) || (m && c.$viewValue !== b.val() ? c.$setViewValue(b.val()) : c.$validate()) } Gc(a, b, d, c); de(c); Wa(a, b, d, c, e, f); var m = c.$$hasNativeValidators && "range" === b[0].type, n = m ? 0 : void 0, q = m ? 100 : void 0, p = m ? 1 : void 0, r = b[0].validity; a = t(d.min);
                    e = t(d.max); f = t(d.step); var z = c.$render; c.$render = m && t(r.rangeUnderflow) && t(r.rangeOverflow) ? function () { z(); c.$setViewValue(b.val()) } : z; a && (c.$validators.min = m ? function () { return !0 } : function (a, b) { return c.$isEmpty(b) || w(n) || b >= n }, g("min", k)); e && (c.$validators.max = m ? function () { return !0 } : function (a, b) { return c.$isEmpty(b) || w(q) || b <= q }, g("max", h)); f && (c.$validators.step = m ? function () { return !r.stepMismatch } : function (a, b) { return c.$isEmpty(b) || w(p) || ee(b, n || 0, p) }, g("step", l))
                }, checkbox: function (a, b, d, c, e,
                    f, g, k) { var h = fe(k, a, "ngTrueValue", d.ngTrueValue, !0), l = fe(k, a, "ngFalseValue", d.ngFalseValue, !1); b.on("click", function (a) { c.$setViewValue(b[0].checked, a && a.type) }); c.$render = function () { b[0].checked = c.$viewValue }; c.$isEmpty = function (a) { return !1 === a }; c.$formatters.push(function (a) { return sa(a, h) }); c.$parsers.push(function (a) { return a ? h : l }) }, hidden: C, button: C, submit: C, reset: C, file: C
            }, Zc = ["$browser", "$sniffer", "$filter", "$parse", function (a, b, d, c) {
                return {
                    restrict: "E", require: ["?ngModel"], link: {
                        pre: function (e,
                            f, g, k) { k[0] && (ne[N(g.type)] || ne.text)(e, f, g, k[0], b, a, d, c) }
                    }
                }
            }], fh = /^(true|false|\d+)$/, mf = function () { function a(a, d, c) { var e = t(c) ? c : 9 === Ca ? "" : null; a.prop("value", e); d.$set("value", c) } return { restrict: "A", priority: 100, compile: function (b, d) { return fh.test(d.ngValue) ? function (b, d, f) { b = b.$eval(f.ngValue); a(d, f, b) } : function (b, d, f) { b.$watch(f.ngValue, function (b) { a(d, f, b) }) } } } }, Me = ["$compile", function (a) {
                return {
                    restrict: "AC", compile: function (b) {
                        a.$$addBindingClass(b); return function (b, c, e) {
                            a.$$addBindingInfo(c,
                                e.ngBind); c = c[0]; b.$watch(e.ngBind, function (a) { c.textContent = dc(a) })
                        }
                    }
                }
            }], Oe = ["$interpolate", "$compile", function (a, b) { return { compile: function (d) { b.$$addBindingClass(d); return function (c, d, f) { c = a(d.attr(f.$attr.ngBindTemplate)); b.$$addBindingInfo(d, c.expressions); d = d[0]; f.$observe("ngBindTemplate", function (a) { d.textContent = w(a) ? "" : a }) } } } }], Ne = ["$sce", "$parse", "$compile", function (a, b, d) {
                return {
                    restrict: "A", compile: function (c, e) {
                        var f = b(e.ngBindHtml), g = b(e.ngBindHtml, function (b) { return a.valueOf(b) });
                        d.$$addBindingClass(c); return function (b, c, e) { d.$$addBindingInfo(c, e.ngBindHtml); b.$watch(g, function () { var d = f(b); c.html(a.getTrustedHtml(d) || "") }) }
                    }
                }
            }], lf = ka({ restrict: "A", require: "ngModel", link: function (a, b, d, c) { c.$viewChangeListeners.push(function () { a.$eval(d.ngChange) }) } }), Pe = Ic("", !0), Re = Ic("Odd", 0), Qe = Ic("Even", 1), Se = Qa({ compile: function (a, b) { b.$set("ngCloak", void 0); a.removeClass("ng-cloak") } }), Te = [function () { return { restrict: "A", scope: !0, controller: "@", priority: 500 } }], dd = {}, gh = { blur: !0, focus: !0 };
    p("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function (a) { var b = Ea("ng-" + a); dd[b] = ["$parse", "$rootScope", function (d, c) { return { restrict: "A", compile: function (e, f) { var g = d(f[b]); return function (b, d) { d.on(a, function (d) { var e = function () { g(b, { $event: d }) }; gh[a] && c.$$phase ? b.$evalAsync(e) : b.$apply(e) }) } } } }] }); var We = ["$animate", "$compile", function (a, b) {
        return {
            multiElement: !0, transclude: "element", priority: 600,
            terminal: !0, restrict: "A", $$tlb: !0, link: function (d, c, e, f, g) { var k, h, l; d.$watch(e.ngIf, function (d) { d ? h || g(function (d, f) { h = f; d[d.length++] = b.$$createComment("end ngIf", e.ngIf); k = { clone: d }; a.enter(d, c.parent(), c) }) : (l && (l.remove(), l = null), h && (h.$destroy(), h = null), k && (l = vb(k.clone), a.leave(l).done(function (a) { !1 !== a && (l = null) }), k = null)) }) }
        }
    }], Xe = ["$templateRequest", "$anchorScroll", "$animate", function (a, b, d) {
        return {
            restrict: "ECA", priority: 400, terminal: !0, transclude: "element", controller: $.noop, compile: function (c,
                e) {
                var f = e.ngInclude || e.src, g = e.onload || "", k = e.autoscroll; return function (c, e, m, n, q) {
                    var p = 0, r, z, v, s = function () { z && (z.remove(), z = null); r && (r.$destroy(), r = null); v && (d.leave(v).done(function (a) { !1 !== a && (z = null) }), z = v, v = null) }; c.$watch(f, function (f) {
                        var m = function (a) { !1 === a || !t(k) || k && !c.$eval(k) || b() }, y = ++p; f ? (a(f, !0).then(function (a) { if (!c.$$destroyed && y === p) { var b = c.$new(); n.template = a; a = q(b, function (a) { s(); d.enter(a, null, e).done(m) }); r = b; v = a; r.$emit("$includeContentLoaded", f); c.$eval(g) } }, function () {
                            c.$$destroyed ||
                                y !== p || (s(), c.$emit("$includeContentError", f))
                        }), c.$emit("$includeContentRequested", f)) : (s(), n.template = null)
                    })
                }
            }
        }
    }], of = ["$compile", function (a) { return { restrict: "ECA", priority: -400, require: "ngInclude", link: function (b, d, c, e) { ha.call(d[0]).match(/SVG/) ? (d.empty(), a(fd(e.template, u.document).childNodes)(b, function (a) { d.append(a) }, { futureParentElement: d })) : (d.html(e.template), a(d.contents())(b)) } } }], Ye = Qa({ priority: 450, compile: function () { return { pre: function (a, b, d) { a.$eval(d.ngInit) } } } }), kf = function () {
        return {
            restrict: "A",
            priority: 100, require: "ngModel", link: function (a, b, d, c) { var e = d.ngList || ", ", f = "false" !== d.ngTrim, g = f ? Q(e) : e; c.$parsers.push(function (a) { if (!w(a)) { var b = []; a && p(a.split(g), function (a) { a && b.push(f ? Q(a) : a) }); return b } }); c.$formatters.push(function (a) { if (I(a)) return a.join(e) }); c.$isEmpty = function (a) { return !a || !a.length } }
        }
    }, pb = "ng-valid", $d = "ng-invalid", Za = "ng-pristine", Tb = "ng-dirty", rb = M("ngModel"); Qb.$inject = "$scope $exceptionHandler $attrs $element $parse $animate $timeout $q $interpolate".split(" ");
    Qb.prototype = {
        $$initGetterSetters: function () { if (this.$options.getOption("getterSetter")) { var a = this.$$parse(this.$$attr.ngModel + "()"), b = this.$$parse(this.$$attr.ngModel + "($$$p)"); this.$$ngModelGet = function (b) { var c = this.$$parsedNgModel(b); A(c) && (c = a(b)); return c }; this.$$ngModelSet = function (a, c) { A(this.$$parsedNgModel(a)) ? b(a, { $$$p: c }) : this.$$parsedNgModelAssign(a, c) } } else if (!this.$$parsedNgModel.assign) throw rb("nonassign", this.$$attr.ngModel, Aa(this.$$element)); }, $render: C, $isEmpty: function (a) {
            return w(a) ||
                "" === a || null === a || a !== a
        }, $$updateEmptyClasses: function (a) { this.$isEmpty(a) ? (this.$$animate.removeClass(this.$$element, "ng-not-empty"), this.$$animate.addClass(this.$$element, "ng-empty")) : (this.$$animate.removeClass(this.$$element, "ng-empty"), this.$$animate.addClass(this.$$element, "ng-not-empty")) }, $setPristine: function () { this.$dirty = !1; this.$pristine = !0; this.$$animate.removeClass(this.$$element, Tb); this.$$animate.addClass(this.$$element, Za) }, $setDirty: function () {
            this.$dirty = !0; this.$pristine = !1; this.$$animate.removeClass(this.$$element,
                Za); this.$$animate.addClass(this.$$element, Tb); this.$$parentForm.$setDirty()
        }, $setUntouched: function () { this.$touched = !1; this.$untouched = !0; this.$$animate.setClass(this.$$element, "ng-untouched", "ng-touched") }, $setTouched: function () { this.$touched = !0; this.$untouched = !1; this.$$animate.setClass(this.$$element, "ng-touched", "ng-untouched") }, $rollbackViewValue: function () { this.$$timeout.cancel(this.$$pendingDebounce); this.$viewValue = this.$$lastCommittedViewValue; this.$render() }, $validate: function () {
            if (!T(this.$modelValue)) {
                var a =
                    this.$$lastCommittedViewValue, b = this.$$rawModelValue, d = this.$valid, c = this.$modelValue, e = this.$options.getOption("allowInvalid"), f = this; this.$$runValidators(b, a, function (a) { e || d === a || (f.$modelValue = a ? b : void 0, f.$modelValue !== c && f.$$writeModelToScope()) })
            }
        }, $$runValidators: function (a, b, d) {
            function c() { var c = !0; p(h.$validators, function (d, e) { var g = Boolean(d(a, b)); c = c && g; f(e, g) }); return c ? !0 : (p(h.$asyncValidators, function (a, b) { f(b, null) }), !1) } function e() {
                var c = [], d = !0; p(h.$asyncValidators, function (e,
                    g) { var h = e(a, b); if (!h || !A(h.then)) throw rb("nopromise", h); f(g, void 0); c.push(h.then(function () { f(g, !0) }, function () { d = !1; f(g, !1) })) }); c.length ? h.$$q.all(c).then(function () { g(d) }, C) : g(!0)
            } function f(a, b) { k === h.$$currentValidationRunId && h.$setValidity(a, b) } function g(a) { k === h.$$currentValidationRunId && d(a) } this.$$currentValidationRunId++; var k = this.$$currentValidationRunId, h = this; (function () {
                var a = h.$$parserName || "parse"; if (w(h.$$parserValid)) f(a, null); else return h.$$parserValid || (p(h.$validators, function (a,
                    b) { f(b, null) }), p(h.$asyncValidators, function (a, b) { f(b, null) })), f(a, h.$$parserValid), h.$$parserValid; return !0
            })() ? c() ? e() : g(!1) : g(!1)
        }, $commitViewValue: function () { var a = this.$viewValue; this.$$timeout.cancel(this.$$pendingDebounce); if (this.$$lastCommittedViewValue !== a || "" === a && this.$$hasNativeValidators) this.$$updateEmptyClasses(a), this.$$lastCommittedViewValue = a, this.$pristine && this.$setDirty(), this.$$parseAndValidate() }, $$parseAndValidate: function () {
            var a = this.$$lastCommittedViewValue, b = this; if (this.$$parserValid =
                w(a) ? void 0 : !0) for (var d = 0; d < this.$parsers.length; d++)if (a = this.$parsers[d](a), w(a)) { this.$$parserValid = !1; break } T(this.$modelValue) && (this.$modelValue = this.$$ngModelGet(this.$$scope)); var c = this.$modelValue, e = this.$options.getOption("allowInvalid"); this.$$rawModelValue = a; e && (this.$modelValue = a, b.$modelValue !== c && b.$$writeModelToScope()); this.$$runValidators(a, this.$$lastCommittedViewValue, function (d) { e || (b.$modelValue = d ? a : void 0, b.$modelValue !== c && b.$$writeModelToScope()) })
        }, $$writeModelToScope: function () {
            this.$$ngModelSet(this.$$scope,
                this.$modelValue); p(this.$viewChangeListeners, function (a) { try { a() } catch (b) { this.$$exceptionHandler(b) } }, this)
        }, $setViewValue: function (a, b) { this.$viewValue = a; this.$options.getOption("updateOnDefault") && this.$$debounceViewValueCommit(b) }, $$debounceViewValueCommit: function (a) {
            var b = this.$options.getOption("debounce"); Y(b[a]) ? b = b[a] : Y(b["default"]) && (b = b["default"]); this.$$timeout.cancel(this.$$pendingDebounce); var d = this; 0 < b ? this.$$pendingDebounce = this.$$timeout(function () { d.$commitViewValue() }, b) : this.$$scope.$root.$$phase ?
                this.$commitViewValue() : this.$$scope.$apply(function () { d.$commitViewValue() })
        }, $overrideModelOptions: function (a) { this.$options = this.$options.createChild(a) }
    }; ae({ clazz: Qb, set: function (a, b) { a[b] = !0 }, unset: function (a, b) { delete a[b] } }); var jf = ["$rootScope", function (a) {
        return {
            restrict: "A", require: ["ngModel", "^?form", "^?ngModelOptions"], controller: Qb, priority: 1, compile: function (b) {
                b.addClass(Za).addClass("ng-untouched").addClass(pb); return {
                    pre: function (a, b, e, f) {
                        var g = f[0]; b = f[1] || g.$$parentForm; if (f = f[2]) g.$options =
                            f.$options; g.$$initGetterSetters(); b.$addControl(g); e.$observe("name", function (a) { g.$name !== a && g.$$parentForm.$$renameControl(g, a) }); a.$on("$destroy", function () { g.$$parentForm.$removeControl(g) })
                    }, post: function (b, c, e, f) { function g() { k.$setTouched() } var k = f[0]; if (k.$options.getOption("updateOn")) c.on(k.$options.getOption("updateOn"), function (a) { k.$$debounceViewValueCommit(a && a.type) }); c.on("blur", function () { k.$touched || (a.$$phase ? b.$evalAsync(g) : b.$apply(g)) }) }
                }
            }
        }
    }], Rb, hh = /(\s+|^)default(\s+|$)/; Jc.prototype =
        { getOption: function (a) { return this.$$options[a] }, createChild: function (a) { var b = !1; a = P({}, a); p(a, function (d, c) { "$inherit" === d ? "*" === c ? b = !0 : (a[c] = this.$$options[c], "updateOn" === c && (a.updateOnDefault = this.$$options.updateOnDefault)) : "updateOn" === c && (a.updateOnDefault = !1, a[c] = Q(d.replace(hh, function () { a.updateOnDefault = !0; return " " }))) }, this); b && (delete a["*"], ge(a, this.$$options)); ge(a, Rb.$$options); return new Jc(a) } }; Rb = new Jc({
            updateOn: "", updateOnDefault: !0, debounce: 0, getterSetter: !1, allowInvalid: !1,
            timezone: null
        }); var nf = function () { function a(a, d) { this.$$attrs = a; this.$$scope = d } a.$inject = ["$attrs", "$scope"]; a.prototype = { $onInit: function () { var a = this.parentCtrl ? this.parentCtrl.$options : Rb, d = this.$$scope.$eval(this.$$attrs.ngModelOptions); this.$options = a.createChild(d) } }; return { restrict: "A", priority: 10, require: { parentCtrl: "?^^ngModelOptions" }, bindToController: !0, controller: a } }, Ze = Qa({ terminal: !0, priority: 1E3 }), ih = M("ngOptions"), jh = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,
            gf = ["$compile", "$document", "$parse", function (a, b, d) {
                function c(a, b, c) {
                    function e(a, b, c, d, f) { this.selectValue = a; this.viewValue = b; this.label = c; this.group = d; this.disabled = f } function f(a) { var b; if (!p && xa(a)) b = a; else { b = []; for (var c in a) a.hasOwnProperty(c) && "$" !== c.charAt(0) && b.push(c) } return b } var n = a.match(jh); if (!n) throw ih("iexp", a, Aa(b)); var q = n[5] || n[7], p = n[6]; a = / as /.test(n[0]) && n[1]; var r = n[9]; b = d(n[2] ? n[1] : q); var z = a && d(a) || b, t = r && d(r), s = r ? function (a, b) { return t(c, b) } : function (a) { return Pa(a) },
                        w = function (a, b) { return s(a, A(a, b)) }, u = d(n[2] || n[1]), y = d(n[3] || ""), J = d(n[4] || ""), H = d(n[8]), B = {}, A = p ? function (a, b) { B[p] = b; B[q] = a; return B } : function (a) { B[q] = a; return B }; return {
                            trackBy: r, getTrackByValue: w, getWatchables: d(H, function (a) { var b = []; a = a || []; for (var d = f(a), e = d.length, g = 0; g < e; g++) { var k = a === d ? g : d[g], l = a[k], k = A(l, k), l = s(l, k); b.push(l); if (n[2] || n[1]) l = u(c, k), b.push(l); n[4] && (k = J(c, k), b.push(k)) } return b }), getOptions: function () {
                                for (var a = [], b = {}, d = H(c) || [], g = f(d), k = g.length, n = 0; n < k; n++) {
                                    var q = d ===
                                        g ? n : g[n], p = A(d[q], q), t = z(c, p), q = s(t, p), v = u(c, p), G = y(c, p), p = J(c, p), t = new e(q, t, v, G, p); a.push(t); b[q] = t
                                } return { items: a, selectValueMap: b, getOptionFromViewValue: function (a) { return b[w(a)] }, getViewValueFromOption: function (a) { return r ? pa(a.viewValue) : a.viewValue } }
                            }
                        }
                } var e = u.document.createElement("option"), f = u.document.createElement("optgroup"); return {
                    restrict: "A", terminal: !0, require: ["select", "ngModel"], link: {
                        pre: function (a, b, c, d) { d[0].registerOption = C }, post: function (d, k, h, l) {
                            function m(a) {
                                var b = (a = s.getOptionFromViewValue(a)) &&
                                    a.element; b && !b.selected && (b.selected = !0); return a
                            } function n(a, b) { a.element = b; b.disabled = a.disabled; a.label !== b.label && (b.label = a.label, b.textContent = a.label); b.value = a.selectValue } var q = l[0], r = l[1], w = h.multiple; l = 0; for (var z = k.children(), v = z.length; l < v; l++)if ("" === z[l].value) { q.hasEmptyOption = !0; q.emptyOption = z.eq(l); break } k.empty(); l = !!q.emptyOption; B(e.cloneNode(!1)).val("?"); var s, u = c(h.ngOptions, k, d), A = b[0].createDocumentFragment(); q.generateUnknownOptionValue = function (a) { return "?" }; w ? (q.writeValue =
                                function (a) { if (s) { var b = a && a.map(m) || []; s.items.forEach(function (a) { a.element.selected && -1 === Array.prototype.indexOf.call(b, a) && (a.element.selected = !1) }) } }, q.readValue = function () { var a = k.val() || [], b = []; p(a, function (a) { (a = s.selectValueMap[a]) && !a.disabled && b.push(s.getViewValueFromOption(a)) }); return b }, u.trackBy && d.$watchCollection(function () { if (I(r.$viewValue)) return r.$viewValue.map(function (a) { return u.getTrackByValue(a) }) }, function () { r.$render() })) : (q.writeValue = function (a) {
                                    if (s) {
                                        var b = k[0].options[k[0].selectedIndex],
                                            c = s.getOptionFromViewValue(a); b && b.removeAttribute("selected"); c ? (k[0].value !== c.selectValue && (q.removeUnknownOption(), k[0].value = c.selectValue, c.element.selected = !0), c.element.setAttribute("selected", "selected")) : q.selectUnknownOrEmptyOption(a)
                                    }
                                }, q.readValue = function () { var a = s.selectValueMap[k.val()]; return a && !a.disabled ? (q.unselectEmptyOption(), q.removeUnknownOption(), s.getViewValueFromOption(a)) : null }, u.trackBy && d.$watch(function () { return u.getTrackByValue(r.$viewValue) }, function () { r.$render() }));
                            l && (a(q.emptyOption)(d), k.prepend(q.emptyOption), 8 === q.emptyOption[0].nodeType ? (q.hasEmptyOption = !1, q.registerOption = function (a, b) { "" === b.val() && (q.hasEmptyOption = !0, q.emptyOption = b, q.emptyOption.removeClass("ng-scope"), r.$render(), b.on("$destroy", function () { var a = q.$isEmptyOptionSelected(); q.hasEmptyOption = !1; q.emptyOption = void 0; a && r.$render() })) }) : q.emptyOption.removeClass("ng-scope")); d.$watchCollection(u.getWatchables, function () {
                                var a = s && q.readValue(); if (s) for (var b = s.items.length - 1; 0 <= b; b--) {
                                    var c =
                                        s.items[b]; t(c.group) ? Gb(c.element.parentNode) : Gb(c.element)
                                } s = u.getOptions(); var d = {}; s.items.forEach(function (a) { var b; if (t(a.group)) { b = d[a.group]; b || (b = f.cloneNode(!1), A.appendChild(b), b.label = null === a.group ? "null" : a.group, d[a.group] = b); var c = e.cloneNode(!1); b.appendChild(c); n(a, c) } else b = e.cloneNode(!1), A.appendChild(b), n(a, b) }); k[0].appendChild(A); r.$render(); r.$isEmpty(a) || (b = q.readValue(), (u.trackBy || w ? sa(a, b) : a === b) || (r.$setViewValue(b), r.$render()))
                            })
                        }
                    }
                }
            }], $e = ["$locale", "$interpolate", "$log",
                function (a, b, d) {
                    var c = /{}/g, e = /^when(Minus)?(.+)$/; return {
                        link: function (f, g, k) {
                            function h(a) { g.text(a || "") } var l = k.count, m = k.$attr.when && g.attr(k.$attr.when), n = k.offset || 0, q = f.$eval(m) || {}, r = {}, t = b.startSymbol(), z = b.endSymbol(), v = t + l + "-" + n + z, s = $.noop, u; p(k, function (a, b) { var c = e.exec(b); c && (c = (c[1] ? "-" : "") + N(c[2]), q[c] = g.attr(k.$attr[b])) }); p(q, function (a, d) { r[d] = b(a.replace(c, v)) }); f.$watch(l, function (b) {
                                var c = parseFloat(b), e = T(c); e || c in q || (c = a.pluralCat(c - n)); c === u || e && T(u) || (s(), e = r[c], w(e) ? (null !=
                                    b && d.debug("ngPluralize: no rule defined for '" + c + "' in " + m), s = C, h()) : s = f.$watch(e, h), u = c)
                            })
                        }
                    }
                }], af = ["$parse", "$animate", "$compile", function (a, b, d) {
                    var c = M("ngRepeat"), e = function (a, b, c, d, e, m, n) { a[c] = d; e && (a[e] = m); a.$index = b; a.$first = 0 === b; a.$last = b === n - 1; a.$middle = !(a.$first || a.$last); a.$odd = !(a.$even = 0 === (b & 1)) }; return {
                        restrict: "A", multiElement: !0, transclude: "element", priority: 1E3, terminal: !0, $$tlb: !0, compile: function (f, g) {
                            var k = g.ngRepeat, h = d.$$createComment("end ngRepeat", k), l = k.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                            if (!l) throw c("iexp", k); var m = l[1], n = l[2], q = l[3], r = l[4], l = m.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/); if (!l) throw c("iidexp", m); var t = l[3] || l[1], z = l[2]; if (q && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(q) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(q))) throw c("badident", q); var v, s, u, w, y = { $id: Pa }; r ? v = a(r) : (u = function (a, b) { return Pa(b) }, w = function (a) { return a }); return function (a, d, f, g, l) {
                                v && (s = function (b, c, d) {
                                    z && (y[z] = b); y[t] = c; y.$index =
                                        d; return v(a, y)
                                }); var m = S(); a.$watchCollection(n, function (f) {
                                    var g, n, r = d[0], v, y = S(), B, A, G, C, E, D, I; q && (a[q] = f); if (xa(f)) E = f, n = s || u; else for (I in n = s || w, E = [], f) ra.call(f, I) && "$" !== I.charAt(0) && E.push(I); B = E.length; I = Array(B); for (g = 0; g < B; g++)if (A = f === E ? g : E[g], G = f[A], C = n(A, G, g), m[C]) D = m[C], delete m[C], y[C] = D, I[g] = D; else { if (y[C]) throw p(I, function (a) { a && a.scope && (m[a.id] = a) }), c("dupes", k, C, G); I[g] = { id: C, scope: void 0, clone: void 0 }; y[C] = !0 } for (v in m) {
                                        D = m[v]; C = vb(D.clone); b.leave(C); if (C[0].parentNode) for (g =
                                            0, n = C.length; g < n; g++)C[g].$$NG_REMOVED = !0; D.scope.$destroy()
                                    } for (g = 0; g < B; g++)if (A = f === E ? g : E[g], G = f[A], D = I[g], D.scope) { v = r; do v = v.nextSibling; while (v && v.$$NG_REMOVED); D.clone[0] !== v && b.move(vb(D.clone), null, r); r = D.clone[D.clone.length - 1]; e(D.scope, g, t, G, z, A, B) } else l(function (a, c) { D.scope = c; var d = h.cloneNode(!1); a[a.length++] = d; b.enter(a, null, r); r = d; D.clone = a; y[D.id] = D; e(D.scope, g, t, G, z, A, B) }); m = y
                                })
                            }
                        }
                    }
                }], bf = ["$animate", function (a) {
                    return {
                        restrict: "A", multiElement: !0, link: function (b, d, c) {
                            b.$watch(c.ngShow,
                                function (b) { a[b ? "removeClass" : "addClass"](d, "ng-hide", { tempClasses: "ng-hide-animate" }) })
                        }
                    }
                }], Ve = ["$animate", function (a) { return { restrict: "A", multiElement: !0, link: function (b, d, c) { b.$watch(c.ngHide, function (b) { a[b ? "addClass" : "removeClass"](d, "ng-hide", { tempClasses: "ng-hide-animate" }) }) } } }], cf = Qa(function (a, b, d) { a.$watch(d.ngStyle, function (a, d) { d && a !== d && p(d, function (a, c) { b.css(c, "") }); a && b.css(a) }, !0) }), df = ["$animate", "$compile", function (a, b) {
                    return {
                        require: "ngSwitch", controller: ["$scope", function () {
                            this.cases =
                                {}
                        }], link: function (d, c, e, f) {
                            var g = [], k = [], h = [], l = [], m = function (a, b) { return function (c) { !1 !== c && a.splice(b, 1) } }; d.$watch(e.ngSwitch || e.on, function (c) {
                                for (var d, e; h.length;)a.cancel(h.pop()); d = 0; for (e = l.length; d < e; ++d) { var r = vb(k[d].clone); l[d].$destroy(); (h[d] = a.leave(r)).done(m(h, d)) } k.length = 0; l.length = 0; (g = f.cases["!" + c] || f.cases["?"]) && p(g, function (c) {
                                    c.transclude(function (d, e) {
                                        l.push(e); var f = c.element; d[d.length++] = b.$$createComment("end ngSwitchWhen"); k.push({ clone: d }); a.enter(d, f.parent(),
                                            f)
                                    })
                                })
                            })
                        }
                    }
                }], ef = Qa({ transclude: "element", priority: 1200, require: "^ngSwitch", multiElement: !0, link: function (a, b, d, c, e) { a = d.ngSwitchWhen.split(d.ngSwitchWhenSeparator).sort().filter(function (a, b, c) { return c[b - 1] !== a }); p(a, function (a) { c.cases["!" + a] = c.cases["!" + a] || []; c.cases["!" + a].push({ transclude: e, element: b }) }) } }), ff = Qa({ transclude: "element", priority: 1200, require: "^ngSwitch", multiElement: !0, link: function (a, b, d, c, e) { c.cases["?"] = c.cases["?"] || []; c.cases["?"].push({ transclude: e, element: b }) } }), kh = M("ngTransclude"),
            hf = ["$compile", function (a) {
                return {
                    restrict: "EAC", terminal: !0, compile: function (b) {
                        var d = a(b.contents()); b.empty(); return function (a, b, f, g, k) {
                            function h() { d(a, function (a) { b.append(a) }) } if (!k) throw kh("orphan", Aa(b)); f.ngTransclude === f.$attr.ngTransclude && (f.ngTransclude = ""); f = f.ngTransclude || f.ngTranscludeSlot; k(function (a, c) { var d; if (d = a.length) a: { d = 0; for (var f = a.length; d < f; d++) { var g = a[d]; if (g.nodeType !== Oa || g.nodeValue.trim()) { d = !0; break a } } d = void 0 } d ? b.append(a) : (h(), c.$destroy()) }, null, f); f && !k.isSlotFilled(f) &&
                                h()
                        }
                    }
                }
            }], Je = ["$templateCache", function (a) { return { restrict: "E", terminal: !0, compile: function (b, d) { "text/ng-template" === d.type && a.put(d.id, b[0].text) } } }], lh = { $setViewValue: C, $render: C }, mh = ["$element", "$scope", function (a, b) {
                function d() { g || (g = !0, b.$$postDigest(function () { g = !1; e.ngModelCtrl.$render() })) } function c(a) { k || (k = !0, b.$$postDigest(function () { b.$$destroyed || (k = !1, e.ngModelCtrl.$setViewValue(e.readValue()), a && e.ngModelCtrl.$render()) })) } var e = this, f = new Ib; e.selectValueMap = {}; e.ngModelCtrl = lh;
                e.multiple = !1; e.unknownOption = B(u.document.createElement("option")); e.hasEmptyOption = !1; e.emptyOption = void 0; e.renderUnknownOption = function (b) { b = e.generateUnknownOptionValue(b); e.unknownOption.val(b); a.prepend(e.unknownOption); Ga(e.unknownOption, !0); a.val(b) }; e.updateUnknownOption = function (b) { b = e.generateUnknownOptionValue(b); e.unknownOption.val(b); Ga(e.unknownOption, !0); a.val(b) }; e.generateUnknownOptionValue = function (a) { return "? " + Pa(a) + " ?" }; e.removeUnknownOption = function () {
                    e.unknownOption.parent() &&
                        e.unknownOption.remove()
                }; e.selectEmptyOption = function () { e.emptyOption && (a.val(""), Ga(e.emptyOption, !0)) }; e.unselectEmptyOption = function () { e.hasEmptyOption && Ga(e.emptyOption, !1) }; b.$on("$destroy", function () { e.renderUnknownOption = C }); e.readValue = function () { var b = a.val(), b = b in e.selectValueMap ? e.selectValueMap[b] : b; return e.hasOption(b) ? b : null }; e.writeValue = function (b) {
                    var c = a[0].options[a[0].selectedIndex]; c && Ga(B(c), !1); e.hasOption(b) ? (e.removeUnknownOption(), c = Pa(b), a.val(c in e.selectValueMap ?
                        c : b), Ga(B(a[0].options[a[0].selectedIndex]), !0)) : e.selectUnknownOrEmptyOption(b)
                }; e.addOption = function (a, b) { if (8 !== b[0].nodeType) { Ia(a, '"option value"'); "" === a && (e.hasEmptyOption = !0, e.emptyOption = b); var c = f.get(a) || 0; f.set(a, c + 1); d() } }; e.removeOption = function (a) { var b = f.get(a); b && (1 === b ? (f.delete(a), "" === a && (e.hasEmptyOption = !1, e.emptyOption = void 0)) : f.set(a, b - 1)) }; e.hasOption = function (a) { return !!f.get(a) }; e.$hasEmptyOption = function () { return e.hasEmptyOption }; e.$isUnknownOptionSelected = function () {
                    return a[0].options[0] ===
                        e.unknownOption[0]
                }; e.$isEmptyOptionSelected = function () { return e.hasEmptyOption && a[0].options[a[0].selectedIndex] === e.emptyOption[0] }; e.selectUnknownOrEmptyOption = function (a) { null == a && e.emptyOption ? (e.removeUnknownOption(), e.selectEmptyOption()) : e.unknownOption.parent().length ? e.updateUnknownOption(a) : e.renderUnknownOption(a) }; var g = !1, k = !1; e.registerOption = function (a, b, f, g, k) {
                    if (f.$attr.ngValue) {
                        var p, r = NaN; f.$observe("value", function (a) {
                            var d, f = b.prop("selected"); t(r) && (e.removeOption(p), delete e.selectValueMap[r],
                                d = !0); r = Pa(a); p = a; e.selectValueMap[r] = a; e.addOption(a, b); b.attr("value", r); d && f && c()
                        })
                    } else g ? f.$observe("value", function (a) { e.readValue(); var d, f = b.prop("selected"); t(p) && (e.removeOption(p), d = !0); p = a; e.addOption(a, b); d && f && c() }) : k ? a.$watch(k, function (a, d) { f.$set("value", a); var g = b.prop("selected"); d !== a && e.removeOption(d); e.addOption(a, b); d && g && c() }) : e.addOption(f.value, b); f.$observe("disabled", function (a) { if ("true" === a || a && b.prop("selected")) e.multiple ? c(!0) : (e.ngModelCtrl.$setViewValue(null), e.ngModelCtrl.$render()) });
                    b.on("$destroy", function () { var a = e.readValue(), b = f.value; e.removeOption(b); d(); (e.multiple && a && -1 !== a.indexOf(b) || a === b) && c(!0) })
                }
            }], Ke = function () {
                return {
                    restrict: "E", require: ["select", "?ngModel"], controller: mh, priority: 1, link: {
                        pre: function (a, b, d, c) {
                            var e = c[0], f = c[1]; if (f) {
                                if (e.ngModelCtrl = f, b.on("change", function () { e.removeUnknownOption(); a.$apply(function () { f.$setViewValue(e.readValue()) }) }), d.multiple) {
                                    e.multiple = !0; e.readValue = function () {
                                        var a = []; p(b.find("option"), function (b) {
                                            b.selected && !b.disabled &&
                                                (b = b.value, a.push(b in e.selectValueMap ? e.selectValueMap[b] : b))
                                        }); return a
                                    }; e.writeValue = function (a) { p(b.find("option"), function (b) { var c = !!a && (-1 !== Array.prototype.indexOf.call(a, b.value) || -1 !== Array.prototype.indexOf.call(a, e.selectValueMap[b.value])); c !== b.selected && Ga(B(b), c) }) }; var g, k = NaN; a.$watch(function () { k !== f.$viewValue || sa(g, f.$viewValue) || (g = ja(f.$viewValue), f.$render()); k = f.$viewValue }); f.$isEmpty = function (a) { return !a || 0 === a.length }
                                }
                            } else e.registerOption = C
                        }, post: function (a, b, d, c) {
                            var e =
                                c[1]; if (e) { var f = c[0]; e.$render = function () { f.writeValue(e.$viewValue) } }
                        }
                    }
                }
            }, Le = ["$interpolate", function (a) { return { restrict: "E", priority: 100, compile: function (b, d) { var c, e; t(d.ngValue) || (t(d.value) ? c = a(d.value, !0) : (e = a(b.text(), !0)) || d.$set("value", b.text())); return function (a, b, d) { var h = b.parent(); (h = h.data("$selectController") || h.parent().data("$selectController")) && h.registerOption(a, b, d, c, e) } } } }], ad = function () {
                return {
                    restrict: "A", require: "?ngModel", link: function (a, b, d, c) {
                        c && (d.required = !0, c.$validators.required =
                            function (a, b) { return !d.required || !c.$isEmpty(b) }, d.$observe("required", function () { c.$validate() }))
                    }
                }
            }, $c = function () { return { restrict: "A", require: "?ngModel", link: function (a, b, d, c) { if (c) { var e, f = d.ngPattern || d.pattern; d.$observe("pattern", function (a) { D(a) && 0 < a.length && (a = new RegExp("^" + a + "$")); if (a && !a.test) throw M("ngPattern")("noregexp", f, a, Aa(b)); e = a || void 0; c.$validate() }); c.$validators.pattern = function (a, b) { return c.$isEmpty(b) || w(e) || e.test(b) } } } } }, cd = function () {
                return {
                    restrict: "A", require: "?ngModel",
                    link: function (a, b, d, c) { if (c) { var e = -1; d.$observe("maxlength", function (a) { a = Z(a); e = T(a) ? -1 : a; c.$validate() }); c.$validators.maxlength = function (a, b) { return 0 > e || c.$isEmpty(b) || b.length <= e } } }
                }
            }, bd = function () { return { restrict: "A", require: "?ngModel", link: function (a, b, d, c) { if (c) { var e = 0; d.$observe("minlength", function (a) { e = Z(a) || 0; c.$validate() }); c.$validators.minlength = function (a, b) { return c.$isEmpty(b) || b.length >= e } } } } }; u.angular.bootstrap ? u.console && console.log("WARNING: Tried to load angular more than once.") :
                (Be(), Ee($), $.module("ngLocale", [], ["$provide", function (a) {
                    function b(a) { a += ""; var b = a.indexOf("."); return -1 == b ? 0 : a.length - b - 1 } a.value("$locale", {
                        DATETIME_FORMATS: {
                            AMPMS: ["AM", "PM"], DAY: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), ERANAMES: ["Before Christ", "Anno Domini"], ERAS: ["BC", "AD"], FIRSTDAYOFWEEK: 6, MONTH: "January February March April May June July August September October November December".split(" "), SHORTDAY: "Sun Mon Tue Wed Thu Fri Sat".split(" "), SHORTMONTH: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
                            STANDALONEMONTH: "January February March April May June July August September October November December".split(" "), WEEKENDRANGE: [5, 6], fullDate: "EEEE, MMMM d, y", longDate: "MMMM d, y", medium: "MMM d, y h:mm:ss a", mediumDate: "MMM d, y", mediumTime: "h:mm:ss a", "short": "M/d/yy h:mm a", shortDate: "M/d/yy", shortTime: "h:mm a"
                        }, NUMBER_FORMATS: {
                            CURRENCY_SYM: "$", DECIMAL_SEP: ".", GROUP_SEP: ",", PATTERNS: [{ gSize: 3, lgSize: 3, maxFrac: 3, minFrac: 0, minInt: 1, negPre: "-", negSuf: "", posPre: "", posSuf: "" }, {
                                gSize: 3, lgSize: 3, maxFrac: 2,
                                minFrac: 2, minInt: 1, negPre: "-\u00a4", negSuf: "", posPre: "\u00a4", posSuf: ""
                            }]
                        }, id: "en-us", localeID: "en_US", pluralCat: function (a, c) { var e = a | 0, f = c; void 0 === f && (f = Math.min(b(a), 3)); Math.pow(10, f); return 1 == e && 0 == f ? "one" : "other" }
                    })
                }]), B(function () { we(u.document, Uc) }))
})(window); !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
//# sourceMappingURL=angular.min.js.map

/*
 AngularJS v1.6.6
 (c) 2010-2017 Google, Inc. http://angularjs.org
 License: MIT
*/
(function (S, q) {
    'use strict'; function Ea(a, b, c) { if (!a) throw Pa("areq", b || "?", c || "required"); return a } function Fa(a, b) { if (!a && !b) return ""; if (!a) return b; if (!b) return a; V(a) && (a = a.join(" ")); V(b) && (b = b.join(" ")); return a + " " + b } function Qa(a) { var b = {}; a && (a.to || a.from) && (b.to = a.to, b.from = a.from); return b } function W(a, b, c) { var d = ""; a = V(a) ? a : a && C(a) && a.length ? a.split(/\s+/) : []; t(a, function (a, f) { a && 0 < a.length && (d += 0 < f ? " " : "", d += c ? b + a : a + b) }); return d } function Ga(a) {
        if (a instanceof A) switch (a.length) {
            case 0: return a;
            case 1: if (1 === a[0].nodeType) return a; break; default: return A(ua(a))
        }if (1 === a.nodeType) return A(a)
    } function ua(a) { if (!a[0]) return a; for (var b = 0; b < a.length; b++) { var c = a[b]; if (1 === c.nodeType) return c } } function Ra(a, b, c) { t(b, function (b) { a.addClass(b, c) }) } function Sa(a, b, c) { t(b, function (b) { a.removeClass(b, c) }) } function X(a) { return function (b, c) { c.addClass && (Ra(a, b, c.addClass), c.addClass = null); c.removeClass && (Sa(a, b, c.removeClass), c.removeClass = null) } } function oa(a) {
        a = a || {}; if (!a.$$prepared) {
            var b = a.domOperation ||
                O; a.domOperation = function () { a.$$domOperationFired = !0; b(); b = O }; a.$$prepared = !0
        } return a
    } function ha(a, b) { Ha(a, b); Ia(a, b) } function Ha(a, b) { b.from && (a.css(b.from), b.from = null) } function Ia(a, b) { b.to && (a.css(b.to), b.to = null) } function T(a, b, c) {
        var d = b.options || {}; c = c.options || {}; var e = (d.addClass || "") + " " + (c.addClass || ""), f = (d.removeClass || "") + " " + (c.removeClass || ""); a = Ta(a.attr("class"), e, f); c.preparationClasses && (d.preparationClasses = ca(c.preparationClasses, d.preparationClasses), delete c.preparationClasses);
        e = d.domOperation !== O ? d.domOperation : null; va(d, c); e && (d.domOperation = e); d.addClass = a.addClass ? a.addClass : null; d.removeClass = a.removeClass ? a.removeClass : null; b.addClass = d.addClass; b.removeClass = d.removeClass; return d
    } function Ta(a, b, c) {
        function d(a) { C(a) && (a = a.split(" ")); var b = {}; t(a, function (a) { a.length && (b[a] = !0) }); return b } var e = {}; a = d(a); b = d(b); t(b, function (a, b) { e[b] = 1 }); c = d(c); t(c, function (a, b) { e[b] = 1 === e[b] ? null : -1 }); var f = { addClass: "", removeClass: "" }; t(e, function (b, c) {
            var d, e; 1 === b ? (d = "addClass",
                e = !a[c] || a[c + "-remove"]) : -1 === b && (d = "removeClass", e = a[c] || a[c + "-add"]); e && (f[d].length && (f[d] += " "), f[d] += c)
        }); return f
    } function J(a) { return a instanceof A ? a[0] : a } function Ua(a, b, c) { var d = ""; b && (d = W(b, "ng-", !0)); c.addClass && (d = ca(d, W(c.addClass, "-add"))); c.removeClass && (d = ca(d, W(c.removeClass, "-remove"))); d.length && (c.preparationClasses = d, a.addClass(d)) } function pa(a, b) { var c = b ? "-" + b + "s" : ""; ka(a, [la, c]); return [la, c] } function wa(a, b) { var c = b ? "paused" : "", d = Y + "PlayState"; ka(a, [d, c]); return [d, c] } function ka(a,
        b) { a.style[b[0]] = b[1] } function ca(a, b) { return a ? b ? a + " " + b : a : b } function Ja(a, b, c) { var d = Object.create(null), e = a.getComputedStyle(b) || {}; t(c, function (a, b) { var c = e[a]; if (c) { var l = c.charAt(0); if ("-" === l || "+" === l || 0 <= l) c = Va(c); 0 === c && (c = null); d[b] = c } }); return d } function Va(a) { var b = 0; a = a.split(/\s*,\s*/); t(a, function (a) { "s" === a.charAt(a.length - 1) && (a = a.substring(0, a.length - 1)); a = parseFloat(a) || 0; b = b ? Math.max(a, b) : a }); return b } function xa(a) { return 0 === a || null != a } function Ka(a, b) {
            var c = Q, d = a + "s"; b ? c += "Duration" :
                d += " linear all"; return [c, d]
        } function La() { var a = Object.create(null); return { flush: function () { a = Object.create(null) }, count: function (b) { return (b = a[b]) ? b.total : 0 }, get: function (b) { return (b = a[b]) && b.value }, put: function (b, c) { a[b] ? a[b].total++ : a[b] = { total: 1, value: c } } } } function Ma(a, b, c) { t(c, function (c) { a[c] = ya(a[c]) ? a[c] : b.style.getPropertyValue(c) }) } var Q, za, Y, Aa; void 0 === S.ontransitionend && void 0 !== S.onwebkittransitionend ? (Q = "WebkitTransition", za = "webkitTransitionEnd transitionend") : (Q = "transition", za =
            "transitionend"); void 0 === S.onanimationend && void 0 !== S.onwebkitanimationend ? (Y = "WebkitAnimation", Aa = "webkitAnimationEnd animationend") : (Y = "animation", Aa = "animationend"); var qa = Y + "Delay", Ba = Y + "Duration", la = Q + "Delay", Na = Q + "Duration", Pa = q.$$minErr("ng"), Wa = { transitionDuration: Na, transitionDelay: la, transitionProperty: Q + "Property", animationDuration: Ba, animationDelay: qa, animationIterationCount: Y + "IterationCount" }, Xa = { transitionDuration: Na, transitionDelay: la, animationDuration: Ba, animationDelay: qa }, Ca, va,
                t, V, ya, Z, Da, ra, C, P, A, O; q.module("ngAnimate", [], function () { O = q.noop; Ca = q.copy; va = q.extend; A = q.element; t = q.forEach; V = q.isArray; C = q.isString; ra = q.isObject; P = q.isUndefined; ya = q.isDefined; Da = q.isFunction; Z = q.isElement }).info({ angularVersion: "1.6.6" }).directive("ngAnimateSwap", ["$animate", "$rootScope", function (a, b) {
                    return {
                        restrict: "A", transclude: "element", terminal: !0, priority: 600, link: function (b, d, e, f, n) {
                            var G, l; b.$watchCollection(e.ngAnimateSwap || e["for"], function (e) {
                                G && a.leave(G); l && (l.$destroy(), l = null);
                                if (e || 0 === e) l = b.$new(), n(l, function (b) { G = b; a.enter(b, null, d) })
                            })
                        }
                    }
                }]).directive("ngAnimateChildren", ["$interpolate", function (a) { return { link: function (b, c, d) { function e(a) { c.data("$$ngAnimateChildren", "on" === a || "true" === a) } var f = d.ngAnimateChildren; C(f) && 0 === f.length ? c.data("$$ngAnimateChildren", !0) : (e(a(f)(b)), d.$observe("ngAnimateChildren", e)) } } }]).factory("$$rAFScheduler", ["$$rAF", function (a) {
                    function b(a) { d = d.concat(a); c() } function c() {
                        if (d.length) {
                            for (var b = d.shift(), n = 0; n < b.length; n++)b[n]();
                            e || a(function () { e || c() })
                        }
                    } var d, e; d = b.queue = []; b.waitUntilQuiet = function (b) { e && e(); e = a(function () { e = null; b(); c() }) }; return b
                }]).provider("$$animateQueue", ["$animateProvider", function (a) {
                    function b(a) { if (!a) return null; a = a.split(" "); var b = Object.create(null); t(a, function (a) { b[a] = !0 }); return b } function c(a, c) { if (a && c) { var d = b(c); return a.split(" ").some(function (a) { return d[a] }) } } function d(a, b, c) { return f[a].some(function (a) { return a(b, c) }) } function e(a, b) {
                        var c = 0 < (a.addClass || "").length, d = 0 < (a.removeClass ||
                            "").length; return b ? c && d : c || d
                    } var f = this.rules = { skip: [], cancel: [], join: [] }; f.join.push(function (a, b) { return !a.structural && e(a) }); f.skip.push(function (a, b) { return !a.structural && !e(a) }); f.skip.push(function (a, b) { return "leave" === b.event && a.structural }); f.skip.push(function (a, b) { return b.structural && 2 === b.state && !a.structural }); f.cancel.push(function (a, b) { return b.structural && a.structural }); f.cancel.push(function (a, b) { return 2 === b.state && a.structural }); f.cancel.push(function (a, b) {
                        if (b.structural) return !1;
                        var d = a.addClass, e = a.removeClass, f = b.addClass, sa = b.removeClass; return P(d) && P(e) || P(f) && P(sa) ? !1 : c(d, sa) || c(e, f)
                    }); this.$get = ["$$rAF", "$rootScope", "$rootElement", "$document", "$$Map", "$$animation", "$$AnimateRunner", "$templateRequest", "$$jqLite", "$$forceReflow", "$$isDocumentHidden", function (b, c, f, s, y, sa, da, v, E, g, M) {
                        function x() { var a = !1; return function (b) { a ? b() : c.$$postDigest(function () { a = !0; b() }) } } function H(a, b, c) {
                            var h = [], d = k[c]; d && t(d, function (d) {
                                u.call(d.node, b) ? h.push(d.callback) : "leave" === c &&
                                    u.call(d.node, a) && h.push(d.callback)
                            }); return h
                        } function I(a, b, c) { var h = ua(b); return a.filter(function (a) { return !(a.node === h && (!c || a.callback === c)) }) } function K(a, k, w) {
                            function K(a, c, h, k) { s(function () { var a = H(na, p, c); a.length ? b(function () { t(a, function (a) { a(f, h, k) }); "close" !== h || p.parentNode || ba.off(p) }) : "close" !== h || p.parentNode || ba.off(p) }); a.progress(c, h, k) } function I(a) {
                                var b = f, c = g; c.preparationClasses && (b.removeClass(c.preparationClasses), c.preparationClasses = null); c.activeClasses && (b.removeClass(c.activeClasses),
                                    c.activeClasses = null); Oa(f, g); ha(f, g); g.domOperation(); l.complete(!a)
                            } var g = Ca(w), f = Ga(a), p = J(f), na = p && p.parentNode, g = oa(g), l = new da, s = x(); V(g.addClass) && (g.addClass = g.addClass.join(" ")); g.addClass && !C(g.addClass) && (g.addClass = null); V(g.removeClass) && (g.removeClass = g.removeClass.join(" ")); g.removeClass && !C(g.removeClass) && (g.removeClass = null); g.from && !ra(g.from) && (g.from = null); g.to && !ra(g.to) && (g.to = null); if (!(h && p && Ya(p, k, w) && D(p, g))) return I(), l; var v = 0 <= ["enter", "move", "leave"].indexOf(k), u =
                                M(), y = u || ga.get(p); w = !y && z.get(p) || {}; var E = !!w.state; y || E && 1 === w.state || (y = !L(p, na, k)); if (y) return u && K(l, k, "start"), I(), u && K(l, k, "close"), l; v && ta(p); u = { structural: v, element: f, event: k, addClass: g.addClass, removeClass: g.removeClass, close: I, options: g, runner: l }; if (E) {
                                    if (d("skip", u, w)) { if (2 === w.state) return I(), l; T(f, w, u); return w.runner } if (d("cancel", u, w)) if (2 === w.state) w.runner.end(); else if (w.structural) w.close(); else return T(f, w, u), w.runner; else if (d("join", u, w)) if (2 === w.state) T(f, u, {}); else return Ua(f,
                                        v ? k : null, g), k = u.event = w.event, g = T(f, w, u), w.runner
                                } else T(f, u, {}); (E = u.structural) || (E = "animate" === u.event && 0 < Object.keys(u.options.to || {}).length || e(u)); if (!E) return I(), m(p), l; var q = (w.counter || 0) + 1; u.counter = q; F(p, 1, u); c.$$postDigest(function () {
                                    f = Ga(a); var b = z.get(p), c = !b, b = b || {}, h = 0 < (f.parent() || []).length && ("animate" === b.event || b.structural || e(b)); if (c || b.counter !== q || !h) { c && (Oa(f, g), ha(f, g)); if (c || v && b.event !== k) g.domOperation(), l.end(); h || m(p) } else k = !b.structural && e(b, !0) ? "setClass" : b.event,
                                        F(p, 2), b = sa(f, k, b.options), l.setHost(b), K(l, k, "start", {}), b.done(function (a) { I(!a); (a = z.get(p)) && a.counter === q && m(p); K(l, k, "close", {}) })
                                }); return l
                        } function ta(a) { a = a.querySelectorAll("[data-ng-animate]"); t(a, function (a) { var b = parseInt(a.getAttribute("data-ng-animate"), 10), c = z.get(a); if (c) switch (b) { case 2: c.runner.end(); case 1: z.delete(a) } }) } function m(a) { a.removeAttribute("data-ng-animate"); z.delete(a) } function L(a, b, c) {
                            c = s[0].body; var h = J(f), k = a === c || "HTML" === a.nodeName, d = a === h, g = !1, e = ga.get(a),
                                p; for ((a = A.data(a, "$ngAnimatePin")) && (b = J(a)); b;) { d || (d = b === h); if (1 !== b.nodeType) break; a = z.get(b) || {}; if (!g) { var H = ga.get(b); if (!0 === H && !1 !== e) { e = !0; break } else !1 === H && (e = !1); g = a.structural } if (P(p) || !0 === p) a = A.data(b, "$$ngAnimateChildren"), ya(a) && (p = a); if (g && !1 === p) break; k || (k = b === c); if (k && d) break; if (!d && (a = A.data(b, "$ngAnimatePin"))) { b = J(a); continue } b = b.parentNode } return (!g || p) && !0 !== e && d && k
                        } function F(a, b, c) { c = c || {}; c.state = b; a.setAttribute("data-ng-animate", b); c = (b = z.get(a)) ? va(b, c) : c; z.set(a, c) }
                        var z = new y, ga = new y, h = null, p = c.$watch(function () { return 0 === v.totalPendingRequests }, function (a) { a && (p(), c.$$postDigest(function () { c.$$postDigest(function () { null === h && (h = !0) }) })) }), k = Object.create(null); y = a.customFilter(); var na = a.classNameFilter(); g = function () { return !0 }; var Ya = y || g, D = na ? function (a, b) { var c = [a.getAttribute("class"), b.addClass, b.removeClass].join(" "); return na.test(c) } : g, Oa = X(E), u = S.Node.prototype.contains || function (a) { return this === a || !!(this.compareDocumentPosition(a) & 16) }, ba = {
                            on: function (a,
                                b, c) { var h = ua(b); k[a] = k[a] || []; k[a].push({ node: h, callback: c }); A(b).on("$destroy", function () { z.get(h) || ba.off(a, b, c) }) }, off: function (a, b, c) { if (1 !== arguments.length || C(arguments[0])) { var h = k[a]; h && (k[a] = 1 === arguments.length ? null : I(h, b, c)) } else for (h in b = arguments[0], k) k[h] = I(k[h], b) }, pin: function (a, b) { Ea(Z(a), "element", "not an element"); Ea(Z(b), "parentElement", "not an element"); a.data("$ngAnimatePin", b) }, push: function (a, b, c, h) { c = c || {}; c.domOperation = h; return K(a, b, c) }, enabled: function (a, b) {
                                    var c = arguments.length;
                                    if (0 === c) b = !!h; else if (Z(a)) { var k = J(a); 1 === c ? b = !ga.get(k) : ga.set(k, !b) } else b = h = !!a; return b
                                }
                        }; return ba
                    }]
                }]).provider("$$animation", ["$animateProvider", function (a) {
                    var b = this.drivers = []; this.$get = ["$$jqLite", "$rootScope", "$injector", "$$AnimateRunner", "$$Map", "$$rAFScheduler", function (a, d, e, f, n, G) {
                        function l(a) {
                            function b(a) {
                                if (a.processed) return a; a.processed = !0; var d = a.domNode, e = d.parentNode; g.set(d, a); for (var f; e;) { if (f = g.get(e)) { f.processed || (f = b(f)); break } e = e.parentNode } (f || c).children.push(a);
                                return a
                            } var c = { children: [] }, d, g = new n; for (d = 0; d < a.length; d++) { var e = a[d]; g.set(e.domNode, a[d] = { domNode: e.domNode, fn: e.fn, children: [] }) } for (d = 0; d < a.length; d++)b(a[d]); return function (a) { var b = [], c = [], d; for (d = 0; d < a.children.length; d++)c.push(a.children[d]); a = c.length; var g = 0, e = []; for (d = 0; d < c.length; d++) { var f = c[d]; 0 >= a && (a = g, g = 0, b.push(e), e = []); e.push(f.fn); f.children.forEach(function (a) { g++; c.push(a) }); a-- } e.length && b.push(e); return b }(c)
                        } var s = [], y = X(a); return function (n, q, v) {
                            function E(a) {
                                a = a.hasAttribute("ng-animate-ref") ?
                                    [a] : a.querySelectorAll("[ng-animate-ref]"); var b = []; t(a, function (a) { var c = a.getAttribute("ng-animate-ref"); c && c.length && b.push(a) }); return b
                            } function g(a) {
                                var b = [], c = {}; t(a, function (a, d) { var k = J(a.element), g = 0 <= ["enter", "move"].indexOf(a.event), k = a.structural ? E(k) : []; if (k.length) { var e = g ? "to" : "from"; t(k, function (a) { var b = a.getAttribute("ng-animate-ref"); c[b] = c[b] || {}; c[b][e] = { animationID: d, element: A(a) } }) } else b.push(a) }); var d = {}, g = {}; t(c, function (c, e) {
                                    var f = c.from, p = c.to; if (f && p) {
                                        var H = a[f.animationID],
                                            z = a[p.animationID], m = f.animationID.toString(); if (!g[m]) { var l = g[m] = { structural: !0, beforeStart: function () { H.beforeStart(); z.beforeStart() }, close: function () { H.close(); z.close() }, classes: M(H.classes, z.classes), from: H, to: z, anchors: [] }; l.classes.length ? b.push(l) : (b.push(H), b.push(z)) } g[m].anchors.push({ out: f.element, "in": p.element })
                                    } else f = f ? f.animationID : p.animationID, p = f.toString(), d[p] || (d[p] = !0, b.push(a[f]))
                                }); return b
                            } function M(a, b) {
                                a = a.split(" "); b = b.split(" "); for (var c = [], d = 0; d < a.length; d++) {
                                    var g =
                                        a[d]; if ("ng-" !== g.substring(0, 3)) for (var e = 0; e < b.length; e++)if (g === b[e]) { c.push(g); break }
                                } return c.join(" ")
                            } function x(a) { for (var c = b.length - 1; 0 <= c; c--) { var d = e.get(b[c])(a); if (d) return d } } function H(a, b) { function c(a) { (a = a.data("$$animationRunner")) && a.setHost(b) } a.from && a.to ? (c(a.from.element), c(a.to.element)) : c(a.element) } function I() { var a = n.data("$$animationRunner"); !a || "leave" === q && v.$$domOperationFired || a.end() } function K(b) {
                                n.off("$destroy", I); n.removeData("$$animationRunner"); y(n, v); ha(n,
                                    v); v.domOperation(); F && a.removeClass(n, F); n.removeClass("ng-animate"); m.complete(!b)
                            } v = oa(v); var ta = 0 <= ["enter", "move", "leave"].indexOf(q), m = new f({ end: function () { K() }, cancel: function () { K(!0) } }); if (!b.length) return K(), m; n.data("$$animationRunner", m); var L = Fa(n.attr("class"), Fa(v.addClass, v.removeClass)), F = v.tempClasses; F && (L += " " + F, v.tempClasses = null); var z; ta && (z = "ng-" + q + "-prepare", a.addClass(n, z)); s.push({
                                element: n, classes: L, event: q, structural: ta, options: v, beforeStart: function () {
                                    n.addClass("ng-animate");
                                    F && a.addClass(n, F); z && (a.removeClass(n, z), z = null)
                                }, close: K
                            }); n.on("$destroy", I); if (1 < s.length) return m; d.$$postDigest(function () {
                                var a = []; t(s, function (b) { b.element.data("$$animationRunner") ? a.push(b) : b.close() }); s.length = 0; var b = g(a), c = []; t(b, function (a) {
                                    c.push({
                                        domNode: J(a.from ? a.from.element : a.element), fn: function () {
                                            a.beforeStart(); var b, c = a.close; if ((a.anchors ? a.from.element || a.to.element : a.element).data("$$animationRunner")) { var d = x(a); d && (b = d.start) } b ? (b = b(), b.done(function (a) { c(!a) }), H(a, b)) :
                                                c()
                                        }
                                    })
                                }); G(l(c))
                            }); return m
                        }
                    }]
                }]).provider("$animateCss", ["$animateProvider", function (a) {
                    var b = La(), c = La(); this.$get = ["$window", "$$jqLite", "$$AnimateRunner", "$timeout", "$$forceReflow", "$sniffer", "$$rAFScheduler", "$$animateQueue", function (a, e, f, n, G, l, s, y) {
                        function q(a, b) { var c = a.parentNode; return (c.$$ngAnimateParentKey || (c.$$ngAnimateParentKey = ++M)) + "-" + a.getAttribute("class") + "-" + b } function da(g, f, l, n) {
                            var m; 0 < b.count(l) && (m = c.get(l), m || (f = W(f, "-stagger"), e.addClass(g, f), m = Ja(a, g, n), m.animationDuration =
                                Math.max(m.animationDuration, 0), m.transitionDuration = Math.max(m.transitionDuration, 0), e.removeClass(g, f), c.put(l, m))); return m || {}
                        } function v(a) { x.push(a); s.waitUntilQuiet(function () { b.flush(); c.flush(); for (var a = G(), d = 0; d < x.length; d++)x[d](a); x.length = 0 }) } function E(c, g, e) {
                            g = b.get(e); g || (g = Ja(a, c, Wa), "infinite" === g.animationIterationCount && (g.animationIterationCount = 1)); b.put(e, g); c = g; e = c.animationDelay; g = c.transitionDelay; c.maxDelay = e && g ? Math.max(e, g) : e || g; c.maxDuration = Math.max(c.animationDuration *
                                c.animationIterationCount, c.transitionDuration); return c
                        } var g = X(e), M = 0, x = []; return function (a, c) {
                            function d() { m() } function s() { m(!0) } function m(b) {
                                if (!(M || ba && u)) {
                                    M = !0; u = !1; h.$$skipPreparationClasses || e.removeClass(a, fa); e.removeClass(a, ca); wa(k, !1); pa(k, !1); t(x, function (a) { k.style[a[0]] = "" }); g(a, h); ha(a, h); Object.keys(p).length && t(p, function (a, b) { a ? k.style.setProperty(b, a) : k.style.removeProperty(b) }); if (h.onDone) h.onDone(); ea && ea.length && a.off(ea.join(" "), z); var c = a.data("$$animateCss"); c && (n.cancel(c[0].timer),
                                        a.removeData("$$animateCss")); A && A.complete(!b)
                                }
                            } function L(a) { r.blockTransition && pa(k, a); r.blockKeyframeAnimation && wa(k, !!a) } function F() { A = new f({ end: d, cancel: s }); v(O); m(); return { $$willAnimate: !1, start: function () { return A }, end: d } } function z(a) { a.stopPropagation(); var b = a.originalEvent || a; a = b.$manualTimeStamp || Date.now(); b = parseFloat(b.elapsedTime.toFixed(3)); Math.max(a - T, 0) >= P && b >= N && (ba = !0, m()) } function ga() {
                                function b() {
                                    if (!M) {
                                        L(!1); t(x, function (a) { k.style[a[0]] = a[1] }); g(a, h); e.addClass(a, ca);
                                        if (r.recalculateTimingStyles) { ma = k.getAttribute("class") + " " + fa; ja = q(k, ma); B = E(k, ma, ja); $ = B.maxDelay; w = Math.max($, 0); N = B.maxDuration; if (0 === N) { m(); return } r.hasTransitions = 0 < B.transitionDuration; r.hasAnimations = 0 < B.animationDuration } r.applyAnimationDelay && ($ = "boolean" !== typeof h.delay && xa(h.delay) ? parseFloat(h.delay) : $, w = Math.max($, 0), B.animationDelay = $, aa = [qa, $ + "s"], x.push(aa), k.style[aa[0]] = aa[1]); P = 1E3 * w; S = 1E3 * N; if (h.easing) {
                                            var d, f = h.easing; r.hasTransitions && (d = Q + "TimingFunction", x.push([d, f]),
                                                k.style[d] = f); r.hasAnimations && (d = Y + "TimingFunction", x.push([d, f]), k.style[d] = f)
                                        } B.transitionDuration && ea.push(za); B.animationDuration && ea.push(Aa); T = Date.now(); var l = P + 1.5 * S; d = T + l; var f = a.data("$$animateCss") || [], F = !0; if (f.length) { var s = f[0]; (F = d > s.expectedEndTime) ? n.cancel(s.timer) : f.push(m) } F && (l = n(c, l, !1), f[0] = { timer: l, expectedEndTime: d }, f.push(m), a.data("$$animateCss", f)); if (ea.length) a.on(ea.join(" "), z); h.to && (h.cleanupStyles && Ma(p, k, Object.keys(h.to)), Ia(a, h))
                                    }
                                } function c() {
                                    var b = a.data("$$animateCss");
                                    if (b) { for (var d = 1; d < b.length; d++)b[d](); a.removeData("$$animateCss") }
                                } if (!M) if (k.parentNode) { var d = function (a) { if (ba) u && a && (u = !1, m()); else if (u = !a, B.animationDuration) if (a = wa(k, u), u) x.push(a); else { var b = x, c = b.indexOf(a); 0 <= a && b.splice(c, 1) } }, f = 0 < Z && (B.transitionDuration && 0 === U.transitionDuration || B.animationDuration && 0 === U.animationDuration) && Math.max(U.animationDelay, U.transitionDelay); f ? n(b, Math.floor(f * Z * 1E3), !1) : b(); C.resume = function () { d(!0) }; C.pause = function () { d(!1) } } else m()
                            } var h = c || {}; h.$$prepared ||
                                (h = oa(Ca(h))); var p = {}, k = J(a); if (!k || !k.parentNode || !y.enabled()) return F(); var x = [], G = a.attr("class"), D = Qa(h), M, u, ba, A, C, w, P, N, S, T, ea = []; if (0 === h.duration || !l.animations && !l.transitions) return F(); var ia = h.event && V(h.event) ? h.event.join(" ") : h.event, X = "", R = ""; ia && h.structural ? X = W(ia, "ng-", !0) : ia && (X = ia); h.addClass && (R += W(h.addClass, "-add")); h.removeClass && (R.length && (R += " "), R += W(h.removeClass, "-remove")); h.applyClassesEarly && R.length && g(a, h); var fa = [X, R].join(" ").trim(), ma = G + " " + fa, ca = W(fa, "-active"),
                                    G = D.to && 0 < Object.keys(D.to).length; if (!(0 < (h.keyframeStyle || "").length || G || fa)) return F(); var ja, U; 0 < h.stagger ? (D = parseFloat(h.stagger), U = { transitionDelay: D, animationDelay: D, transitionDuration: 0, animationDuration: 0 }) : (ja = q(k, ma), U = da(k, fa, ja, Xa)); h.$$skipPreparationClasses || e.addClass(a, fa); h.transitionStyle && (D = [Q, h.transitionStyle], ka(k, D), x.push(D)); 0 <= h.duration && (D = 0 < k.style[Q].length, D = Ka(h.duration, D), ka(k, D), x.push(D)); h.keyframeStyle && (D = [Y, h.keyframeStyle], ka(k, D), x.push(D)); var Z = U ? 0 <=
                                        h.staggerIndex ? h.staggerIndex : b.count(ja) : 0; (ia = 0 === Z) && !h.skipBlocking && pa(k, 9999); var B = E(k, ma, ja), $ = B.maxDelay; w = Math.max($, 0); N = B.maxDuration; var r = {}; r.hasTransitions = 0 < B.transitionDuration; r.hasAnimations = 0 < B.animationDuration; r.hasTransitionAll = r.hasTransitions && "all" === B.transitionProperty; r.applyTransitionDuration = G && (r.hasTransitions && !r.hasTransitionAll || r.hasAnimations && !r.hasTransitions); r.applyAnimationDuration = h.duration && r.hasAnimations; r.applyTransitionDelay = xa(h.delay) && (r.applyTransitionDuration ||
                                            r.hasTransitions); r.applyAnimationDelay = xa(h.delay) && r.hasAnimations; r.recalculateTimingStyles = 0 < R.length; if (r.applyTransitionDuration || r.applyAnimationDuration) N = h.duration ? parseFloat(h.duration) : N, r.applyTransitionDuration && (r.hasTransitions = !0, B.transitionDuration = N, D = 0 < k.style[Q + "Property"].length, x.push(Ka(N, D))), r.applyAnimationDuration && (r.hasAnimations = !0, B.animationDuration = N, x.push([Ba, N + "s"])); if (0 === N && !r.recalculateTimingStyles) return F(); if (null != h.delay) {
                                                var aa; "boolean" !== typeof h.delay &&
                                                    (aa = parseFloat(h.delay), w = Math.max(aa, 0)); r.applyTransitionDelay && x.push([la, aa + "s"]); r.applyAnimationDelay && x.push([qa, aa + "s"])
                                            } null == h.duration && 0 < B.transitionDuration && (r.recalculateTimingStyles = r.recalculateTimingStyles || ia); P = 1E3 * w; S = 1E3 * N; h.skipBlocking || (r.blockTransition = 0 < B.transitionDuration, r.blockKeyframeAnimation = 0 < B.animationDuration && 0 < U.animationDelay && 0 === U.animationDuration); h.from && (h.cleanupStyles && Ma(p, k, Object.keys(h.from)), Ha(a, h)); r.blockTransition || r.blockKeyframeAnimation ?
                                                L(N) : h.skipBlocking || pa(k, !1); return { $$willAnimate: !0, end: d, start: function () { if (!M) return C = { end: d, cancel: s, resume: null, pause: null }, A = new f(C), v(ga), A } }
                        }
                    }]
                }]).provider("$$animateCssDriver", ["$$animationProvider", function (a) {
                    a.drivers.push("$$animateCssDriver"); this.$get = ["$animateCss", "$rootScope", "$$AnimateRunner", "$rootElement", "$sniffer", "$$jqLite", "$document", function (a, c, d, e, f, n, G) {
                        function l(a) { return a.replace(/\bng-\S+\b/g, "") } function s(a, b) {
                            C(a) && (a = a.split(" ")); C(b) && (b = b.split(" "));
                            return a.filter(function (a) { return -1 === b.indexOf(a) }).join(" ")
                        } function y(c, f, e) {
                            function n(a) { var b = {}, c = J(a).getBoundingClientRect(); t(["width", "height", "top", "left"], function (a) { var d = c[a]; switch (a) { case "top": d += v.scrollTop; break; case "left": d += v.scrollLeft }b[a] = Math.floor(d) + "px" }); return b } function G() { var c = l(e.attr("class") || ""), d = s(c, m), c = s(m, c), d = a(y, { to: n(e), addClass: "ng-anchor-in " + d, removeClass: "ng-anchor-out " + c, delay: !0 }); return d.$$willAnimate ? d : null } function q() {
                                y.remove(); f.removeClass("ng-animate-shim");
                                e.removeClass("ng-animate-shim")
                            } var y = A(J(f).cloneNode(!0)), m = l(y.attr("class") || ""); f.addClass("ng-animate-shim"); e.addClass("ng-animate-shim"); y.addClass("ng-anchor"); E.append(y); var L; c = function () { var c = a(y, { addClass: "ng-anchor-out", delay: !0, from: n(f) }); return c.$$willAnimate ? c : null }(); if (!c && (L = G(), !L)) return q(); var F = c || L; return {
                                start: function () {
                                    function a() { c && c.end() } var b, c = F.start(); c.done(function () {
                                        c = null; if (!L && (L = G())) return c = L.start(), c.done(function () { c = null; q(); b.complete() }), c;
                                        q(); b.complete()
                                    }); return b = new d({ end: a, cancel: a })
                                }
                            }
                        } function q(a, b, c, f) { var e = da(a, O), l = da(b, O), n = []; t(f, function (a) { (a = y(c, a.out, a["in"])) && n.push(a) }); if (e || l || 0 !== n.length) return { start: function () { function a() { t(b, function (a) { a.end() }) } var b = []; e && b.push(e.start()); l && b.push(l.start()); t(n, function (a) { b.push(a.start()) }); var c = new d({ end: a, cancel: a }); d.all(b, function (a) { c.complete(a) }); return c } } } function da(c) {
                            var d = c.element, e = c.options || {}; c.structural && (e.event = c.event, e.structural = !0, e.applyClassesEarly =
                                !0, "leave" === c.event && (e.onDone = e.domOperation)); e.preparationClasses && (e.event = ca(e.event, e.preparationClasses)); c = a(d, e); return c.$$willAnimate ? c : null
                        } if (!f.animations && !f.transitions) return O; var v = G[0].body; c = J(e); var E = A(c.parentNode && 11 === c.parentNode.nodeType || v.contains(c) ? c : v); return function (a) { return a.from && a.to ? q(a.from, a.to, a.classes, a.anchors) : da(a) }
                    }]
                }]).provider("$$animateJs", ["$animateProvider", function (a) {
                    this.$get = ["$injector", "$$AnimateRunner", "$$jqLite", function (b, c, d) {
                        function e(c) {
                            c =
                                V(c) ? c : c.split(" "); for (var d = [], e = {}, f = 0; f < c.length; f++) { var y = c[f], q = a.$$registeredAnimations[y]; q && !e[y] && (d.push(b.get(q)), e[y] = !0) } return d
                        } var f = X(d); return function (a, b, d, s) {
                            function q() { s.domOperation(); f(a, s) } function A(a, b, d, e, f) {
                                switch (d) { case "animate": b = [b, e.from, e.to, f]; break; case "setClass": b = [b, g, M, f]; break; case "addClass": b = [b, g, f]; break; case "removeClass": b = [b, M, f]; break; default: b = [b, f] }b.push(e); if (a = a.apply(a, b)) if (Da(a.start) && (a = a.start()), a instanceof c) a.done(f); else if (Da(a)) return a;
                                return O
                            } function C(a, b, d, e, f) { var g = []; t(e, function (e) { var l = e[f]; l && g.push(function () { var e, f, h = !1, g = function (a) { h || (h = !0, (f || O)(a), e.complete(!a)) }; e = new c({ end: function () { g() }, cancel: function () { g(!0) } }); f = A(l, a, b, d, function (a) { g(!1 === a) }); return e }) }); return g } function v(a, b, d, e, f) {
                                var g = C(a, b, d, e, f); if (0 === g.length) {
                                    var k, l; "beforeSetClass" === f ? (k = C(a, "removeClass", d, e, "beforeRemoveClass"), l = C(a, "addClass", d, e, "beforeAddClass")) : "setClass" === f && (k = C(a, "removeClass", d, e, "removeClass"), l = C(a, "addClass",
                                        d, e, "addClass")); k && (g = g.concat(k)); l && (g = g.concat(l))
                                } if (0 !== g.length) return function (a) { var b = []; g.length && t(g, function (a) { b.push(a()) }); b.length ? c.all(b, a) : a(); return function (a) { t(b, function (b) { a ? b.cancel() : b.end() }) } }
                            } var E = !1; 3 === arguments.length && ra(d) && (s = d, d = null); s = oa(s); d || (d = a.attr("class") || "", s.addClass && (d += " " + s.addClass), s.removeClass && (d += " " + s.removeClass)); var g = s.addClass, M = s.removeClass, x = e(d), H, I; if (x.length) {
                                var K, J; "leave" === b ? (J = "leave", K = "afterLeave") : (J = "before" + b.charAt(0).toUpperCase() +
                                    b.substr(1), K = b); "enter" !== b && "move" !== b && (H = v(a, b, s, x, J)); I = v(a, b, s, x, K)
                            } if (H || I) {
                                var m; return {
                                    $$willAnimate: !0, end: function () { m ? m.end() : (E = !0, q(), ha(a, s), m = new c, m.complete(!0)); return m }, start: function () {
                                        function b(c) { E = !0; q(); ha(a, s); m.complete(c) } if (m) return m; m = new c; var d, e = []; H && e.push(function (a) { d = H(a) }); e.length ? e.push(function (a) { q(); a(!0) }) : q(); I && e.push(function (a) { d = I(a) }); m.setHost({ end: function () { E || ((d || O)(void 0), b(void 0)) }, cancel: function () { E || ((d || O)(!0), b(!0)) } }); c.chain(e,
                                            b); return m
                                    }
                                }
                            }
                        }
                    }]
                }]).provider("$$animateJsDriver", ["$$animationProvider", function (a) {
                    a.drivers.push("$$animateJsDriver"); this.$get = ["$$animateJs", "$$AnimateRunner", function (a, c) {
                        function d(c) { return a(c.element, c.event, c.classes, c.options) } return function (a) {
                            if (a.from && a.to) {
                                var b = d(a.from), n = d(a.to); if (b || n) return {
                                    start: function () {
                                        function a() { return function () { t(d, function (a) { a.end() }) } } var d = []; b && d.push(b.start()); n && d.push(n.start()); c.all(d, function (a) { e.complete(a) }); var e = new c({ end: a(), cancel: a() });
                                        return e
                                    }
                                }
                            } else return d(a)
                        }
                    }]
                }])
})(window, window.angular);
//# sourceMappingURL=angular-animate.min.js.map

/**
 * @license AngularJS v1.6.6
 * (c) 2010-2017 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function (window, angular) {
    'use strict';

    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     *     Any commits to this file should be reviewed with security in mind.  *
     *   Changes to this file can potentially create security vulnerabilities. *
     *          An approval from 2 Core members with history of modifying      *
     *                         this file is required.                          *
     *                                                                         *
     *  Does the change somehow allow for arbitrary javascript to be executed? *
     *    Or allows for someone to change the prototype of built-in objects?   *
     *     Or gives undesired access to variables likes document or window?    *
     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

    var $sanitizeMinErr = angular.$$minErr('$sanitize');
    var bind;
    var extend;
    var forEach;
    var isDefined;
    var lowercase;
    var noop;
    var nodeContains;
    var htmlParser;
    var htmlSanitizeWriter;

    /**
     * @ngdoc module
     * @name ngSanitize
     * @description
     *
     * # ngSanitize
     *
     * The `ngSanitize` module provides functionality to sanitize HTML.
     *
     *
     * <div doc-module-components="ngSanitize"></div>
     *
     * See {@link ngSanitize.$sanitize `$sanitize`} for usage.
     */

    /**
     * @ngdoc service
     * @name $sanitize
     * @kind function
     *
     * @description
     *   Sanitizes an html string by stripping all potentially dangerous tokens.
     *
     *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are
     *   then serialized back to properly escaped html string. This means that no unsafe input can make
     *   it into the returned string.
     *
     *   The whitelist for URL sanitization of attribute values is configured using the functions
     *   `aHrefSanitizationWhitelist` and `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider
     *   `$compileProvider`}.
     *
     *   The input may also contain SVG markup if this is enabled via {@link $sanitizeProvider}.
     *
     * @param {string} html HTML input.
     * @returns {string} Sanitized HTML.
     *
     * @example
       <example module="sanitizeExample" deps="angular-sanitize.js" name="sanitize-service">
       <file name="index.html">
         <script>
             angular.module('sanitizeExample', ['ngSanitize'])
               .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {
                 $scope.snippet =
                   '<p style="color:blue">an html\n' +
                   '<em onmouseover="this.textContent=\'PWN3D!\'">click here</em>\n' +
                   'snippet</p>';
                 $scope.deliberatelyTrustDangerousSnippet = function() {
                   return $sce.trustAsHtml($scope.snippet);
                 };
               }]);
         </script>
         <div ng-controller="ExampleController">
            Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
           <table>
             <tr>
               <td>Directive</td>
               <td>How</td>
               <td>Source</td>
               <td>Rendered</td>
             </tr>
             <tr id="bind-html-with-sanitize">
               <td>ng-bind-html</td>
               <td>Automatically uses $sanitize</td>
               <td><pre>&lt;div ng-bind-html="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
               <td><div ng-bind-html="snippet"></div></td>
             </tr>
             <tr id="bind-html-with-trust">
               <td>ng-bind-html</td>
               <td>Bypass $sanitize by explicitly trusting the dangerous value</td>
               <td>
               <pre>&lt;div ng-bind-html="deliberatelyTrustDangerousSnippet()"&gt;
    &lt;/div&gt;</pre>
               </td>
               <td><div ng-bind-html="deliberatelyTrustDangerousSnippet()"></div></td>
             </tr>
             <tr id="bind-default">
               <td>ng-bind</td>
               <td>Automatically escapes</td>
               <td><pre>&lt;div ng-bind="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
               <td><div ng-bind="snippet"></div></td>
             </tr>
           </table>
           </div>
       </file>
       <file name="protractor.js" type="protractor">
         it('should sanitize the html snippet by default', function() {
           expect(element(by.css('#bind-html-with-sanitize div')).getAttribute('innerHTML')).
             toBe('<p>an html\n<em>click here</em>\nsnippet</p>');
         });
    
         it('should inline raw snippet if bound to a trusted value', function() {
           expect(element(by.css('#bind-html-with-trust div')).getAttribute('innerHTML')).
             toBe("<p style=\"color:blue\">an html\n" +
                  "<em onmouseover=\"this.textContent='PWN3D!'\">click here</em>\n" +
                  "snippet</p>");
         });
    
         it('should escape snippet without any filter', function() {
           expect(element(by.css('#bind-default div')).getAttribute('innerHTML')).
             toBe("&lt;p style=\"color:blue\"&gt;an html\n" +
                  "&lt;em onmouseover=\"this.textContent='PWN3D!'\"&gt;click here&lt;/em&gt;\n" +
                  "snippet&lt;/p&gt;");
         });
    
         it('should update', function() {
           element(by.model('snippet')).clear();
           element(by.model('snippet')).sendKeys('new <b onclick="alert(1)">text</b>');
           expect(element(by.css('#bind-html-with-sanitize div')).getAttribute('innerHTML')).
             toBe('new <b>text</b>');
           expect(element(by.css('#bind-html-with-trust div')).getAttribute('innerHTML')).toBe(
             'new <b onclick="alert(1)">text</b>');
           expect(element(by.css('#bind-default div')).getAttribute('innerHTML')).toBe(
             "new &lt;b onclick=\"alert(1)\"&gt;text&lt;/b&gt;");
         });
       </file>
       </example>
     */


    /**
     * @ngdoc provider
     * @name $sanitizeProvider
     * @this
     *
     * @description
     * Creates and configures {@link $sanitize} instance.
     */
    function $SanitizeProvider() {
        var svgEnabled = false;

        this.$get = ['$$sanitizeUri', function ($$sanitizeUri) {
            if (svgEnabled) {
                extend(validElements, svgElements);
            }
            return function (html) {
                var buf = [];
                htmlParser(html, htmlSanitizeWriter(buf, function (uri, isImage) {
                    return !/^unsafe:/.test($$sanitizeUri(uri, isImage));
                }));
                return buf.join('');
            };
        }];


        /**
         * @ngdoc method
         * @name $sanitizeProvider#enableSvg
         * @kind function
         *
         * @description
         * Enables a subset of svg to be supported by the sanitizer.
         *
         * <div class="alert alert-warning">
         *   <p>By enabling this setting without taking other precautions, you might expose your
         *   application to click-hijacking attacks. In these attacks, sanitized svg elements could be positioned
         *   outside of the containing element and be rendered over other elements on the page (e.g. a login
         *   link). Such behavior can then result in phishing incidents.</p>
         *
         *   <p>To protect against these, explicitly setup `overflow: hidden` css rule for all potential svg
         *   tags within the sanitized content:</p>
         *
         *   <br>
         *
         *   <pre><code>
         *   .rootOfTheIncludedContent svg {
         *     overflow: hidden !important;
         *   }
         *   </code></pre>
         * </div>
         *
         * @param {boolean=} flag Enable or disable SVG support in the sanitizer.
         * @returns {boolean|ng.$sanitizeProvider} Returns the currently configured value if called
         *    without an argument or self for chaining otherwise.
         */
        this.enableSvg = function (enableSvg) {
            if (isDefined(enableSvg)) {
                svgEnabled = enableSvg;
                return this;
            } else {
                return svgEnabled;
            }
        };

        //////////////////////////////////////////////////////////////////////////////////////////////////
        // Private stuff
        //////////////////////////////////////////////////////////////////////////////////////////////////

        bind = angular.bind;
        extend = angular.extend;
        forEach = angular.forEach;
        isDefined = angular.isDefined;
        lowercase = angular.lowercase;
        noop = angular.noop;

        htmlParser = htmlParserImpl;
        htmlSanitizeWriter = htmlSanitizeWriterImpl;

        nodeContains = window.Node.prototype.contains || /** @this */ function (arg) {
            // eslint-disable-next-line no-bitwise
            return !!(this.compareDocumentPosition(arg) & 16);
        };

        // Regular Expressions for parsing tags and attributes
        var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
            // Match everything outside of normal chars and " (quote character)
            NON_ALPHANUMERIC_REGEXP = /([^#-~ |!])/g;


        // Good source of info about elements and attributes
        // http://dev.w3.org/html5/spec/Overview.html#semantics
        // http://simon.html5.org/html-elements

        // Safe Void Elements - HTML5
        // http://dev.w3.org/html5/spec/Overview.html#void-elements
        var voidElements = toMap('area,br,col,hr,img,wbr');

        // Elements that you can, intentionally, leave open (and which close themselves)
        // http://dev.w3.org/html5/spec/Overview.html#optional-tags
        var optionalEndTagBlockElements = toMap('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr'),
            optionalEndTagInlineElements = toMap('rp,rt'),
            optionalEndTagElements = extend({},
                optionalEndTagInlineElements,
                optionalEndTagBlockElements);

        // Safe Block Elements - HTML5
        var blockElements = extend({}, optionalEndTagBlockElements, toMap('address,article,' +
            'aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +
            'h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul'));

        // Inline Elements - HTML5
        var inlineElements = extend({}, optionalEndTagInlineElements, toMap('a,abbr,acronym,b,' +
            'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,' +
            'samp,small,span,strike,strong,sub,sup,time,tt,u,var'));

        // SVG Elements
        // https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements
        // Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.
        // They can potentially allow for arbitrary javascript to be executed. See #11290
        var svgElements = toMap('circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,' +
            'hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,' +
            'radialGradient,rect,stop,svg,switch,text,title,tspan');

        // Blocked Elements (will be stripped)
        var blockedElements = toMap('script,style');

        var validElements = extend({},
            voidElements,
            blockElements,
            inlineElements,
            optionalEndTagElements);

        //Attributes that have href and hence need to be sanitized
        var uriAttrs = toMap('background,cite,href,longdesc,src,xlink:href');

        var htmlAttrs = toMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +
            'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +
            'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +
            'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +
            'valign,value,vspace,width');

        // SVG attributes (without "id" and "name" attributes)
        // https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes
        var svgAttrs = toMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +
            'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +
            'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +
            'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +
            'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +
            'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +
            'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +
            'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +
            'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +
            'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +
            'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +
            'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +
            'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +
            'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +
            'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);

        var validAttrs = extend({},
            uriAttrs,
            svgAttrs,
            htmlAttrs);

        function toMap(str, lowercaseKeys) {
            var obj = {}, items = str.split(','), i;
            for (i = 0; i < items.length; i++) {
                obj[lowercaseKeys ? lowercase(items[i]) : items[i]] = true;
            }
            return obj;
        }

        /**
         * Create an inert document that contains the dirty HTML that needs sanitizing
         * Depending upon browser support we use one of three strategies for doing this.
         * Support: Safari 10.x -> XHR strategy
         * Support: Firefox -> DomParser strategy
         */
        var getInertBodyElement /* function(html: string): HTMLBodyElement */ = (function (window, document) {
            var inertDocument;
            if (document && document.implementation) {
                inertDocument = document.implementation.createHTMLDocument('inert');
            } else {
                throw $sanitizeMinErr('noinert', 'Can\'t create an inert html document');
            }
            var inertBodyElement = (inertDocument.documentElement || inertDocument.getDocumentElement()).querySelector('body');

            // Check for the Safari 10.1 bug - which allows JS to run inside the SVG G element
            inertBodyElement.innerHTML = '<svg><g onload="this.parentNode.remove()"></g></svg>';
            if (!inertBodyElement.querySelector('svg')) {
                return getInertBodyElement_XHR;
            } else {
                // Check for the Firefox bug - which prevents the inner img JS from being sanitized
                inertBodyElement.innerHTML = '<svg><p><style><img src="</style><img src=x onerror=alert(1)//">';
                if (inertBodyElement.querySelector('svg img')) {
                    return getInertBodyElement_DOMParser;
                } else {
                    return getInertBodyElement_InertDocument;
                }
            }

            function getInertBodyElement_XHR(html) {
                // We add this dummy element to ensure that the rest of the content is parsed as expected
                // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the `<head>` tag.
                html = '<remove></remove>' + html;
                try {
                    html = encodeURI(html);
                } catch (e) {
                    return undefined;
                }
                var xhr = new window.XMLHttpRequest();
                xhr.responseType = 'document';
                xhr.open('GET', 'data:text/html;charset=utf-8,' + html, false);
                xhr.send(null);
                var body = xhr.response.body;
                body.firstChild.remove();
                return body;
            }

            function getInertBodyElement_DOMParser(html) {
                // We add this dummy element to ensure that the rest of the content is parsed as expected
                // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the `<head>` tag.
                html = '<remove></remove>' + html;
                try {
                    var body = new window.DOMParser().parseFromString(html, 'text/html').body;
                    body.firstChild.remove();
                    return body;
                } catch (e) {
                    return undefined;
                }
            }

            function getInertBodyElement_InertDocument(html) {
                inertBodyElement.innerHTML = html;

                // Support: IE 9-11 only
                // strip custom-namespaced attributes on IE<=11
                if (document.documentMode) {
                    stripCustomNsAttrs(inertBodyElement);
                }

                return inertBodyElement;
            }
        })(window, window.document);

        /**
         * @example
         * htmlParser(htmlString, {
         *     start: function(tag, attrs) {},
         *     end: function(tag) {},
         *     chars: function(text) {},
         *     comment: function(text) {}
         * });
         *
         * @param {string} html string
         * @param {object} handler
         */
        function htmlParserImpl(html, handler) {
            if (html === null || html === undefined) {
                html = '';
            } else if (typeof html !== 'string') {
                html = '' + html;
            }

            var inertBodyElement = getInertBodyElement(html);
            if (!inertBodyElement) return '';

            //mXSS protection
            var mXSSAttempts = 5;
            do {
                if (mXSSAttempts === 0) {
                    throw $sanitizeMinErr('uinput', 'Failed to sanitize html because the input is unstable');
                }
                mXSSAttempts--;

                // trigger mXSS if it is going to happen by reading and writing the innerHTML
                html = inertBodyElement.innerHTML;
                inertBodyElement = getInertBodyElement(html);
            } while (html !== inertBodyElement.innerHTML);

            var node = inertBodyElement.firstChild;
            while (node) {
                switch (node.nodeType) {
                    case 1: // ELEMENT_NODE
                        handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));
                        break;
                    case 3: // TEXT NODE
                        handler.chars(node.textContent);
                        break;
                }

                var nextNode;
                if (!(nextNode = node.firstChild)) {
                    if (node.nodeType === 1) {
                        handler.end(node.nodeName.toLowerCase());
                    }
                    nextNode = getNonDescendant('nextSibling', node);
                    if (!nextNode) {
                        while (nextNode == null) {
                            node = getNonDescendant('parentNode', node);
                            if (node === inertBodyElement) break;
                            nextNode = getNonDescendant('nextSibling', node);
                            if (node.nodeType === 1) {
                                handler.end(node.nodeName.toLowerCase());
                            }
                        }
                    }
                }
                node = nextNode;
            }

            while ((node = inertBodyElement.firstChild)) {
                inertBodyElement.removeChild(node);
            }
        }

        function attrToMap(attrs) {
            var map = {};
            for (var i = 0, ii = attrs.length; i < ii; i++) {
                var attr = attrs[i];
                map[attr.name] = attr.value;
            }
            return map;
        }


        /**
         * Escapes all potentially dangerous characters, so that the
         * resulting string can be safely inserted into attribute or
         * element text.
         * @param value
         * @returns {string} escaped text
         */
        function encodeEntities(value) {
            return value.
                replace(/&/g, '&amp;').
                replace(SURROGATE_PAIR_REGEXP, function (value) {
                    var hi = value.charCodeAt(0);
                    var low = value.charCodeAt(1);
                    return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
                }).
                replace(NON_ALPHANUMERIC_REGEXP, function (value) {
                    return '&#' + value.charCodeAt(0) + ';';
                }).
                replace(/</g, '&lt;').
                replace(/>/g, '&gt;');
        }

        /**
         * create an HTML/XML writer which writes to buffer
         * @param {Array} buf use buf.join('') to get out sanitized html string
         * @returns {object} in the form of {
         *     start: function(tag, attrs) {},
         *     end: function(tag) {},
         *     chars: function(text) {},
         *     comment: function(text) {}
         * }
         */
        function htmlSanitizeWriterImpl(buf, uriValidator) {
            var ignoreCurrentElement = false;
            var out = bind(buf, buf.push);
            return {
                start: function (tag, attrs) {
                    tag = lowercase(tag);
                    if (!ignoreCurrentElement && blockedElements[tag]) {
                        ignoreCurrentElement = tag;
                    }
                    if (!ignoreCurrentElement && validElements[tag] === true) {
                        out('<');
                        out(tag);
                        forEach(attrs, function (value, key) {
                            var lkey = lowercase(key);
                            var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
                            if (validAttrs[lkey] === true &&
                                (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                                out(' ');
                                out(key);
                                out('="');
                                out(encodeEntities(value));
                                out('"');
                            }
                        });
                        out('>');
                    }
                },
                end: function (tag) {
                    tag = lowercase(tag);
                    if (!ignoreCurrentElement && validElements[tag] === true && voidElements[tag] !== true) {
                        out('</');
                        out(tag);
                        out('>');
                    }
                    // eslint-disable-next-line eqeqeq
                    if (tag == ignoreCurrentElement) {
                        ignoreCurrentElement = false;
                    }
                },
                chars: function (chars) {
                    if (!ignoreCurrentElement) {
                        out(encodeEntities(chars));
                    }
                }
            };
        }


        /**
         * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1' attribute to declare
         * ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo'). This is undesirable since we don't want
         * to allow any of these custom attributes. This method strips them all.
         *
         * @param node Root element to process
         */
        function stripCustomNsAttrs(node) {
            while (node) {
                if (node.nodeType === window.Node.ELEMENT_NODE) {
                    var attrs = node.attributes;
                    for (var i = 0, l = attrs.length; i < l; i++) {
                        var attrNode = attrs[i];
                        var attrName = attrNode.name.toLowerCase();
                        if (attrName === 'xmlns:ns1' || attrName.lastIndexOf('ns1:', 0) === 0) {
                            node.removeAttributeNode(attrNode);
                            i--;
                            l--;
                        }
                    }
                }

                var nextNode = node.firstChild;
                if (nextNode) {
                    stripCustomNsAttrs(nextNode);
                }

                node = getNonDescendant('nextSibling', node);
            }
        }

        function getNonDescendant(propName, node) {
            // An element is clobbered if its `propName` property points to one of its descendants
            var nextNode = node[propName];
            if (nextNode && nodeContains.call(node, nextNode)) {
                throw $sanitizeMinErr('elclob', 'Failed to sanitize html because the element is clobbered: {0}', node.outerHTML || node.outerText);
            }
            return nextNode;
        }
    }

    function sanitizeText(chars) {
        var buf = [];
        var writer = htmlSanitizeWriter(buf, noop);
        writer.chars(chars);
        return buf.join('');
    }


    // define ngSanitize module and register $sanitize service
    angular.module('ngSanitize', [])
        .provider('$sanitize', $SanitizeProvider)
        .info({ angularVersion: '1.6.6' });

    /**
     * @ngdoc filter
     * @name linky
     * @kind function
     *
     * @description
     * Finds links in text input and turns them into html links. Supports `http/https/ftp/mailto` and
     * plain email address links.
     *
     * Requires the {@link ngSanitize `ngSanitize`} module to be installed.
     *
     * @param {string} text Input text.
     * @param {string} target Window (`_blank|_self|_parent|_top`) or named frame to open links in.
     * @param {object|function(url)} [attributes] Add custom attributes to the link element.
     *
     *    Can be one of:
     *
     *    - `object`: A map of attributes
     *    - `function`: Takes the url as a parameter and returns a map of attributes
     *
     *    If the map of attributes contains a value for `target`, it overrides the value of
     *    the target parameter.
     *
     *
     * @returns {string} Html-linkified and {@link $sanitize sanitized} text.
     *
     * @usage
       <span ng-bind-html="linky_expression | linky"></span>
     *
     * @example
       <example module="linkyExample" deps="angular-sanitize.js" name="linky-filter">
         <file name="index.html">
           <div ng-controller="ExampleController">
           Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
           <table>
             <tr>
               <th>Filter</th>
               <th>Source</th>
               <th>Rendered</th>
             </tr>
             <tr id="linky-filter">
               <td>linky filter</td>
               <td>
                 <pre>&lt;div ng-bind-html="snippet | linky"&gt;<br>&lt;/div&gt;</pre>
               </td>
               <td>
                 <div ng-bind-html="snippet | linky"></div>
               </td>
             </tr>
             <tr id="linky-target">
              <td>linky target</td>
              <td>
                <pre>&lt;div ng-bind-html="snippetWithSingleURL | linky:'_blank'"&gt;<br>&lt;/div&gt;</pre>
              </td>
              <td>
                <div ng-bind-html="snippetWithSingleURL | linky:'_blank'"></div>
              </td>
             </tr>
             <tr id="linky-custom-attributes">
              <td>linky custom attributes</td>
              <td>
                <pre>&lt;div ng-bind-html="snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}"&gt;<br>&lt;/div&gt;</pre>
              </td>
              <td>
                <div ng-bind-html="snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}"></div>
              </td>
             </tr>
             <tr id="escaped-html">
               <td>no filter</td>
               <td><pre>&lt;div ng-bind="snippet"&gt;<br>&lt;/div&gt;</pre></td>
               <td><div ng-bind="snippet"></div></td>
             </tr>
           </table>
         </file>
         <file name="script.js">
           angular.module('linkyExample', ['ngSanitize'])
             .controller('ExampleController', ['$scope', function($scope) {
               $scope.snippet =
                 'Pretty text with some links:\n' +
                 'http://angularjs.org/,\n' +
                 'mailto:us@somewhere.org,\n' +
                 'another@somewhere.org,\n' +
                 'and one more: ftp://127.0.0.1/.';
               $scope.snippetWithSingleURL = 'http://angularjs.org/';
             }]);
         </file>
         <file name="protractor.js" type="protractor">
           it('should linkify the snippet with urls', function() {
             expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
                 toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +
                      'another@somewhere.org, and one more: ftp://127.0.0.1/.');
             expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);
           });
    
           it('should not linkify snippet without the linky filter', function() {
             expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).
                 toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +
                      'another@somewhere.org, and one more: ftp://127.0.0.1/.');
             expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);
           });
    
           it('should update', function() {
             element(by.model('snippet')).clear();
             element(by.model('snippet')).sendKeys('new http://link.');
             expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
                 toBe('new http://link.');
             expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);
             expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())
                 .toBe('new http://link.');
           });
    
           it('should work with the target property', function() {
            expect(element(by.id('linky-target')).
                element(by.binding("snippetWithSingleURL | linky:'_blank'")).getText()).
                toBe('http://angularjs.org/');
            expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');
           });
    
           it('should optionally add custom attributes', function() {
            expect(element(by.id('linky-custom-attributes')).
                element(by.binding("snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}")).getText()).
                toBe('http://angularjs.org/');
            expect(element(by.css('#linky-custom-attributes a')).getAttribute('rel')).toEqual('nofollow');
           });
         </file>
       </example>
     */
    angular.module('ngSanitize').filter('linky', ['$sanitize', function ($sanitize) {
        var LINKY_URL_REGEXP =
            /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
            MAILTO_REGEXP = /^mailto:/i;

        var linkyMinErr = angular.$$minErr('linky');
        var isDefined = angular.isDefined;
        var isFunction = angular.isFunction;
        var isObject = angular.isObject;
        var isString = angular.isString;

        return function (text, target, attributes) {
            if (text == null || text === '') return text;
            if (!isString(text)) throw linkyMinErr('notstring', 'Expected string but received: {0}', text);

            var attributesFn =
                isFunction(attributes) ? attributes :
                    isObject(attributes) ? function getAttributesObject() { return attributes; } :
                        function getEmptyAttributesObject() { return {}; };

            var match;
            var raw = text;
            var html = [];
            var url;
            var i;
            while ((match = raw.match(LINKY_URL_REGEXP))) {
                // We can not end in these as they are sometimes found at the end of the sentence
                url = match[0];
                // if we did not match ftp/http/www/mailto then assume mailto
                if (!match[2] && !match[4]) {
                    url = (match[3] ? 'http://' : 'mailto:') + url;
                }
                i = match.index;
                addText(raw.substr(0, i));
                addLink(url, match[0].replace(MAILTO_REGEXP, ''));
                raw = raw.substring(i + match[0].length);
            }
            addText(raw);
            return $sanitize(html.join(''));

            function addText(text) {
                if (!text) {
                    return;
                }
                html.push(sanitizeText(text));
            }

            function addLink(url, text) {
                var key, linkAttributes = attributesFn(url);
                html.push('<a ');

                for (key in linkAttributes) {
                    html.push(key + '="' + linkAttributes[key] + '" ');
                }

                if (isDefined(target) && !('target' in linkAttributes)) {
                    html.push('target="',
                        target,
                        '" ');
                }
                html.push('href="',
                    url.replace(/"/g, '&quot;'),
                    '">');
                addText(text);
                html.push('</a>');
            }
        };
    }]);


})(window, window.angular);

/*
 AngularJS v1.6.6
 (c) 2010-2017 Google, Inc. http://angularjs.org
 License: MIT
*/
(function (s, p) {
    'use strict'; var c = "BUTTON A INPUT TEXTAREA SELECT DETAILS SUMMARY".split(" "), h = function (a, b) { if (-1 !== b.indexOf(a[0].nodeName)) return !0 }; p.module("ngAria", ["ng"]).info({ angularVersion: "1.6.6" }).provider("$aria", function () {
        function a(a, c, n, k) { return function (d, f, e) { var g = e.$normalize(c); !b[g] || h(f, n) || e[g] || d.$watch(e[a], function (a) { a = k ? !a : !!a; f.attr(c, a) }) } } var b = {
            ariaHidden: !0, ariaChecked: !0, ariaReadonly: !0, ariaDisabled: !0, ariaRequired: !0, ariaInvalid: !0, ariaValue: !0, tabindex: !0, bindKeydown: !0,
            bindRoleForClick: !0
        }; this.config = function (a) { b = p.extend(b, a) }; this.$get = function () { return { config: function (a) { return b[a] }, $$watchExpr: a } }
    }).directive("ngShow", ["$aria", function (a) { return a.$$watchExpr("ngShow", "aria-hidden", [], !0) }]).directive("ngHide", ["$aria", function (a) { return a.$$watchExpr("ngHide", "aria-hidden", [], !1) }]).directive("ngValue", ["$aria", function (a) { return a.$$watchExpr("ngValue", "aria-checked", c, !1) }]).directive("ngChecked", ["$aria", function (a) {
        return a.$$watchExpr("ngChecked", "aria-checked",
            c, !1)
    }]).directive("ngReadonly", ["$aria", function (a) { return a.$$watchExpr("ngReadonly", "aria-readonly", c, !1) }]).directive("ngRequired", ["$aria", function (a) { return a.$$watchExpr("ngRequired", "aria-required", c, !1) }]).directive("ngModel", ["$aria", function (a) {
        function b(b, k, d, f) { return a.config(k) && !d.attr(b) && (f || !h(d, c)) } function l(a, b) { return !b.attr("role") && b.attr("type") === a && !h(b, c) } function m(a, b) {
            var d = a.type, f = a.role; return "checkbox" === (d || f) || "menuitemcheckbox" === f ? "checkbox" : "radio" === (d ||
                f) || "menuitemradio" === f ? "radio" : "range" === d || "progressbar" === f || "slider" === f ? "range" : ""
        } return {
            restrict: "A", require: "ngModel", priority: 200, compile: function (c, k) {
                var d = m(k, c); return {
                    post: function (f, e, g, c) {
                        function k() { return c.$modelValue } function h(a) { e.attr("aria-checked", g.value == c.$viewValue) } function m() { e.attr("aria-checked", !c.$isEmpty(c.$viewValue)) } var n = b("tabindex", "tabindex", e, !1); switch (d) {
                            case "radio": case "checkbox": l(d, e) && e.attr("role", d); b("aria-checked", "ariaChecked", e, !1) && f.$watch(k,
                                "radio" === d ? h : m); n && e.attr("tabindex", 0); break; case "range": l(d, e) && e.attr("role", "slider"); if (a.config("ariaValue")) { var p = !e.attr("aria-valuemin") && (g.hasOwnProperty("min") || g.hasOwnProperty("ngMin")), q = !e.attr("aria-valuemax") && (g.hasOwnProperty("max") || g.hasOwnProperty("ngMax")), r = !e.attr("aria-valuenow"); p && g.$observe("min", function (a) { e.attr("aria-valuemin", a) }); q && g.$observe("max", function (a) { e.attr("aria-valuemax", a) }); r && f.$watch(k, function (a) { e.attr("aria-valuenow", a) }) } n && e.attr("tabindex",
                                    0)
                        }!g.hasOwnProperty("ngRequired") && c.$validators.required && b("aria-required", "ariaRequired", e, !1) && g.$observe("required", function () { e.attr("aria-required", !!g.required) }); b("aria-invalid", "ariaInvalid", e, !0) && f.$watch(function () { return c.$invalid }, function (a) { e.attr("aria-invalid", !!a) })
                    }
                }
            }
        }
    }]).directive("ngDisabled", ["$aria", function (a) { return a.$$watchExpr("ngDisabled", "aria-disabled", c, !1) }]).directive("ngMessages", function () {
        return {
            restrict: "A", require: "?ngMessages", link: function (a, b, c, h) {
                b.attr("aria-live") ||
                    b.attr("aria-live", "assertive")
            }
        }
    }).directive("ngClick", ["$aria", "$parse", function (a, b) { return { restrict: "A", compile: function (l, m) { var n = b(m.ngClick); return function (b, d, f) { if (!h(d, c) && (a.config("bindRoleForClick") && !d.attr("role") && d.attr("role", "button"), a.config("tabindex") && !d.attr("tabindex") && d.attr("tabindex", 0), a.config("bindKeydown") && !f.ngKeydown && !f.ngKeypress && !f.ngKeyup)) d.on("keydown", function (a) { function c() { n(b, { $event: a }) } var d = a.which || a.keyCode; 32 !== d && 13 !== d || b.$apply(c) }) } } } }]).directive("ngDblclick",
        ["$aria", function (a) { return function (b, l, m) { !a.config("tabindex") || l.attr("tabindex") || h(l, c) || l.attr("tabindex", 0) } }])
})(window, window.angular);
//# sourceMappingURL=angular-aria.min.js.map

/*
 AngularJS v1.6.6
 (c) 2010-2017 Google, Inc. http://angularjs.org
 License: MIT
*/
(function (y, l) {
    'use strict'; function w() {
        return ["$animate", function (t) {
            return {
                restrict: "AE", transclude: "element", priority: 1, terminal: !0, require: "^^ngMessages", link: function (u, n, a, c, f) {
                    var e = n[0], d, r = a.ngMessage || a.when; a = a.ngMessageExp || a.whenExp; var k = function (a) { d = a ? p(a) ? a : a.split(/[\s,]+/) : null; c.reRender() }; a ? (k(u.$eval(a)), u.$watchCollection(a, k)) : k(r); var g, s; c.register(e, s = {
                        test: function (a) { var m = d; a = m ? p(m) ? 0 <= m.indexOf(a) : m.hasOwnProperty(a) : void 0; return a }, attach: function () {
                            g || f(function (a,
                                m) { t.enter(a, null, n); g = a; var d = g.$$attachId = c.getAttachId(); g.on("$destroy", function () { g && g.$$attachId === d && (c.deregister(e), s.detach()); m.$destroy() }) })
                        }, detach: function () { if (g) { var a = g; g = null; t.leave(a) } }
                    })
                }
            }
        }]
    } var v, p, q, x; l.module("ngMessages", [], function () { v = l.forEach; p = l.isArray; q = l.isString; x = l.element }).info({ angularVersion: "1.6.6" }).directive("ngMessages", ["$animate", function (t) {
        function u(a, c) { return q(c) && 0 === c.length || n(a.$eval(c)) } function n(a) { return q(a) ? a.length : !!a } return {
            require: "ngMessages",
            restrict: "AE", controller: ["$element", "$scope", "$attrs", function (a, c, f) {
                function e(a, c) { for (var b = c, d = []; b && b !== a;) { var h = b.$$ngMessageNode; if (h && h.length) return g[h]; b.childNodes.length && -1 === d.indexOf(b) ? (d.push(b), b = b.childNodes[b.childNodes.length - 1]) : b.previousSibling ? b = b.previousSibling : (b = b.parentNode, d.push(b)) } } var d = this, r = 0, k = 0; this.getAttachId = function () { return k++ }; var g = this.messages = {}, s, l; this.render = function (m) {
                    m = m || {}; s = !1; l = m; for (var g = u(c, f.ngMessagesMultiple) || u(c, f.multiple),
                        b = [], e = {}, h = d.head, r = !1, k = 0; null != h;) { k++; var q = h.message, p = !1; r || v(m, function (a, b) { !p && n(a) && q.test(b) && !e[b] && (p = e[b] = !0, q.attach()) }); p ? r = !g : b.push(q); h = h.next } v(b, function (a) { a.detach() }); b.length !== k ? t.setClass(a, "ng-active", "ng-inactive") : t.setClass(a, "ng-inactive", "ng-active")
                }; c.$watchCollection(f.ngMessages || f["for"], d.render); a.on("$destroy", function () { v(g, function (a) { a.message.detach() }) }); this.reRender = function () { s || (s = !0, c.$evalAsync(function () { s && l && d.render(l) })) }; this.register = function (c,
                    f) { var b = r.toString(); g[b] = { message: f }; var k = a[0], h = g[b]; d.head ? (k = e(k, c)) ? (h.next = k.next, k.next = h) : (h.next = d.head, d.head = h) : d.head = h; c.$$ngMessageNode = b; r++; d.reRender() }; this.deregister = function (c) { var f = c.$$ngMessageNode; delete c.$$ngMessageNode; var b = g[f]; (c = e(a[0], c)) ? c.next = b.next : d.head = b.next; delete g[f]; d.reRender() }
            }]
        }
    }]).directive("ngMessagesInclude", ["$templateRequest", "$document", "$compile", function (l, p, n) {
        function a(a, f) {
            var e = n.$$createComment ? n.$$createComment("ngMessagesInclude",
                f) : p[0].createComment(" ngMessagesInclude: " + f + " "), e = x(e); a.after(e); a.remove()
        } return { restrict: "AE", require: "^^ngMessages", link: function (c, f, e) { var d = e.ngMessagesInclude || e.src; l(d).then(function (e) { c.$$destroyed || (q(e) && !e.trim() ? a(f, d) : n(e)(c, function (c) { f.after(c); a(f, d) })) }) } }
    }]).directive("ngMessage", w()).directive("ngMessageExp", w())
})(window, window.angular);
//# sourceMappingURL=angular-messages.min.js.map

/**
 * State-based routing for AngularJS
 * @version v0.3.2
 * @link http://angular-ui.github.com/
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
"undefined" != typeof module && "undefined" != typeof exports && module.exports === exports && (module.exports = "ui.router"), function (a, b, c) {
    "use strict"; function d(a, b) { return S(new (S(function () { }, { prototype: a })), b) } function e(a) { return R(arguments, function (b) { b !== a && R(b, function (b, c) { a.hasOwnProperty(c) || (a[c] = b) }) }), a } function f(a, b) { var c = []; for (var d in a.path) { if (a.path[d] !== b.path[d]) break; c.push(a.path[d]) } return c } function g(a) { if (Object.keys) return Object.keys(a); var b = []; return R(a, function (a, c) { b.push(c) }), b } function h(a, b) { if (Array.prototype.indexOf) return a.indexOf(b, Number(arguments[2]) || 0); var c = a.length >>> 0, d = Number(arguments[2]) || 0; for (d = d < 0 ? Math.ceil(d) : Math.floor(d), d < 0 && (d += c); d < c; d++)if (d in a && a[d] === b) return d; return -1 } function i(a, b, c, d) { var e, i = f(c, d), j = {}, k = []; for (var l in i) if (i[l] && i[l].params && (e = g(i[l].params), e.length)) for (var m in e) h(k, e[m]) >= 0 || (k.push(e[m]), j[e[m]] = a[e[m]]); return S({}, j, b) } function j(a, b, c) { if (!c) { c = []; for (var d in a) c.push(d) } for (var e = 0; e < c.length; e++) { var f = c[e]; if (a[f] != b[f]) return !1 } return !0 } function k(a, b) { var c = {}; return R(a, function (a) { c[a] = b[a] }), c } function l(a) { var b = {}, c = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1)); return R(c, function (c) { c in a && (b[c] = a[c]) }), b } function m(a) { var b = {}, c = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1)); for (var d in a) h(c, d) == -1 && (b[d] = a[d]); return b } function n(a, b) { var c = Q(a), d = c ? [] : {}; return R(a, function (a, e) { b(a, e) && (d[c ? d.length : e] = a) }), d } function o(a, b) { var c = Q(a) ? [] : {}; return R(a, function (a, d) { c[d] = b(a, d) }), c } function p(a) { return a.then(c, function () { }) && a } function q(a, b) { var d = 1, f = 2, i = {}, j = [], k = i, l = S(a.when(i), { $$promises: i, $$values: i }); this.study = function (i) { function n(a, c) { if (s[c] !== f) { if (r.push(c), s[c] === d) throw r.splice(0, h(r, c)), new Error("Cyclic dependency: " + r.join(" -> ")); if (s[c] = d, O(a)) q.push(c, [function () { return b.get(a) }], j); else { var e = b.annotate(a); R(e, function (a) { a !== c && i.hasOwnProperty(a) && n(i[a], a) }), q.push(c, a, e) } r.pop(), s[c] = f } } function o(a) { return P(a) && a.then && a.$$promises } if (!P(i)) throw new Error("'invocables' must be an object"); var p = g(i || {}), q = [], r = [], s = {}; return R(i, n), i = r = s = null, function (d, f, g) { function h() { --u || (v || e(t, f.$$values), r.$$values = t, r.$$promises = r.$$promises || !0, delete r.$$inheritedValues, n.resolve(t)) } function i(a) { r.$$failure = a, n.reject(a) } function j(c, e, f) { function j(a) { l.reject(a), i(a) } function k() { if (!M(r.$$failure)) try { l.resolve(b.invoke(e, g, t)), l.promise.then(function (a) { t[c] = a, h() }, j) } catch (a) { j(a) } } var l = a.defer(), m = 0; R(f, function (a) { s.hasOwnProperty(a) && !d.hasOwnProperty(a) && (m++ , s[a].then(function (b) { t[a] = b, --m || k() }, j)) }), m || k(), s[c] = l.promise } if (o(d) && g === c && (g = f, f = d, d = null), d) { if (!P(d)) throw new Error("'locals' must be an object") } else d = k; if (f) { if (!o(f)) throw new Error("'parent' must be a promise returned by $resolve.resolve()") } else f = l; var n = a.defer(), r = n.promise, s = r.$$promises = {}, t = S({}, d), u = 1 + q.length / 3, v = !1; if (M(f.$$failure)) return i(f.$$failure), r; f.$$inheritedValues && e(t, m(f.$$inheritedValues, p)), S(s, f.$$promises), f.$$values ? (v = e(t, m(f.$$values, p)), r.$$inheritedValues = m(f.$$values, p), h()) : (f.$$inheritedValues && (r.$$inheritedValues = m(f.$$inheritedValues, p)), f.then(h, i)); for (var w = 0, x = q.length; w < x; w += 3)d.hasOwnProperty(q[w]) ? h() : j(q[w], q[w + 1], q[w + 2]); return r } }, this.resolve = function (a, b, c, d) { return this.study(a)(b, c, d) } } function r(a, b, c) { this.fromConfig = function (a, b, c) { return M(a.template) ? this.fromString(a.template, b) : M(a.templateUrl) ? this.fromUrl(a.templateUrl, b) : M(a.templateProvider) ? this.fromProvider(a.templateProvider, b, c) : null }, this.fromString = function (a, b) { return N(a) ? a(b) : a }, this.fromUrl = function (c, d) { return N(c) && (c = c(d)), null == c ? null : a.get(c, { cache: b, headers: { Accept: "text/html" } }).then(function (a) { return a.data }) }, this.fromProvider = function (a, b, d) { return c.invoke(a, null, d || { params: b }) } } function s(a, b, e) { function f(b, c, d, e) { if (q.push(b), o[b]) return o[b]; if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(b)) throw new Error("Invalid parameter name '" + b + "' in pattern '" + a + "'"); if (p[b]) throw new Error("Duplicate parameter name '" + b + "' in pattern '" + a + "'"); return p[b] = new V.Param(b, c, d, e), p[b] } function g(a, b, c, d) { var e = ["", ""], f = a.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&"); if (!b) return f; switch (c) { case !1: e = ["(", ")" + (d ? "?" : "")]; break; case !0: f = f.replace(/\/$/, ""), e = ["(?:/(", ")|/)?"]; break; default: e = ["(" + c + "|", ")?"] }return f + e[0] + b + e[1] } function h(e, f) { var g, h, i, j, k; return g = e[2] || e[3], k = b.params[g], i = a.substring(m, e.index), h = f ? e[4] : e[4] || ("*" == e[1] ? ".*" : null), h && (j = V.type(h) || d(V.type("string"), { pattern: new RegExp(h, b.caseInsensitive ? "i" : c) })), { id: g, regexp: h, segment: i, type: j, cfg: k } } b = S({ params: {} }, P(b) ? b : {}); var i, j = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, k = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, l = "^", m = 0, n = this.segments = [], o = e ? e.params : {}, p = this.params = e ? e.params.$$new() : new V.ParamSet, q = []; this.source = a; for (var r, s, t; (i = j.exec(a)) && (r = h(i, !1), !(r.segment.indexOf("?") >= 0));)s = f(r.id, r.type, r.cfg, "path"), l += g(r.segment, s.type.pattern.source, s.squash, s.isOptional), n.push(r.segment), m = j.lastIndex; t = a.substring(m); var u = t.indexOf("?"); if (u >= 0) { var v = this.sourceSearch = t.substring(u); if (t = t.substring(0, u), this.sourcePath = a.substring(0, m + u), v.length > 0) for (m = 0; i = k.exec(v);)r = h(i, !0), s = f(r.id, r.type, r.cfg, "search"), m = j.lastIndex } else this.sourcePath = a, this.sourceSearch = ""; l += g(t) + (b.strict === !1 ? "/?" : "") + "$", n.push(t), this.regexp = new RegExp(l, b.caseInsensitive ? "i" : c), this.prefix = n[0], this.$$paramNames = q } function t(a) { S(this, a) } function u() { function a(a) { return null != a ? a.toString().replace(/(~|\/)/g, function (a) { return { "~": "~~", "/": "~2F" }[a] }) : a } function e(a) { return null != a ? a.toString().replace(/(~~|~2F)/g, function (a) { return { "~~": "~", "~2F": "/" }[a] }) : a } function f() { return { strict: p, caseInsensitive: m } } function i(a) { return N(a) || Q(a) && N(a[a.length - 1]) } function j() { for (; w.length;) { var a = w.shift(); if (a.pattern) throw new Error("You cannot override a type's .pattern at runtime."); b.extend(r[a.name], l.invoke(a.def)) } } function k(a) { S(this, a || {}) } V = this; var l, m = !1, p = !0, q = !1, r = {}, v = !0, w = [], x = { string: { encode: a, decode: e, is: function (a) { return null == a || !M(a) || "string" == typeof a }, pattern: /[^\/]*/ }, int: { encode: a, decode: function (a) { return parseInt(a, 10) }, is: function (a) { return M(a) && this.decode(a.toString()) === a }, pattern: /\d+/ }, bool: { encode: function (a) { return a ? 1 : 0 }, decode: function (a) { return 0 !== parseInt(a, 10) }, is: function (a) { return a === !0 || a === !1 }, pattern: /0|1/ }, date: { encode: function (a) { return this.is(a) ? [a.getFullYear(), ("0" + (a.getMonth() + 1)).slice(-2), ("0" + a.getDate()).slice(-2)].join("-") : c }, decode: function (a) { if (this.is(a)) return a; var b = this.capture.exec(a); return b ? new Date(b[1], b[2] - 1, b[3]) : c }, is: function (a) { return a instanceof Date && !isNaN(a.valueOf()) }, equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString() }, pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/, capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/ }, json: { encode: b.toJson, decode: b.fromJson, is: b.isObject, equals: b.equals, pattern: /[^\/]*/ }, any: { encode: b.identity, decode: b.identity, equals: b.equals, pattern: /.*/ } }; u.$$getDefaultValue = function (a) { if (!i(a.value)) return a.value; if (!l) throw new Error("Injectable functions cannot be called at configuration time"); return l.invoke(a.value) }, this.caseInsensitive = function (a) { return M(a) && (m = a), m }, this.strictMode = function (a) { return M(a) && (p = a), p }, this.defaultSquashPolicy = function (a) { if (!M(a)) return q; if (a !== !0 && a !== !1 && !O(a)) throw new Error("Invalid squash policy: " + a + ". Valid policies: false, true, arbitrary-string"); return q = a, a }, this.compile = function (a, b) { return new s(a, S(f(), b)) }, this.isMatcher = function (a) { if (!P(a)) return !1; var b = !0; return R(s.prototype, function (c, d) { N(c) && (b = b && M(a[d]) && N(a[d])) }), b }, this.type = function (a, b, c) { if (!M(b)) return r[a]; if (r.hasOwnProperty(a)) throw new Error("A type named '" + a + "' has already been defined."); return r[a] = new t(S({ name: a }, b)), c && (w.push({ name: a, def: c }), v || j()), this }, R(x, function (a, b) { r[b] = new t(S({ name: b }, a)) }), r = d(r, {}), this.$get = ["$injector", function (a) { return l = a, v = !1, j(), R(x, function (a, b) { r[b] || (r[b] = new t(a)) }), this }], this.Param = function (a, d, e, f) { function j(a) { var b = P(a) ? g(a) : [], c = h(b, "value") === -1 && h(b, "type") === -1 && h(b, "squash") === -1 && h(b, "array") === -1; return c && (a = { value: a }), a.$$fn = i(a.value) ? a.value : function () { return a.value }, a } function k(c, d, e) { if (c.type && d) throw new Error("Param '" + a + "' has two type configurations."); return d ? d : c.type ? b.isString(c.type) ? r[c.type] : c.type instanceof t ? c.type : new t(c.type) : "config" === e ? r.any : r.string } function m() { var b = { array: "search" === f && "auto" }, c = a.match(/\[\]$/) ? { array: !0 } : {}; return S(b, c, e).array } function p(a, b) { var c = a.squash; if (!b || c === !1) return !1; if (!M(c) || null == c) return q; if (c === !0 || O(c)) return c; throw new Error("Invalid squash policy: '" + c + "'. Valid policies: false, true, or arbitrary string") } function s(a, b, d, e) { var f, g, i = [{ from: "", to: d || b ? c : "" }, { from: null, to: d || b ? c : "" }]; return f = Q(a.replace) ? a.replace : [], O(e) && f.push({ from: e, to: c }), g = o(f, function (a) { return a.from }), n(i, function (a) { return h(g, a.from) === -1 }).concat(f) } function u() { if (!l) throw new Error("Injectable functions cannot be called at configuration time"); var a = l.invoke(e.$$fn); if (null !== a && a !== c && !x.type.is(a)) throw new Error("Default value (" + a + ") for parameter '" + x.id + "' is not an instance of Type (" + x.type.name + ")"); return a } function v(a) { function b(a) { return function (b) { return b.from === a } } function c(a) { var c = o(n(x.replace, b(a)), function (a) { return a.to }); return c.length ? c[0] : a } return a = c(a), M(a) ? x.type.$normalize(a) : u() } function w() { return "{Param:" + a + " " + d + " squash: '" + A + "' optional: " + z + "}" } var x = this; e = j(e), d = k(e, d, f); var y = m(); d = y ? d.$asArray(y, "search" === f) : d, "string" !== d.name || y || "path" !== f || e.value !== c || (e.value = ""); var z = e.value !== c, A = p(e, z), B = s(e, y, z, A); S(this, { id: a, type: d, location: f, array: y, squash: A, replace: B, isOptional: z, value: v, dynamic: c, config: e, toString: w }) }, k.prototype = { $$new: function () { return d(this, S(new k, { $$parent: this })) }, $$keys: function () { for (var a = [], b = [], c = this, d = g(k.prototype); c;)b.push(c), c = c.$$parent; return b.reverse(), R(b, function (b) { R(g(b), function (b) { h(a, b) === -1 && h(d, b) === -1 && a.push(b) }) }), a }, $$values: function (a) { var b = {}, c = this; return R(c.$$keys(), function (d) { b[d] = c[d].value(a && a[d]) }), b }, $$equals: function (a, b) { var c = !0, d = this; return R(d.$$keys(), function (e) { var f = a && a[e], g = b && b[e]; d[e].type.equals(f, g) || (c = !1) }), c }, $$validates: function (a) { var d, e, f, g, h, i = this.$$keys(); for (d = 0; d < i.length && (e = this[i[d]], f = a[i[d]], f !== c && null !== f || !e.isOptional); d++) { if (g = e.type.$normalize(f), !e.type.is(g)) return !1; if (h = e.type.encode(g), b.isString(h) && !e.type.pattern.exec(h)) return !1 } return !0 }, $$parent: c }, this.ParamSet = k } function v(a, d) { function e(a) { var b = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(a.source); return null != b ? b[1].replace(/\\(.)/g, "$1") : "" } function f(a, b) { return a.replace(/\$(\$|\d{1,2})/, function (a, c) { return b["$" === c ? 0 : Number(c)] }) } function g(a, b, c) { if (!c) return !1; var d = a.invoke(b, b, { $match: c }); return !M(d) || d } function h(d, e, f, g, h) { function m(a, b, c) { return "/" === q ? a : b ? q.slice(0, -1) + a : c ? q.slice(1) + a : a } function n(a) { function b(a) { var b = a(f, d); return !!b && (O(b) && d.replace().url(b), !0) } if (!a || !a.defaultPrevented) { p && d.url() === p; p = c; var e, g = j.length; for (e = 0; e < g; e++)if (b(j[e])) return; k && b(k) } } function o() { return i = i || e.$on("$locationChangeSuccess", n) } var p, q = g.baseHref(), r = d.url(); return l || o(), { sync: function () { n() }, listen: function () { return o() }, update: function (a) { return a ? void (r = d.url()) : void (d.url() !== r && (d.url(r), d.replace())) }, push: function (a, b, e) { var f = a.format(b || {}); null !== f && b && b["#"] && (f += "#" + b["#"]), d.url(f), p = e && e.$$avoidResync ? d.url() : c, e && e.replace && d.replace() }, href: function (c, e, f) { if (!c.validates(e)) return null; var g = a.html5Mode(); b.isObject(g) && (g = g.enabled), g = g && h.history; var i = c.format(e); if (f = f || {}, g || null === i || (i = "#" + a.hashPrefix() + i), null !== i && e && e["#"] && (i += "#" + e["#"]), i = m(i, g, f.absolute), !f.absolute || !i) return i; var j = !g && i ? "/" : "", k = d.port(); return k = 80 === k || 443 === k ? "" : ":" + k, [d.protocol(), "://", d.host(), k, j, i].join("") } } } var i, j = [], k = null, l = !1; this.rule = function (a) { if (!N(a)) throw new Error("'rule' must be a function"); return j.push(a), this }, this.otherwise = function (a) { if (O(a)) { var b = a; a = function () { return b } } else if (!N(a)) throw new Error("'rule' must be a function"); return k = a, this }, this.when = function (a, b) { var c, h = O(b); if (O(a) && (a = d.compile(a)), !h && !N(b) && !Q(b)) throw new Error("invalid 'handler' in when()"); var i = { matcher: function (a, b) { return h && (c = d.compile(b), b = ["$match", function (a) { return c.format(a) }]), S(function (c, d) { return g(c, b, a.exec(d.path(), d.search())) }, { prefix: O(a.prefix) ? a.prefix : "" }) }, regex: function (a, b) { if (a.global || a.sticky) throw new Error("when() RegExp must not be global or sticky"); return h && (c = b, b = ["$match", function (a) { return f(c, a) }]), S(function (c, d) { return g(c, b, a.exec(d.path())) }, { prefix: e(a) }) } }, j = { matcher: d.isMatcher(a), regex: a instanceof RegExp }; for (var k in j) if (j[k]) return this.rule(i[k](a, b)); throw new Error("invalid 'what' in when()") }, this.deferIntercept = function (a) { a === c && (a = !0), l = a }, this.$get = h, h.$inject = ["$location", "$rootScope", "$injector", "$browser", "$sniffer"] } function w(a, e) { function f(a) { return 0 === a.indexOf(".") || 0 === a.indexOf("^") } function m(a, b) { if (!a) return c; var d = O(a), e = d ? a : a.name, g = f(e); if (g) { if (!b) throw new Error("No reference point given for path '" + e + "'"); b = m(b); for (var h = e.split("."), i = 0, j = h.length, k = b; i < j; i++)if ("" !== h[i] || 0 !== i) { if ("^" !== h[i]) break; if (!k.parent) throw new Error("Path '" + e + "' not valid for state '" + b.name + "'"); k = k.parent } else k = b; h = h.slice(i).join("."), e = k.name + (k.name && h ? "." : "") + h } var l = A[e]; return !l || !d && (d || l !== a && l.self !== a) ? c : l } function n(a, b) { B[a] || (B[a] = []), B[a].push(b) } function q(a) { for (var b = B[a] || []; b.length;)r(b.shift()) } function r(b) { b = d(b, { self: b, resolve: b.resolve || {}, toString: function () { return this.name } }); var c = b.name; if (!O(c) || c.indexOf("@") >= 0) throw new Error("State must have a valid name"); if (A.hasOwnProperty(c)) throw new Error("State '" + c + "' is already defined"); var e = c.indexOf(".") !== -1 ? c.substring(0, c.lastIndexOf(".")) : O(b.parent) ? b.parent : P(b.parent) && O(b.parent.name) ? b.parent.name : ""; if (e && !A[e]) return n(e, b.self); for (var f in D) N(D[f]) && (b[f] = D[f](b, D.$delegates[f])); return A[c] = b, !b[C] && b.url && a.when(b.url, ["$match", "$stateParams", function (a, c) { z.$current.navigable == b && j(a, c) || z.transitionTo(b, a, { inherit: !0, location: !1 }) }]), q(c), b } function s(a) { return a.indexOf("*") > -1 } function t(a) { for (var b = a.split("."), c = z.$current.name.split("."), d = 0, e = b.length; d < e; d++)"*" === b[d] && (c[d] = "*"); return "**" === b[0] && (c = c.slice(h(c, b[1])), c.unshift("**")), "**" === b[b.length - 1] && (c.splice(h(c, b[b.length - 2]) + 1, Number.MAX_VALUE), c.push("**")), b.length == c.length && c.join("") === b.join("") } function u(a, b) { return O(a) && !M(b) ? D[a] : N(b) && O(a) ? (D[a] && !D.$delegates[a] && (D.$delegates[a] = D[a]), D[a] = b, this) : this } function v(a, b) { return P(a) ? b = a : b.name = a, r(b), this } function w(a, e, f, h, l, n, q, r, u) { function v(b, c, d, f) { var g = a.$broadcast("$stateNotFound", b, c, d); if (g.defaultPrevented) return q.update(), F; if (!g.retry) return null; if (f.$retry) return q.update(), G; var h = z.transition = e.when(g.retry); return h.then(function () { return h !== z.transition ? (a.$broadcast("$stateChangeCancel", b.to, b.toParams, c, d), D) : (b.options.$retry = !0, z.transitionTo(b.to, b.toParams, b.options)) }, function () { return F }), q.update(), h } function w(a, c, d, g, i, j) { function m() { var c = []; return R(a.views, function (d, e) { var g = d.resolve && d.resolve !== a.resolve ? d.resolve : {}; g.$template = [function () { return f.load(e, { view: d, locals: i.globals, params: n, notify: j.notify }) || "" }], c.push(l.resolve(g, i.globals, i.resolve, a).then(function (c) { if (N(d.controllerProvider) || Q(d.controllerProvider)) { var f = b.extend({}, g, i.globals); c.$$controller = h.invoke(d.controllerProvider, null, f) } else c.$$controller = d.controller; c.$$state = a, c.$$controllerAs = d.controllerAs, c.$$resolveAs = d.resolveAs, i[e] = c })) }), e.all(c).then(function () { return i.globals }) } var n = d ? c : k(a.params.$$keys(), c), o = { $stateParams: n }; i.resolve = l.resolve(a.resolve, o, i.resolve, a); var p = [i.resolve.then(function (a) { i.globals = a })]; return g && p.push(g), e.all(p).then(m).then(function (a) { return i }) } var B = new Error("transition superseded"), D = p(e.reject(B)), E = p(e.reject(new Error("transition prevented"))), F = p(e.reject(new Error("transition aborted"))), G = p(e.reject(new Error("transition failed"))); return y.locals = { resolve: null, globals: { $stateParams: {} } }, z = { params: {}, current: y.self, $current: y, transition: null }, z.reload = function (a) { return z.transitionTo(z.current, n, { reload: a || !0, inherit: !1, notify: !0 }) }, z.go = function (a, b, c) { return z.transitionTo(a, b, S({ inherit: !0, relative: z.$current }, c)) }, z.transitionTo = function (b, c, f) { c = c || {}, f = S({ location: !0, inherit: !1, relative: null, notify: !0, reload: !1, $retry: !1 }, f || {}); var g, j = z.$current, l = z.params, o = j.path, p = m(b, f.relative), r = c["#"]; if (!M(p)) { var s = { to: b, toParams: c, options: f }, t = v(s, j.self, l, f); if (t) return t; if (b = s.to, c = s.toParams, f = s.options, p = m(b, f.relative), !M(p)) { if (!f.relative) throw new Error("No such state '" + b + "'"); throw new Error("Could not resolve '" + b + "' from state '" + f.relative + "'") } } if (p[C]) throw new Error("Cannot transition to abstract state '" + b + "'"); if (f.inherit && (c = i(n, c || {}, z.$current, p)), !p.params.$$validates(c)) return G; c = p.params.$$values(c), b = p; var u = b.path, A = 0, F = u[A], H = y.locals, I = []; if (f.reload) { if (O(f.reload) || P(f.reload)) { if (P(f.reload) && !f.reload.name) throw new Error("Invalid reload state object"); var J = f.reload === !0 ? o[0] : m(f.reload); if (f.reload && !J) throw new Error("No such reload state '" + (O(f.reload) ? f.reload : f.reload.name) + "'"); for (; F && F === o[A] && F !== J;)H = I[A] = F.locals, A++ , F = u[A] } } else for (; F && F === o[A] && F.ownParams.$$equals(c, l);)H = I[A] = F.locals, A++ , F = u[A]; if (x(b, c, j, l, H, f)) return r && (c["#"] = r), z.params = c, T(z.params, n), T(k(b.params.$$keys(), n), b.locals.globals.$stateParams), f.location && b.navigable && b.navigable.url && (q.push(b.navigable.url, c, { $$avoidResync: !0, replace: "replace" === f.location }), q.update(!0)), z.transition = null, e.when(z.current); if (c = k(b.params.$$keys(), c || {}), r && (c["#"] = r), f.notify && a.$broadcast("$stateChangeStart", b.self, c, j.self, l, f).defaultPrevented) return a.$broadcast("$stateChangeCancel", b.self, c, j.self, l), null == z.transition && q.update(), E; for (var K = e.when(H), L = A; L < u.length; L++ , F = u[L])H = I[L] = d(H), K = w(F, c, F === b, K, H, f); var N = z.transition = K.then(function () { var d, e, g; if (z.transition !== N) return a.$broadcast("$stateChangeCancel", b.self, c, j.self, l), D; for (d = o.length - 1; d >= A; d--)g = o[d], g.self.onExit && h.invoke(g.self.onExit, g.self, g.locals.globals), g.locals = null; for (d = A; d < u.length; d++)e = u[d], e.locals = I[d], e.self.onEnter && h.invoke(e.self.onEnter, e.self, e.locals.globals); return z.transition !== N ? (a.$broadcast("$stateChangeCancel", b.self, c, j.self, l), D) : (z.$current = b, z.current = b.self, z.params = c, T(z.params, n), z.transition = null, f.location && b.navigable && q.push(b.navigable.url, b.navigable.locals.globals.$stateParams, { $$avoidResync: !0, replace: "replace" === f.location }), f.notify && a.$broadcast("$stateChangeSuccess", b.self, c, j.self, l), q.update(!0), z.current) }).then(null, function (d) { return d === B ? D : z.transition !== N ? (a.$broadcast("$stateChangeCancel", b.self, c, j.self, l), D) : (z.transition = null, g = a.$broadcast("$stateChangeError", b.self, c, j.self, l, d), g.defaultPrevented || q.update(), e.reject(d)) }); return N }, z.is = function (a, b, d) { d = S({ relative: z.$current }, d || {}); var e = m(a, d.relative); return M(e) ? z.$current === e && (!b || j(e.params.$$values(b), n)) : c }, z.includes = function (a, b, d) { if (d = S({ relative: z.$current }, d || {}), O(a) && s(a)) { if (!t(a)) return !1; a = z.$current.name } var e = m(a, d.relative); if (!M(e)) return c; if (!M(z.$current.includes[e.name])) return !1; if (!b) return !0; for (var f = g(b), h = 0; h < f.length; h++) { var i = f[h], j = e.params[i]; if (j && !j.type.equals(n[i], b[i])) return !1 } return !0 }, z.href = function (a, b, d) { d = S({ lossy: !0, inherit: !0, absolute: !1, relative: z.$current }, d || {}); var e = m(a, d.relative); if (!M(e)) return null; d.inherit && (b = i(n, b || {}, z.$current, e)); var f = e && d.lossy ? e.navigable : e; return f && f.url !== c && null !== f.url ? q.href(f.url, k(e.params.$$keys().concat("#"), b || {}), { absolute: d.absolute }) : null }, z.get = function (a, b) { if (0 === arguments.length) return o(g(A), function (a) { return A[a].self }); var c = m(a, b || z.$current); return c && c.self ? c.self : null }, z } function x(a, b, c, d, e, f) { function g(a, b, c) { function d(b) { return "search" != a.params[b].location } var e = a.params.$$keys().filter(d), f = l.apply({}, [a.params].concat(e)), g = new V.ParamSet(f); return g.$$equals(b, c) } if (!f.reload && a === c && (e === c.locals || a.self.reloadOnSearch === !1 && g(c, d, b))) return !0 } var y, z, A = {}, B = {}, C = "abstract", D = { parent: function (a) { if (M(a.parent) && a.parent) return m(a.parent); var b = /^(.+)\.[^.]+$/.exec(a.name); return b ? m(b[1]) : y }, data: function (a) { return a.parent && a.parent.data && (a.data = a.self.data = d(a.parent.data, a.data)), a.data }, url: function (a) { var b = a.url, c = { params: a.params || {} }; if (O(b)) return "^" == b.charAt(0) ? e.compile(b.substring(1), c) : (a.parent.navigable || y).url.concat(b, c); if (!b || e.isMatcher(b)) return b; throw new Error("Invalid url '" + b + "' in state '" + a + "'") }, navigable: function (a) { return a.url ? a : a.parent ? a.parent.navigable : null }, ownParams: function (a) { var b = a.url && a.url.params || new V.ParamSet; return R(a.params || {}, function (a, c) { b[c] || (b[c] = new V.Param(c, null, a, "config")) }), b }, params: function (a) { var b = l(a.ownParams, a.ownParams.$$keys()); return a.parent && a.parent.params ? S(a.parent.params.$$new(), b) : new V.ParamSet }, views: function (a) { var b = {}; return R(M(a.views) ? a.views : { "": a }, function (c, d) { d.indexOf("@") < 0 && (d += "@" + a.parent.name), c.resolveAs = c.resolveAs || a.resolveAs || "$resolve", b[d] = c }), b }, path: function (a) { return a.parent ? a.parent.path.concat(a) : [] }, includes: function (a) { var b = a.parent ? S({}, a.parent.includes) : {}; return b[a.name] = !0, b }, $delegates: {} }; y = r({ name: "", url: "^", views: null, abstract: !0 }), y.navigable = null, this.decorator = u, this.state = v, this.$get = w, w.$inject = ["$rootScope", "$q", "$view", "$injector", "$resolve", "$stateParams", "$urlRouter", "$location", "$urlMatcherFactory"] } function x() { function a(a, b) { return { load: function (a, c) { var d, e = { template: null, controller: null, view: null, locals: null, notify: !0, async: !0, params: {} }; return c = S(e, c), c.view && (d = b.fromConfig(c.view, c.params, c.locals)), d } } } this.$get = a, a.$inject = ["$rootScope", "$templateFactory"] } function y() { var a = !1; this.useAnchorScroll = function () { a = !0 }, this.$get = ["$anchorScroll", "$timeout", function (b, c) { return a ? b : function (a) { return c(function () { a[0].scrollIntoView() }, 0, !1) } }] } function z(a, c, d, e, f) { function g() { return c.has ? function (a) { return c.has(a) ? c.get(a) : null } : function (a) { try { return c.get(a) } catch (a) { return null } } } function h(a, c) { var d = function () { return { enter: function (a, b, c) { b.after(a), c() }, leave: function (a, b) { a.remove(), b() } } }; if (k) return { enter: function (a, c, d) { b.version.minor > 2 ? k.enter(a, null, c).then(d) : k.enter(a, null, c, d) }, leave: function (a, c) { b.version.minor > 2 ? k.leave(a).then(c) : k.leave(a, c) } }; if (j) { var e = j && j(c, a); return { enter: function (a, b, c) { e.enter(a, null, b), c() }, leave: function (a, b) { e.leave(a), b() } } } return d() } var i = g(), j = i("$animator"), k = i("$animate"), l = { restrict: "ECA", terminal: !0, priority: 400, transclude: "element", compile: function (c, g, i) { return function (c, g, j) { function k() { if (m && (m.remove(), m = null), o && (o.$destroy(), o = null), n) { var a = n.data("$uiViewAnim"); s.leave(n, function () { a.$$animLeave.resolve(), m = null }), m = n, n = null } } function l(h) { var l, m = B(c, j, g, e), t = m && a.$current && a.$current.locals[m]; if (h || t !== p) { l = c.$new(), p = a.$current.locals[m], l.$emit("$viewContentLoading", m); var u = i(l, function (a) { var e = f.defer(), h = f.defer(), i = { $animEnter: e.promise, $animLeave: h.promise, $$animLeave: h }; a.data("$uiViewAnim", i), s.enter(a, g, function () { e.resolve(), o && o.$emit("$viewContentAnimationEnded"), (b.isDefined(r) && !r || c.$eval(r)) && d(a) }), k() }); n = u, o = l, o.$emit("$viewContentLoaded", m), o.$eval(q) } } var m, n, o, p, q = j.onload || "", r = j.autoscroll, s = h(j, c); g.inheritedData("$uiView"); c.$on("$stateChangeSuccess", function () { l(!1) }), l(!0) } } }; return l } function A(a, c, d, e) { return { restrict: "ECA", priority: -400, compile: function (f) { var g = f.html(); return function (f, h, i) { var j = d.$current, k = B(f, i, h, e), l = j && j.locals[k]; if (l) { h.data("$uiView", { name: k, state: l.$$state }), h.html(l.$template ? l.$template : g); var m = b.extend({}, l); f[l.$$resolveAs] = m; var n = a(h.contents()); if (l.$$controller) { l.$scope = f, l.$element = h; var o = c(l.$$controller, l); l.$$controllerAs && (f[l.$$controllerAs] = o, f[l.$$controllerAs][l.$$resolveAs] = m), N(o.$onInit) && o.$onInit(), h.data("$ngControllerController", o), h.children().data("$ngControllerController", o) } n(f) } } } } } function B(a, b, c, d) { var e = d(b.uiView || b.name || "")(a), f = c.inheritedData("$uiView"); return e.indexOf("@") >= 0 ? e : e + "@" + (f ? f.state.name : "") } function C(a, b) { var c, d = a.match(/^\s*({[^}]*})\s*$/); if (d && (a = b + "(" + d[1] + ")"), c = a.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/), !c || 4 !== c.length) throw new Error("Invalid state ref '" + a + "'"); return { state: c[1], paramExpr: c[3] || null } } function D(a) { var b = a.parent().inheritedData("$uiView"); if (b && b.state && b.state.name) return b.state } function E(a) { var b = "[object SVGAnimatedString]" === Object.prototype.toString.call(a.prop("href")), c = "FORM" === a[0].nodeName; return { attr: c ? "action" : b ? "xlink:href" : "href", isAnchor: "A" === a.prop("tagName").toUpperCase(), clickable: !c } } function F(a, b, c, d, e) { return function (f) { var g = f.which || f.button, h = e(); if (!(g > 1 || f.ctrlKey || f.metaKey || f.shiftKey || a.attr("target"))) { var i = c(function () { b.go(h.state, h.params, h.options) }); f.preventDefault(); var j = d.isAnchor && !h.href ? 1 : 0; f.preventDefault = function () { j-- <= 0 && c.cancel(i) } } } } function G(a, b) { return { relative: D(a) || b.$current, inherit: !0 } } function H(a, c) { return { restrict: "A", require: ["?^uiSrefActive", "?^uiSrefActiveEq"], link: function (d, e, f, g) { var h, i = C(f.uiSref, a.current.name), j = { state: i.state, href: null, params: null }, k = E(e), l = g[1] || g[0], m = null; j.options = S(G(e, a), f.uiSrefOpts ? d.$eval(f.uiSrefOpts) : {}); var n = function (c) { c && (j.params = b.copy(c)), j.href = a.href(i.state, j.params, j.options), m && m(), l && (m = l.$$addStateInfo(i.state, j.params)), null !== j.href && f.$set(k.attr, j.href) }; i.paramExpr && (d.$watch(i.paramExpr, function (a) { a !== j.params && n(a) }, !0), j.params = b.copy(d.$eval(i.paramExpr))), n(), k.clickable && (h = F(e, a, c, k, function () { return j }), e[e.on ? "on" : "bind"]("click", h), d.$on("$destroy", function () { e[e.off ? "off" : "unbind"]("click", h) })) } } } function I(a, b) { return { restrict: "A", require: ["?^uiSrefActive", "?^uiSrefActiveEq"], link: function (c, d, e, f) { function g(b) { m.state = b[0], m.params = b[1], m.options = b[2], m.href = a.href(m.state, m.params, m.options), n && n(), j && (n = j.$$addStateInfo(m.state, m.params)), m.href && e.$set(i.attr, m.href) } var h, i = E(d), j = f[1] || f[0], k = [e.uiState, e.uiStateParams || null, e.uiStateOpts || null], l = "[" + k.map(function (a) { return a || "null" }).join(", ") + "]", m = { state: null, params: null, options: null, href: null }, n = null; c.$watch(l, g, !0), g(c.$eval(l)), i.clickable && (h = F(d, a, b, i, function () { return m }), d[d.on ? "on" : "bind"]("click", h), c.$on("$destroy", function () { d[d.off ? "off" : "unbind"]("click", h) })) } } } function J(a, b, c) { return { restrict: "A", controller: ["$scope", "$element", "$attrs", "$timeout", function (b, d, e, f) { function g(b, c, e) { var f = a.get(b, D(d)), g = h(b, c), i = { state: f || { name: b }, params: c, hash: g }; return p.push(i), q[g] = e, function () { var a = p.indexOf(i); a !== -1 && p.splice(a, 1) } } function h(a, c) { if (!O(a)) throw new Error("state should be a string"); return P(c) ? a + U(c) : (c = b.$eval(c), P(c) ? a + U(c) : a) } function i() { for (var a = 0; a < p.length; a++)l(p[a].state, p[a].params) ? j(d, q[p[a].hash]) : k(d, q[p[a].hash]), m(p[a].state, p[a].params) ? j(d, n) : k(d, n) } function j(a, b) { f(function () { a.addClass(b) }) } function k(a, b) { a.removeClass(b) } function l(b, c) { return a.includes(b.name, c) } function m(b, c) { return a.is(b.name, c) } var n, o, p = [], q = {}; n = c(e.uiSrefActiveEq || "", !1)(b); try { o = b.$eval(e.uiSrefActive) } catch (a) { } o = o || c(e.uiSrefActive || "", !1)(b), P(o) && R(o, function (c, d) { if (O(c)) { var e = C(c, a.current.name); g(e.state, b.$eval(e.paramExpr), d) } }), this.$$addStateInfo = function (a, b) { if (!(P(o) && p.length > 0)) { var c = g(a, b, o); return i(), c } }, b.$on("$stateChangeSuccess", i), i() }] } } function K(a) { var b = function (b, c) { return a.is(b, c) }; return b.$stateful = !0, b } function L(a) { var b = function (b, c, d) { return a.includes(b, c, d) }; return b.$stateful = !0, b } var M = b.isDefined, N = b.isFunction, O = b.isString, P = b.isObject, Q = b.isArray, R = b.forEach, S = b.extend, T = b.copy, U = b.toJson; b.module("ui.router.util", ["ng"]), b.module("ui.router.router", ["ui.router.util"]), b.module("ui.router.state", ["ui.router.router", "ui.router.util"]), b.module("ui.router", ["ui.router.state"]), b.module("ui.router.compat", ["ui.router"]), q.$inject = ["$q", "$injector"], b.module("ui.router.util").service("$resolve", q), r.$inject = ["$http", "$templateCache", "$injector"], b.module("ui.router.util").service("$templateFactory", r); var V; s.prototype.concat = function (a, b) { var c = { caseInsensitive: V.caseInsensitive(), strict: V.strictMode(), squash: V.defaultSquashPolicy() }; return new s(this.sourcePath + a + this.sourceSearch, S(c, b), this) }, s.prototype.toString = function () { return this.source }, s.prototype.exec = function (a, b) { function c(a) { function b(a) { return a.split("").reverse().join("") } function c(a) { return a.replace(/\\-/g, "-") } var d = b(a).split(/-(?!\\)/), e = o(d, b); return o(e, c).reverse() } var d = this.regexp.exec(a); if (!d) return null; b = b || {}; var e, f, g, h = this.parameters(), i = h.length, j = this.segments.length - 1, k = {}; if (j !== d.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'"); var l, m; for (e = 0; e < j; e++) { for (g = h[e], l = this.params[g], m = d[e + 1], f = 0; f < l.replace.length; f++)l.replace[f].from === m && (m = l.replace[f].to); m && l.array === !0 && (m = c(m)), M(m) && (m = l.type.decode(m)), k[g] = l.value(m) } for (; e < i; e++) { for (g = h[e], k[g] = this.params[g].value(b[g]), l = this.params[g], m = b[g], f = 0; f < l.replace.length; f++)l.replace[f].from === m && (m = l.replace[f].to); M(m) && (m = l.type.decode(m)), k[g] = l.value(m) } return k }, s.prototype.parameters = function (a) { return M(a) ? this.params[a] || null : this.$$paramNames }, s.prototype.validates = function (a) { return this.params.$$validates(a) }, s.prototype.format = function (a) { function b(a) { return encodeURIComponent(a).replace(/-/g, function (a) { return "%5C%" + a.charCodeAt(0).toString(16).toUpperCase() }) } a = a || {}; var c = this.segments, d = this.parameters(), e = this.params; if (!this.validates(a)) return null; var f, g = !1, h = c.length - 1, i = d.length, j = c[0]; for (f = 0; f < i; f++) { var k = f < h, l = d[f], m = e[l], n = m.value(a[l]), p = m.isOptional && m.type.equals(m.value(), n), q = !!p && m.squash, r = m.type.encode(n); if (k) { var s = c[f + 1], t = f + 1 === h; if (q === !1) null != r && (j += Q(r) ? o(r, b).join("-") : encodeURIComponent(r)), j += s; else if (q === !0) { var u = j.match(/\/$/) ? /\/?(.*)/ : /(.*)/; j += s.match(u)[1] } else O(q) && (j += q + s); t && m.squash === !0 && "/" === j.slice(-1) && (j = j.slice(0, -1)) } else { if (null == r || p && q !== !1) continue; if (Q(r) || (r = [r]), 0 === r.length) continue; r = o(r, encodeURIComponent).join("&" + l + "="), j += (g ? "&" : "?") + (l + "=" + r), g = !0 } } return j }, t.prototype.is = function (a, b) { return !0 }, t.prototype.encode = function (a, b) { return a }, t.prototype.decode = function (a, b) { return a }, t.prototype.equals = function (a, b) { return a == b }, t.prototype.$subPattern = function () { var a = this.pattern.toString(); return a.substr(1, a.length - 2) }, t.prototype.pattern = /.*/, t.prototype.toString = function () { return "{Type:" + this.name + "}" }, t.prototype.$normalize = function (a) { return this.is(a) ? a : this.decode(a) }, t.prototype.$asArray = function (a, b) {
        function d(a, b) { function d(a, b) { return function () { return a[b].apply(a, arguments) } } function e(a) { return Q(a) ? a : M(a) ? [a] : [] } function f(a) { switch (a.length) { case 0: return c; case 1: return "auto" === b ? a[0] : a; default: return a } } function g(a) { return !a } function h(a, b) { return function (c) { if (Q(c) && 0 === c.length) return c; c = e(c); var d = o(c, a); return b === !0 ? 0 === n(d, g).length : f(d) } } function i(a) { return function (b, c) { var d = e(b), f = e(c); if (d.length !== f.length) return !1; for (var g = 0; g < d.length; g++)if (!a(d[g], f[g])) return !1; return !0 } } this.encode = h(d(a, "encode")), this.decode = h(d(a, "decode")), this.is = h(d(a, "is"), !0), this.equals = i(d(a, "equals")), this.pattern = a.pattern, this.$normalize = h(d(a, "$normalize")), this.name = a.name, this.$arrayMode = b } if (!a) return this; if ("auto" === a && !b) throw new Error("'auto' array mode is for query parameters only"); return new d(this, a);
    }, b.module("ui.router.util").provider("$urlMatcherFactory", u), b.module("ui.router.util").run(["$urlMatcherFactory", function (a) { }]), v.$inject = ["$locationProvider", "$urlMatcherFactoryProvider"], b.module("ui.router.router").provider("$urlRouter", v), w.$inject = ["$urlRouterProvider", "$urlMatcherFactoryProvider"], b.module("ui.router.state").factory("$stateParams", function () { return {} }).constant("$state.runtime", { autoinject: !0 }).provider("$state", w).run(["$injector", function (a) { a.get("$state.runtime").autoinject && a.get("$state") }]), x.$inject = [], b.module("ui.router.state").provider("$view", x), b.module("ui.router.state").provider("$uiViewScroll", y), z.$inject = ["$state", "$injector", "$uiViewScroll", "$interpolate", "$q"], A.$inject = ["$compile", "$controller", "$state", "$interpolate"], b.module("ui.router.state").directive("uiView", z), b.module("ui.router.state").directive("uiView", A), H.$inject = ["$state", "$timeout"], I.$inject = ["$state", "$timeout"], J.$inject = ["$state", "$stateParams", "$interpolate"], b.module("ui.router.state").directive("uiSref", H).directive("uiSrefActive", J).directive("uiSrefActiveEq", J).directive("uiState", I), K.$inject = ["$state"], L.$inject = ["$state"], b.module("ui.router.state").filter("isState", K).filter("includedByState", L)
}(window, window.angular);
/*
 * angular-ui-bootstrap
 * http://angular-ui.github.io/bootstrap/

 * Version: 2.5.0 - 2017-01-28
 * License: MIT
 */angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse", "ui.bootstrap.tabindex", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.isClass", "ui.bootstrap.datepicker", "ui.bootstrap.position", "ui.bootstrap.datepickerPopup", "ui.bootstrap.debounce", "ui.bootstrap.multiMap", "ui.bootstrap.dropdown", "ui.bootstrap.stackedMap", "ui.bootstrap.modal", "ui.bootstrap.paging", "ui.bootstrap.pager", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead"]);
angular.module("ui.bootstrap.tpls", ["uib/template/accordion/accordion-group.html", "uib/template/accordion/accordion.html", "uib/template/alert/alert.html", "uib/template/carousel/carousel.html", "uib/template/carousel/slide.html", "uib/template/datepicker/datepicker.html", "uib/template/datepicker/day.html", "uib/template/datepicker/month.html", "uib/template/datepicker/year.html", "uib/template/datepickerPopup/popup.html", "uib/template/modal/window.html", "uib/template/pager/pager.html", "uib/template/pagination/pagination.html", "uib/template/tooltip/tooltip-html-popup.html", "uib/template/tooltip/tooltip-popup.html", "uib/template/tooltip/tooltip-template-popup.html", "uib/template/popover/popover-html.html", "uib/template/popover/popover-template.html", "uib/template/popover/popover.html", "uib/template/progressbar/bar.html", "uib/template/progressbar/progress.html", "uib/template/progressbar/progressbar.html", "uib/template/rating/rating.html", "uib/template/tabs/tab.html", "uib/template/tabs/tabset.html", "uib/template/timepicker/timepicker.html", "uib/template/typeahead/typeahead-match.html", "uib/template/typeahead/typeahead-popup.html"]);
angular.module('ui.bootstrap.collapse', [])

    .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function ($animate, $q, $parse, $injector) {
        var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
        return {
            link: function (scope, element, attrs) {
                var expandingExpr = $parse(attrs.expanding),
                    expandedExpr = $parse(attrs.expanded),
                    collapsingExpr = $parse(attrs.collapsing),
                    collapsedExpr = $parse(attrs.collapsed),
                    horizontal = false,
                    css = {},
                    cssTo = {};

                init();

                function init() {
                    horizontal = !!('horizontal' in attrs);
                    if (horizontal) {
                        css = {
                            width: ''
                        };
                        cssTo = { width: '0' };
                    } else {
                        css = {
                            height: ''
                        };
                        cssTo = { height: '0' };
                    }
                    if (!scope.$eval(attrs.uibCollapse)) {
                        element.addClass('in')
                            .addClass('collapse')
                            .attr('aria-expanded', true)
                            .attr('aria-hidden', false)
                            .css(css);
                    }
                }

                function getScrollFromElement(element) {
                    if (horizontal) {
                        return { width: element.scrollWidth + 'px' };
                    }
                    return { height: element.scrollHeight + 'px' };
                }

                function expand() {
                    if (element.hasClass('collapse') && element.hasClass('in')) {
                        return;
                    }

                    $q.resolve(expandingExpr(scope))
                        .then(function () {
                            element.removeClass('collapse')
                                .addClass('collapsing')
                                .attr('aria-expanded', true)
                                .attr('aria-hidden', false);

                            if ($animateCss) {
                                $animateCss(element, {
                                    addClass: 'in',
                                    easing: 'ease',
                                    css: {
                                        overflow: 'hidden'
                                    },
                                    to: getScrollFromElement(element[0])
                                }).start()['finally'](expandDone);
                            } else {
                                $animate.addClass(element, 'in', {
                                    css: {
                                        overflow: 'hidden'
                                    },
                                    to: getScrollFromElement(element[0])
                                }).then(expandDone);
                            }
                        }, angular.noop);
                }

                function expandDone() {
                    element.removeClass('collapsing')
                        .addClass('collapse')
                        .css(css);
                    expandedExpr(scope);
                }

                function collapse() {
                    if (!element.hasClass('collapse') && !element.hasClass('in')) {
                        return collapseDone();
                    }

                    $q.resolve(collapsingExpr(scope))
                        .then(function () {
                            element
                                // IMPORTANT: The width must be set before adding "collapsing" class.
                                // Otherwise, the browser attempts to animate from width 0 (in
                                // collapsing class) to the given width here.
                                .css(getScrollFromElement(element[0]))
                                // initially all panel collapse have the collapse class, this removal
                                // prevents the animation from jumping to collapsed state
                                .removeClass('collapse')
                                .addClass('collapsing')
                                .attr('aria-expanded', false)
                                .attr('aria-hidden', true);

                            if ($animateCss) {
                                $animateCss(element, {
                                    removeClass: 'in',
                                    to: cssTo
                                }).start()['finally'](collapseDone);
                            } else {
                                $animate.removeClass(element, 'in', {
                                    to: cssTo
                                }).then(collapseDone);
                            }
                        }, angular.noop);
                }

                function collapseDone() {
                    element.css(cssTo); // Required so that collapse works when animation is disabled
                    element.removeClass('collapsing')
                        .addClass('collapse');
                    collapsedExpr(scope);
                }

                scope.$watch(attrs.uibCollapse, function (shouldCollapse) {
                    if (shouldCollapse) {
                        collapse();
                    } else {
                        expand();
                    }
                });
            }
        };
    }]);

angular.module('ui.bootstrap.tabindex', [])

    .directive('uibTabindexToggle', function () {
        return {
            restrict: 'A',
            link: function (scope, elem, attrs) {
                attrs.$observe('disabled', function (disabled) {
                    attrs.$set('tabindex', disabled ? -1 : null);
                });
            }
        };
    });

angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse', 'ui.bootstrap.tabindex'])

    .constant('uibAccordionConfig', {
        closeOthers: true
    })

    .controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function ($scope, $attrs, accordionConfig) {
        // This array keeps track of the accordion groups
        this.groups = [];

        // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
        this.closeOthers = function (openGroup) {
            var closeOthers = angular.isDefined($attrs.closeOthers) ?
                $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
            if (closeOthers) {
                angular.forEach(this.groups, function (group) {
                    if (group !== openGroup) {
                        group.isOpen = false;
                    }
                });
            }
        };

        // This is called from the accordion-group directive to add itself to the accordion
        this.addGroup = function (groupScope) {
            var that = this;
            this.groups.push(groupScope);

            groupScope.$on('$destroy', function (event) {
                that.removeGroup(groupScope);
            });
        };

        // This is called from the accordion-group directive when to remove itself
        this.removeGroup = function (group) {
            var index = this.groups.indexOf(group);
            if (index !== -1) {
                this.groups.splice(index, 1);
            }
        };
    }])

    // The accordion directive simply sets up the directive controller
    // and adds an accordion CSS class to itself element.
    .directive('uibAccordion', function () {
        return {
            controller: 'UibAccordionController',
            controllerAs: 'accordion',
            transclude: true,
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/accordion/accordion.html';
            }
        };
    })

    // The accordion-group directive indicates a block of html that will expand and collapse in an accordion
    .directive('uibAccordionGroup', function () {
        return {
            require: '^uibAccordion',         // We need this directive to be inside an accordion
            transclude: true,              // It transcludes the contents of the directive into the template
            restrict: 'A',
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';
            },
            scope: {
                heading: '@',               // Interpolate the heading attribute onto this scope
                panelClass: '@?',           // Ditto with panelClass
                isOpen: '=?',
                isDisabled: '=?'
            },
            controller: function () {
                this.setHeading = function (element) {
                    this.heading = element;
                };
            },
            link: function (scope, element, attrs, accordionCtrl) {
                element.addClass('panel');
                accordionCtrl.addGroup(scope);

                scope.openClass = attrs.openClass || 'panel-open';
                scope.panelClass = attrs.panelClass || 'panel-default';
                scope.$watch('isOpen', function (value) {
                    element.toggleClass(scope.openClass, !!value);
                    if (value) {
                        accordionCtrl.closeOthers(scope);
                    }
                });

                scope.toggleOpen = function ($event) {
                    if (!scope.isDisabled) {
                        if (!$event || $event.which === 32) {
                            scope.isOpen = !scope.isOpen;
                        }
                    }
                };

                var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
                scope.headingId = id + '-tab';
                scope.panelId = id + '-panel';
            }
        };
    })

    // Use accordion-heading below an accordion-group to provide a heading containing HTML
    .directive('uibAccordionHeading', function () {
        return {
            transclude: true,   // Grab the contents to be used as the heading
            template: '',       // In effect remove this element!
            replace: true,
            require: '^uibAccordionGroup',
            link: function (scope, element, attrs, accordionGroupCtrl, transclude) {
                // Pass the heading to the accordion-group controller
                // so that it can be transcluded into the right place in the template
                // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
                accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
            }
        };
    })

    // Use in the accordion-group template to indicate where you want the heading to be transcluded
    // You must provide the property on the accordion-group controller that will hold the transcluded element
    .directive('uibAccordionTransclude', function () {
        return {
            require: '^uibAccordionGroup',
            link: function (scope, element, attrs, controller) {
                scope.$watch(function () { return controller[attrs.uibAccordionTransclude]; }, function (heading) {
                    if (heading) {
                        var elem = angular.element(element[0].querySelector(getHeaderSelectors()));
                        elem.html('');
                        elem.append(heading);
                    }
                });
            }
        };

        function getHeaderSelectors() {
            return 'uib-accordion-header,' +
                'data-uib-accordion-header,' +
                'x-uib-accordion-header,' +
                'uib\\:accordion-header,' +
                '[uib-accordion-header],' +
                '[data-uib-accordion-header],' +
                '[x-uib-accordion-header]';
        }
    });

angular.module('ui.bootstrap.alert', [])

    .controller('UibAlertController', ['$scope', '$element', '$attrs', '$interpolate', '$timeout', function ($scope, $element, $attrs, $interpolate, $timeout) {
        $scope.closeable = !!$attrs.close;
        $element.addClass('alert');
        $attrs.$set('role', 'alert');
        if ($scope.closeable) {
            $element.addClass('alert-dismissible');
        }

        var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?
            $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;

        if (dismissOnTimeout) {
            $timeout(function () {
                $scope.close();
            }, parseInt(dismissOnTimeout, 10));
        }
    }])

    .directive('uibAlert', function () {
        return {
            controller: 'UibAlertController',
            controllerAs: 'alert',
            restrict: 'A',
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/alert/alert.html';
            },
            transclude: true,
            scope: {
                close: '&'
            }
        };
    });

angular.module('ui.bootstrap.buttons', [])

    .constant('uibButtonConfig', {
        activeClass: 'active',
        toggleEvent: 'click'
    })

    .controller('UibButtonsController', ['uibButtonConfig', function (buttonConfig) {
        this.activeClass = buttonConfig.activeClass || 'active';
        this.toggleEvent = buttonConfig.toggleEvent || 'click';
    }])

    .directive('uibBtnRadio', ['$parse', function ($parse) {
        return {
            require: ['uibBtnRadio', 'ngModel'],
            controller: 'UibButtonsController',
            controllerAs: 'buttons',
            link: function (scope, element, attrs, ctrls) {
                var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                var uncheckableExpr = $parse(attrs.uibUncheckable);

                element.find('input').css({ display: 'none' });

                //model -> UI
                ngModelCtrl.$render = function () {
                    element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
                };

                //ui->model
                element.on(buttonsCtrl.toggleEvent, function () {
                    if (attrs.disabled) {
                        return;
                    }

                    var isActive = element.hasClass(buttonsCtrl.activeClass);

                    if (!isActive || angular.isDefined(attrs.uncheckable)) {
                        scope.$apply(function () {
                            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
                            ngModelCtrl.$render();
                        });
                    }
                });

                if (attrs.uibUncheckable) {
                    scope.$watch(uncheckableExpr, function (uncheckable) {
                        attrs.$set('uncheckable', uncheckable ? '' : undefined);
                    });
                }
            }
        };
    }])

    .directive('uibBtnCheckbox', function () {
        return {
            require: ['uibBtnCheckbox', 'ngModel'],
            controller: 'UibButtonsController',
            controllerAs: 'button',
            link: function (scope, element, attrs, ctrls) {
                var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

                element.find('input').css({ display: 'none' });

                function getTrueValue() {
                    return getCheckboxValue(attrs.btnCheckboxTrue, true);
                }

                function getFalseValue() {
                    return getCheckboxValue(attrs.btnCheckboxFalse, false);
                }

                function getCheckboxValue(attribute, defaultValue) {
                    return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
                }

                //model -> UI
                ngModelCtrl.$render = function () {
                    element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
                };

                //ui->model
                element.on(buttonsCtrl.toggleEvent, function () {
                    if (attrs.disabled) {
                        return;
                    }

                    scope.$apply(function () {
                        ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
                        ngModelCtrl.$render();
                    });
                });
            }
        };
    });

angular.module('ui.bootstrap.carousel', [])

    .controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function ($scope, $element, $interval, $timeout, $animate) {
        var self = this,
            slides = self.slides = $scope.slides = [],
            SLIDE_DIRECTION = 'uib-slideDirection',
            currentIndex = $scope.active,
            currentInterval, isPlaying;

        var destroyed = false;
        $element.addClass('carousel');

        self.addSlide = function (slide, element) {
            slides.push({
                slide: slide,
                element: element
            });
            slides.sort(function (a, b) {
                return +a.slide.index - +b.slide.index;
            });
            //if this is the first slide or the slide is set to active, select it
            if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {
                if ($scope.$currentTransition) {
                    $scope.$currentTransition = null;
                }

                currentIndex = slide.index;
                $scope.active = slide.index;
                setActive(currentIndex);
                self.select(slides[findSlideIndex(slide)]);
                if (slides.length === 1) {
                    $scope.play();
                }
            }
        };

        self.getCurrentIndex = function () {
            for (var i = 0; i < slides.length; i++) {
                if (slides[i].slide.index === currentIndex) {
                    return i;
                }
            }
        };

        self.next = $scope.next = function () {
            var newIndex = (self.getCurrentIndex() + 1) % slides.length;

            if (newIndex === 0 && $scope.noWrap()) {
                $scope.pause();
                return;
            }

            return self.select(slides[newIndex], 'next');
        };

        self.prev = $scope.prev = function () {
            var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;

            if ($scope.noWrap() && newIndex === slides.length - 1) {
                $scope.pause();
                return;
            }

            return self.select(slides[newIndex], 'prev');
        };

        self.removeSlide = function (slide) {
            var index = findSlideIndex(slide);

            //get the index of the slide inside the carousel
            slides.splice(index, 1);
            if (slides.length > 0 && currentIndex === index) {
                if (index >= slides.length) {
                    currentIndex = slides.length - 1;
                    $scope.active = currentIndex;
                    setActive(currentIndex);
                    self.select(slides[slides.length - 1]);
                } else {
                    currentIndex = index;
                    $scope.active = currentIndex;
                    setActive(currentIndex);
                    self.select(slides[index]);
                }
            } else if (currentIndex > index) {
                currentIndex--;
                $scope.active = currentIndex;
            }

            //clean the active value when no more slide
            if (slides.length === 0) {
                currentIndex = null;
                $scope.active = null;
            }
        };

        /* direction: "prev" or "next" */
        self.select = $scope.select = function (nextSlide, direction) {
            var nextIndex = findSlideIndex(nextSlide.slide);
            //Decide direction if it's not given
            if (direction === undefined) {
                direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
            }
            //Prevent this user-triggered transition from occurring if there is already one in progress
            if (nextSlide.slide.index !== currentIndex &&
                !$scope.$currentTransition) {
                goNext(nextSlide.slide, nextIndex, direction);
            }
        };

        /* Allow outside people to call indexOf on slides array */
        $scope.indexOfSlide = function (slide) {
            return +slide.slide.index;
        };

        $scope.isActive = function (slide) {
            return $scope.active === slide.slide.index;
        };

        $scope.isPrevDisabled = function () {
            return $scope.active === 0 && $scope.noWrap();
        };

        $scope.isNextDisabled = function () {
            return $scope.active === slides.length - 1 && $scope.noWrap();
        };

        $scope.pause = function () {
            if (!$scope.noPause) {
                isPlaying = false;
                resetTimer();
            }
        };

        $scope.play = function () {
            if (!isPlaying) {
                isPlaying = true;
                restartTimer();
            }
        };

        $element.on('mouseenter', $scope.pause);
        $element.on('mouseleave', $scope.play);

        $scope.$on('$destroy', function () {
            destroyed = true;
            resetTimer();
        });

        $scope.$watch('noTransition', function (noTransition) {
            $animate.enabled($element, !noTransition);
        });

        $scope.$watch('interval', restartTimer);

        $scope.$watchCollection('slides', resetTransition);

        $scope.$watch('active', function (index) {
            if (angular.isNumber(index) && currentIndex !== index) {
                for (var i = 0; i < slides.length; i++) {
                    if (slides[i].slide.index === index) {
                        index = i;
                        break;
                    }
                }

                var slide = slides[index];
                if (slide) {
                    setActive(index);
                    self.select(slides[index]);
                    currentIndex = index;
                }
            }
        });

        function getSlideByIndex(index) {
            for (var i = 0, l = slides.length; i < l; ++i) {
                if (slides[i].index === index) {
                    return slides[i];
                }
            }
        }

        function setActive(index) {
            for (var i = 0; i < slides.length; i++) {
                slides[i].slide.active = i === index;
            }
        }

        function goNext(slide, index, direction) {
            if (destroyed) {
                return;
            }

            angular.extend(slide, { direction: direction });
            angular.extend(slides[currentIndex].slide || {}, { direction: direction });
            if ($animate.enabled($element) && !$scope.$currentTransition &&
                slides[index].element && self.slides.length > 1) {
                slides[index].element.data(SLIDE_DIRECTION, slide.direction);
                var currentIdx = self.getCurrentIndex();

                if (angular.isNumber(currentIdx) && slides[currentIdx].element) {
                    slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);
                }

                $scope.$currentTransition = true;
                $animate.on('addClass', slides[index].element, function (element, phase) {
                    if (phase === 'close') {
                        $scope.$currentTransition = null;
                        $animate.off('addClass', element);
                    }
                });
            }

            $scope.active = slide.index;
            currentIndex = slide.index;
            setActive(index);

            //every time you change slides, reset the timer
            restartTimer();
        }

        function findSlideIndex(slide) {
            for (var i = 0; i < slides.length; i++) {
                if (slides[i].slide === slide) {
                    return i;
                }
            }
        }

        function resetTimer() {
            if (currentInterval) {
                $interval.cancel(currentInterval);
                currentInterval = null;
            }
        }

        function resetTransition(slides) {
            if (!slides.length) {
                $scope.$currentTransition = null;
            }
        }

        function restartTimer() {
            resetTimer();
            var interval = +$scope.interval;
            if (!isNaN(interval) && interval > 0) {
                currentInterval = $interval(timerFn, interval);
            }
        }

        function timerFn() {
            var interval = +$scope.interval;
            if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
                $scope.next();
            } else {
                $scope.pause();
            }
        }
    }])

    .directive('uibCarousel', function () {
        return {
            transclude: true,
            controller: 'UibCarouselController',
            controllerAs: 'carousel',
            restrict: 'A',
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/carousel/carousel.html';
            },
            scope: {
                active: '=',
                interval: '=',
                noTransition: '=',
                noPause: '=',
                noWrap: '&'
            }
        };
    })

    .directive('uibSlide', ['$animate', function ($animate) {
        return {
            require: '^uibCarousel',
            restrict: 'A',
            transclude: true,
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/carousel/slide.html';
            },
            scope: {
                actual: '=?',
                index: '=?'
            },
            link: function (scope, element, attrs, carouselCtrl) {
                element.addClass('item');
                carouselCtrl.addSlide(scope, element);
                //when the scope is destroyed then remove the slide from the current slides array
                scope.$on('$destroy', function () {
                    carouselCtrl.removeSlide(scope);
                });

                scope.$watch('active', function (active) {
                    $animate[active ? 'addClass' : 'removeClass'](element, 'active');
                });
            }
        };
    }])

    .animation('.item', ['$animateCss',
        function ($animateCss) {
            var SLIDE_DIRECTION = 'uib-slideDirection';

            function removeClass(element, className, callback) {
                element.removeClass(className);
                if (callback) {
                    callback();
                }
            }

            return {
                beforeAddClass: function (element, className, done) {
                    if (className === 'active') {
                        var stopped = false;
                        var direction = element.data(SLIDE_DIRECTION);
                        var directionClass = direction === 'next' ? 'left' : 'right';
                        var removeClassFn = removeClass.bind(this, element,
                            directionClass + ' ' + direction, done);
                        element.addClass(direction);

                        $animateCss(element, { addClass: directionClass })
                            .start()
                            .done(removeClassFn);

                        return function () {
                            stopped = true;
                        };
                    }
                    done();
                },
                beforeRemoveClass: function (element, className, done) {
                    if (className === 'active') {
                        var stopped = false;
                        var direction = element.data(SLIDE_DIRECTION);
                        var directionClass = direction === 'next' ? 'left' : 'right';
                        var removeClassFn = removeClass.bind(this, element, directionClass, done);

                        $animateCss(element, { addClass: directionClass })
                            .start()
                            .done(removeClassFn);

                        return function () {
                            stopped = true;
                        };
                    }
                    done();
                }
            };
        }]);

angular.module('ui.bootstrap.dateparser', [])

    .service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', 'filterFilter', function ($log, $locale, dateFilter, orderByFilter, filterFilter) {
        // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js
        var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

        var localeId;
        var formatCodeToRegex;

        this.init = function () {
            localeId = $locale.id;

            this.parsers = {};
            this.formatters = {};

            formatCodeToRegex = [
                {
                    key: 'yyyy',
                    regex: '\\d{4}',
                    apply: function (value) { this.year = +value; },
                    formatter: function (date) {
                        var _date = new Date();
                        _date.setFullYear(Math.abs(date.getFullYear()));
                        return dateFilter(_date, 'yyyy');
                    }
                },
                {
                    key: 'yy',
                    regex: '\\d{2}',
                    apply: function (value) { value = +value; this.year = value < 69 ? value + 2000 : value + 1900; },
                    formatter: function (date) {
                        var _date = new Date();
                        _date.setFullYear(Math.abs(date.getFullYear()));
                        return dateFilter(_date, 'yy');
                    }
                },
                {
                    key: 'y',
                    regex: '\\d{1,4}',
                    apply: function (value) { this.year = +value; },
                    formatter: function (date) {
                        var _date = new Date();
                        _date.setFullYear(Math.abs(date.getFullYear()));
                        return dateFilter(_date, 'y');
                    }
                },
                {
                    key: 'M!',
                    regex: '0?[1-9]|1[0-2]',
                    apply: function (value) { this.month = value - 1; },
                    formatter: function (date) {
                        var value = date.getMonth();
                        if (/^[0-9]$/.test(value)) {
                            return dateFilter(date, 'MM');
                        }

                        return dateFilter(date, 'M');
                    }
                },
                {
                    key: 'MMMM',
                    regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
                    apply: function (value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); },
                    formatter: function (date) { return dateFilter(date, 'MMMM'); }
                },
                {
                    key: 'MMM',
                    regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
                    apply: function (value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); },
                    formatter: function (date) { return dateFilter(date, 'MMM'); }
                },
                {
                    key: 'MM',
                    regex: '0[1-9]|1[0-2]',
                    apply: function (value) { this.month = value - 1; },
                    formatter: function (date) { return dateFilter(date, 'MM'); }
                },
                {
                    key: 'M',
                    regex: '[1-9]|1[0-2]',
                    apply: function (value) { this.month = value - 1; },
                    formatter: function (date) { return dateFilter(date, 'M'); }
                },
                {
                    key: 'd!',
                    regex: '[0-2]?[0-9]{1}|3[0-1]{1}',
                    apply: function (value) { this.date = +value; },
                    formatter: function (date) {
                        var value = date.getDate();
                        if (/^[1-9]$/.test(value)) {
                            return dateFilter(date, 'dd');
                        }

                        return dateFilter(date, 'd');
                    }
                },
                {
                    key: 'dd',
                    regex: '[0-2][0-9]{1}|3[0-1]{1}',
                    apply: function (value) { this.date = +value; },
                    formatter: function (date) { return dateFilter(date, 'dd'); }
                },
                {
                    key: 'd',
                    regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
                    apply: function (value) { this.date = +value; },
                    formatter: function (date) { return dateFilter(date, 'd'); }
                },
                {
                    key: 'EEEE',
                    regex: $locale.DATETIME_FORMATS.DAY.join('|'),
                    formatter: function (date) { return dateFilter(date, 'EEEE'); }
                },
                {
                    key: 'EEE',
                    regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
                    formatter: function (date) { return dateFilter(date, 'EEE'); }
                },
                {
                    key: 'HH',
                    regex: '(?:0|1)[0-9]|2[0-3]',
                    apply: function (value) { this.hours = +value; },
                    formatter: function (date) { return dateFilter(date, 'HH'); }
                },
                {
                    key: 'hh',
                    regex: '0[0-9]|1[0-2]',
                    apply: function (value) { this.hours = +value; },
                    formatter: function (date) { return dateFilter(date, 'hh'); }
                },
                {
                    key: 'H',
                    regex: '1?[0-9]|2[0-3]',
                    apply: function (value) { this.hours = +value; },
                    formatter: function (date) { return dateFilter(date, 'H'); }
                },
                {
                    key: 'h',
                    regex: '[0-9]|1[0-2]',
                    apply: function (value) { this.hours = +value; },
                    formatter: function (date) { return dateFilter(date, 'h'); }
                },
                {
                    key: 'mm',
                    regex: '[0-5][0-9]',
                    apply: function (value) { this.minutes = +value; },
                    formatter: function (date) { return dateFilter(date, 'mm'); }
                },
                {
                    key: 'm',
                    regex: '[0-9]|[1-5][0-9]',
                    apply: function (value) { this.minutes = +value; },
                    formatter: function (date) { return dateFilter(date, 'm'); }
                },
                {
                    key: 'sss',
                    regex: '[0-9][0-9][0-9]',
                    apply: function (value) { this.milliseconds = +value; },
                    formatter: function (date) { return dateFilter(date, 'sss'); }
                },
                {
                    key: 'ss',
                    regex: '[0-5][0-9]',
                    apply: function (value) { this.seconds = +value; },
                    formatter: function (date) { return dateFilter(date, 'ss'); }
                },
                {
                    key: 's',
                    regex: '[0-9]|[1-5][0-9]',
                    apply: function (value) { this.seconds = +value; },
                    formatter: function (date) { return dateFilter(date, 's'); }
                },
                {
                    key: 'a',
                    regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
                    apply: function (value) {
                        if (this.hours === 12) {
                            this.hours = 0;
                        }

                        if (value === 'PM') {
                            this.hours += 12;
                        }
                    },
                    formatter: function (date) { return dateFilter(date, 'a'); }
                },
                {
                    key: 'Z',
                    regex: '[+-]\\d{4}',
                    apply: function (value) {
                        var matches = value.match(/([+-])(\d{2})(\d{2})/),
                            sign = matches[1],
                            hours = matches[2],
                            minutes = matches[3];
                        this.hours += toInt(sign + hours);
                        this.minutes += toInt(sign + minutes);
                    },
                    formatter: function (date) {
                        return dateFilter(date, 'Z');
                    }
                },
                {
                    key: 'ww',
                    regex: '[0-4][0-9]|5[0-3]',
                    formatter: function (date) { return dateFilter(date, 'ww'); }
                },
                {
                    key: 'w',
                    regex: '[0-9]|[1-4][0-9]|5[0-3]',
                    formatter: function (date) { return dateFilter(date, 'w'); }
                },
                {
                    key: 'GGGG',
                    regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s'),
                    formatter: function (date) { return dateFilter(date, 'GGGG'); }
                },
                {
                    key: 'GGG',
                    regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
                    formatter: function (date) { return dateFilter(date, 'GGG'); }
                },
                {
                    key: 'GG',
                    regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
                    formatter: function (date) { return dateFilter(date, 'GG'); }
                },
                {
                    key: 'G',
                    regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
                    formatter: function (date) { return dateFilter(date, 'G'); }
                }
            ];

            if (angular.version.major >= 1 && angular.version.minor > 4) {
                formatCodeToRegex.push({
                    key: 'LLLL',
                    regex: $locale.DATETIME_FORMATS.STANDALONEMONTH.join('|'),
                    apply: function (value) { this.month = $locale.DATETIME_FORMATS.STANDALONEMONTH.indexOf(value); },
                    formatter: function (date) { return dateFilter(date, 'LLLL'); }
                });
            }
        };

        this.init();

        function getFormatCodeToRegex(key) {
            return filterFilter(formatCodeToRegex, { key: key }, true)[0];
        }

        this.getParser = function (key) {
            var f = getFormatCodeToRegex(key);
            return f && f.apply || null;
        };

        this.overrideParser = function (key, parser) {
            var f = getFormatCodeToRegex(key);
            if (f && angular.isFunction(parser)) {
                this.parsers = {};
                f.apply = parser;
            }
        }.bind(this);

        function createParser(format) {
            var map = [], regex = format.split('');

            // check for literal values
            var quoteIndex = format.indexOf('\'');
            if (quoteIndex > -1) {
                var inLiteral = false;
                format = format.split('');
                for (var i = quoteIndex; i < format.length; i++) {
                    if (inLiteral) {
                        if (format[i] === '\'') {
                            if (i + 1 < format.length && format[i + 1] === '\'') { // escaped single quote
                                format[i + 1] = '$';
                                regex[i + 1] = '';
                            } else { // end of literal
                                regex[i] = '';
                                inLiteral = false;
                            }
                        }
                        format[i] = '$';
                    } else {
                        if (format[i] === '\'') { // start of literal
                            format[i] = '$';
                            regex[i] = '';
                            inLiteral = true;
                        }
                    }
                }

                format = format.join('');
            }

            angular.forEach(formatCodeToRegex, function (data) {
                var index = format.indexOf(data.key);

                if (index > -1) {
                    format = format.split('');

                    regex[index] = '(' + data.regex + ')';
                    format[index] = '$'; // Custom symbol to define consumed part of format
                    for (var i = index + 1, n = index + data.key.length; i < n; i++) {
                        regex[i] = '';
                        format[i] = '$';
                    }
                    format = format.join('');

                    map.push({
                        index: index,
                        key: data.key,
                        apply: data.apply,
                        matcher: data.regex
                    });
                }
            });

            return {
                regex: new RegExp('^' + regex.join('') + '$'),
                map: orderByFilter(map, 'index')
            };
        }

        function createFormatter(format) {
            var formatters = [];
            var i = 0;
            var formatter, literalIdx;
            while (i < format.length) {
                if (angular.isNumber(literalIdx)) {
                    if (format.charAt(i) === '\'') {
                        if (i + 1 >= format.length || format.charAt(i + 1) !== '\'') {
                            formatters.push(constructLiteralFormatter(format, literalIdx, i));
                            literalIdx = null;
                        }
                    } else if (i === format.length) {
                        while (literalIdx < format.length) {
                            formatter = constructFormatterFromIdx(format, literalIdx);
                            formatters.push(formatter);
                            literalIdx = formatter.endIdx;
                        }
                    }

                    i++;
                    continue;
                }

                if (format.charAt(i) === '\'') {
                    literalIdx = i;
                    i++;
                    continue;
                }

                formatter = constructFormatterFromIdx(format, i);

                formatters.push(formatter.parser);
                i = formatter.endIdx;
            }

            return formatters;
        }

        function constructLiteralFormatter(format, literalIdx, endIdx) {
            return function () {
                return format.substr(literalIdx + 1, endIdx - literalIdx - 1);
            };
        }

        function constructFormatterFromIdx(format, i) {
            var currentPosStr = format.substr(i);
            for (var j = 0; j < formatCodeToRegex.length; j++) {
                if (new RegExp('^' + formatCodeToRegex[j].key).test(currentPosStr)) {
                    var data = formatCodeToRegex[j];
                    return {
                        endIdx: i + data.key.length,
                        parser: data.formatter
                    };
                }
            }

            return {
                endIdx: i + 1,
                parser: function () {
                    return currentPosStr.charAt(0);
                }
            };
        }

        this.filter = function (date, format) {
            if (!angular.isDate(date) || isNaN(date) || !format) {
                return '';
            }

            format = $locale.DATETIME_FORMATS[format] || format;

            if ($locale.id !== localeId) {
                this.init();
            }

            if (!this.formatters[format]) {
                this.formatters[format] = createFormatter(format);
            }

            var formatters = this.formatters[format];

            return formatters.reduce(function (str, formatter) {
                return str + formatter(date);
            }, '');
        };

        this.parse = function (input, format, baseDate) {
            if (!angular.isString(input) || !format) {
                return input;
            }

            format = $locale.DATETIME_FORMATS[format] || format;
            format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');

            if ($locale.id !== localeId) {
                this.init();
            }

            if (!this.parsers[format]) {
                this.parsers[format] = createParser(format, 'apply');
            }

            var parser = this.parsers[format],
                regex = parser.regex,
                map = parser.map,
                results = input.match(regex),
                tzOffset = false;
            if (results && results.length) {
                var fields, dt;
                if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
                    fields = {
                        year: baseDate.getFullYear(),
                        month: baseDate.getMonth(),
                        date: baseDate.getDate(),
                        hours: baseDate.getHours(),
                        minutes: baseDate.getMinutes(),
                        seconds: baseDate.getSeconds(),
                        milliseconds: baseDate.getMilliseconds()
                    };
                } else {
                    if (baseDate) {
                        $log.warn('dateparser:', 'baseDate is not a valid date');
                    }
                    fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
                }

                for (var i = 1, n = results.length; i < n; i++) {
                    var mapper = map[i - 1];
                    if (mapper.matcher === 'Z') {
                        tzOffset = true;
                    }

                    if (mapper.apply) {
                        mapper.apply.call(fields, results[i]);
                    }
                }

                var datesetter = tzOffset ? Date.prototype.setUTCFullYear :
                    Date.prototype.setFullYear;
                var timesetter = tzOffset ? Date.prototype.setUTCHours :
                    Date.prototype.setHours;

                if (isValid(fields.year, fields.month, fields.date)) {
                    if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {
                        dt = new Date(baseDate);
                        datesetter.call(dt, fields.year, fields.month, fields.date);
                        timesetter.call(dt, fields.hours, fields.minutes,
                            fields.seconds, fields.milliseconds);
                    } else {
                        dt = new Date(0);
                        datesetter.call(dt, fields.year, fields.month, fields.date);
                        timesetter.call(dt, fields.hours || 0, fields.minutes || 0,
                            fields.seconds || 0, fields.milliseconds || 0);
                    }
                }

                return dt;
            }
        };

        // Check if date is valid for specific month (and year for February).
        // Month: 0 = Jan, 1 = Feb, etc
        function isValid(year, month, date) {
            if (date < 1) {
                return false;
            }

            if (month === 1 && date > 28) {
                return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
            }

            if (month === 3 || month === 5 || month === 8 || month === 10) {
                return date < 31;
            }

            return true;
        }

        function toInt(str) {
            return parseInt(str, 10);
        }

        this.toTimezone = toTimezone;
        this.fromTimezone = fromTimezone;
        this.timezoneToOffset = timezoneToOffset;
        this.addDateMinutes = addDateMinutes;
        this.convertTimezoneToLocal = convertTimezoneToLocal;

        function toTimezone(date, timezone) {
            return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
        }

        function fromTimezone(date, timezone) {
            return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;
        }

        //https://github.com/angular/angular.js/blob/622c42169699ec07fc6daaa19fe6d224e5d2f70e/src/Angular.js#L1207
        function timezoneToOffset(timezone, fallback) {
            timezone = timezone.replace(/:/g, '');
            var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
            return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
        }

        function addDateMinutes(date, minutes) {
            date = new Date(date.getTime());
            date.setMinutes(date.getMinutes() + minutes);
            return date;
        }

        function convertTimezoneToLocal(date, timezone, reverse) {
            reverse = reverse ? -1 : 1;
            var dateTimezoneOffset = date.getTimezoneOffset();
            var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
            return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
        }
    }]);

// Avoiding use of ng-class as it creates a lot of watchers when a class is to be applied to
// at most one element.
angular.module('ui.bootstrap.isClass', [])
    .directive('uibIsClass', [
        '$animate',
        function ($animate) {
            //                    11111111          22222222
            var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/;
            //                    11111111           22222222
            var IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;

            var dataPerTracked = {};

            return {
                restrict: 'A',
                compile: function (tElement, tAttrs) {
                    var linkedScopes = [];
                    var instances = [];
                    var expToData = {};
                    var lastActivated = null;
                    var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);
                    var onExp = onExpMatches[2];
                    var expsStr = onExpMatches[1];
                    var exps = expsStr.split(',');

                    return linkFn;

                    function linkFn(scope, element, attrs) {
                        linkedScopes.push(scope);
                        instances.push({
                            scope: scope,
                            element: element
                        });

                        exps.forEach(function (exp, k) {
                            addForExp(exp, scope);
                        });

                        scope.$on('$destroy', removeScope);
                    }

                    function addForExp(exp, scope) {
                        var matches = exp.match(IS_REGEXP);
                        var clazz = scope.$eval(matches[1]);
                        var compareWithExp = matches[2];
                        var data = expToData[exp];
                        if (!data) {
                            var watchFn = function (compareWithVal) {
                                var newActivated = null;
                                instances.some(function (instance) {
                                    var thisVal = instance.scope.$eval(onExp);
                                    if (thisVal === compareWithVal) {
                                        newActivated = instance;
                                        return true;
                                    }
                                });
                                if (data.lastActivated !== newActivated) {
                                    if (data.lastActivated) {
                                        $animate.removeClass(data.lastActivated.element, clazz);
                                    }
                                    if (newActivated) {
                                        $animate.addClass(newActivated.element, clazz);
                                    }
                                    data.lastActivated = newActivated;
                                }
                            };
                            expToData[exp] = data = {
                                lastActivated: null,
                                scope: scope,
                                watchFn: watchFn,
                                compareWithExp: compareWithExp,
                                watcher: scope.$watch(compareWithExp, watchFn)
                            };
                        }
                        data.watchFn(scope.$eval(compareWithExp));
                    }

                    function removeScope(e) {
                        var removedScope = e.targetScope;
                        var index = linkedScopes.indexOf(removedScope);
                        linkedScopes.splice(index, 1);
                        instances.splice(index, 1);
                        if (linkedScopes.length) {
                            var newWatchScope = linkedScopes[0];
                            angular.forEach(expToData, function (data) {
                                if (data.scope === removedScope) {
                                    data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);
                                    data.scope = newWatchScope;
                                }
                            });
                        } else {
                            expToData = {};
                        }
                    }
                }
            };
        }]);
angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass'])

    .value('$datepickerSuppressError', false)

    .value('$datepickerLiteralWarning', true)

    .constant('uibDatepickerConfig', {
        datepickerMode: 'day',
        formatDay: 'dd',
        formatMonth: 'MMMM',
        formatYear: 'yyyy',
        formatDayHeader: 'EEE',
        formatDayTitle: 'MMMM yyyy',
        formatMonthTitle: 'yyyy',
        maxDate: null,
        maxMode: 'year',
        minDate: null,
        minMode: 'day',
        monthColumns: 3,
        ngModelOptions: {},
        shortcutPropagation: false,
        showWeeks: true,
        yearColumns: 5,
        yearRows: 4
    })

    .controller('UibDatepickerController', ['$scope', '$element', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerLiteralWarning', '$datepickerSuppressError', 'uibDateParser',
        function ($scope, $element, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {
            var self = this,
                ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl;
                ngModelOptions = {},
                watchListeners = [];

            $element.addClass('uib-datepicker');
            $attrs.$set('role', 'application');

            if (!$scope.datepickerOptions) {
                $scope.datepickerOptions = {};
            }

            // Modes chain
            this.modes = ['day', 'month', 'year'];

            [
                'customClass',
                'dateDisabled',
                'datepickerMode',
                'formatDay',
                'formatDayHeader',
                'formatDayTitle',
                'formatMonth',
                'formatMonthTitle',
                'formatYear',
                'maxDate',
                'maxMode',
                'minDate',
                'minMode',
                'monthColumns',
                'showWeeks',
                'shortcutPropagation',
                'startingDay',
                'yearColumns',
                'yearRows'
            ].forEach(function (key) {
                switch (key) {
                    case 'customClass':
                    case 'dateDisabled':
                        $scope[key] = $scope.datepickerOptions[key] || angular.noop;
                        break;
                    case 'datepickerMode':
                        $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ?
                            $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;
                        break;
                    case 'formatDay':
                    case 'formatDayHeader':
                    case 'formatDayTitle':
                    case 'formatMonth':
                    case 'formatMonthTitle':
                    case 'formatYear':
                        self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
                            $interpolate($scope.datepickerOptions[key])($scope.$parent) :
                            datepickerConfig[key];
                        break;
                    case 'monthColumns':
                    case 'showWeeks':
                    case 'shortcutPropagation':
                    case 'yearColumns':
                    case 'yearRows':
                        self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
                            $scope.datepickerOptions[key] : datepickerConfig[key];
                        break;
                    case 'startingDay':
                        if (angular.isDefined($scope.datepickerOptions.startingDay)) {
                            self.startingDay = $scope.datepickerOptions.startingDay;
                        } else if (angular.isNumber(datepickerConfig.startingDay)) {
                            self.startingDay = datepickerConfig.startingDay;
                        } else {
                            self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
                        }

                        break;
                    case 'maxDate':
                    case 'minDate':
                        $scope.$watch('datepickerOptions.' + key, function (value) {
                            if (value) {
                                if (angular.isDate(value)) {
                                    self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.getOption('timezone'));
                                } else {
                                    if ($datepickerLiteralWarning) {
                                        $log.warn('Literal date support has been deprecated, please switch to date object usage');
                                    }

                                    self[key] = new Date(dateFilter(value, 'medium'));
                                }
                            } else {
                                self[key] = datepickerConfig[key] ?
                                    dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.getOption('timezone')) :
                                    null;
                            }

                            self.refreshView();
                        });

                        break;
                    case 'maxMode':
                    case 'minMode':
                        if ($scope.datepickerOptions[key]) {
                            $scope.$watch(function () { return $scope.datepickerOptions[key]; }, function (value) {
                                self[key] = $scope[key] = angular.isDefined(value) ? value : $scope.datepickerOptions[key];
                                if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) ||
                                    key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {
                                    $scope.datepickerMode = self[key];
                                    $scope.datepickerOptions.datepickerMode = self[key];
                                }
                            });
                        } else {
                            self[key] = $scope[key] = datepickerConfig[key] || null;
                        }

                        break;
                }
            });

            $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);

            $scope.disabled = angular.isDefined($attrs.disabled) || false;
            if (angular.isDefined($attrs.ngDisabled)) {
                watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function (disabled) {
                    $scope.disabled = disabled;
                    self.refreshView();
                }));
            }

            $scope.isActive = function (dateObject) {
                if (self.compare(dateObject.date, self.activeDate) === 0) {
                    $scope.activeDateId = dateObject.uid;
                    return true;
                }
                return false;
            };

            this.init = function (ngModelCtrl_) {
                ngModelCtrl = ngModelCtrl_;
                ngModelOptions = extractOptions(ngModelCtrl);

                if ($scope.datepickerOptions.initDate) {
                    self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.getOption('timezone')) || new Date();
                    $scope.$watch('datepickerOptions.initDate', function (initDate) {
                        if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
                            self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.getOption('timezone'));
                            self.refreshView();
                        }
                    });
                } else {
                    self.activeDate = new Date();
                }

                var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();
                this.activeDate = !isNaN(date) ?
                    dateParser.fromTimezone(date, ngModelOptions.getOption('timezone')) :
                    dateParser.fromTimezone(new Date(), ngModelOptions.getOption('timezone'));

                ngModelCtrl.$render = function () {
                    self.render();
                };
            };

            this.render = function () {
                if (ngModelCtrl.$viewValue) {
                    var date = new Date(ngModelCtrl.$viewValue),
                        isValid = !isNaN(date);

                    if (isValid) {
                        this.activeDate = dateParser.fromTimezone(date, ngModelOptions.getOption('timezone'));
                    } else if (!$datepickerSuppressError) {
                        $log.error('Datepicker directive: "ng-model" value must be a Date object');
                    }
                }
                this.refreshView();
            };

            this.refreshView = function () {
                if (this.element) {
                    $scope.selectedDt = null;
                    this._refreshView();
                    if ($scope.activeDt) {
                        $scope.activeDateId = $scope.activeDt.uid;
                    }

                    var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
                    date = dateParser.fromTimezone(date, ngModelOptions.getOption('timezone'));
                    ngModelCtrl.$setValidity('dateDisabled', !date ||
                        this.element && !this.isDisabled(date));
                }
            };

            this.createDateObject = function (date, format) {
                var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
                model = dateParser.fromTimezone(model, ngModelOptions.getOption('timezone'));
                var today = new Date();
                today = dateParser.fromTimezone(today, ngModelOptions.getOption('timezone'));
                var time = this.compare(date, today);
                var dt = {
                    date: date,
                    label: dateParser.filter(date, format),
                    selected: model && this.compare(date, model) === 0,
                    disabled: this.isDisabled(date),
                    past: time < 0,
                    current: time === 0,
                    future: time > 0,
                    customClass: this.customClass(date) || null
                };

                if (model && this.compare(date, model) === 0) {
                    $scope.selectedDt = dt;
                }

                if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {
                    $scope.activeDt = dt;
                }

                return dt;
            };

            this.isDisabled = function (date) {
                return $scope.disabled ||
                    this.minDate && this.compare(date, this.minDate) < 0 ||
                    this.maxDate && this.compare(date, this.maxDate) > 0 ||
                    $scope.dateDisabled && $scope.dateDisabled({ date: date, mode: $scope.datepickerMode });
            };

            this.customClass = function (date) {
                return $scope.customClass({ date: date, mode: $scope.datepickerMode });
            };

            // Split array into smaller arrays
            this.split = function (arr, size) {
                var arrays = [];
                while (arr.length > 0) {
                    arrays.push(arr.splice(0, size));
                }
                return arrays;
            };

            $scope.select = function (date) {
                if ($scope.datepickerMode === self.minMode) {
                    var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.getOption('timezone')) : new Date(0, 0, 0, 0, 0, 0, 0);
                    dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
                    dt = dateParser.toTimezone(dt, ngModelOptions.getOption('timezone'));
                    ngModelCtrl.$setViewValue(dt);
                    ngModelCtrl.$render();
                } else {
                    self.activeDate = date;
                    setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);

                    $scope.$emit('uib:datepicker.mode');
                }

                $scope.$broadcast('uib:datepicker.focus');
            };

            $scope.move = function (direction) {
                var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
                    month = self.activeDate.getMonth() + direction * (self.step.months || 0);
                self.activeDate.setFullYear(year, month, 1);
                self.refreshView();
            };

            $scope.toggleMode = function (direction) {
                direction = direction || 1;

                if ($scope.datepickerMode === self.maxMode && direction === 1 ||
                    $scope.datepickerMode === self.minMode && direction === -1) {
                    return;
                }

                setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);

                $scope.$emit('uib:datepicker.mode');
            };

            // Key event mapper
            $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };

            var focusElement = function () {
                self.element[0].focus();
            };

            // Listen for focus requests from popup directive
            $scope.$on('uib:datepicker.focus', focusElement);

            $scope.keydown = function (evt) {
                var key = $scope.keys[evt.which];

                if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {
                    return;
                }

                evt.preventDefault();
                if (!self.shortcutPropagation) {
                    evt.stopPropagation();
                }

                if (key === 'enter' || key === 'space') {
                    if (self.isDisabled(self.activeDate)) {
                        return; // do nothing
                    }
                    $scope.select(self.activeDate);
                } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
                    $scope.toggleMode(key === 'up' ? 1 : -1);
                } else {
                    self.handleKeyDown(key, evt);
                    self.refreshView();
                }
            };

            $element.on('keydown', function (evt) {
                $scope.$apply(function () {
                    $scope.keydown(evt);
                });
            });

            $scope.$on('$destroy', function () {
                //Clear all watch listeners on destroy
                while (watchListeners.length) {
                    watchListeners.shift()();
                }
            });

            function setMode(mode) {
                $scope.datepickerMode = mode;
                $scope.datepickerOptions.datepickerMode = mode;
            }

            function extractOptions(ngModelCtrl) {
                var ngModelOptions;

                if (angular.version.minor < 6) { // in angular < 1.6 $options could be missing
                    // guarantee a value
                    ngModelOptions = ngModelCtrl.$options ||
                        $scope.datepickerOptions.ngModelOptions ||
                        datepickerConfig.ngModelOptions ||
                        {};

                    // mimic 1.6+ api
                    ngModelOptions.getOption = function (key) {
                        return ngModelOptions[key];
                    };
                } else { // in angular >=1.6 $options is always present
                    // ng-model-options defaults timezone to null; don't let its precedence squash a non-null value
                    var timezone = ngModelCtrl.$options.getOption('timezone') ||
                        ($scope.datepickerOptions.ngModelOptions ? $scope.datepickerOptions.ngModelOptions.timezone : null) ||
                        (datepickerConfig.ngModelOptions ? datepickerConfig.ngModelOptions.timezone : null);

                    // values passed to createChild override existing values
                    ngModelOptions = ngModelCtrl.$options // start with a ModelOptions instance
                        .createChild(datepickerConfig.ngModelOptions) // lowest precedence
                        .createChild($scope.datepickerOptions.ngModelOptions)
                        .createChild(ngModelCtrl.$options) // highest precedence
                        .createChild({ timezone: timezone }); // to keep from squashing a non-null value
                }

                return ngModelOptions;
            }
        }])

    .controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function (scope, $element, dateFilter) {
        var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

        this.step = { months: 1 };
        this.element = $element;
        function getDaysInMonth(year, month) {
            return month === 1 && year % 4 === 0 &&
                (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
        }

        this.init = function (ctrl) {
            angular.extend(ctrl, this);
            scope.showWeeks = ctrl.showWeeks;
            ctrl.refreshView();
        };

        this.getDates = function (startDate, n) {
            var dates = new Array(n), current = new Date(startDate), i = 0, date;
            while (i < n) {
                date = new Date(current);
                dates[i++] = date;
                current.setDate(current.getDate() + 1);
            }
            return dates;
        };

        this._refreshView = function () {
            var year = this.activeDate.getFullYear(),
                month = this.activeDate.getMonth(),
                firstDayOfMonth = new Date(this.activeDate);

            firstDayOfMonth.setFullYear(year, month, 1);

            var difference = this.startingDay - firstDayOfMonth.getDay(),
                numDisplayedFromPreviousMonth = difference > 0 ?
                    7 - difference : - difference,
                firstDate = new Date(firstDayOfMonth);

            if (numDisplayedFromPreviousMonth > 0) {
                firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
            }

            // 42 is the number of days on a six-week calendar
            var days = this.getDates(firstDate, 42);
            for (var i = 0; i < 42; i++) {
                days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
                    secondary: days[i].getMonth() !== month,
                    uid: scope.uniqueId + '-' + i
                });
            }

            scope.labels = new Array(7);
            for (var j = 0; j < 7; j++) {
                scope.labels[j] = {
                    abbr: dateFilter(days[j].date, this.formatDayHeader),
                    full: dateFilter(days[j].date, 'EEEE')
                };
            }

            scope.title = dateFilter(this.activeDate, this.formatDayTitle);
            scope.rows = this.split(days, 7);

            if (scope.showWeeks) {
                scope.weekNumbers = [];
                var thursdayIndex = (4 + 7 - this.startingDay) % 7,
                    numWeeks = scope.rows.length;
                for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
                    scope.weekNumbers.push(
                        getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
                }
            }
        };

        this.compare = function (date1, date2) {
            var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());
            var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
            _date1.setFullYear(date1.getFullYear());
            _date2.setFullYear(date2.getFullYear());
            return _date1 - _date2;
        };

        function getISO8601WeekNumber(date) {
            var checkDate = new Date(date);
            checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
            var time = checkDate.getTime();
            checkDate.setMonth(0); // Compare with Jan 1
            checkDate.setDate(1);
            return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
        }

        this.handleKeyDown = function (key, evt) {
            var date = this.activeDate.getDate();

            if (key === 'left') {
                date = date - 1;
            } else if (key === 'up') {
                date = date - 7;
            } else if (key === 'right') {
                date = date + 1;
            } else if (key === 'down') {
                date = date + 7;
            } else if (key === 'pageup' || key === 'pagedown') {
                var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);
                this.activeDate.setMonth(month, 1);
                date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
            } else if (key === 'home') {
                date = 1;
            } else if (key === 'end') {
                date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
            }
            this.activeDate.setDate(date);
        };
    }])

    .controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function (scope, $element, dateFilter) {
        this.step = { years: 1 };
        this.element = $element;

        this.init = function (ctrl) {
            angular.extend(ctrl, this);
            ctrl.refreshView();
        };

        this._refreshView = function () {
            var months = new Array(12),
                year = this.activeDate.getFullYear(),
                date;

            for (var i = 0; i < 12; i++) {
                date = new Date(this.activeDate);
                date.setFullYear(year, i, 1);
                months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
                    uid: scope.uniqueId + '-' + i
                });
            }

            scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
            scope.rows = this.split(months, this.monthColumns);
            scope.yearHeaderColspan = this.monthColumns > 3 ? this.monthColumns - 2 : 1;
        };

        this.compare = function (date1, date2) {
            var _date1 = new Date(date1.getFullYear(), date1.getMonth());
            var _date2 = new Date(date2.getFullYear(), date2.getMonth());
            _date1.setFullYear(date1.getFullYear());
            _date2.setFullYear(date2.getFullYear());
            return _date1 - _date2;
        };

        this.handleKeyDown = function (key, evt) {
            var date = this.activeDate.getMonth();

            if (key === 'left') {
                date = date - 1;
            } else if (key === 'up') {
                date = date - this.monthColumns;
            } else if (key === 'right') {
                date = date + 1;
            } else if (key === 'down') {
                date = date + this.monthColumns;
            } else if (key === 'pageup' || key === 'pagedown') {
                var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);
                this.activeDate.setFullYear(year);
            } else if (key === 'home') {
                date = 0;
            } else if (key === 'end') {
                date = 11;
            }
            this.activeDate.setMonth(date);
        };
    }])

    .controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function (scope, $element, dateFilter) {
        var columns, range;
        this.element = $element;

        function getStartingYear(year) {
            return parseInt((year - 1) / range, 10) * range + 1;
        }

        this.yearpickerInit = function () {
            columns = this.yearColumns;
            range = this.yearRows * columns;
            this.step = { years: range };
        };

        this._refreshView = function () {
            var years = new Array(range), date;

            for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {
                date = new Date(this.activeDate);
                date.setFullYear(start + i, 0, 1);
                years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
                    uid: scope.uniqueId + '-' + i
                });
            }

            scope.title = [years[0].label, years[range - 1].label].join(' - ');
            scope.rows = this.split(years, columns);
            scope.columns = columns;
        };

        this.compare = function (date1, date2) {
            return date1.getFullYear() - date2.getFullYear();
        };

        this.handleKeyDown = function (key, evt) {
            var date = this.activeDate.getFullYear();

            if (key === 'left') {
                date = date - 1;
            } else if (key === 'up') {
                date = date - columns;
            } else if (key === 'right') {
                date = date + 1;
            } else if (key === 'down') {
                date = date + columns;
            } else if (key === 'pageup' || key === 'pagedown') {
                date += (key === 'pageup' ? - 1 : 1) * range;
            } else if (key === 'home') {
                date = getStartingYear(this.activeDate.getFullYear());
            } else if (key === 'end') {
                date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
            }
            this.activeDate.setFullYear(date);
        };
    }])

    .directive('uibDatepicker', function () {
        return {
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';
            },
            scope: {
                datepickerOptions: '=?'
            },
            require: ['uibDatepicker', '^ngModel'],
            restrict: 'A',
            controller: 'UibDatepickerController',
            controllerAs: 'datepicker',
            link: function (scope, element, attrs, ctrls) {
                var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

                datepickerCtrl.init(ngModelCtrl);
            }
        };
    })

    .directive('uibDaypicker', function () {
        return {
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/datepicker/day.html';
            },
            require: ['^uibDatepicker', 'uibDaypicker'],
            restrict: 'A',
            controller: 'UibDaypickerController',
            link: function (scope, element, attrs, ctrls) {
                var datepickerCtrl = ctrls[0],
                    daypickerCtrl = ctrls[1];

                daypickerCtrl.init(datepickerCtrl);
            }
        };
    })

    .directive('uibMonthpicker', function () {
        return {
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/datepicker/month.html';
            },
            require: ['^uibDatepicker', 'uibMonthpicker'],
            restrict: 'A',
            controller: 'UibMonthpickerController',
            link: function (scope, element, attrs, ctrls) {
                var datepickerCtrl = ctrls[0],
                    monthpickerCtrl = ctrls[1];

                monthpickerCtrl.init(datepickerCtrl);
            }
        };
    })

    .directive('uibYearpicker', function () {
        return {
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/datepicker/year.html';
            },
            require: ['^uibDatepicker', 'uibYearpicker'],
            restrict: 'A',
            controller: 'UibYearpickerController',
            link: function (scope, element, attrs, ctrls) {
                var ctrl = ctrls[0];
                angular.extend(ctrl, ctrls[1]);
                ctrl.yearpickerInit();

                ctrl.refreshView();
            }
        };
    });

angular.module('ui.bootstrap.position', [])

    /**
     * A set of utility methods for working with the DOM.
     * It is meant to be used where we need to absolute-position elements in
     * relation to another element (this is the case for tooltips, popovers,
     * typeahead suggestions etc.).
     */
    .factory('$uibPosition', ['$document', '$window', function ($document, $window) {
        /**
         * Used by scrollbarWidth() function to cache scrollbar's width.
         * Do not access this variable directly, use scrollbarWidth() instead.
         */
        var SCROLLBAR_WIDTH;
        /**
         * scrollbar on body and html element in IE and Edge overlay
         * content and should be considered 0 width.
         */
        var BODY_SCROLLBAR_WIDTH;
        var OVERFLOW_REGEX = {
            normal: /(auto|scroll)/,
            hidden: /(auto|scroll|hidden)/
        };
        var PLACEMENT_REGEX = {
            auto: /\s?auto?\s?/i,
            primary: /^(top|bottom|left|right)$/,
            secondary: /^(top|bottom|left|right|center)$/,
            vertical: /^(top|bottom)$/
        };
        var BODY_REGEX = /(HTML|BODY)/;

        return {

            /**
             * Provides a raw DOM element from a jQuery/jQLite element.
             *
             * @param {element} elem - The element to convert.
             *
             * @returns {element} A HTML element.
             */
            getRawNode: function (elem) {
                return elem.nodeName ? elem : elem[0] || elem;
            },

            /**
             * Provides a parsed number for a style property.  Strips
             * units and casts invalid numbers to 0.
             *
             * @param {string} value - The style value to parse.
             *
             * @returns {number} A valid number.
             */
            parseStyle: function (value) {
                value = parseFloat(value);
                return isFinite(value) ? value : 0;
            },

            /**
             * Provides the closest positioned ancestor.
             *
             * @param {element} element - The element to get the offest parent for.
             *
             * @returns {element} The closest positioned ancestor.
             */
            offsetParent: function (elem) {
                elem = this.getRawNode(elem);

                var offsetParent = elem.offsetParent || $document[0].documentElement;

                function isStaticPositioned(el) {
                    return ($window.getComputedStyle(el).position || 'static') === 'static';
                }

                while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {
                    offsetParent = offsetParent.offsetParent;
                }

                return offsetParent || $document[0].documentElement;
            },

            /**
             * Provides the scrollbar width, concept from TWBS measureScrollbar()
             * function in https://github.com/twbs/bootstrap/blob/master/js/modal.js
             * In IE and Edge, scollbar on body and html element overlay and should
             * return a width of 0.
             *
             * @returns {number} The width of the browser scollbar.
             */
            scrollbarWidth: function (isBody) {
                if (isBody) {
                    if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {
                        var bodyElem = $document.find('body');
                        bodyElem.addClass('uib-position-body-scrollbar-measure');
                        BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;
                        BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0;
                        bodyElem.removeClass('uib-position-body-scrollbar-measure');
                    }
                    return BODY_SCROLLBAR_WIDTH;
                }

                if (angular.isUndefined(SCROLLBAR_WIDTH)) {
                    var scrollElem = angular.element('<div class="uib-position-scrollbar-measure"></div>');
                    $document.find('body').append(scrollElem);
                    SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;
                    SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;
                    scrollElem.remove();
                }

                return SCROLLBAR_WIDTH;
            },

            /**
             * Provides the padding required on an element to replace the scrollbar.
             *
             * @returns {object} An object with the following properties:
             *   <ul>
             *     <li>**scrollbarWidth**: the width of the scrollbar</li>
             *     <li>**widthOverflow**: whether the the width is overflowing</li>
             *     <li>**right**: the amount of right padding on the element needed to replace the scrollbar</li>
             *     <li>**rightOriginal**: the amount of right padding currently on the element</li>
             *     <li>**heightOverflow**: whether the the height is overflowing</li>
             *     <li>**bottom**: the amount of bottom padding on the element needed to replace the scrollbar</li>
             *     <li>**bottomOriginal**: the amount of bottom padding currently on the element</li>
             *   </ul>
             */
            scrollbarPadding: function (elem) {
                elem = this.getRawNode(elem);

                var elemStyle = $window.getComputedStyle(elem);
                var paddingRight = this.parseStyle(elemStyle.paddingRight);
                var paddingBottom = this.parseStyle(elemStyle.paddingBottom);
                var scrollParent = this.scrollParent(elem, false, true);
                var scrollbarWidth = this.scrollbarWidth(BODY_REGEX.test(scrollParent.tagName));

                return {
                    scrollbarWidth: scrollbarWidth,
                    widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,
                    right: paddingRight + scrollbarWidth,
                    originalRight: paddingRight,
                    heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,
                    bottom: paddingBottom + scrollbarWidth,
                    originalBottom: paddingBottom
                };
            },

            /**
             * Checks to see if the element is scrollable.
             *
             * @param {element} elem - The element to check.
             * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,
             *   default is false.
             *
             * @returns {boolean} Whether the element is scrollable.
             */
            isScrollable: function (elem, includeHidden) {
                elem = this.getRawNode(elem);

                var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
                var elemStyle = $window.getComputedStyle(elem);
                return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);
            },

            /**
             * Provides the closest scrollable ancestor.
             * A port of the jQuery UI scrollParent method:
             * https://github.com/jquery/jquery-ui/blob/master/ui/scroll-parent.js
             *
             * @param {element} elem - The element to find the scroll parent of.
             * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,
             *   default is false.
             * @param {boolean=} [includeSelf=false] - Should the element being passed be
             * included in the scrollable llokup.
             *
             * @returns {element} A HTML element.
             */
            scrollParent: function (elem, includeHidden, includeSelf) {
                elem = this.getRawNode(elem);

                var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
                var documentEl = $document[0].documentElement;
                var elemStyle = $window.getComputedStyle(elem);
                if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) {
                    return elem;
                }
                var excludeStatic = elemStyle.position === 'absolute';
                var scrollParent = elem.parentElement || documentEl;

                if (scrollParent === documentEl || elemStyle.position === 'fixed') {
                    return documentEl;
                }

                while (scrollParent.parentElement && scrollParent !== documentEl) {
                    var spStyle = $window.getComputedStyle(scrollParent);
                    if (excludeStatic && spStyle.position !== 'static') {
                        excludeStatic = false;
                    }

                    if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {
                        break;
                    }
                    scrollParent = scrollParent.parentElement;
                }

                return scrollParent;
            },

            /**
             * Provides read-only equivalent of jQuery's position function:
             * http://api.jquery.com/position/ - distance to closest positioned
             * ancestor.  Does not account for margins by default like jQuery position.
             *
             * @param {element} elem - The element to caclulate the position on.
             * @param {boolean=} [includeMargins=false] - Should margins be accounted
             * for, default is false.
             *
             * @returns {object} An object with the following properties:
             *   <ul>
             *     <li>**width**: the width of the element</li>
             *     <li>**height**: the height of the element</li>
             *     <li>**top**: distance to top edge of offset parent</li>
             *     <li>**left**: distance to left edge of offset parent</li>
             *   </ul>
             */
            position: function (elem, includeMagins) {
                elem = this.getRawNode(elem);

                var elemOffset = this.offset(elem);
                if (includeMagins) {
                    var elemStyle = $window.getComputedStyle(elem);
                    elemOffset.top -= this.parseStyle(elemStyle.marginTop);
                    elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
                }
                var parent = this.offsetParent(elem);
                var parentOffset = { top: 0, left: 0 };

                if (parent !== $document[0].documentElement) {
                    parentOffset = this.offset(parent);
                    parentOffset.top += parent.clientTop - parent.scrollTop;
                    parentOffset.left += parent.clientLeft - parent.scrollLeft;
                }

                return {
                    width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
                    height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
                    top: Math.round(elemOffset.top - parentOffset.top),
                    left: Math.round(elemOffset.left - parentOffset.left)
                };
            },

            /**
             * Provides read-only equivalent of jQuery's offset function:
             * http://api.jquery.com/offset/ - distance to viewport.  Does
             * not account for borders, margins, or padding on the body
             * element.
             *
             * @param {element} elem - The element to calculate the offset on.
             *
             * @returns {object} An object with the following properties:
             *   <ul>
             *     <li>**width**: the width of the element</li>
             *     <li>**height**: the height of the element</li>
             *     <li>**top**: distance to top edge of viewport</li>
             *     <li>**right**: distance to bottom edge of viewport</li>
             *   </ul>
             */
            offset: function (elem) {
                elem = this.getRawNode(elem);

                var elemBCR = elem.getBoundingClientRect();
                return {
                    width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
                    height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
                    top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
                    left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
                };
            },

            /**
             * Provides offset distance to the closest scrollable ancestor
             * or viewport.  Accounts for border and scrollbar width.
             *
             * Right and bottom dimensions represent the distance to the
             * respective edge of the viewport element.  If the element
             * edge extends beyond the viewport, a negative value will be
             * reported.
             *
             * @param {element} elem - The element to get the viewport offset for.
             * @param {boolean=} [useDocument=false] - Should the viewport be the document element instead
             * of the first scrollable element, default is false.
             * @param {boolean=} [includePadding=true] - Should the padding on the offset parent element
             * be accounted for, default is true.
             *
             * @returns {object} An object with the following properties:
             *   <ul>
             *     <li>**top**: distance to the top content edge of viewport element</li>
             *     <li>**bottom**: distance to the bottom content edge of viewport element</li>
             *     <li>**left**: distance to the left content edge of viewport element</li>
             *     <li>**right**: distance to the right content edge of viewport element</li>
             *   </ul>
             */
            viewportOffset: function (elem, useDocument, includePadding) {
                elem = this.getRawNode(elem);
                includePadding = includePadding !== false ? true : false;

                var elemBCR = elem.getBoundingClientRect();
                var offsetBCR = { top: 0, left: 0, bottom: 0, right: 0 };

                var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);
                var offsetParentBCR = offsetParent.getBoundingClientRect();

                offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;
                offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;
                if (offsetParent === $document[0].documentElement) {
                    offsetBCR.top += $window.pageYOffset;
                    offsetBCR.left += $window.pageXOffset;
                }
                offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;
                offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;

                if (includePadding) {
                    var offsetParentStyle = $window.getComputedStyle(offsetParent);
                    offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);
                    offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);
                    offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);
                    offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
                }

                return {
                    top: Math.round(elemBCR.top - offsetBCR.top),
                    bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
                    left: Math.round(elemBCR.left - offsetBCR.left),
                    right: Math.round(offsetBCR.right - elemBCR.right)
                };
            },

            /**
             * Provides an array of placement values parsed from a placement string.
             * Along with the 'auto' indicator, supported placement strings are:
             *   <ul>
             *     <li>top: element on top, horizontally centered on host element.</li>
             *     <li>top-left: element on top, left edge aligned with host element left edge.</li>
             *     <li>top-right: element on top, lerightft edge aligned with host element right edge.</li>
             *     <li>bottom: element on bottom, horizontally centered on host element.</li>
             *     <li>bottom-left: element on bottom, left edge aligned with host element left edge.</li>
             *     <li>bottom-right: element on bottom, right edge aligned with host element right edge.</li>
             *     <li>left: element on left, vertically centered on host element.</li>
             *     <li>left-top: element on left, top edge aligned with host element top edge.</li>
             *     <li>left-bottom: element on left, bottom edge aligned with host element bottom edge.</li>
             *     <li>right: element on right, vertically centered on host element.</li>
             *     <li>right-top: element on right, top edge aligned with host element top edge.</li>
             *     <li>right-bottom: element on right, bottom edge aligned with host element bottom edge.</li>
             *   </ul>
             * A placement string with an 'auto' indicator is expected to be
             * space separated from the placement, i.e: 'auto bottom-left'  If
             * the primary and secondary placement values do not match 'top,
             * bottom, left, right' then 'top' will be the primary placement and
             * 'center' will be the secondary placement.  If 'auto' is passed, true
             * will be returned as the 3rd value of the array.
             *
             * @param {string} placement - The placement string to parse.
             *
             * @returns {array} An array with the following values
             * <ul>
             *   <li>**[0]**: The primary placement.</li>
             *   <li>**[1]**: The secondary placement.</li>
             *   <li>**[2]**: If auto is passed: true, else undefined.</li>
             * </ul>
             */
            parsePlacement: function (placement) {
                var autoPlace = PLACEMENT_REGEX.auto.test(placement);
                if (autoPlace) {
                    placement = placement.replace(PLACEMENT_REGEX.auto, '');
                }

                placement = placement.split('-');

                placement[0] = placement[0] || 'top';
                if (!PLACEMENT_REGEX.primary.test(placement[0])) {
                    placement[0] = 'top';
                }

                placement[1] = placement[1] || 'center';
                if (!PLACEMENT_REGEX.secondary.test(placement[1])) {
                    placement[1] = 'center';
                }

                if (autoPlace) {
                    placement[2] = true;
                } else {
                    placement[2] = false;
                }

                return placement;
            },

            /**
             * Provides coordinates for an element to be positioned relative to
             * another element.  Passing 'auto' as part of the placement parameter
             * will enable smart placement - where the element fits. i.e:
             * 'auto left-top' will check to see if there is enough space to the left
             * of the hostElem to fit the targetElem, if not place right (same for secondary
             * top placement).  Available space is calculated using the viewportOffset
             * function.
             *
             * @param {element} hostElem - The element to position against.
             * @param {element} targetElem - The element to position.
             * @param {string=} [placement=top] - The placement for the targetElem,
             *   default is 'top'. 'center' is assumed as secondary placement for
             *   'top', 'left', 'right', and 'bottom' placements.  Available placements are:
             *   <ul>
             *     <li>top</li>
             *     <li>top-right</li>
             *     <li>top-left</li>
             *     <li>bottom</li>
             *     <li>bottom-left</li>
             *     <li>bottom-right</li>
             *     <li>left</li>
             *     <li>left-top</li>
             *     <li>left-bottom</li>
             *     <li>right</li>
             *     <li>right-top</li>
             *     <li>right-bottom</li>
             *   </ul>
             * @param {boolean=} [appendToBody=false] - Should the top and left values returned
             *   be calculated from the body element, default is false.
             *
             * @returns {object} An object with the following properties:
             *   <ul>
             *     <li>**top**: Value for targetElem top.</li>
             *     <li>**left**: Value for targetElem left.</li>
             *     <li>**placement**: The resolved placement.</li>
             *   </ul>
             */
            positionElements: function (hostElem, targetElem, placement, appendToBody) {
                hostElem = this.getRawNode(hostElem);
                targetElem = this.getRawNode(targetElem);

                // need to read from prop to support tests.
                var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');
                var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');

                placement = this.parsePlacement(placement);

                var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);
                var targetElemPos = { top: 0, left: 0, placement: '' };

                if (placement[2]) {
                    var viewportOffset = this.viewportOffset(hostElem, appendToBody);

                    var targetElemStyle = $window.getComputedStyle(targetElem);
                    var adjustedSize = {
                        width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
                        height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
                    };

                    placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' :
                        placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' :
                            placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' :
                                placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' :
                                    placement[0];

                    placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' :
                        placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' :
                            placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' :
                                placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' :
                                    placement[1];

                    if (placement[1] === 'center') {
                        if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                            var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
                            if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {
                                placement[1] = 'left';
                            } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {
                                placement[1] = 'right';
                            }
                        } else {
                            var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
                            if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {
                                placement[1] = 'top';
                            } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {
                                placement[1] = 'bottom';
                            }
                        }
                    }
                }

                switch (placement[0]) {
                    case 'top':
                        targetElemPos.top = hostElemPos.top - targetHeight;
                        break;
                    case 'bottom':
                        targetElemPos.top = hostElemPos.top + hostElemPos.height;
                        break;
                    case 'left':
                        targetElemPos.left = hostElemPos.left - targetWidth;
                        break;
                    case 'right':
                        targetElemPos.left = hostElemPos.left + hostElemPos.width;
                        break;
                }

                switch (placement[1]) {
                    case 'top':
                        targetElemPos.top = hostElemPos.top;
                        break;
                    case 'bottom':
                        targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
                        break;
                    case 'left':
                        targetElemPos.left = hostElemPos.left;
                        break;
                    case 'right':
                        targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
                        break;
                    case 'center':
                        if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                            targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;
                        } else {
                            targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
                        }
                        break;
                }

                targetElemPos.top = Math.round(targetElemPos.top);
                targetElemPos.left = Math.round(targetElemPos.left);
                targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];

                return targetElemPos;
            },

            /**
             * Provides a way to adjust the top positioning after first
             * render to correctly align element to top after content
             * rendering causes resized element height
             *
             * @param {array} placementClasses - The array of strings of classes
             * element should have.
             * @param {object} containerPosition - The object with container
             * position information
             * @param {number} initialHeight - The initial height for the elem.
             * @param {number} currentHeight - The current height for the elem.
             */
            adjustTop: function (placementClasses, containerPosition, initialHeight, currentHeight) {
                if (placementClasses.indexOf('top') !== -1 && initialHeight !== currentHeight) {
                    return {
                        top: containerPosition.top - currentHeight + 'px'
                    };
                }
            },

            /**
             * Provides a way for positioning tooltip & dropdown
             * arrows when using placement options beyond the standard
             * left, right, top, or bottom.
             *
             * @param {element} elem - The tooltip/dropdown element.
             * @param {string} placement - The placement for the elem.
             */
            positionArrow: function (elem, placement) {
                elem = this.getRawNode(elem);

                var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');
                if (!innerElem) {
                    return;
                }

                var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');

                var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');
                if (!arrowElem) {
                    return;
                }

                var arrowCss = {
                    top: '',
                    bottom: '',
                    left: '',
                    right: ''
                };

                placement = this.parsePlacement(placement);
                if (placement[1] === 'center') {
                    // no adjustment necessary - just reset styles
                    angular.element(arrowElem).css(arrowCss);
                    return;
                }

                var borderProp = 'border-' + placement[0] + '-width';
                var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];

                var borderRadiusProp = 'border-';
                if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                    borderRadiusProp += placement[0] + '-' + placement[1];
                } else {
                    borderRadiusProp += placement[1] + '-' + placement[0];
                }
                borderRadiusProp += '-radius';
                var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];

                switch (placement[0]) {
                    case 'top':
                        arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;
                        break;
                    case 'bottom':
                        arrowCss.top = isTooltip ? '0' : '-' + borderWidth;
                        break;
                    case 'left':
                        arrowCss.right = isTooltip ? '0' : '-' + borderWidth;
                        break;
                    case 'right':
                        arrowCss.left = isTooltip ? '0' : '-' + borderWidth;
                        break;
                }

                arrowCss[placement[1]] = borderRadius;

                angular.element(arrowElem).css(arrowCss);
            }
        };
    }]);

angular.module('ui.bootstrap.datepickerPopup', ['ui.bootstrap.datepicker', 'ui.bootstrap.position'])

    .value('$datepickerPopupLiteralWarning', true)

    .constant('uibDatepickerPopupConfig', {
        altInputFormats: [],
        appendToBody: false,
        clearText: 'Clear',
        closeOnDateSelection: true,
        closeText: 'Done',
        currentText: 'Today',
        datepickerPopup: 'yyyy-MM-dd',
        datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html',
        datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',
        html5Types: {
            date: 'yyyy-MM-dd',
            'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
            'month': 'yyyy-MM'
        },
        onOpenFocus: true,
        showButtonBar: true,
        placement: 'auto bottom-left'
    })

    .controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', '$datepickerPopupLiteralWarning',
        function ($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {
            var cache = {},
                isHtml5DateInput = false;
            var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,
                datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl,
                ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [];

            this.init = function (_ngModel_) {
                ngModel = _ngModel_;
                ngModelOptions = extractOptions(ngModel);
                closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ?
                    $scope.$parent.$eval($attrs.closeOnDateSelection) :
                    datepickerPopupConfig.closeOnDateSelection;
                appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ?
                    $scope.$parent.$eval($attrs.datepickerAppendToBody) :
                    datepickerPopupConfig.appendToBody;
                onOpenFocus = angular.isDefined($attrs.onOpenFocus) ?
                    $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
                datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ?
                    $attrs.datepickerPopupTemplateUrl :
                    datepickerPopupConfig.datepickerPopupTemplateUrl;
                datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ?
                    $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
                altInputFormats = angular.isDefined($attrs.altInputFormats) ?
                    $scope.$parent.$eval($attrs.altInputFormats) :
                    datepickerPopupConfig.altInputFormats;

                $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ?
                    $scope.$parent.$eval($attrs.showButtonBar) :
                    datepickerPopupConfig.showButtonBar;

                if (datepickerPopupConfig.html5Types[$attrs.type]) {
                    dateFormat = datepickerPopupConfig.html5Types[$attrs.type];
                    isHtml5DateInput = true;
                } else {
                    dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
                    $attrs.$observe('uibDatepickerPopup', function (value, oldValue) {
                        var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
                        // Invalidate the $modelValue to ensure that formatters re-run
                        // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764
                        if (newDateFormat !== dateFormat) {
                            dateFormat = newDateFormat;
                            ngModel.$modelValue = null;

                            if (!dateFormat) {
                                throw new Error('uibDatepickerPopup must have a date format specified.');
                            }
                        }
                    });
                }

                if (!dateFormat) {
                    throw new Error('uibDatepickerPopup must have a date format specified.');
                }

                if (isHtml5DateInput && $attrs.uibDatepickerPopup) {
                    throw new Error('HTML5 date input types do not support custom formats.');
                }

                // popup element used to display calendar
                popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');

                popupEl.attr({
                    'ng-model': 'date',
                    'ng-change': 'dateSelection(date)',
                    'template-url': datepickerPopupTemplateUrl
                });

                // datepicker element
                datepickerEl = angular.element(popupEl.children()[0]);
                datepickerEl.attr('template-url', datepickerTemplateUrl);

                if (!$scope.datepickerOptions) {
                    $scope.datepickerOptions = {};
                }

                if (isHtml5DateInput) {
                    if ($attrs.type === 'month') {
                        $scope.datepickerOptions.datepickerMode = 'month';
                        $scope.datepickerOptions.minMode = 'month';
                    }
                }

                datepickerEl.attr('datepicker-options', 'datepickerOptions');

                if (!isHtml5DateInput) {
                    // Internal API to maintain the correct ng-invalid-[key] class
                    ngModel.$$parserName = 'date';
                    ngModel.$validators.date = validator;
                    ngModel.$parsers.unshift(parseDate);
                    ngModel.$formatters.push(function (value) {
                        if (ngModel.$isEmpty(value)) {
                            $scope.date = value;
                            return value;
                        }

                        if (angular.isNumber(value)) {
                            value = new Date(value);
                        }

                        $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption('timezone'));

                        return dateParser.filter($scope.date, dateFormat);
                    });
                } else {
                    ngModel.$formatters.push(function (value) {
                        $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption('timezone'));
                        return value;
                    });
                }

                // Detect changes in the view from the text box
                ngModel.$viewChangeListeners.push(function () {
                    $scope.date = parseDateString(ngModel.$viewValue);
                });

                $element.on('keydown', inputKeydownBind);

                $popup = $compile(popupEl)($scope);
                // Prevent jQuery cache memory leak (template is now redundant after linking)
                popupEl.remove();

                if (appendToBody) {
                    $document.find('body').append($popup);
                } else {
                    $element.after($popup);
                }

                $scope.$on('$destroy', function () {
                    if ($scope.isOpen === true) {
                        if (!$rootScope.$$phase) {
                            $scope.$apply(function () {
                                $scope.isOpen = false;
                            });
                        }
                    }

                    $popup.remove();
                    $element.off('keydown', inputKeydownBind);
                    $document.off('click', documentClickBind);
                    if (scrollParentEl) {
                        scrollParentEl.off('scroll', positionPopup);
                    }
                    angular.element($window).off('resize', positionPopup);

                    //Clear all watch listeners on destroy
                    while (watchListeners.length) {
                        watchListeners.shift()();
                    }
                });
            };

            $scope.getText = function (key) {
                return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
            };

            $scope.isDisabled = function (date) {
                if (date === 'today') {
                    date = dateParser.fromTimezone(new Date(), ngModelOptions.getOption('timezone'));
                }

                var dates = {};
                angular.forEach(['minDate', 'maxDate'], function (key) {
                    if (!$scope.datepickerOptions[key]) {
                        dates[key] = null;
                    } else if (angular.isDate($scope.datepickerOptions[key])) {
                        dates[key] = new Date($scope.datepickerOptions[key]);
                    } else {
                        if ($datepickerPopupLiteralWarning) {
                            $log.warn('Literal date support has been deprecated, please switch to date object usage');
                        }

                        dates[key] = new Date(dateFilter($scope.datepickerOptions[key], 'medium'));
                    }
                });

                return $scope.datepickerOptions &&
                    dates.minDate && $scope.compare(date, dates.minDate) < 0 ||
                    dates.maxDate && $scope.compare(date, dates.maxDate) > 0;
            };

            $scope.compare = function (date1, date2) {
                return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
            };

            // Inner change
            $scope.dateSelection = function (dt) {
                $scope.date = dt;
                var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function
                $element.val(date);
                ngModel.$setViewValue(date);

                if (closeOnDateSelection) {
                    $scope.isOpen = false;
                    $element[0].focus();
                }
            };

            $scope.keydown = function (evt) {
                if (evt.which === 27) {
                    evt.stopPropagation();
                    $scope.isOpen = false;
                    $element[0].focus();
                }
            };

            $scope.select = function (date, evt) {
                evt.stopPropagation();

                if (date === 'today') {
                    var today = new Date();
                    if (angular.isDate($scope.date)) {
                        date = new Date($scope.date);
                        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
                    } else {
                        date = dateParser.fromTimezone(today, ngModelOptions.getOption('timezone'));
                        date.setHours(0, 0, 0, 0);
                    }
                }
                $scope.dateSelection(date);
            };

            $scope.close = function (evt) {
                evt.stopPropagation();

                $scope.isOpen = false;
                $element[0].focus();
            };

            $scope.disabled = angular.isDefined($attrs.disabled) || false;
            if ($attrs.ngDisabled) {
                watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function (disabled) {
                    $scope.disabled = disabled;
                }));
            }

            $scope.$watch('isOpen', function (value) {
                if (value) {
                    if (!$scope.disabled) {
                        $timeout(function () {
                            positionPopup();

                            if (onOpenFocus) {
                                $scope.$broadcast('uib:datepicker.focus');
                            }

                            $document.on('click', documentClickBind);

                            var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
                            if (appendToBody || $position.parsePlacement(placement)[2]) {
                                scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));
                                if (scrollParentEl) {
                                    scrollParentEl.on('scroll', positionPopup);
                                }
                            } else {
                                scrollParentEl = null;
                            }

                            angular.element($window).on('resize', positionPopup);
                        }, 0, false);
                    } else {
                        $scope.isOpen = false;
                    }
                } else {
                    $document.off('click', documentClickBind);
                    if (scrollParentEl) {
                        scrollParentEl.off('scroll', positionPopup);
                    }
                    angular.element($window).off('resize', positionPopup);
                }
            });

            function cameltoDash(string) {
                return string.replace(/([A-Z])/g, function ($1) { return '-' + $1.toLowerCase(); });
            }

            function parseDateString(viewValue) {
                var date = dateParser.parse(viewValue, dateFormat, $scope.date);
                if (isNaN(date)) {
                    for (var i = 0; i < altInputFormats.length; i++) {
                        date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);
                        if (!isNaN(date)) {
                            return date;
                        }
                    }
                }
                return date;
            }

            function parseDate(viewValue) {
                if (angular.isNumber(viewValue)) {
                    // presumably timestamp to date object
                    viewValue = new Date(viewValue);
                }

                if (!viewValue) {
                    return null;
                }

                if (angular.isDate(viewValue) && !isNaN(viewValue)) {
                    return viewValue;
                }

                if (angular.isString(viewValue)) {
                    var date = parseDateString(viewValue);
                    if (!isNaN(date)) {
                        return dateParser.toTimezone(date, ngModelOptions.getOption('timezone'));
                    }
                }

                return ngModelOptions.getOption('allowInvalid') ? viewValue : undefined;
            }

            function validator(modelValue, viewValue) {
                var value = modelValue || viewValue;

                if (!$attrs.ngRequired && !value) {
                    return true;
                }

                if (angular.isNumber(value)) {
                    value = new Date(value);
                }

                if (!value) {
                    return true;
                }

                if (angular.isDate(value) && !isNaN(value)) {
                    return true;
                }

                if (angular.isString(value)) {
                    return !isNaN(parseDateString(value));
                }

                return false;
            }

            function documentClickBind(event) {
                if (!$scope.isOpen && $scope.disabled) {
                    return;
                }

                var popup = $popup[0];
                var dpContainsTarget = $element[0].contains(event.target);
                // The popup node may not be an element node
                // In some browsers (IE) only element nodes have the 'contains' function
                var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
                if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
                    $scope.$apply(function () {
                        $scope.isOpen = false;
                    });
                }
            }

            function inputKeydownBind(evt) {
                if (evt.which === 27 && $scope.isOpen) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    $scope.$apply(function () {
                        $scope.isOpen = false;
                    });
                    $element[0].focus();
                } else if (evt.which === 40 && !$scope.isOpen) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    $scope.$apply(function () {
                        $scope.isOpen = true;
                    });
                }
            }

            function positionPopup() {
                if ($scope.isOpen) {
                    var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));
                    var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
                    var position = $position.positionElements($element, dpElement, placement, appendToBody);
                    dpElement.css({ top: position.top + 'px', left: position.left + 'px' });
                    if (dpElement.hasClass('uib-position-measure')) {
                        dpElement.removeClass('uib-position-measure');
                    }
                }
            }

            function extractOptions(ngModelCtrl) {
                var ngModelOptions;

                if (angular.version.minor < 6) { // in angular < 1.6 $options could be missing
                    // guarantee a value
                    ngModelOptions = angular.isObject(ngModelCtrl.$options) ?
                        ngModelCtrl.$options :
                        {
                            timezone: null
                        };

                    // mimic 1.6+ api
                    ngModelOptions.getOption = function (key) {
                        return ngModelOptions[key];
                    };
                } else { // in angular >=1.6 $options is always present
                    ngModelOptions = ngModelCtrl.$options;
                }

                return ngModelOptions;
            }

            $scope.$on('uib:datepicker.mode', function () {
                $timeout(positionPopup, 0, false);
            });
        }])

    .directive('uibDatepickerPopup', function () {
        return {
            require: ['ngModel', 'uibDatepickerPopup'],
            controller: 'UibDatepickerPopupController',
            scope: {
                datepickerOptions: '=?',
                isOpen: '=?',
                currentText: '@',
                clearText: '@',
                closeText: '@'
            },
            link: function (scope, element, attrs, ctrls) {
                var ngModel = ctrls[0],
                    ctrl = ctrls[1];

                ctrl.init(ngModel);
            }
        };
    })

    .directive('uibDatepickerPopupWrap', function () {
        return {
            restrict: 'A',
            transclude: true,
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/datepickerPopup/popup.html';
            }
        };
    });

angular.module('ui.bootstrap.debounce', [])
    /**
     * A helper, internal service that debounces a function
     */
    .factory('$$debounce', ['$timeout', function ($timeout) {
        return function (callback, debounceTime) {
            var timeoutPromise;

            return function () {
                var self = this;
                var args = Array.prototype.slice.call(arguments);
                if (timeoutPromise) {
                    $timeout.cancel(timeoutPromise);
                }

                timeoutPromise = $timeout(function () {
                    callback.apply(self, args);
                }, debounceTime);
            };
        };
    }]);

angular.module('ui.bootstrap.multiMap', [])
    /**
     * A helper, internal data structure that stores all references attached to key
     */
    .factory('$$multiMap', function () {
        return {
            createNew: function () {
                var map = {};

                return {
                    entries: function () {
                        return Object.keys(map).map(function (key) {
                            return {
                                key: key,
                                value: map[key]
                            };
                        });
                    },
                    get: function (key) {
                        return map[key];
                    },
                    hasKey: function (key) {
                        return !!map[key];
                    },
                    keys: function () {
                        return Object.keys(map);
                    },
                    put: function (key, value) {
                        if (!map[key]) {
                            map[key] = [];
                        }

                        map[key].push(value);
                    },
                    remove: function (key, value) {
                        var values = map[key];

                        if (!values) {
                            return;
                        }

                        var idx = values.indexOf(value);

                        if (idx !== -1) {
                            values.splice(idx, 1);
                        }

                        if (!values.length) {
                            delete map[key];
                        }
                    }
                };
            }
        };
    });

angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.multiMap', 'ui.bootstrap.position'])

    .constant('uibDropdownConfig', {
        appendToOpenClass: 'uib-dropdown-open',
        openClass: 'open'
    })

    .service('uibDropdownService', ['$document', '$rootScope', '$$multiMap', function ($document, $rootScope, $$multiMap) {
        var openScope = null;
        var openedContainers = $$multiMap.createNew();

        this.isOnlyOpen = function (dropdownScope, appendTo) {
            var openedDropdowns = openedContainers.get(appendTo);
            if (openedDropdowns) {
                var openDropdown = openedDropdowns.reduce(function (toClose, dropdown) {
                    if (dropdown.scope === dropdownScope) {
                        return dropdown;
                    }

                    return toClose;
                }, {});
                if (openDropdown) {
                    return openedDropdowns.length === 1;
                }
            }

            return false;
        };

        this.open = function (dropdownScope, element, appendTo) {
            if (!openScope) {
                $document.on('click', closeDropdown);
            }

            if (openScope && openScope !== dropdownScope) {
                openScope.isOpen = false;
            }

            openScope = dropdownScope;

            if (!appendTo) {
                return;
            }

            var openedDropdowns = openedContainers.get(appendTo);
            if (openedDropdowns) {
                var openedScopes = openedDropdowns.map(function (dropdown) {
                    return dropdown.scope;
                });
                if (openedScopes.indexOf(dropdownScope) === -1) {
                    openedContainers.put(appendTo, {
                        scope: dropdownScope
                    });
                }
            } else {
                openedContainers.put(appendTo, {
                    scope: dropdownScope
                });
            }
        };

        this.close = function (dropdownScope, element, appendTo) {
            if (openScope === dropdownScope) {
                $document.off('click', closeDropdown);
                $document.off('keydown', this.keybindFilter);
                openScope = null;
            }

            if (!appendTo) {
                return;
            }

            var openedDropdowns = openedContainers.get(appendTo);
            if (openedDropdowns) {
                var dropdownToClose = openedDropdowns.reduce(function (toClose, dropdown) {
                    if (dropdown.scope === dropdownScope) {
                        return dropdown;
                    }

                    return toClose;
                }, {});
                if (dropdownToClose) {
                    openedContainers.remove(appendTo, dropdownToClose);
                }
            }
        };

        var closeDropdown = function (evt) {
            // This method may still be called during the same mouse event that
            // unbound this event handler. So check openScope before proceeding.
            if (!openScope || !openScope.isOpen) { return; }

            if (evt && openScope.getAutoClose() === 'disabled') { return; }

            if (evt && evt.which === 3) { return; }

            var toggleElement = openScope.getToggleElement();
            if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
                return;
            }

            var dropdownElement = openScope.getDropdownElement();
            if (evt && openScope.getAutoClose() === 'outsideClick' &&
                dropdownElement && dropdownElement[0].contains(evt.target)) {
                return;
            }

            openScope.focusToggleElement();
            openScope.isOpen = false;

            if (!$rootScope.$$phase) {
                openScope.$apply();
            }
        };

        this.keybindFilter = function (evt) {
            if (!openScope) {
                // see this.close as ESC could have been pressed which kills the scope so we can not proceed
                return;
            }

            var dropdownElement = openScope.getDropdownElement();
            var toggleElement = openScope.getToggleElement();
            var dropdownElementTargeted = dropdownElement && dropdownElement[0].contains(evt.target);
            var toggleElementTargeted = toggleElement && toggleElement[0].contains(evt.target);
            if (evt.which === 27) {
                evt.stopPropagation();
                openScope.focusToggleElement();
                closeDropdown();
            } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen && (dropdownElementTargeted || toggleElementTargeted)) {
                evt.preventDefault();
                evt.stopPropagation();
                openScope.focusDropdownEntry(evt.which);
            }
        };
    }])

    .controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function ($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
        var self = this,
            scope = $scope.$new(), // create a child scope so we are not polluting original one
            templateScope,
            appendToOpenClass = dropdownConfig.appendToOpenClass,
            openClass = dropdownConfig.openClass,
            getIsOpen,
            setIsOpen = angular.noop,
            toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
            keynavEnabled = false,
            selectedOption = null,
            body = $document.find('body');

        $element.addClass('dropdown');

        this.init = function () {
            if ($attrs.isOpen) {
                getIsOpen = $parse($attrs.isOpen);
                setIsOpen = getIsOpen.assign;

                $scope.$watch(getIsOpen, function (value) {
                    scope.isOpen = !!value;
                });
            }

            keynavEnabled = angular.isDefined($attrs.keyboardNav);
        };

        this.toggle = function (open) {
            scope.isOpen = arguments.length ? !!open : !scope.isOpen;
            if (angular.isFunction(setIsOpen)) {
                setIsOpen(scope, scope.isOpen);
            }

            return scope.isOpen;
        };

        // Allow other directives to watch status
        this.isOpen = function () {
            return scope.isOpen;
        };

        scope.getToggleElement = function () {
            return self.toggleElement;
        };

        scope.getAutoClose = function () {
            return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'
        };

        scope.getElement = function () {
            return $element;
        };

        scope.isKeynavEnabled = function () {
            return keynavEnabled;
        };

        scope.focusDropdownEntry = function (keyCode) {
            var elems = self.dropdownMenu ? //If append to body is used.
                angular.element(self.dropdownMenu).find('a') :
                $element.find('ul').eq(0).find('a');

            switch (keyCode) {
                case 40: {
                    if (!angular.isNumber(self.selectedOption)) {
                        self.selectedOption = 0;
                    } else {
                        self.selectedOption = self.selectedOption === elems.length - 1 ?
                            self.selectedOption :
                            self.selectedOption + 1;
                    }
                    break;
                }
                case 38: {
                    if (!angular.isNumber(self.selectedOption)) {
                        self.selectedOption = elems.length - 1;
                    } else {
                        self.selectedOption = self.selectedOption === 0 ?
                            0 : self.selectedOption - 1;
                    }
                    break;
                }
            }
            elems[self.selectedOption].focus();
        };

        scope.getDropdownElement = function () {
            return self.dropdownMenu;
        };

        scope.focusToggleElement = function () {
            if (self.toggleElement) {
                self.toggleElement[0].focus();
            }
        };

        function removeDropdownMenu() {
            $element.append(self.dropdownMenu);
        }

        scope.$watch('isOpen', function (isOpen, wasOpen) {
            var appendTo = null,
                appendToBody = false;

            if (angular.isDefined($attrs.dropdownAppendTo)) {
                var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
                if (appendToEl) {
                    appendTo = angular.element(appendToEl);
                }
            }

            if (angular.isDefined($attrs.dropdownAppendToBody)) {
                var appendToBodyValue = $parse($attrs.dropdownAppendToBody)(scope);
                if (appendToBodyValue !== false) {
                    appendToBody = true;
                }
            }

            if (appendToBody && !appendTo) {
                appendTo = body;
            }

            if (appendTo && self.dropdownMenu) {
                if (isOpen) {
                    appendTo.append(self.dropdownMenu);
                    $element.on('$destroy', removeDropdownMenu);
                } else {
                    $element.off('$destroy', removeDropdownMenu);
                    removeDropdownMenu();
                }
            }

            if (appendTo && self.dropdownMenu) {
                var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),
                    css,
                    rightalign,
                    scrollbarPadding,
                    scrollbarWidth = 0;

                css = {
                    top: pos.top + 'px',
                    display: isOpen ? 'block' : 'none'
                };

                rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
                if (!rightalign) {
                    css.left = pos.left + 'px';
                    css.right = 'auto';
                } else {
                    css.left = 'auto';
                    scrollbarPadding = $position.scrollbarPadding(appendTo);

                    if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
                        scrollbarWidth = scrollbarPadding.scrollbarWidth;
                    }

                    css.right = window.innerWidth - scrollbarWidth -
                        (pos.left + $element.prop('offsetWidth')) + 'px';
                }

                // Need to adjust our positioning to be relative to the appendTo container
                // if it's not the body element
                if (!appendToBody) {
                    var appendOffset = $position.offset(appendTo);

                    css.top = pos.top - appendOffset.top + 'px';

                    if (!rightalign) {
                        css.left = pos.left - appendOffset.left + 'px';
                    } else {
                        css.right = window.innerWidth -
                            (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';
                    }
                }

                self.dropdownMenu.css(css);
            }

            var openContainer = appendTo ? appendTo : $element;
            var dropdownOpenClass = appendTo ? appendToOpenClass : openClass;
            var hasOpenClass = openContainer.hasClass(dropdownOpenClass);
            var isOnlyOpen = uibDropdownService.isOnlyOpen($scope, appendTo);

            if (hasOpenClass === !isOpen) {
                var toggleClass;
                if (appendTo) {
                    toggleClass = !isOnlyOpen ? 'addClass' : 'removeClass';
                } else {
                    toggleClass = isOpen ? 'addClass' : 'removeClass';
                }
                $animate[toggleClass](openContainer, dropdownOpenClass).then(function () {
                    if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
                        toggleInvoker($scope, { open: !!isOpen });
                    }
                });
            }

            if (isOpen) {
                if (self.dropdownMenuTemplateUrl) {
                    $templateRequest(self.dropdownMenuTemplateUrl).then(function (tplContent) {
                        templateScope = scope.$new();
                        $compile(tplContent.trim())(templateScope, function (dropdownElement) {
                            var newEl = dropdownElement;
                            self.dropdownMenu.replaceWith(newEl);
                            self.dropdownMenu = newEl;
                            $document.on('keydown', uibDropdownService.keybindFilter);
                        });
                    });
                } else {
                    $document.on('keydown', uibDropdownService.keybindFilter);
                }

                scope.focusToggleElement();
                uibDropdownService.open(scope, $element, appendTo);
            } else {
                uibDropdownService.close(scope, $element, appendTo);
                if (self.dropdownMenuTemplateUrl) {
                    if (templateScope) {
                        templateScope.$destroy();
                    }
                    var newEl = angular.element('<ul class="dropdown-menu"></ul>');
                    self.dropdownMenu.replaceWith(newEl);
                    self.dropdownMenu = newEl;
                }

                self.selectedOption = null;
            }

            if (angular.isFunction(setIsOpen)) {
                setIsOpen($scope, isOpen);
            }
        });
    }])

    .directive('uibDropdown', function () {
        return {
            controller: 'UibDropdownController',
            link: function (scope, element, attrs, dropdownCtrl) {
                dropdownCtrl.init();
            }
        };
    })

    .directive('uibDropdownMenu', function () {
        return {
            restrict: 'A',
            require: '?^uibDropdown',
            link: function (scope, element, attrs, dropdownCtrl) {
                if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
                    return;
                }

                element.addClass('dropdown-menu');

                var tplUrl = attrs.templateUrl;
                if (tplUrl) {
                    dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
                }

                if (!dropdownCtrl.dropdownMenu) {
                    dropdownCtrl.dropdownMenu = element;
                }
            }
        };
    })

    .directive('uibDropdownToggle', function () {
        return {
            require: '?^uibDropdown',
            link: function (scope, element, attrs, dropdownCtrl) {
                if (!dropdownCtrl) {
                    return;
                }

                element.addClass('dropdown-toggle');

                dropdownCtrl.toggleElement = element;

                var toggleDropdown = function (event) {
                    event.preventDefault();

                    if (!element.hasClass('disabled') && !attrs.disabled) {
                        scope.$apply(function () {
                            dropdownCtrl.toggle();
                        });
                    }
                };

                element.on('click', toggleDropdown);

                // WAI-ARIA
                element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
                scope.$watch(dropdownCtrl.isOpen, function (isOpen) {
                    element.attr('aria-expanded', !!isOpen);
                });

                scope.$on('$destroy', function () {
                    element.off('click', toggleDropdown);
                });
            }
        };
    });

angular.module('ui.bootstrap.stackedMap', [])
    /**
     * A helper, internal data structure that acts as a map but also allows getting / removing
     * elements in the LIFO order
     */
    .factory('$$stackedMap', function () {
        return {
            createNew: function () {
                var stack = [];

                return {
                    add: function (key, value) {
                        stack.push({
                            key: key,
                            value: value
                        });
                    },
                    get: function (key) {
                        for (var i = 0; i < stack.length; i++) {
                            if (key === stack[i].key) {
                                return stack[i];
                            }
                        }
                    },
                    keys: function () {
                        var keys = [];
                        for (var i = 0; i < stack.length; i++) {
                            keys.push(stack[i].key);
                        }
                        return keys;
                    },
                    top: function () {
                        return stack[stack.length - 1];
                    },
                    remove: function (key) {
                        var idx = -1;
                        for (var i = 0; i < stack.length; i++) {
                            if (key === stack[i].key) {
                                idx = i;
                                break;
                            }
                        }
                        return stack.splice(idx, 1)[0];
                    },
                    removeTop: function () {
                        return stack.pop();
                    },
                    length: function () {
                        return stack.length;
                    }
                };
            }
        };
    });
angular.module('ui.bootstrap.modal', ['ui.bootstrap.multiMap', 'ui.bootstrap.stackedMap', 'ui.bootstrap.position'])
    /**
     * Pluggable resolve mechanism for the modal resolve resolution
     * Supports UI Router's $resolve service
     */
    .provider('$uibResolve', function () {
        var resolve = this;
        this.resolver = null;

        this.setResolver = function (resolver) {
            this.resolver = resolver;
        };

        this.$get = ['$injector', '$q', function ($injector, $q) {
            var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
            return {
                resolve: function (invocables, locals, parent, self) {
                    if (resolver) {
                        return resolver.resolve(invocables, locals, parent, self);
                    }

                    var promises = [];

                    angular.forEach(invocables, function (value) {
                        if (angular.isFunction(value) || angular.isArray(value)) {
                            promises.push($q.resolve($injector.invoke(value)));
                        } else if (angular.isString(value)) {
                            promises.push($q.resolve($injector.get(value)));
                        } else {
                            promises.push($q.resolve(value));
                        }
                    });

                    return $q.all(promises).then(function (resolves) {
                        var resolveObj = {};
                        var resolveIter = 0;
                        angular.forEach(invocables, function (value, key) {
                            resolveObj[key] = resolves[resolveIter++];
                        });

                        return resolveObj;
                    });
                }
            };
        }];
    })

    /**
     * A helper directive for the $modal service. It creates a backdrop element.
     */
    .directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack',
        function ($animate, $injector, $modalStack) {
            return {
                restrict: 'A',
                compile: function (tElement, tAttrs) {
                    tElement.addClass(tAttrs.backdropClass);
                    return linkFn;
                }
            };

            function linkFn(scope, element, attrs) {
                if (attrs.modalInClass) {
                    $animate.addClass(element, attrs.modalInClass);

                    scope.$on($modalStack.NOW_CLOSING_EVENT, function (e, setIsAsync) {
                        var done = setIsAsync();
                        if (scope.modalOptions.animation) {
                            $animate.removeClass(element, attrs.modalInClass).then(done);
                        } else {
                            done();
                        }
                    });
                }
            }
        }])

    .directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document',
        function ($modalStack, $q, $animateCss, $document) {
            return {
                scope: {
                    index: '@'
                },
                restrict: 'A',
                transclude: true,
                templateUrl: function (tElement, tAttrs) {
                    return tAttrs.templateUrl || 'uib/template/modal/window.html';
                },
                link: function (scope, element, attrs) {
                    element.addClass(attrs.windowTopClass || '');
                    scope.size = attrs.size;

                    scope.close = function (evt) {
                        var modal = $modalStack.getTop();
                        if (modal && modal.value.backdrop &&
                            modal.value.backdrop !== 'static' &&
                            evt.target === evt.currentTarget) {
                            evt.preventDefault();
                            evt.stopPropagation();
                            $modalStack.dismiss(modal.key, 'backdrop click');
                        }
                    };

                    // moved from template to fix issue #2280
                    element.on('click', scope.close);

                    // This property is only added to the scope for the purpose of detecting when this directive is rendered.
                    // We can detect that by using this property in the template associated with this directive and then use
                    // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
                    scope.$isRendered = true;

                    // Deferred object that will be resolved when this modal is rendered.
                    var modalRenderDeferObj = $q.defer();
                    // Resolve render promise post-digest
                    scope.$$postDigest(function () {
                        modalRenderDeferObj.resolve();
                    });

                    modalRenderDeferObj.promise.then(function () {
                        var animationPromise = null;

                        if (attrs.modalInClass) {
                            animationPromise = $animateCss(element, {
                                addClass: attrs.modalInClass
                            }).start();

                            scope.$on($modalStack.NOW_CLOSING_EVENT, function (e, setIsAsync) {
                                var done = setIsAsync();
                                $animateCss(element, {
                                    removeClass: attrs.modalInClass
                                }).start().then(done);
                            });
                        }


                        $q.when(animationPromise).then(function () {
                            // Notify {@link $modalStack} that modal is rendered.
                            var modal = $modalStack.getTop();
                            if (modal) {
                                $modalStack.modalRendered(modal.key);
                            }

                            /**
                             * If something within the freshly-opened modal already has focus (perhaps via a
                             * directive that causes focus) then there's no need to try to focus anything.
                             */
                            if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {
                                var inputWithAutofocus = element[0].querySelector('[autofocus]');
                                /**
                                 * Auto-focusing of a freshly-opened modal element causes any child elements
                                 * with the autofocus attribute to lose focus. This is an issue on touch
                                 * based devices which will show and then hide the onscreen keyboard.
                                 * Attempts to refocus the autofocus element via JavaScript will not reopen
                                 * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
                                 * the modal element if the modal does not contain an autofocus element.
                                 */
                                if (inputWithAutofocus) {
                                    inputWithAutofocus.focus();
                                } else {
                                    element[0].focus();
                                }
                            }
                        });
                    });
                }
            };
        }])

    .directive('uibModalAnimationClass', function () {
        return {
            compile: function (tElement, tAttrs) {
                if (tAttrs.modalAnimation) {
                    tElement.addClass(tAttrs.uibModalAnimationClass);
                }
            }
        };
    })

    .directive('uibModalTransclude', ['$animate', function ($animate) {
        return {
            link: function (scope, element, attrs, controller, transclude) {
                transclude(scope.$parent, function (clone) {
                    element.empty();
                    $animate.enter(clone, element);
                });
            }
        };
    }])

    .factory('$uibModalStack', ['$animate', '$animateCss', '$document',
        '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', '$uibPosition',
        function ($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {
            var OPENED_MODAL_CLASS = 'modal-open';

            var backdropDomEl, backdropScope;
            var openedWindows = $$stackedMap.createNew();
            var openedClasses = $$multiMap.createNew();
            var $modalStack = {
                NOW_CLOSING_EVENT: 'modal.stack.now-closing'
            };
            var topModalIndex = 0;
            var previousTopOpenedModal = null;
            var ARIA_HIDDEN_ATTRIBUTE_NAME = 'data-bootstrap-modal-aria-hidden-count';

            //Modal focus behavior
            var tabbableSelector = 'a[href], area[href], input:not([disabled]):not([tabindex=\'-1\']), ' +
                'button:not([disabled]):not([tabindex=\'-1\']),select:not([disabled]):not([tabindex=\'-1\']), textarea:not([disabled]):not([tabindex=\'-1\']), ' +
                'iframe, object, embed, *[tabindex]:not([tabindex=\'-1\']), *[contenteditable=true]';
            var scrollbarPadding;
            var SNAKE_CASE_REGEXP = /[A-Z]/g;

            // TODO: extract into common dependency with tooltip
            function snake_case(name) {
                var separator = '-';
                return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
                    return (pos ? separator : '') + letter.toLowerCase();
                });
            }

            function isVisible(element) {
                return !!(element.offsetWidth ||
                    element.offsetHeight ||
                    element.getClientRects().length);
            }

            function backdropIndex() {
                var topBackdropIndex = -1;
                var opened = openedWindows.keys();
                for (var i = 0; i < opened.length; i++) {
                    if (openedWindows.get(opened[i]).value.backdrop) {
                        topBackdropIndex = i;
                    }
                }

                // If any backdrop exist, ensure that it's index is always
                // right below the top modal
                if (topBackdropIndex > -1 && topBackdropIndex < topModalIndex) {
                    topBackdropIndex = topModalIndex;
                }
                return topBackdropIndex;
            }

            $rootScope.$watch(backdropIndex, function (newBackdropIndex) {
                if (backdropScope) {
                    backdropScope.index = newBackdropIndex;
                }
            });

            function removeModalWindow(modalInstance, elementToReceiveFocus) {
                var modalWindow = openedWindows.get(modalInstance).value;
                var appendToElement = modalWindow.appendTo;

                //clean up the stack
                openedWindows.remove(modalInstance);
                previousTopOpenedModal = openedWindows.top();
                if (previousTopOpenedModal) {
                    topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10);
                }

                removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function () {
                    var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
                    openedClasses.remove(modalBodyClass, modalInstance);
                    var areAnyOpen = openedClasses.hasKey(modalBodyClass);
                    appendToElement.toggleClass(modalBodyClass, areAnyOpen);
                    if (!areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
                        if (scrollbarPadding.originalRight) {
                            appendToElement.css({ paddingRight: scrollbarPadding.originalRight + 'px' });
                        } else {
                            appendToElement.css({ paddingRight: '' });
                        }
                        scrollbarPadding = null;
                    }
                    toggleTopWindowClass(true);
                }, modalWindow.closedDeferred);
                checkRemoveBackdrop();

                //move focus to specified element if available, or else to body
                if (elementToReceiveFocus && elementToReceiveFocus.focus) {
                    elementToReceiveFocus.focus();
                } else if (appendToElement.focus) {
                    appendToElement.focus();
                }
            }

            // Add or remove "windowTopClass" from the top window in the stack
            function toggleTopWindowClass(toggleSwitch) {
                var modalWindow;

                if (openedWindows.length() > 0) {
                    modalWindow = openedWindows.top().value;
                    modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
                }
            }

            function checkRemoveBackdrop() {
                //remove backdrop if no longer needed
                if (backdropDomEl && backdropIndex() === -1) {
                    var backdropScopeRef = backdropScope;
                    removeAfterAnimate(backdropDomEl, backdropScope, function () {
                        backdropScopeRef = null;
                    });
                    backdropDomEl = undefined;
                    backdropScope = undefined;
                }
            }

            function removeAfterAnimate(domEl, scope, done, closedDeferred) {
                var asyncDeferred;
                var asyncPromise = null;
                var setIsAsync = function () {
                    if (!asyncDeferred) {
                        asyncDeferred = $q.defer();
                        asyncPromise = asyncDeferred.promise;
                    }

                    return function asyncDone() {
                        asyncDeferred.resolve();
                    };
                };
                scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);

                // Note that it's intentional that asyncPromise might be null.
                // That's when setIsAsync has not been called during the
                // NOW_CLOSING_EVENT broadcast.
                return $q.when(asyncPromise).then(afterAnimating);

                function afterAnimating() {
                    if (afterAnimating.done) {
                        return;
                    }
                    afterAnimating.done = true;

                    $animate.leave(domEl).then(function () {
                        if (done) {
                            done();
                        }

                        domEl.remove();
                        if (closedDeferred) {
                            closedDeferred.resolve();
                        }
                    });

                    scope.$destroy();
                }
            }

            $document.on('keydown', keydownListener);

            $rootScope.$on('$destroy', function () {
                $document.off('keydown', keydownListener);
            });

            function keydownListener(evt) {
                if (evt.isDefaultPrevented()) {
                    return evt;
                }

                var modal = openedWindows.top();
                if (modal) {
                    switch (evt.which) {
                        case 27: {
                            if (modal.value.keyboard) {
                                evt.preventDefault();
                                $rootScope.$apply(function () {
                                    $modalStack.dismiss(modal.key, 'escape key press');
                                });
                            }
                            break;
                        }
                        case 9: {
                            var list = $modalStack.loadFocusElementList(modal);
                            var focusChanged = false;
                            if (evt.shiftKey) {
                                if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {
                                    focusChanged = $modalStack.focusLastFocusableElement(list);
                                }
                            } else {
                                if ($modalStack.isFocusInLastItem(evt, list)) {
                                    focusChanged = $modalStack.focusFirstFocusableElement(list);
                                }
                            }

                            if (focusChanged) {
                                evt.preventDefault();
                                evt.stopPropagation();
                            }

                            break;
                        }
                    }
                }
            }

            $modalStack.open = function (modalInstance, modal) {
                var modalOpener = $document[0].activeElement,
                    modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;

                toggleTopWindowClass(false);

                // Store the current top first, to determine what index we ought to use
                // for the current top modal
                previousTopOpenedModal = openedWindows.top();

                openedWindows.add(modalInstance, {
                    deferred: modal.deferred,
                    renderDeferred: modal.renderDeferred,
                    closedDeferred: modal.closedDeferred,
                    modalScope: modal.scope,
                    backdrop: modal.backdrop,
                    keyboard: modal.keyboard,
                    openedClass: modal.openedClass,
                    windowTopClass: modal.windowTopClass,
                    animation: modal.animation,
                    appendTo: modal.appendTo
                });

                openedClasses.put(modalBodyClass, modalInstance);

                var appendToElement = modal.appendTo,
                    currBackdropIndex = backdropIndex();

                if (currBackdropIndex >= 0 && !backdropDomEl) {
                    backdropScope = $rootScope.$new(true);
                    backdropScope.modalOptions = modal;
                    backdropScope.index = currBackdropIndex;
                    backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
                    backdropDomEl.attr({
                        'class': 'modal-backdrop',
                        'ng-style': '{\'z-index\': 1040 + (index && 1 || 0) + index*10}',
                        'uib-modal-animation-class': 'fade',
                        'modal-in-class': 'in'
                    });
                    if (modal.backdropClass) {
                        backdropDomEl.addClass(modal.backdropClass);
                    }

                    if (modal.animation) {
                        backdropDomEl.attr('modal-animation', 'true');
                    }
                    $compile(backdropDomEl)(backdropScope);
                    $animate.enter(backdropDomEl, appendToElement);
                    if ($uibPosition.isScrollable(appendToElement)) {
                        scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);
                        if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
                            appendToElement.css({ paddingRight: scrollbarPadding.right + 'px' });
                        }
                    }
                }

                var content;
                if (modal.component) {
                    content = document.createElement(snake_case(modal.component.name));
                    content = angular.element(content);
                    content.attr({
                        resolve: '$resolve',
                        'modal-instance': '$uibModalInstance',
                        close: '$close($value)',
                        dismiss: '$dismiss($value)'
                    });
                } else {
                    content = modal.content;
                }

                // Set the top modal index based on the index of the previous top modal
                topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10) + 1 : 0;
                var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
                angularDomEl.attr({
                    'class': 'modal',
                    'template-url': modal.windowTemplateUrl,
                    'window-top-class': modal.windowTopClass,
                    'role': 'dialog',
                    'aria-labelledby': modal.ariaLabelledBy,
                    'aria-describedby': modal.ariaDescribedBy,
                    'size': modal.size,
                    'index': topModalIndex,
                    'animate': 'animate',
                    'ng-style': '{\'z-index\': 1050 + $$topModalIndex*10, display: \'block\'}',
                    'tabindex': -1,
                    'uib-modal-animation-class': 'fade',
                    'modal-in-class': 'in'
                }).append(content);
                if (modal.windowClass) {
                    angularDomEl.addClass(modal.windowClass);
                }

                if (modal.animation) {
                    angularDomEl.attr('modal-animation', 'true');
                }

                appendToElement.addClass(modalBodyClass);
                if (modal.scope) {
                    // we need to explicitly add the modal index to the modal scope
                    // because it is needed by ngStyle to compute the zIndex property.
                    modal.scope.$$topModalIndex = topModalIndex;
                }
                $animate.enter($compile(angularDomEl)(modal.scope), appendToElement);

                openedWindows.top().value.modalDomEl = angularDomEl;
                openedWindows.top().value.modalOpener = modalOpener;

                applyAriaHidden(angularDomEl);

                function applyAriaHidden(el) {
                    if (!el || el[0].tagName === 'BODY') {
                        return;
                    }

                    getSiblings(el).forEach(function (sibling) {
                        var elemIsAlreadyHidden = sibling.getAttribute('aria-hidden') === 'true',
                            ariaHiddenCount = parseInt(sibling.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10);

                        if (!ariaHiddenCount) {
                            ariaHiddenCount = elemIsAlreadyHidden ? 1 : 0;
                        }

                        sibling.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, ariaHiddenCount + 1);
                        sibling.setAttribute('aria-hidden', 'true');
                    });

                    return applyAriaHidden(el.parent());

                    function getSiblings(el) {
                        var children = el.parent() ? el.parent().children() : [];

                        return Array.prototype.filter.call(children, function (child) {
                            return child !== el[0];
                        });
                    }
                }
            };

            function broadcastClosing(modalWindow, resultOrReason, closing) {
                return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
            }

            function unhideBackgroundElements() {
                Array.prototype.forEach.call(
                    document.querySelectorAll('[' + ARIA_HIDDEN_ATTRIBUTE_NAME + ']'),
                    function (hiddenEl) {
                        var ariaHiddenCount = parseInt(hiddenEl.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10),
                            newHiddenCount = ariaHiddenCount - 1;
                        hiddenEl.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, newHiddenCount);

                        if (!newHiddenCount) {
                            hiddenEl.removeAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME);
                            hiddenEl.removeAttribute('aria-hidden');
                        }
                    }
                );
            }

            $modalStack.close = function (modalInstance, result) {
                var modalWindow = openedWindows.get(modalInstance);
                unhideBackgroundElements();
                if (modalWindow && broadcastClosing(modalWindow, result, true)) {
                    modalWindow.value.modalScope.$$uibDestructionScheduled = true;
                    modalWindow.value.deferred.resolve(result);
                    removeModalWindow(modalInstance, modalWindow.value.modalOpener);
                    return true;
                }

                return !modalWindow;
            };

            $modalStack.dismiss = function (modalInstance, reason) {
                var modalWindow = openedWindows.get(modalInstance);
                unhideBackgroundElements();
                if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
                    modalWindow.value.modalScope.$$uibDestructionScheduled = true;
                    modalWindow.value.deferred.reject(reason);
                    removeModalWindow(modalInstance, modalWindow.value.modalOpener);
                    return true;
                }
                return !modalWindow;
            };

            $modalStack.dismissAll = function (reason) {
                var topModal = this.getTop();
                while (topModal && this.dismiss(topModal.key, reason)) {
                    topModal = this.getTop();
                }
            };

            $modalStack.getTop = function () {
                return openedWindows.top();
            };

            $modalStack.modalRendered = function (modalInstance) {
                var modalWindow = openedWindows.get(modalInstance);
                if (modalWindow) {
                    modalWindow.value.renderDeferred.resolve();
                }
            };

            $modalStack.focusFirstFocusableElement = function (list) {
                if (list.length > 0) {
                    list[0].focus();
                    return true;
                }
                return false;
            };

            $modalStack.focusLastFocusableElement = function (list) {
                if (list.length > 0) {
                    list[list.length - 1].focus();
                    return true;
                }
                return false;
            };

            $modalStack.isModalFocused = function (evt, modalWindow) {
                if (evt && modalWindow) {
                    var modalDomEl = modalWindow.value.modalDomEl;
                    if (modalDomEl && modalDomEl.length) {
                        return (evt.target || evt.srcElement) === modalDomEl[0];
                    }
                }
                return false;
            };

            $modalStack.isFocusInFirstItem = function (evt, list) {
                if (list.length > 0) {
                    return (evt.target || evt.srcElement) === list[0];
                }
                return false;
            };

            $modalStack.isFocusInLastItem = function (evt, list) {
                if (list.length > 0) {
                    return (evt.target || evt.srcElement) === list[list.length - 1];
                }
                return false;
            };

            $modalStack.loadFocusElementList = function (modalWindow) {
                if (modalWindow) {
                    var modalDomE1 = modalWindow.value.modalDomEl;
                    if (modalDomE1 && modalDomE1.length) {
                        var elements = modalDomE1[0].querySelectorAll(tabbableSelector);
                        return elements ?
                            Array.prototype.filter.call(elements, function (element) {
                                return isVisible(element);
                            }) : elements;
                    }
                }
            };

            return $modalStack;
        }])

    .provider('$uibModal', function () {
        var $modalProvider = {
            options: {
                animation: true,
                backdrop: true, //can also be false or 'static'
                keyboard: true
            },
            $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',
                function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
                    var $modal = {};

                    function getTemplatePromise(options) {
                        return options.template ? $q.when(options.template) :
                            $templateRequest(angular.isFunction(options.templateUrl) ?
                                options.templateUrl() : options.templateUrl);
                    }

                    var promiseChain = null;
                    $modal.getPromiseChain = function () {
                        return promiseChain;
                    };

                    $modal.open = function (modalOptions) {
                        var modalResultDeferred = $q.defer();
                        var modalOpenedDeferred = $q.defer();
                        var modalClosedDeferred = $q.defer();
                        var modalRenderDeferred = $q.defer();

                        //prepare an instance of a modal to be injected into controllers and returned to a caller
                        var modalInstance = {
                            result: modalResultDeferred.promise,
                            opened: modalOpenedDeferred.promise,
                            closed: modalClosedDeferred.promise,
                            rendered: modalRenderDeferred.promise,
                            close: function (result) {
                                return $modalStack.close(modalInstance, result);
                            },
                            dismiss: function (reason) {
                                return $modalStack.dismiss(modalInstance, reason);
                            }
                        };

                        //merge and clean up options
                        modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
                        modalOptions.resolve = modalOptions.resolve || {};
                        modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);

                        if (!modalOptions.appendTo.length) {
                            throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');
                        }

                        //verify options
                        if (!modalOptions.component && !modalOptions.template && !modalOptions.templateUrl) {
                            throw new Error('One of component or template or templateUrl options is required.');
                        }

                        var templateAndResolvePromise;
                        if (modalOptions.component) {
                            templateAndResolvePromise = $q.when($uibResolve.resolve(modalOptions.resolve, {}, null, null));
                        } else {
                            templateAndResolvePromise =
                                $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);
                        }

                        function resolveWithTemplate() {
                            return templateAndResolvePromise;
                        }

                        // Wait for the resolution of the existing promise chain.
                        // Then switch to our own combined promise dependency (regardless of how the previous modal fared).
                        // Then add to $modalStack and resolve opened.
                        // Finally clean up the chain variable if no subsequent modal has overwritten it.
                        var samePromise;
                        samePromise = promiseChain = $q.all([promiseChain])
                            .then(resolveWithTemplate, resolveWithTemplate)
                            .then(function resolveSuccess(tplAndVars) {
                                var providedScope = modalOptions.scope || $rootScope;

                                var modalScope = providedScope.$new();
                                modalScope.$close = modalInstance.close;
                                modalScope.$dismiss = modalInstance.dismiss;

                                modalScope.$on('$destroy', function () {
                                    if (!modalScope.$$uibDestructionScheduled) {
                                        modalScope.$dismiss('$uibUnscheduledDestruction');
                                    }
                                });

                                var modal = {
                                    scope: modalScope,
                                    deferred: modalResultDeferred,
                                    renderDeferred: modalRenderDeferred,
                                    closedDeferred: modalClosedDeferred,
                                    animation: modalOptions.animation,
                                    backdrop: modalOptions.backdrop,
                                    keyboard: modalOptions.keyboard,
                                    backdropClass: modalOptions.backdropClass,
                                    windowTopClass: modalOptions.windowTopClass,
                                    windowClass: modalOptions.windowClass,
                                    windowTemplateUrl: modalOptions.windowTemplateUrl,
                                    ariaLabelledBy: modalOptions.ariaLabelledBy,
                                    ariaDescribedBy: modalOptions.ariaDescribedBy,
                                    size: modalOptions.size,
                                    openedClass: modalOptions.openedClass,
                                    appendTo: modalOptions.appendTo
                                };

                                var component = {};
                                var ctrlInstance, ctrlInstantiate, ctrlLocals = {};

                                if (modalOptions.component) {
                                    constructLocals(component, false, true, false);
                                    component.name = modalOptions.component;
                                    modal.component = component;
                                } else if (modalOptions.controller) {
                                    constructLocals(ctrlLocals, true, false, true);

                                    // the third param will make the controller instantiate later,private api
                                    // @see https://github.com/angular/angular.js/blob/master/src/ng/controller.js#L126
                                    ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true, modalOptions.controllerAs);
                                    if (modalOptions.controllerAs && modalOptions.bindToController) {
                                        ctrlInstance = ctrlInstantiate.instance;
                                        ctrlInstance.$close = modalScope.$close;
                                        ctrlInstance.$dismiss = modalScope.$dismiss;
                                        angular.extend(ctrlInstance, {
                                            $resolve: ctrlLocals.$scope.$resolve
                                        }, providedScope);
                                    }

                                    ctrlInstance = ctrlInstantiate();

                                    if (angular.isFunction(ctrlInstance.$onInit)) {
                                        ctrlInstance.$onInit();
                                    }
                                }

                                if (!modalOptions.component) {
                                    modal.content = tplAndVars[0];
                                }

                                $modalStack.open(modalInstance, modal);
                                modalOpenedDeferred.resolve(true);

                                function constructLocals(obj, template, instanceOnScope, injectable) {
                                    obj.$scope = modalScope;
                                    obj.$scope.$resolve = {};
                                    if (instanceOnScope) {
                                        obj.$scope.$uibModalInstance = modalInstance;
                                    } else {
                                        obj.$uibModalInstance = modalInstance;
                                    }

                                    var resolves = template ? tplAndVars[1] : tplAndVars;
                                    angular.forEach(resolves, function (value, key) {
                                        if (injectable) {
                                            obj[key] = value;
                                        }

                                        obj.$scope.$resolve[key] = value;
                                    });
                                }
                            }, function resolveError(reason) {
                                modalOpenedDeferred.reject(reason);
                                modalResultDeferred.reject(reason);
                            })['finally'](function () {
                                if (promiseChain === samePromise) {
                                    promiseChain = null;
                                }
                            });

                        return modalInstance;
                    };

                    return $modal;
                }
            ]
        };

        return $modalProvider;
    });

angular.module('ui.bootstrap.paging', [])
    /**
     * Helper internal service for generating common controller code between the
     * pager and pagination components
     */
    .factory('uibPaging', ['$parse', function ($parse) {
        return {
            create: function (ctrl, $scope, $attrs) {
                ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
                ctrl.ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl
                ctrl._watchers = [];

                ctrl.init = function (ngModelCtrl, config) {
                    ctrl.ngModelCtrl = ngModelCtrl;
                    ctrl.config = config;

                    ngModelCtrl.$render = function () {
                        ctrl.render();
                    };

                    if ($attrs.itemsPerPage) {
                        ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function (value) {
                            ctrl.itemsPerPage = parseInt(value, 10);
                            $scope.totalPages = ctrl.calculateTotalPages();
                            ctrl.updatePage();
                        }));
                    } else {
                        ctrl.itemsPerPage = config.itemsPerPage;
                    }

                    $scope.$watch('totalItems', function (newTotal, oldTotal) {
                        if (angular.isDefined(newTotal) || newTotal !== oldTotal) {
                            $scope.totalPages = ctrl.calculateTotalPages();
                            ctrl.updatePage();
                        }
                    });
                };

                ctrl.calculateTotalPages = function () {
                    var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
                    return Math.max(totalPages || 0, 1);
                };

                ctrl.render = function () {
                    $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
                };

                $scope.selectPage = function (page, evt) {
                    if (evt) {
                        evt.preventDefault();
                    }

                    var clickAllowed = !$scope.ngDisabled || !evt;
                    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
                        if (evt && evt.target) {
                            evt.target.blur();
                        }
                        ctrl.ngModelCtrl.$setViewValue(page);
                        ctrl.ngModelCtrl.$render();
                    }
                };

                $scope.getText = function (key) {
                    return $scope[key + 'Text'] || ctrl.config[key + 'Text'];
                };

                $scope.noPrevious = function () {
                    return $scope.page === 1;
                };

                $scope.noNext = function () {
                    return $scope.page === $scope.totalPages;
                };

                ctrl.updatePage = function () {
                    ctrl.setNumPages($scope.$parent, $scope.totalPages); // Readonly variable

                    if ($scope.page > $scope.totalPages) {
                        $scope.selectPage($scope.totalPages);
                    } else {
                        ctrl.ngModelCtrl.$render();
                    }
                };

                $scope.$on('$destroy', function () {
                    while (ctrl._watchers.length) {
                        ctrl._watchers.shift()();
                    }
                });
            }
        };
    }]);

angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex'])

    .controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function ($scope, $attrs, uibPaging, uibPagerConfig) {
        $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;

        uibPaging.create(this, $scope, $attrs);
    }])

    .constant('uibPagerConfig', {
        itemsPerPage: 10,
        previousText: '« Previous',
        nextText: 'Next »',
        align: true
    })

    .directive('uibPager', ['uibPagerConfig', function (uibPagerConfig) {
        return {
            scope: {
                totalItems: '=',
                previousText: '@',
                nextText: '@',
                ngDisabled: '='
            },
            require: ['uibPager', '?ngModel'],
            restrict: 'A',
            controller: 'UibPagerController',
            controllerAs: 'pager',
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/pager/pager.html';
            },
            link: function (scope, element, attrs, ctrls) {
                element.addClass('pager');
                var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

                if (!ngModelCtrl) {
                    return; // do nothing if no ng-model
                }

                paginationCtrl.init(ngModelCtrl, uibPagerConfig);
            }
        };
    }]);

angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex'])
    .controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function ($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
        var ctrl = this;
        // Setup configuration parameters
        var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,
            rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,
            forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,
            boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers,
            pageLabel = angular.isDefined($attrs.pageLabel) ? function (idx) { return $scope.$parent.$eval($attrs.pageLabel, { $page: idx }); } : angular.identity;
        $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;
        $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;
        $attrs.$set('role', 'menu');

        uibPaging.create(this, $scope, $attrs);

        if ($attrs.maxSize) {
            ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function (value) {
                maxSize = parseInt(value, 10);
                ctrl.render();
            }));
        }

        // Create page object used in template
        function makePage(number, text, isActive) {
            return {
                number: number,
                text: text,
                active: isActive
            };
        }

        function getPages(currentPage, totalPages) {
            var pages = [];

            // Default page limits
            var startPage = 1, endPage = totalPages;
            var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;

            // recompute if maxSize
            if (isMaxSized) {
                if (rotate) {
                    // Current page is displayed in the middle of the visible ones
                    startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
                    endPage = startPage + maxSize - 1;

                    // Adjust if limit is exceeded
                    if (endPage > totalPages) {
                        endPage = totalPages;
                        startPage = endPage - maxSize + 1;
                    }
                } else {
                    // Visible pages are paginated with maxSize
                    startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;

                    // Adjust last page if limit is exceeded
                    endPage = Math.min(startPage + maxSize - 1, totalPages);
                }
            }

            // Add page number links
            for (var number = startPage; number <= endPage; number++) {
                var page = makePage(number, pageLabel(number), number === currentPage);
                pages.push(page);
            }

            // Add links to move between page sets
            if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {
                if (startPage > 1) {
                    if (!boundaryLinkNumbers || startPage > 3) { //need ellipsis for all options unless range is too close to beginning
                        var previousPageSet = makePage(startPage - 1, '...', false);
                        pages.unshift(previousPageSet);
                    }
                    if (boundaryLinkNumbers) {
                        if (startPage === 3) { //need to replace ellipsis when the buttons would be sequential
                            var secondPageLink = makePage(2, '2', false);
                            pages.unshift(secondPageLink);
                        }
                        //add the first page
                        var firstPageLink = makePage(1, '1', false);
                        pages.unshift(firstPageLink);
                    }
                }

                if (endPage < totalPages) {
                    if (!boundaryLinkNumbers || endPage < totalPages - 2) { //need ellipsis for all options unless range is too close to end
                        var nextPageSet = makePage(endPage + 1, '...', false);
                        pages.push(nextPageSet);
                    }
                    if (boundaryLinkNumbers) {
                        if (endPage === totalPages - 2) { //need to replace ellipsis when the buttons would be sequential
                            var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);
                            pages.push(secondToLastPageLink);
                        }
                        //add the last page
                        var lastPageLink = makePage(totalPages, totalPages, false);
                        pages.push(lastPageLink);
                    }
                }
            }
            return pages;
        }

        var originalRender = this.render;
        this.render = function () {
            originalRender();
            if ($scope.page > 0 && $scope.page <= $scope.totalPages) {
                $scope.pages = getPages($scope.page, $scope.totalPages);
            }
        };
    }])

    .constant('uibPaginationConfig', {
        itemsPerPage: 10,
        boundaryLinks: false,
        boundaryLinkNumbers: false,
        directionLinks: true,
        firstText: 'First',
        previousText: 'Previous',
        nextText: 'Next',
        lastText: 'Last',
        rotate: true,
        forceEllipses: false
    })

    .directive('uibPagination', ['$parse', 'uibPaginationConfig', function ($parse, uibPaginationConfig) {
        return {
            scope: {
                totalItems: '=',
                firstText: '@',
                previousText: '@',
                nextText: '@',
                lastText: '@',
                ngDisabled: '='
            },
            require: ['uibPagination', '?ngModel'],
            restrict: 'A',
            controller: 'UibPaginationController',
            controllerAs: 'pagination',
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/pagination/pagination.html';
            },
            link: function (scope, element, attrs, ctrls) {
                element.addClass('pagination');
                var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

                if (!ngModelCtrl) {
                    return; // do nothing if no ng-model
                }

                paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
            }
        };
    }]);

/**
 * The following features are still outstanding: animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html tooltips, and selector delegation.
 */
angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])

    /**
     * The $tooltip service creates tooltip- and popover-like directives as well as
     * houses global options for them.
     */
    .provider('$uibTooltip', function () {
        // The default options tooltip and popover.
        var defaultOptions = {
            placement: 'top',
            placementClassPrefix: '',
            animation: true,
            popupDelay: 0,
            popupCloseDelay: 0,
            useContentExp: false
        };

        // Default hide triggers for each show trigger
        var triggerMap = {
            'mouseenter': 'mouseleave',
            'click': 'click',
            'outsideClick': 'outsideClick',
            'focus': 'blur',
            'none': ''
        };

        // The options specified to the provider globally.
        var globalOptions = {};

        /**
         * `options({})` allows global configuration of all tooltips in the
         * application.
         *
         *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
         *     // place tooltips left instead of top by default
         *     $tooltipProvider.options( { placement: 'left' } );
         *   });
         */
        this.options = function (value) {
            angular.extend(globalOptions, value);
        };

        /**
         * This allows you to extend the set of trigger mappings available. E.g.:
         *
         *   $tooltipProvider.setTriggers( { 'openTrigger': 'closeTrigger' } );
         */
        this.setTriggers = function setTriggers(triggers) {
            angular.extend(triggerMap, triggers);
        };

        /**
         * This is a helper function for translating camel-case to snake_case.
         */
        function snake_case(name) {
            var regexp = /[A-Z]/g;
            var separator = '-';
            return name.replace(regexp, function (letter, pos) {
                return (pos ? separator : '') + letter.toLowerCase();
            });
        }

        /**
         * Returns the actual instance of the $tooltip service.
         * TODO support multiple triggers
         */
        this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function ($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
            var openedTooltips = $$stackedMap.createNew();
            $document.on('keyup', keypressListener);

            $rootScope.$on('$destroy', function () {
                $document.off('keyup', keypressListener);
            });

            function keypressListener(e) {
                if (e.which === 27) {
                    var last = openedTooltips.top();
                    if (last) {
                        last.value.close();
                        last = null;
                    }
                }
            }

            return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
                options = angular.extend({}, defaultOptions, globalOptions, options);

                /**
                 * Returns an object of show and hide triggers.
                 *
                 * If a trigger is supplied,
                 * it is used to show the tooltip; otherwise, it will use the `trigger`
                 * option passed to the `$tooltipProvider.options` method; else it will
                 * default to the trigger supplied to this directive factory.
                 *
                 * The hide trigger is based on the show trigger. If the `trigger` option
                 * was passed to the `$tooltipProvider.options` method, it will use the
                 * mapped trigger from `triggerMap` or the passed trigger if the map is
                 * undefined; otherwise, it uses the `triggerMap` value of the show
                 * trigger; else it will just use the show trigger.
                 */
                function getTriggers(trigger) {
                    var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
                    var hide = show.map(function (trigger) {
                        return triggerMap[trigger] || trigger;
                    });
                    return {
                        show: show,
                        hide: hide
                    };
                }

                var directiveName = snake_case(ttType);

                var startSym = $interpolate.startSymbol();
                var endSym = $interpolate.endSymbol();
                var template =
                    '<div ' + directiveName + '-popup ' +
                    'uib-title="' + startSym + 'title' + endSym + '" ' +
                    (options.useContentExp ?
                        'content-exp="contentExp()" ' :
                        'content="' + startSym + 'content' + endSym + '" ') +
                    'origin-scope="origScope" ' +
                    'class="uib-position-measure ' + prefix + '" ' +
                    'tooltip-animation-class="fade"' +
                    'uib-tooltip-classes ' +
                    'ng-class="{ in: isOpen }" ' +
                    '>' +
                    '</div>';

                return {
                    compile: function (tElem, tAttrs) {
                        var tooltipLinker = $compile(template);

                        return function link(scope, element, attrs, tooltipCtrl) {
                            var tooltip;
                            var tooltipLinkedScope;
                            var transitionTimeout;
                            var showTimeout;
                            var hideTimeout;
                            var positionTimeout;
                            var adjustmentTimeout;
                            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
                            var triggers = getTriggers(undefined);
                            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
                            var ttScope = scope.$new(true);
                            var repositionScheduled = false;
                            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
                            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
                            var observers = [];
                            var lastPlacement;

                            var positionTooltip = function () {
                                // check if tooltip exists and is not empty
                                if (!tooltip || !tooltip.html()) { return; }

                                if (!positionTimeout) {
                                    positionTimeout = $timeout(function () {
                                        var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                                        var initialHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
                                        var elementPos = appendToBody ? $position.offset(element) : $position.position(element);
                                        tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px' });
                                        var placementClasses = ttPosition.placement.split('-');

                                        if (!tooltip.hasClass(placementClasses[0])) {
                                            tooltip.removeClass(lastPlacement.split('-')[0]);
                                            tooltip.addClass(placementClasses[0]);
                                        }

                                        if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {
                                            tooltip.removeClass(options.placementClassPrefix + lastPlacement);
                                            tooltip.addClass(options.placementClassPrefix + ttPosition.placement);
                                        }

                                        adjustmentTimeout = $timeout(function () {
                                            var currentHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
                                            var adjustment = $position.adjustTop(placementClasses, elementPos, initialHeight, currentHeight);
                                            if (adjustment) {
                                                tooltip.css(adjustment);
                                            }
                                            adjustmentTimeout = null;
                                        }, 0, false);

                                        // first time through tt element will have the
                                        // uib-position-measure class or if the placement
                                        // has changed we need to position the arrow.
                                        if (tooltip.hasClass('uib-position-measure')) {
                                            $position.positionArrow(tooltip, ttPosition.placement);
                                            tooltip.removeClass('uib-position-measure');
                                        } else if (lastPlacement !== ttPosition.placement) {
                                            $position.positionArrow(tooltip, ttPosition.placement);
                                        }
                                        lastPlacement = ttPosition.placement;

                                        positionTimeout = null;
                                    }, 0, false);
                                }
                            };

                            // Set up the correct scope to allow transclusion later
                            ttScope.origScope = scope;

                            // By default, the tooltip is not open.
                            // TODO add ability to start tooltip opened
                            ttScope.isOpen = false;

                            function toggleTooltipBind() {
                                if (!ttScope.isOpen) {
                                    showTooltipBind();
                                } else {
                                    hideTooltipBind();
                                }
                            }

                            // Show the tooltip with delay if specified, otherwise show it immediately
                            function showTooltipBind() {
                                if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                                    return;
                                }

                                cancelHide();
                                prepareTooltip();

                                if (ttScope.popupDelay) {
                                    // Do nothing if the tooltip was already scheduled to pop-up.
                                    // This happens if show is triggered multiple times before any hide is triggered.
                                    if (!showTimeout) {
                                        showTimeout = $timeout(show, ttScope.popupDelay, false);
                                    }
                                } else {
                                    show();
                                }
                            }

                            function hideTooltipBind() {
                                cancelShow();

                                if (ttScope.popupCloseDelay) {
                                    if (!hideTimeout) {
                                        hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
                                    }
                                } else {
                                    hide();
                                }
                            }

                            // Show the tooltip popup element.
                            function show() {
                                cancelShow();
                                cancelHide();

                                // Don't show empty tooltips.
                                if (!ttScope.content) {
                                    return angular.noop;
                                }

                                createTooltip();

                                // And show the tooltip.
                                ttScope.$evalAsync(function () {
                                    ttScope.isOpen = true;
                                    assignIsOpen(true);
                                    positionTooltip();
                                });
                            }

                            function cancelShow() {
                                if (showTimeout) {
                                    $timeout.cancel(showTimeout);
                                    showTimeout = null;
                                }

                                if (positionTimeout) {
                                    $timeout.cancel(positionTimeout);
                                    positionTimeout = null;
                                }
                            }

                            // Hide the tooltip popup element.
                            function hide() {
                                if (!ttScope) {
                                    return;
                                }

                                // First things first: we don't show it anymore.
                                ttScope.$evalAsync(function () {
                                    if (ttScope) {
                                        ttScope.isOpen = false;
                                        assignIsOpen(false);
                                        // And now we remove it from the DOM. However, if we have animation, we
                                        // need to wait for it to expire beforehand.
                                        // FIXME: this is a placeholder for a port of the transitions library.
                                        // The fade transition in TWBS is 150ms.
                                        if (ttScope.animation) {
                                            if (!transitionTimeout) {
                                                transitionTimeout = $timeout(removeTooltip, 150, false);
                                            }
                                        } else {
                                            removeTooltip();
                                        }
                                    }
                                });
                            }

                            function cancelHide() {
                                if (hideTimeout) {
                                    $timeout.cancel(hideTimeout);
                                    hideTimeout = null;
                                }

                                if (transitionTimeout) {
                                    $timeout.cancel(transitionTimeout);
                                    transitionTimeout = null;
                                }
                            }

                            function createTooltip() {
                                // There can only be one tooltip element per directive shown at once.
                                if (tooltip) {
                                    return;
                                }

                                tooltipLinkedScope = ttScope.$new();
                                tooltip = tooltipLinker(tooltipLinkedScope, function (tooltip) {
                                    if (appendToBody) {
                                        $document.find('body').append(tooltip);
                                    } else {
                                        element.after(tooltip);
                                    }
                                });

                                openedTooltips.add(ttScope, {
                                    close: hide
                                });

                                prepObservers();
                            }

                            function removeTooltip() {
                                cancelShow();
                                cancelHide();
                                unregisterObservers();

                                if (tooltip) {
                                    tooltip.remove();

                                    tooltip = null;
                                    if (adjustmentTimeout) {
                                        $timeout.cancel(adjustmentTimeout);
                                    }
                                }

                                openedTooltips.remove(ttScope);

                                if (tooltipLinkedScope) {
                                    tooltipLinkedScope.$destroy();
                                    tooltipLinkedScope = null;
                                }
                            }

                            /**
                             * Set the initial scope values. Once
                             * the tooltip is created, the observers
                             * will be added to keep things in sync.
                             */
                            function prepareTooltip() {
                                ttScope.title = attrs[prefix + 'Title'];
                                if (contentParse) {
                                    ttScope.content = contentParse(scope);
                                } else {
                                    ttScope.content = attrs[ttType];
                                }

                                ttScope.popupClass = attrs[prefix + 'Class'];
                                ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;
                                var placement = $position.parsePlacement(ttScope.placement);
                                lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];

                                var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
                                var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
                                ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
                                ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
                            }

                            function assignIsOpen(isOpen) {
                                if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
                                    isOpenParse.assign(scope, isOpen);
                                }
                            }

                            ttScope.contentExp = function () {
                                return ttScope.content;
                            };

                            /**
                             * Observe the relevant attributes.
                             */
                            attrs.$observe('disabled', function (val) {
                                if (val) {
                                    cancelShow();
                                }

                                if (val && ttScope.isOpen) {
                                    hide();
                                }
                            });

                            if (isOpenParse) {
                                scope.$watch(isOpenParse, function (val) {
                                    if (ttScope && !val === ttScope.isOpen) {
                                        toggleTooltipBind();
                                    }
                                });
                            }

                            function prepObservers() {
                                observers.length = 0;

                                if (contentParse) {
                                    observers.push(
                                        scope.$watch(contentParse, function (val) {
                                            ttScope.content = val;
                                            if (!val && ttScope.isOpen) {
                                                hide();
                                            }
                                        })
                                    );

                                    observers.push(
                                        tooltipLinkedScope.$watch(function () {
                                            if (!repositionScheduled) {
                                                repositionScheduled = true;
                                                tooltipLinkedScope.$$postDigest(function () {
                                                    repositionScheduled = false;
                                                    if (ttScope && ttScope.isOpen) {
                                                        positionTooltip();
                                                    }
                                                });
                                            }
                                        })
                                    );
                                } else {
                                    observers.push(
                                        attrs.$observe(ttType, function (val) {
                                            ttScope.content = val;
                                            if (!val && ttScope.isOpen) {
                                                hide();
                                            } else {
                                                positionTooltip();
                                            }
                                        })
                                    );
                                }

                                observers.push(
                                    attrs.$observe(prefix + 'Title', function (val) {
                                        ttScope.title = val;
                                        if (ttScope.isOpen) {
                                            positionTooltip();
                                        }
                                    })
                                );

                                observers.push(
                                    attrs.$observe(prefix + 'Placement', function (val) {
                                        ttScope.placement = val ? val : options.placement;
                                        if (ttScope.isOpen) {
                                            positionTooltip();
                                        }
                                    })
                                );
                            }

                            function unregisterObservers() {
                                if (observers.length) {
                                    angular.forEach(observers, function (observer) {
                                        observer();
                                    });
                                    observers.length = 0;
                                }
                            }

                            // hide tooltips/popovers for outsideClick trigger
                            function bodyHideTooltipBind(e) {
                                if (!ttScope || !ttScope.isOpen || !tooltip) {
                                    return;
                                }
                                // make sure the tooltip/popover link or tool tooltip/popover itself were not clicked
                                if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {
                                    hideTooltipBind();
                                }
                            }

                            // KeyboardEvent handler to hide the tooltip on Escape key press
                            function hideOnEscapeKey(e) {
                                if (e.which === 27) {
                                    hideTooltipBind();
                                }
                            }

                            var unregisterTriggers = function () {
                                triggers.show.forEach(function (trigger) {
                                    if (trigger === 'outsideClick') {
                                        element.off('click', toggleTooltipBind);
                                    } else {
                                        element.off(trigger, showTooltipBind);
                                        element.off(trigger, toggleTooltipBind);
                                    }
                                    element.off('keypress', hideOnEscapeKey);
                                });
                                triggers.hide.forEach(function (trigger) {
                                    if (trigger === 'outsideClick') {
                                        $document.off('click', bodyHideTooltipBind);
                                    } else {
                                        element.off(trigger, hideTooltipBind);
                                    }
                                });
                            };

                            function prepTriggers() {
                                var showTriggers = [], hideTriggers = [];
                                var val = scope.$eval(attrs[prefix + 'Trigger']);
                                unregisterTriggers();

                                if (angular.isObject(val)) {
                                    Object.keys(val).forEach(function (key) {
                                        showTriggers.push(key);
                                        hideTriggers.push(val[key]);
                                    });
                                    triggers = {
                                        show: showTriggers,
                                        hide: hideTriggers
                                    };
                                } else {
                                    triggers = getTriggers(val);
                                }

                                if (triggers.show !== 'none') {
                                    triggers.show.forEach(function (trigger, idx) {
                                        if (trigger === 'outsideClick') {
                                            element.on('click', toggleTooltipBind);
                                            $document.on('click', bodyHideTooltipBind);
                                        } else if (trigger === triggers.hide[idx]) {
                                            element.on(trigger, toggleTooltipBind);
                                        } else if (trigger) {
                                            element.on(trigger, showTooltipBind);
                                            element.on(triggers.hide[idx], hideTooltipBind);
                                        }
                                        element.on('keypress', hideOnEscapeKey);
                                    });
                                }
                            }

                            prepTriggers();

                            var animation = scope.$eval(attrs[prefix + 'Animation']);
                            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;

                            var appendToBodyVal;
                            var appendKey = prefix + 'AppendToBody';
                            if (appendKey in attrs && attrs[appendKey] === undefined) {
                                appendToBodyVal = true;
                            } else {
                                appendToBodyVal = scope.$eval(attrs[appendKey]);
                            }

                            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;

                            // Make sure tooltip is destroyed and removed.
                            scope.$on('$destroy', function onDestroyTooltip() {
                                unregisterTriggers();
                                removeTooltip();
                                ttScope = null;
                            });
                        };
                    }
                };
            };
        }];
    })

    // This is mostly ngInclude code but with a custom scope
    .directive('uibTooltipTemplateTransclude', [
        '$animate', '$sce', '$compile', '$templateRequest',
        function ($animate, $sce, $compile, $templateRequest) {
            return {
                link: function (scope, elem, attrs) {
                    var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);

                    var changeCounter = 0,
                        currentScope,
                        previousElement,
                        currentElement;

                    var cleanupLastIncludeContent = function () {
                        if (previousElement) {
                            previousElement.remove();
                            previousElement = null;
                        }

                        if (currentScope) {
                            currentScope.$destroy();
                            currentScope = null;
                        }

                        if (currentElement) {
                            $animate.leave(currentElement).then(function () {
                                previousElement = null;
                            });
                            previousElement = currentElement;
                            currentElement = null;
                        }
                    };

                    scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function (src) {
                        var thisChangeId = ++changeCounter;

                        if (src) {
                            //set the 2nd param to true to ignore the template request error so that the inner
                            //contents and scope can be cleaned up.
                            $templateRequest(src, true).then(function (response) {
                                if (thisChangeId !== changeCounter) { return; }
                                var newScope = origScope.$new();
                                var template = response;

                                var clone = $compile(template)(newScope, function (clone) {
                                    cleanupLastIncludeContent();
                                    $animate.enter(clone, elem);
                                });

                                currentScope = newScope;
                                currentElement = clone;

                                currentScope.$emit('$includeContentLoaded', src);
                            }, function () {
                                if (thisChangeId === changeCounter) {
                                    cleanupLastIncludeContent();
                                    scope.$emit('$includeContentError', src);
                                }
                            });
                            scope.$emit('$includeContentRequested', src);
                        } else {
                            cleanupLastIncludeContent();
                        }
                    });

                    scope.$on('$destroy', cleanupLastIncludeContent);
                }
            };
        }])

    /**
     * Note that it's intentional that these classes are *not* applied through $animate.
     * They must not be animated as they're expected to be present on the tooltip on
     * initialization.
     */
    .directive('uibTooltipClasses', ['$uibPosition', function ($uibPosition) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                // need to set the primary position so the
                // arrow has space during position measure.
                // tooltip.positionTooltip()
                if (scope.placement) {
                    // // There are no top-left etc... classes
                    // // in TWBS, so we need the primary position.
                    var position = $uibPosition.parsePlacement(scope.placement);
                    element.addClass(position[0]);
                }

                if (scope.popupClass) {
                    element.addClass(scope.popupClass);
                }

                if (scope.animation) {
                    element.addClass(attrs.tooltipAnimationClass);
                }
            }
        };
    }])

    .directive('uibTooltipPopup', function () {
        return {
            restrict: 'A',
            scope: { content: '@' },
            templateUrl: 'uib/template/tooltip/tooltip-popup.html'
        };
    })

    .directive('uibTooltip', ['$uibTooltip', function ($uibTooltip) {
        return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
    }])

    .directive('uibTooltipTemplatePopup', function () {
        return {
            restrict: 'A',
            scope: { contentExp: '&', originScope: '&' },
            templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'
        };
    })

    .directive('uibTooltipTemplate', ['$uibTooltip', function ($uibTooltip) {
        return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {
            useContentExp: true
        });
    }])

    .directive('uibTooltipHtmlPopup', function () {
        return {
            restrict: 'A',
            scope: { contentExp: '&' },
            templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'
        };
    })

    .directive('uibTooltipHtml', ['$uibTooltip', function ($uibTooltip) {
        return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {
            useContentExp: true
        });
    }]);

/**
 * The following features are still outstanding: popup delay, animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, and selector delegatation.
 */
angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])

    .directive('uibPopoverTemplatePopup', function () {
        return {
            restrict: 'A',
            scope: { uibTitle: '@', contentExp: '&', originScope: '&' },
            templateUrl: 'uib/template/popover/popover-template.html'
        };
    })

    .directive('uibPopoverTemplate', ['$uibTooltip', function ($uibTooltip) {
        return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {
            useContentExp: true
        });
    }])

    .directive('uibPopoverHtmlPopup', function () {
        return {
            restrict: 'A',
            scope: { contentExp: '&', uibTitle: '@' },
            templateUrl: 'uib/template/popover/popover-html.html'
        };
    })

    .directive('uibPopoverHtml', ['$uibTooltip', function ($uibTooltip) {
        return $uibTooltip('uibPopoverHtml', 'popover', 'click', {
            useContentExp: true
        });
    }])

    .directive('uibPopoverPopup', function () {
        return {
            restrict: 'A',
            scope: { uibTitle: '@', content: '@' },
            templateUrl: 'uib/template/popover/popover.html'
        };
    })

    .directive('uibPopover', ['$uibTooltip', function ($uibTooltip) {
        return $uibTooltip('uibPopover', 'popover', 'click');
    }]);

angular.module('ui.bootstrap.progressbar', [])

    .constant('uibProgressConfig', {
        animate: true,
        max: 100
    })

    .controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function ($scope, $attrs, progressConfig) {
        var self = this,
            animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

        this.bars = [];
        $scope.max = getMaxOrDefault();

        this.addBar = function (bar, element, attrs) {
            if (!animate) {
                element.css({ 'transition': 'none' });
            }

            this.bars.push(bar);

            bar.max = getMaxOrDefault();
            bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';

            bar.$watch('value', function (value) {
                bar.recalculatePercentage();
            });

            bar.recalculatePercentage = function () {
                var totalPercentage = self.bars.reduce(function (total, bar) {
                    bar.percent = +(100 * bar.value / bar.max).toFixed(2);
                    return total + bar.percent;
                }, 0);

                if (totalPercentage > 100) {
                    bar.percent -= totalPercentage - 100;
                }
            };

            bar.$on('$destroy', function () {
                element = null;
                self.removeBar(bar);
            });
        };

        this.removeBar = function (bar) {
            this.bars.splice(this.bars.indexOf(bar), 1);
            this.bars.forEach(function (bar) {
                bar.recalculatePercentage();
            });
        };

        //$attrs.$observe('maxParam', function(maxParam) {
        $scope.$watch('maxParam', function (maxParam) {
            self.bars.forEach(function (bar) {
                bar.max = getMaxOrDefault();
                bar.recalculatePercentage();
            });
        });

        function getMaxOrDefault() {
            return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;
        }
    }])

    .directive('uibProgress', function () {
        return {
            replace: true,
            transclude: true,
            controller: 'UibProgressController',
            require: 'uibProgress',
            scope: {
                maxParam: '=?max'
            },
            templateUrl: 'uib/template/progressbar/progress.html'
        };
    })

    .directive('uibBar', function () {
        return {
            replace: true,
            transclude: true,
            require: '^uibProgress',
            scope: {
                value: '=',
                type: '@'
            },
            templateUrl: 'uib/template/progressbar/bar.html',
            link: function (scope, element, attrs, progressCtrl) {
                progressCtrl.addBar(scope, element, attrs);
            }
        };
    })

    .directive('uibProgressbar', function () {
        return {
            replace: true,
            transclude: true,
            controller: 'UibProgressController',
            scope: {
                value: '=',
                maxParam: '=?max',
                type: '@'
            },
            templateUrl: 'uib/template/progressbar/progressbar.html',
            link: function (scope, element, attrs, progressCtrl) {
                progressCtrl.addBar(scope, angular.element(element.children()[0]), { title: attrs.title });
            }
        };
    });

angular.module('ui.bootstrap.rating', [])

    .constant('uibRatingConfig', {
        max: 5,
        stateOn: null,
        stateOff: null,
        enableReset: true,
        titles: ['one', 'two', 'three', 'four', 'five']
    })

    .controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function ($scope, $attrs, ratingConfig) {
        var ngModelCtrl = { $setViewValue: angular.noop },
            self = this;

        this.init = function (ngModelCtrl_) {
            ngModelCtrl = ngModelCtrl_;
            ngModelCtrl.$render = this.render;

            ngModelCtrl.$formatters.push(function (value) {
                if (angular.isNumber(value) && value << 0 !== value) {
                    value = Math.round(value);
                }

                return value;
            });

            this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
            this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
            this.enableReset = angular.isDefined($attrs.enableReset) ?
                $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;
            var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
            this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?
                tmpTitles : ratingConfig.titles;

            var ratingStates = angular.isDefined($attrs.ratingStates) ?
                $scope.$parent.$eval($attrs.ratingStates) :
                new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
            $scope.range = this.buildTemplateObjects(ratingStates);
        };

        this.buildTemplateObjects = function (states) {
            for (var i = 0, n = states.length; i < n; i++) {
                states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);
            }
            return states;
        };

        this.getTitle = function (index) {
            if (index >= this.titles.length) {
                return index + 1;
            }

            return this.titles[index];
        };

        $scope.rate = function (value) {
            if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
                var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;
                ngModelCtrl.$setViewValue(newViewValue);
                ngModelCtrl.$render();
            }
        };

        $scope.enter = function (value) {
            if (!$scope.readonly) {
                $scope.value = value;
            }
            $scope.onHover({ value: value });
        };

        $scope.reset = function () {
            $scope.value = ngModelCtrl.$viewValue;
            $scope.onLeave();
        };

        $scope.onKeydown = function (evt) {
            if (/(37|38|39|40)/.test(evt.which)) {
                evt.preventDefault();
                evt.stopPropagation();
                $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
            }
        };

        this.render = function () {
            $scope.value = ngModelCtrl.$viewValue;
            $scope.title = self.getTitle($scope.value - 1);
        };
    }])

    .directive('uibRating', function () {
        return {
            require: ['uibRating', 'ngModel'],
            restrict: 'A',
            scope: {
                readonly: '=?readOnly',
                onHover: '&',
                onLeave: '&'
            },
            controller: 'UibRatingController',
            templateUrl: 'uib/template/rating/rating.html',
            link: function (scope, element, attrs, ctrls) {
                var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                ratingCtrl.init(ngModelCtrl);
            }
        };
    });

angular.module('ui.bootstrap.tabs', [])

    .controller('UibTabsetController', ['$scope', function ($scope) {
        var ctrl = this,
            oldIndex;
        ctrl.tabs = [];

        ctrl.select = function (index, evt) {
            if (!destroyed) {
                var previousIndex = findTabIndex(oldIndex);
                var previousSelected = ctrl.tabs[previousIndex];
                if (previousSelected) {
                    previousSelected.tab.onDeselect({
                        $event: evt,
                        $selectedIndex: index
                    });
                    if (evt && evt.isDefaultPrevented()) {
                        return;
                    }
                    previousSelected.tab.active = false;
                }

                var selected = ctrl.tabs[index];
                if (selected) {
                    selected.tab.onSelect({
                        $event: evt
                    });
                    selected.tab.active = true;
                    ctrl.active = selected.index;
                    oldIndex = selected.index;
                } else if (!selected && angular.isDefined(oldIndex)) {
                    ctrl.active = null;
                    oldIndex = null;
                }
            }
        };

        ctrl.addTab = function addTab(tab) {
            ctrl.tabs.push({
                tab: tab,
                index: tab.index
            });
            ctrl.tabs.sort(function (t1, t2) {
                if (t1.index > t2.index) {
                    return 1;
                }

                if (t1.index < t2.index) {
                    return -1;
                }

                return 0;
            });

            if (tab.index === ctrl.active || !angular.isDefined(ctrl.active) && ctrl.tabs.length === 1) {
                var newActiveIndex = findTabIndex(tab.index);
                ctrl.select(newActiveIndex);
            }
        };

        ctrl.removeTab = function removeTab(tab) {
            var index;
            for (var i = 0; i < ctrl.tabs.length; i++) {
                if (ctrl.tabs[i].tab === tab) {
                    index = i;
                    break;
                }
            }

            if (ctrl.tabs[index].index === ctrl.active) {
                var newActiveTabIndex = index === ctrl.tabs.length - 1 ?
                    index - 1 : index + 1 % ctrl.tabs.length;
                ctrl.select(newActiveTabIndex);
            }

            ctrl.tabs.splice(index, 1);
        };

        $scope.$watch('tabset.active', function (val) {
            if (angular.isDefined(val) && val !== oldIndex) {
                ctrl.select(findTabIndex(val));
            }
        });

        var destroyed;
        $scope.$on('$destroy', function () {
            destroyed = true;
        });

        function findTabIndex(index) {
            for (var i = 0; i < ctrl.tabs.length; i++) {
                if (ctrl.tabs[i].index === index) {
                    return i;
                }
            }
        }
    }])

    .directive('uibTabset', function () {
        return {
            transclude: true,
            replace: true,
            scope: {},
            bindToController: {
                active: '=?',
                type: '@'
            },
            controller: 'UibTabsetController',
            controllerAs: 'tabset',
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/tabs/tabset.html';
            },
            link: function (scope, element, attrs) {
                scope.vertical = angular.isDefined(attrs.vertical) ?
                    scope.$parent.$eval(attrs.vertical) : false;
                scope.justified = angular.isDefined(attrs.justified) ?
                    scope.$parent.$eval(attrs.justified) : false;
            }
        };
    })

    .directive('uibTab', ['$parse', function ($parse) {
        return {
            require: '^uibTabset',
            replace: true,
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/tabs/tab.html';
            },
            transclude: true,
            scope: {
                heading: '@',
                index: '=?',
                classes: '@?',
                onSelect: '&select', //This callback is called in contentHeadingTransclude
                //once it inserts the tab's content into the dom
                onDeselect: '&deselect'
            },
            controller: function () {
                //Empty controller so other directives can require being 'under' a tab
            },
            controllerAs: 'tab',
            link: function (scope, elm, attrs, tabsetCtrl, transclude) {
                scope.disabled = false;
                if (attrs.disable) {
                    scope.$parent.$watch($parse(attrs.disable), function (value) {
                        scope.disabled = !!value;
                    });
                }

                if (angular.isUndefined(attrs.index)) {
                    if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {
                        scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function (t) { return t.index; })) + 1;
                    } else {
                        scope.index = 0;
                    }
                }

                if (angular.isUndefined(attrs.classes)) {
                    scope.classes = '';
                }

                scope.select = function (evt) {
                    if (!scope.disabled) {
                        var index;
                        for (var i = 0; i < tabsetCtrl.tabs.length; i++) {
                            if (tabsetCtrl.tabs[i].tab === scope) {
                                index = i;
                                break;
                            }
                        }

                        tabsetCtrl.select(index, evt);
                    }
                };

                tabsetCtrl.addTab(scope);
                scope.$on('$destroy', function () {
                    tabsetCtrl.removeTab(scope);
                });

                //We need to transclude later, once the content container is ready.
                //when this link happens, we're inside a tab heading.
                scope.$transcludeFn = transclude;
            }
        };
    }])

    .directive('uibTabHeadingTransclude', function () {
        return {
            restrict: 'A',
            require: '^uibTab',
            link: function (scope, elm) {
                scope.$watch('headingElement', function updateHeadingElement(heading) {
                    if (heading) {
                        elm.html('');
                        elm.append(heading);
                    }
                });
            }
        };
    })

    .directive('uibTabContentTransclude', function () {
        return {
            restrict: 'A',
            require: '^uibTabset',
            link: function (scope, elm, attrs) {
                var tab = scope.$eval(attrs.uibTabContentTransclude).tab;

                //Now our tab is ready to be transcluded: both the tab heading area
                //and the tab content area are loaded.  Transclude 'em both.
                tab.$transcludeFn(tab.$parent, function (contents) {
                    angular.forEach(contents, function (node) {
                        if (isTabHeading(node)) {
                            //Let tabHeadingTransclude know.
                            tab.headingElement = node;
                        } else {
                            elm.append(node);
                        }
                    });
                });
            }
        };

        function isTabHeading(node) {
            return node.tagName && (
                node.hasAttribute('uib-tab-heading') ||
                node.hasAttribute('data-uib-tab-heading') ||
                node.hasAttribute('x-uib-tab-heading') ||
                node.tagName.toLowerCase() === 'uib-tab-heading' ||
                node.tagName.toLowerCase() === 'data-uib-tab-heading' ||
                node.tagName.toLowerCase() === 'x-uib-tab-heading' ||
                node.tagName.toLowerCase() === 'uib:tab-heading'
            );
        }
    });

angular.module('ui.bootstrap.timepicker', [])

    .constant('uibTimepickerConfig', {
        hourStep: 1,
        minuteStep: 1,
        secondStep: 1,
        showMeridian: true,
        showSeconds: false,
        meridians: null,
        readonlyInput: false,
        mousewheel: true,
        arrowkeys: true,
        showSpinners: true,
        templateUrl: 'uib/template/timepicker/timepicker.html'
    })

    .controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function ($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
        var hoursModelCtrl, minutesModelCtrl, secondsModelCtrl;
        var selected = new Date(),
            watchers = [],
            ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
            meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS,
            padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;

        $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
        $element.removeAttr('tabindex');

        this.init = function (ngModelCtrl_, inputs) {
            ngModelCtrl = ngModelCtrl_;
            ngModelCtrl.$render = this.render;

            ngModelCtrl.$formatters.unshift(function (modelValue) {
                return modelValue ? new Date(modelValue) : null;
            });

            var hoursInputEl = inputs.eq(0),
                minutesInputEl = inputs.eq(1),
                secondsInputEl = inputs.eq(2);

            hoursModelCtrl = hoursInputEl.controller('ngModel');
            minutesModelCtrl = minutesInputEl.controller('ngModel');
            secondsModelCtrl = secondsInputEl.controller('ngModel');

            var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;

            if (mousewheel) {
                this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
            }

            var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
            if (arrowkeys) {
                this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);
            }

            $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
            this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
        };

        var hourStep = timepickerConfig.hourStep;
        if ($attrs.hourStep) {
            watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function (value) {
                hourStep = +value;
            }));
        }

        var minuteStep = timepickerConfig.minuteStep;
        if ($attrs.minuteStep) {
            watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function (value) {
                minuteStep = +value;
            }));
        }

        var min;
        watchers.push($scope.$parent.$watch($parse($attrs.min), function (value) {
            var dt = new Date(value);
            min = isNaN(dt) ? undefined : dt;
        }));

        var max;
        watchers.push($scope.$parent.$watch($parse($attrs.max), function (value) {
            var dt = new Date(value);
            max = isNaN(dt) ? undefined : dt;
        }));

        var disabled = false;
        if ($attrs.ngDisabled) {
            watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function (value) {
                disabled = value;
            }));
        }

        $scope.noIncrementHours = function () {
            var incrementedSelected = addMinutes(selected, hourStep * 60);
            return disabled || incrementedSelected > max ||
                incrementedSelected < selected && incrementedSelected < min;
        };

        $scope.noDecrementHours = function () {
            var decrementedSelected = addMinutes(selected, -hourStep * 60);
            return disabled || decrementedSelected < min ||
                decrementedSelected > selected && decrementedSelected > max;
        };

        $scope.noIncrementMinutes = function () {
            var incrementedSelected = addMinutes(selected, minuteStep);
            return disabled || incrementedSelected > max ||
                incrementedSelected < selected && incrementedSelected < min;
        };

        $scope.noDecrementMinutes = function () {
            var decrementedSelected = addMinutes(selected, -minuteStep);
            return disabled || decrementedSelected < min ||
                decrementedSelected > selected && decrementedSelected > max;
        };

        $scope.noIncrementSeconds = function () {
            var incrementedSelected = addSeconds(selected, secondStep);
            return disabled || incrementedSelected > max ||
                incrementedSelected < selected && incrementedSelected < min;
        };

        $scope.noDecrementSeconds = function () {
            var decrementedSelected = addSeconds(selected, -secondStep);
            return disabled || decrementedSelected < min ||
                decrementedSelected > selected && decrementedSelected > max;
        };

        $scope.noToggleMeridian = function () {
            if (selected.getHours() < 12) {
                return disabled || addMinutes(selected, 12 * 60) > max;
            }

            return disabled || addMinutes(selected, -12 * 60) < min;
        };

        var secondStep = timepickerConfig.secondStep;
        if ($attrs.secondStep) {
            watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function (value) {
                secondStep = +value;
            }));
        }

        $scope.showSeconds = timepickerConfig.showSeconds;
        if ($attrs.showSeconds) {
            watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function (value) {
                $scope.showSeconds = !!value;
            }));
        }

        // 12H / 24H mode
        $scope.showMeridian = timepickerConfig.showMeridian;
        if ($attrs.showMeridian) {
            watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function (value) {
                $scope.showMeridian = !!value;

                if (ngModelCtrl.$error.time) {
                    // Evaluate from template
                    var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
                    if (angular.isDefined(hours) && angular.isDefined(minutes)) {
                        selected.setHours(hours);
                        refresh();
                    }
                } else {
                    updateTemplate();
                }
            }));
        }

        // Get $scope.hours in 24H mode if valid
        function getHoursFromTemplate() {
            var hours = +$scope.hours;
            var valid = $scope.showMeridian ? hours > 0 && hours < 13 :
                hours >= 0 && hours < 24;
            if (!valid || $scope.hours === '') {
                return undefined;
            }

            if ($scope.showMeridian) {
                if (hours === 12) {
                    hours = 0;
                }
                if ($scope.meridian === meridians[1]) {
                    hours = hours + 12;
                }
            }
            return hours;
        }

        function getMinutesFromTemplate() {
            var minutes = +$scope.minutes;
            var valid = minutes >= 0 && minutes < 60;
            if (!valid || $scope.minutes === '') {
                return undefined;
            }
            return minutes;
        }

        function getSecondsFromTemplate() {
            var seconds = +$scope.seconds;
            return seconds >= 0 && seconds < 60 ? seconds : undefined;
        }

        function pad(value, noPad) {
            if (value === null) {
                return '';
            }

            return angular.isDefined(value) && value.toString().length < 2 && !noPad ?
                '0' + value : value.toString();
        }

        // Respond on mousewheel spin
        this.setupMousewheelEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
            var isScrollingUp = function (e) {
                if (e.originalEvent) {
                    e = e.originalEvent;
                }
                //pick correct delta variable depending on event
                var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
                return e.detail || delta > 0;
            };

            hoursInputEl.on('mousewheel wheel', function (e) {
                if (!disabled) {
                    $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
                }
                e.preventDefault();
            });

            minutesInputEl.on('mousewheel wheel', function (e) {
                if (!disabled) {
                    $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
                }
                e.preventDefault();
            });

            secondsInputEl.on('mousewheel wheel', function (e) {
                if (!disabled) {
                    $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());
                }
                e.preventDefault();
            });
        };

        // Respond on up/down arrowkeys
        this.setupArrowkeyEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
            hoursInputEl.on('keydown', function (e) {
                if (!disabled) {
                    if (e.which === 38) { // up
                        e.preventDefault();
                        $scope.incrementHours();
                        $scope.$apply();
                    } else if (e.which === 40) { // down
                        e.preventDefault();
                        $scope.decrementHours();
                        $scope.$apply();
                    }
                }
            });

            minutesInputEl.on('keydown', function (e) {
                if (!disabled) {
                    if (e.which === 38) { // up
                        e.preventDefault();
                        $scope.incrementMinutes();
                        $scope.$apply();
                    } else if (e.which === 40) { // down
                        e.preventDefault();
                        $scope.decrementMinutes();
                        $scope.$apply();
                    }
                }
            });

            secondsInputEl.on('keydown', function (e) {
                if (!disabled) {
                    if (e.which === 38) { // up
                        e.preventDefault();
                        $scope.incrementSeconds();
                        $scope.$apply();
                    } else if (e.which === 40) { // down
                        e.preventDefault();
                        $scope.decrementSeconds();
                        $scope.$apply();
                    }
                }
            });
        };

        this.setupInputEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
            if ($scope.readonlyInput) {
                $scope.updateHours = angular.noop;
                $scope.updateMinutes = angular.noop;
                $scope.updateSeconds = angular.noop;
                return;
            }

            var invalidate = function (invalidHours, invalidMinutes, invalidSeconds) {
                ngModelCtrl.$setViewValue(null);
                ngModelCtrl.$setValidity('time', false);
                if (angular.isDefined(invalidHours)) {
                    $scope.invalidHours = invalidHours;
                    if (hoursModelCtrl) {
                        hoursModelCtrl.$setValidity('hours', false);
                    }
                }

                if (angular.isDefined(invalidMinutes)) {
                    $scope.invalidMinutes = invalidMinutes;
                    if (minutesModelCtrl) {
                        minutesModelCtrl.$setValidity('minutes', false);
                    }
                }

                if (angular.isDefined(invalidSeconds)) {
                    $scope.invalidSeconds = invalidSeconds;
                    if (secondsModelCtrl) {
                        secondsModelCtrl.$setValidity('seconds', false);
                    }
                }
            };

            $scope.updateHours = function () {
                var hours = getHoursFromTemplate(),
                    minutes = getMinutesFromTemplate();

                ngModelCtrl.$setDirty();

                if (angular.isDefined(hours) && angular.isDefined(minutes)) {
                    selected.setHours(hours);
                    selected.setMinutes(minutes);
                    if (selected < min || selected > max) {
                        invalidate(true);
                    } else {
                        refresh('h');
                    }
                } else {
                    invalidate(true);
                }
            };

            hoursInputEl.on('blur', function (e) {
                ngModelCtrl.$setTouched();
                if (modelIsEmpty()) {
                    makeValid();
                } else if ($scope.hours === null || $scope.hours === '') {
                    invalidate(true);
                } else if (!$scope.invalidHours && $scope.hours < 10) {
                    $scope.$apply(function () {
                        $scope.hours = pad($scope.hours, !padHours);
                    });
                }
            });

            $scope.updateMinutes = function () {
                var minutes = getMinutesFromTemplate(),
                    hours = getHoursFromTemplate();

                ngModelCtrl.$setDirty();

                if (angular.isDefined(minutes) && angular.isDefined(hours)) {
                    selected.setHours(hours);
                    selected.setMinutes(minutes);
                    if (selected < min || selected > max) {
                        invalidate(undefined, true);
                    } else {
                        refresh('m');
                    }
                } else {
                    invalidate(undefined, true);
                }
            };

            minutesInputEl.on('blur', function (e) {
                ngModelCtrl.$setTouched();
                if (modelIsEmpty()) {
                    makeValid();
                } else if ($scope.minutes === null) {
                    invalidate(undefined, true);
                } else if (!$scope.invalidMinutes && $scope.minutes < 10) {
                    $scope.$apply(function () {
                        $scope.minutes = pad($scope.minutes);
                    });
                }
            });

            $scope.updateSeconds = function () {
                var seconds = getSecondsFromTemplate();

                ngModelCtrl.$setDirty();

                if (angular.isDefined(seconds)) {
                    selected.setSeconds(seconds);
                    refresh('s');
                } else {
                    invalidate(undefined, undefined, true);
                }
            };

            secondsInputEl.on('blur', function (e) {
                if (modelIsEmpty()) {
                    makeValid();
                } else if (!$scope.invalidSeconds && $scope.seconds < 10) {
                    $scope.$apply(function () {
                        $scope.seconds = pad($scope.seconds);
                    });
                }
            });

        };

        this.render = function () {
            var date = ngModelCtrl.$viewValue;

            if (isNaN(date)) {
                ngModelCtrl.$setValidity('time', false);
                $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
            } else {
                if (date) {
                    selected = date;
                }

                if (selected < min || selected > max) {
                    ngModelCtrl.$setValidity('time', false);
                    $scope.invalidHours = true;
                    $scope.invalidMinutes = true;
                } else {
                    makeValid();
                }
                updateTemplate();
            }
        };

        // Call internally when we know that model is valid.
        function refresh(keyboardChange) {
            makeValid();
            ngModelCtrl.$setViewValue(new Date(selected));
            updateTemplate(keyboardChange);
        }

        function makeValid() {
            if (hoursModelCtrl) {
                hoursModelCtrl.$setValidity('hours', true);
            }

            if (minutesModelCtrl) {
                minutesModelCtrl.$setValidity('minutes', true);
            }

            if (secondsModelCtrl) {
                secondsModelCtrl.$setValidity('seconds', true);
            }

            ngModelCtrl.$setValidity('time', true);
            $scope.invalidHours = false;
            $scope.invalidMinutes = false;
            $scope.invalidSeconds = false;
        }

        function updateTemplate(keyboardChange) {
            if (!ngModelCtrl.$modelValue) {
                $scope.hours = null;
                $scope.minutes = null;
                $scope.seconds = null;
                $scope.meridian = meridians[0];
            } else {
                var hours = selected.getHours(),
                    minutes = selected.getMinutes(),
                    seconds = selected.getSeconds();

                if ($scope.showMeridian) {
                    hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system
                }

                $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);
                if (keyboardChange !== 'm') {
                    $scope.minutes = pad(minutes);
                }
                $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];

                if (keyboardChange !== 's') {
                    $scope.seconds = pad(seconds);
                }
                $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
            }
        }

        function addSecondsToSelected(seconds) {
            selected = addSeconds(selected, seconds);
            refresh();
        }

        function addMinutes(selected, minutes) {
            return addSeconds(selected, minutes * 60);
        }

        function addSeconds(date, seconds) {
            var dt = new Date(date.getTime() + seconds * 1000);
            var newDate = new Date(date);
            newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());
            return newDate;
        }

        function modelIsEmpty() {
            return ($scope.hours === null || $scope.hours === '') &&
                ($scope.minutes === null || $scope.minutes === '') &&
                (!$scope.showSeconds || $scope.showSeconds && ($scope.seconds === null || $scope.seconds === ''));
        }

        $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?
            $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;

        $scope.incrementHours = function () {
            if (!$scope.noIncrementHours()) {
                addSecondsToSelected(hourStep * 60 * 60);
            }
        };

        $scope.decrementHours = function () {
            if (!$scope.noDecrementHours()) {
                addSecondsToSelected(-hourStep * 60 * 60);
            }
        };

        $scope.incrementMinutes = function () {
            if (!$scope.noIncrementMinutes()) {
                addSecondsToSelected(minuteStep * 60);
            }
        };

        $scope.decrementMinutes = function () {
            if (!$scope.noDecrementMinutes()) {
                addSecondsToSelected(-minuteStep * 60);
            }
        };

        $scope.incrementSeconds = function () {
            if (!$scope.noIncrementSeconds()) {
                addSecondsToSelected(secondStep);
            }
        };

        $scope.decrementSeconds = function () {
            if (!$scope.noDecrementSeconds()) {
                addSecondsToSelected(-secondStep);
            }
        };

        $scope.toggleMeridian = function () {
            var minutes = getMinutesFromTemplate(),
                hours = getHoursFromTemplate();

            if (!$scope.noToggleMeridian()) {
                if (angular.isDefined(minutes) && angular.isDefined(hours)) {
                    addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));
                } else {
                    $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];
                }
            }
        };

        $scope.blur = function () {
            ngModelCtrl.$setTouched();
        };

        $scope.$on('$destroy', function () {
            while (watchers.length) {
                watchers.shift()();
            }
        });
    }])

    .directive('uibTimepicker', ['uibTimepickerConfig', function (uibTimepickerConfig) {
        return {
            require: ['uibTimepicker', '?^ngModel'],
            restrict: 'A',
            controller: 'UibTimepickerController',
            controllerAs: 'timepicker',
            scope: {},
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || uibTimepickerConfig.templateUrl;
            },
            link: function (scope, element, attrs, ctrls) {
                var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

                if (ngModelCtrl) {
                    timepickerCtrl.init(ngModelCtrl, element.find('input'));
                }
            }
        };
    }]);

angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])

    /**
     * A helper service that can parse typeahead's syntax (string provided by users)
     * Extracted to a separate service for ease of unit testing
     */
    .factory('uibTypeaheadParser', ['$parse', function ($parse) {
        //                      000001111111100000000000002222222200000000000000003333333333333330000000000044444444000
        var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
        return {
            parse: function (input) {
                var match = input.match(TYPEAHEAD_REGEXP);
                if (!match) {
                    throw new Error(
                        'Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' +
                        ' but got "' + input + '".');
                }

                return {
                    itemName: match[3],
                    source: $parse(match[4]),
                    viewMapper: $parse(match[2] || match[1]),
                    modelMapper: $parse(match[1])
                };
            }
        };
    }])

    .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',
        function (originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
            var HOT_KEYS = [9, 13, 27, 38, 40];
            var eventDebounceTime = 200;
            var modelCtrl, ngModelOptions;
            //SUPPORTED ATTRIBUTES (OPTIONS)

            //minimal no of characters that needs to be entered before typeahead kicks-in
            var minLength = originalScope.$eval(attrs.typeaheadMinLength);
            if (!minLength && minLength !== 0) {
                minLength = 1;
            }

            originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {
                minLength = !newVal && newVal !== 0 ? 1 : newVal;
            });

            //minimal wait time after last character typed before typeahead kicks-in
            var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

            //should it restrict model values to the ones selected from the popup only?
            var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
            originalScope.$watch(attrs.typeaheadEditable, function (newVal) {
                isEditable = newVal !== false;
            });

            //binding to a variable that indicates if matches are being retrieved asynchronously
            var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

            //a function to determine if an event should cause selection
            var isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function (scope, vals) {
                var evt = vals.$event;
                return evt.which === 13 || evt.which === 9;
            };

            //a callback executed when a match is selected
            var onSelectCallback = $parse(attrs.typeaheadOnSelect);

            //should it select highlighted popup value when losing focus?
            var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;

            //binding to a variable that indicates if there were no results after the query is completed
            var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;

            var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

            var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;

            var appendTo = attrs.typeaheadAppendTo ?
                originalScope.$eval(attrs.typeaheadAppendTo) : null;

            var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;

            //If input matches an item of the list exactly, select it automatically
            var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;

            //binding to a variable that indicates if dropdown is open
            var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;

            var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;

            //INTERNAL VARIABLES

            //model setter executed upon match selection
            var parsedModel = $parse(attrs.ngModel);
            var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
            var $setModelValue = function (scope, newValue) {
                if (angular.isFunction(parsedModel(originalScope)) &&
                    ngModelOptions.getOption('getterSetter')) {
                    return invokeModelSetter(scope, { $$$p: newValue });
                }

                return parsedModel.assign(scope, newValue);
            };

            //expressions used by typeahead
            var parserResult = typeaheadParser.parse(attrs.uibTypeahead);

            var hasFocus;

            //Used to avoid bug in iOS webview where iOS keyboard does not fire
            //mousedown & mouseup events
            //Issue #3699
            var selected;

            //create a child scope for the typeahead directive so we are not polluting original scope
            //with typeahead-specific data (matches, query etc.)
            var scope = originalScope.$new();
            var offDestroy = originalScope.$on('$destroy', function () {
                scope.$destroy();
            });
            scope.$on('$destroy', offDestroy);

            // WAI-ARIA
            var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
            element.attr({
                'aria-autocomplete': 'list',
                'aria-expanded': false,
                'aria-owns': popupId
            });

            var inputsContainer, hintInputElem;
            //add read-only input to show hint
            if (showHint) {
                inputsContainer = angular.element('<div></div>');
                inputsContainer.css('position', 'relative');
                element.after(inputsContainer);
                hintInputElem = element.clone();
                hintInputElem.attr('placeholder', '');
                hintInputElem.attr('tabindex', '-1');
                hintInputElem.val('');
                hintInputElem.css({
                    'position': 'absolute',
                    'top': '0px',
                    'left': '0px',
                    'border-color': 'transparent',
                    'box-shadow': 'none',
                    'opacity': 1,
                    'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',
                    'color': '#999'
                });
                element.css({
                    'position': 'relative',
                    'vertical-align': 'top',
                    'background-color': 'transparent'
                });

                if (hintInputElem.attr('id')) {
                    hintInputElem.removeAttr('id'); // remove duplicate id if present.
                }
                inputsContainer.append(hintInputElem);
                hintInputElem.after(element);
            }

            //pop-up element used to display matches
            var popUpEl = angular.element('<div uib-typeahead-popup></div>');
            popUpEl.attr({
                id: popupId,
                matches: 'matches',
                active: 'activeIdx',
                select: 'select(activeIdx, evt)',
                'move-in-progress': 'moveInProgress',
                query: 'query',
                position: 'position',
                'assign-is-open': 'assignIsOpen(isOpen)',
                debounce: 'debounceUpdate'
            });
            //custom item template
            if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
                popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
            }

            if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
                popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
            }

            var resetHint = function () {
                if (showHint) {
                    hintInputElem.val('');
                }
            };

            var resetMatches = function () {
                scope.matches = [];
                scope.activeIdx = -1;
                element.attr('aria-expanded', false);
                resetHint();
            };

            var getMatchId = function (index) {
                return popupId + '-option-' + index;
            };

            // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
            // This attribute is added or removed automatically when the `activeIdx` changes.
            scope.$watch('activeIdx', function (index) {
                if (index < 0) {
                    element.removeAttr('aria-activedescendant');
                } else {
                    element.attr('aria-activedescendant', getMatchId(index));
                }
            });

            var inputIsExactMatch = function (inputValue, index) {
                if (scope.matches.length > index && inputValue) {
                    return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
                }

                return false;
            };

            var getMatchesAsync = function (inputValue, evt) {
                var locals = { $viewValue: inputValue };
                isLoadingSetter(originalScope, true);
                isNoResultsSetter(originalScope, false);
                $q.when(parserResult.source(originalScope, locals)).then(function (matches) {
                    //it might happen that several async queries were in progress if a user were typing fast
                    //but we are interested only in responses that correspond to the current view value
                    var onCurrentRequest = inputValue === modelCtrl.$viewValue;
                    if (onCurrentRequest && hasFocus) {
                        if (matches && matches.length > 0) {
                            scope.activeIdx = focusFirst ? 0 : -1;
                            isNoResultsSetter(originalScope, false);
                            scope.matches.length = 0;

                            //transform labels
                            for (var i = 0; i < matches.length; i++) {
                                locals[parserResult.itemName] = matches[i];
                                scope.matches.push({
                                    id: getMatchId(i),
                                    label: parserResult.viewMapper(scope, locals),
                                    model: matches[i]
                                });
                            }

                            scope.query = inputValue;
                            //position pop-up with matches - we need to re-calculate its position each time we are opening a window
                            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
                            //due to other elements being rendered
                            recalculatePosition();

                            element.attr('aria-expanded', true);

                            //Select the single remaining option if user input matches
                            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
                                if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                                    $$debounce(function () {
                                        scope.select(0, evt);
                                    }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
                                } else {
                                    scope.select(0, evt);
                                }
                            }

                            if (showHint) {
                                var firstLabel = scope.matches[0].label;
                                if (angular.isString(inputValue) &&
                                    inputValue.length > 0 &&
                                    firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {
                                    hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));
                                } else {
                                    hintInputElem.val('');
                                }
                            }
                        } else {
                            resetMatches();
                            isNoResultsSetter(originalScope, true);
                        }
                    }
                    if (onCurrentRequest) {
                        isLoadingSetter(originalScope, false);
                    }
                }, function () {
                    resetMatches();
                    isLoadingSetter(originalScope, false);
                    isNoResultsSetter(originalScope, true);
                });
            };

            // bind events only if appendToBody params exist - performance feature
            if (appendToBody) {
                angular.element($window).on('resize', fireRecalculating);
                $document.find('body').on('scroll', fireRecalculating);
            }

            // Declare the debounced function outside recalculating for
            // proper debouncing
            var debouncedRecalculate = $$debounce(function () {
                // if popup is visible
                if (scope.matches.length) {
                    recalculatePosition();
                }

                scope.moveInProgress = false;
            }, eventDebounceTime);

            // Default progress type
            scope.moveInProgress = false;

            function fireRecalculating() {
                if (!scope.moveInProgress) {
                    scope.moveInProgress = true;
                    scope.$digest();
                }

                debouncedRecalculate();
            }

            // recalculate actual position and set new values to scope
            // after digest loop is popup in right position
            function recalculatePosition() {
                scope.position = appendToBody ? $position.offset(element) : $position.position(element);
                scope.position.top += element.prop('offsetHeight');
            }

            //we need to propagate user's query so we can higlight matches
            scope.query = undefined;

            //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
            var timeoutPromise;

            var scheduleSearchWithTimeout = function (inputValue) {
                timeoutPromise = $timeout(function () {
                    getMatchesAsync(inputValue);
                }, waitTime);
            };

            var cancelPreviousTimeout = function () {
                if (timeoutPromise) {
                    $timeout.cancel(timeoutPromise);
                }
            };

            resetMatches();

            scope.assignIsOpen = function (isOpen) {
                isOpenSetter(originalScope, isOpen);
            };

            scope.select = function (activeIdx, evt) {
                //called from within the $digest() cycle
                var locals = {};
                var model, item;

                selected = true;
                locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
                model = parserResult.modelMapper(originalScope, locals);
                $setModelValue(originalScope, model);
                modelCtrl.$setValidity('editable', true);
                modelCtrl.$setValidity('parse', true);

                onSelectCallback(originalScope, {
                    $item: item,
                    $model: model,
                    $label: parserResult.viewMapper(originalScope, locals),
                    $event: evt
                });

                resetMatches();

                //return focus to the input element if a match was selected via a mouse click event
                // use timeout to avoid $rootScope:inprog error
                if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
                    $timeout(function () { element[0].focus(); }, 0, false);
                }
            };

            //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
            element.on('keydown', function (evt) {
                //typeahead is open and an "interesting" key was pressed
                if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
                    return;
                }

                var shouldSelect = isSelectEvent(originalScope, { $event: evt });

                /**
                 * if there's nothing selected (i.e. focusFirst) and enter or tab is hit
                 * or
                 * shift + tab is pressed to bring focus to the previous element
                 * then clear the results
                 */
                if (scope.activeIdx === -1 && shouldSelect || evt.which === 9 && !!evt.shiftKey) {
                    resetMatches();
                    scope.$digest();
                    return;
                }

                evt.preventDefault();
                var target;
                switch (evt.which) {
                    case 27: // escape
                        evt.stopPropagation();

                        resetMatches();
                        originalScope.$digest();
                        break;
                    case 38: // up arrow
                        scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
                        scope.$digest();
                        target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
                        target.parentNode.scrollTop = target.offsetTop;
                        break;
                    case 40: // down arrow
                        scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
                        scope.$digest();
                        target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
                        target.parentNode.scrollTop = target.offsetTop;
                        break;
                    default:
                        if (shouldSelect) {
                            scope.$apply(function () {
                                if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                                    $$debounce(function () {
                                        scope.select(scope.activeIdx, evt);
                                    }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
                                } else {
                                    scope.select(scope.activeIdx, evt);
                                }
                            });
                        }
                }
            });

            element.on('focus', function (evt) {
                hasFocus = true;
                if (minLength === 0 && !modelCtrl.$viewValue) {
                    $timeout(function () {
                        getMatchesAsync(modelCtrl.$viewValue, evt);
                    }, 0);
                }
            });

            element.on('blur', function (evt) {
                if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
                    selected = true;
                    scope.$apply(function () {
                        if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {
                            $$debounce(function () {
                                scope.select(scope.activeIdx, evt);
                            }, scope.debounceUpdate.blur);
                        } else {
                            scope.select(scope.activeIdx, evt);
                        }
                    });
                }
                if (!isEditable && modelCtrl.$error.editable) {
                    modelCtrl.$setViewValue();
                    scope.$apply(function () {
                        // Reset validity as we are clearing
                        modelCtrl.$setValidity('editable', true);
                        modelCtrl.$setValidity('parse', true);
                    });
                    element.val('');
                }
                hasFocus = false;
                selected = false;
            });

            // Keep reference to click handler to unbind it.
            var dismissClickHandler = function (evt) {
                // Issue #3973
                // Firefox treats right click as a click on document
                if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
                    resetMatches();
                    if (!$rootScope.$$phase) {
                        originalScope.$digest();
                    }
                }
            };

            $document.on('click', dismissClickHandler);

            originalScope.$on('$destroy', function () {
                $document.off('click', dismissClickHandler);
                if (appendToBody || appendTo) {
                    $popup.remove();
                }

                if (appendToBody) {
                    angular.element($window).off('resize', fireRecalculating);
                    $document.find('body').off('scroll', fireRecalculating);
                }
                // Prevent jQuery cache memory leak
                popUpEl.remove();

                if (showHint) {
                    inputsContainer.remove();
                }
            });

            var $popup = $compile(popUpEl)(scope);

            if (appendToBody) {
                $document.find('body').append($popup);
            } else if (appendTo) {
                angular.element(appendTo).eq(0).append($popup);
            } else {
                element.after($popup);
            }

            this.init = function (_modelCtrl) {
                modelCtrl = _modelCtrl;
                ngModelOptions = extractOptions(modelCtrl);

                scope.debounceUpdate = $parse(ngModelOptions.getOption('debounce'))(originalScope);

                //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
                //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
                modelCtrl.$parsers.unshift(function (inputValue) {
                    hasFocus = true;

                    if (minLength === 0 || inputValue && inputValue.length >= minLength) {
                        if (waitTime > 0) {
                            cancelPreviousTimeout();
                            scheduleSearchWithTimeout(inputValue);
                        } else {
                            getMatchesAsync(inputValue);
                        }
                    } else {
                        isLoadingSetter(originalScope, false);
                        cancelPreviousTimeout();
                        resetMatches();
                    }

                    if (isEditable) {
                        return inputValue;
                    }

                    if (!inputValue) {
                        // Reset in case user had typed something previously.
                        modelCtrl.$setValidity('editable', true);
                        return null;
                    }

                    modelCtrl.$setValidity('editable', false);
                    return undefined;
                });

                modelCtrl.$formatters.push(function (modelValue) {
                    var candidateViewValue, emptyViewValue;
                    var locals = {};

                    // The validity may be set to false via $parsers (see above) if
                    // the model is restricted to selected values. If the model
                    // is set manually it is considered to be valid.
                    if (!isEditable) {
                        modelCtrl.$setValidity('editable', true);
                    }

                    if (inputFormatter) {
                        locals.$model = modelValue;
                        return inputFormatter(originalScope, locals);
                    }

                    //it might happen that we don't have enough info to properly render input value
                    //we need to check for this situation and simply return model value if we can't apply custom formatting
                    locals[parserResult.itemName] = modelValue;
                    candidateViewValue = parserResult.viewMapper(originalScope, locals);
                    locals[parserResult.itemName] = undefined;
                    emptyViewValue = parserResult.viewMapper(originalScope, locals);

                    return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
                });
            };

            function extractOptions(ngModelCtrl) {
                var ngModelOptions;

                if (angular.version.minor < 6) { // in angular < 1.6 $options could be missing
                    // guarantee a value
                    ngModelOptions = ngModelCtrl.$options || {};

                    // mimic 1.6+ api
                    ngModelOptions.getOption = function (key) {
                        return ngModelOptions[key];
                    };
                } else { // in angular >=1.6 $options is always present
                    ngModelOptions = ngModelCtrl.$options;
                }

                return ngModelOptions;
            }
        }])

    .directive('uibTypeahead', function () {
        return {
            controller: 'UibTypeaheadController',
            require: ['ngModel', 'uibTypeahead'],
            link: function (originalScope, element, attrs, ctrls) {
                ctrls[1].init(ctrls[0]);
            }
        };
    })

    .directive('uibTypeaheadPopup', ['$$debounce', function ($$debounce) {
        return {
            scope: {
                matches: '=',
                query: '=',
                active: '=',
                position: '&',
                moveInProgress: '=',
                select: '&',
                assignIsOpen: '&',
                debounce: '&'
            },
            replace: true,
            templateUrl: function (element, attrs) {
                return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';
            },
            link: function (scope, element, attrs) {
                scope.templateUrl = attrs.templateUrl;

                scope.isOpen = function () {
                    var isDropdownOpen = scope.matches.length > 0;
                    scope.assignIsOpen({ isOpen: isDropdownOpen });
                    return isDropdownOpen;
                };

                scope.isActive = function (matchIdx) {
                    return scope.active === matchIdx;
                };

                scope.selectActive = function (matchIdx) {
                    scope.active = matchIdx;
                };

                scope.selectMatch = function (activeIdx, evt) {
                    var debounce = scope.debounce();
                    if (angular.isNumber(debounce) || angular.isObject(debounce)) {
                        $$debounce(function () {
                            scope.select({ activeIdx: activeIdx, evt: evt });
                        }, angular.isNumber(debounce) ? debounce : debounce['default']);
                    } else {
                        scope.select({ activeIdx: activeIdx, evt: evt });
                    }
                };
            }
        };
    }])

    .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function ($templateRequest, $compile, $parse) {
        return {
            scope: {
                index: '=',
                match: '=',
                query: '='
            },
            link: function (scope, element, attrs) {
                var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';
                $templateRequest(tplUrl).then(function (tplContent) {
                    var tplEl = angular.element(tplContent.trim());
                    element.replaceWith(tplEl);
                    $compile(tplEl)(scope);
                });
            }
        };
    }])

    .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function ($sce, $injector, $log) {
        var isSanitizePresent;
        isSanitizePresent = $injector.has('$sanitize');

        function escapeRegexp(queryToEscape) {
            // Regex: capture the whole query string and replace it with the string that will be used to match
            // the results, for example if the capture is "a" the result will be \a
            return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
        }

        function containsHtml(matchItem) {
            return /<.*>/g.test(matchItem);
        }

        return function (matchItem, query) {
            if (!isSanitizePresent && containsHtml(matchItem)) {
                $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger
            }
            matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a "strong" tag
            if (!isSanitizePresent) {
                matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive
            }
            return matchItem;
        };
    }]);

angular.module("uib/template/accordion/accordion-group.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/accordion/accordion-group.html",
        "<div role=\"tab\" id=\"{{::headingId}}\" aria-selected=\"{{isOpen}}\" class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\n" +
        "  <h4 class=\"panel-title\">\n" +
        "    <a role=\"button\" data-toggle=\"collapse\" href aria-expanded=\"{{isOpen}}\" aria-controls=\"{{::panelId}}\" tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\" ng-disabled=\"isDisabled\" uib-tabindex-toggle><span uib-accordion-header ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" +
        "  </h4>\n" +
        "</div>\n" +
        "<div id=\"{{::panelId}}\" aria-labelledby=\"{{::headingId}}\" aria-hidden=\"{{!isOpen}}\" role=\"tabpanel\" class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\">\n" +
        "  <div class=\"panel-body\" ng-transclude></div>\n" +
        "</div>\n" +
        "");
}]);

angular.module("uib/template/accordion/accordion.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/accordion/accordion.html",
        "<div role=\"tablist\" class=\"panel-group\" ng-transclude></div>");
}]);

angular.module("uib/template/alert/alert.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/alert/alert.html",
        "<button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\n" +
        "  <span aria-hidden=\"true\">&times;</span>\n" +
        "  <span class=\"sr-only\">Close</span>\n" +
        "</button>\n" +
        "<div ng-transclude></div>\n" +
        "");
}]);

angular.module("uib/template/carousel/carousel.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/carousel/carousel.html",
        "<div class=\"carousel-inner\" ng-transclude></div>\n" +
        "<a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-class=\"{ disabled: isPrevDisabled() }\" ng-show=\"slides.length > 1\">\n" +
        "  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\n" +
        "  <span class=\"sr-only\">previous</span>\n" +
        "</a>\n" +
        "<a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-class=\"{ disabled: isNextDisabled() }\" ng-show=\"slides.length > 1\">\n" +
        "  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\n" +
        "  <span class=\"sr-only\">next</span>\n" +
        "</a>\n" +
        "<ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" +
        "  <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" +
        "    <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" +
        "  </li>\n" +
        "</ol>\n" +
        "");
}]);

angular.module("uib/template/carousel/slide.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/carousel/slide.html",
        "<div class=\"text-center\" ng-transclude></div>\n" +
        "");
}]);

angular.module("uib/template/datepicker/datepicker.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/datepicker/datepicker.html",
        "<div ng-switch=\"datepickerMode\">\n" +
        "  <div uib-daypicker ng-switch-when=\"day\" tabindex=\"0\" class=\"uib-daypicker\"></div>\n" +
        "  <div uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\" class=\"uib-monthpicker\"></div>\n" +
        "  <div uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\" class=\"uib-yearpicker\"></div>\n" +
        "</div>\n" +
        "");
}]);

angular.module("uib/template/datepicker/day.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/datepicker/day.html",
        "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
        "  <thead>\n" +
        "    <tr>\n" +
        "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\n" +
        "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
        "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></button></th>\n" +
        "    </tr>\n" +
        "    <tr>\n" +
        "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" +
        "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" +
        "    </tr>\n" +
        "  </thead>\n" +
        "  <tbody>\n" +
        "    <tr class=\"uib-weeks\" ng-repeat=\"row in rows track by $index\" role=\"row\">\n" +
        "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" +
        "      <td ng-repeat=\"dt in row\" class=\"uib-day text-center\" role=\"gridcell\"\n" +
        "        id=\"{{::dt.uid}}\"\n" +
        "        ng-class=\"::dt.customClass\">\n" +
        "        <button type=\"button\" class=\"btn btn-default btn-sm\"\n" +
        "          uib-is-class=\"\n" +
        "            'btn-info' for selectedDt,\n" +
        "            'active' for activeDt\n" +
        "            on dt\"\n" +
        "          ng-click=\"select(dt.date)\"\n" +
        "          ng-disabled=\"::dt.disabled\"\n" +
        "          tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
        "      </td>\n" +
        "    </tr>\n" +
        "  </tbody>\n" +
        "</table>\n" +
        "");
}]);

angular.module("uib/template/datepicker/month.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/datepicker/month.html",
        "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
        "  <thead>\n" +
        "    <tr>\n" +
        "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\n" +
        "      <th colspan=\"{{::yearHeaderColspan}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
        "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></i></button></th>\n" +
        "    </tr>\n" +
        "  </thead>\n" +
        "  <tbody>\n" +
        "    <tr class=\"uib-months\" ng-repeat=\"row in rows track by $index\" role=\"row\">\n" +
        "      <td ng-repeat=\"dt in row\" class=\"uib-month text-center\" role=\"gridcell\"\n" +
        "        id=\"{{::dt.uid}}\"\n" +
        "        ng-class=\"::dt.customClass\">\n" +
        "        <button type=\"button\" class=\"btn btn-default\"\n" +
        "          uib-is-class=\"\n" +
        "            'btn-info' for selectedDt,\n" +
        "            'active' for activeDt\n" +
        "            on dt\"\n" +
        "          ng-click=\"select(dt.date)\"\n" +
        "          ng-disabled=\"::dt.disabled\"\n" +
        "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
        "      </td>\n" +
        "    </tr>\n" +
        "  </tbody>\n" +
        "</table>\n" +
        "");
}]);

angular.module("uib/template/datepicker/year.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/datepicker/year.html",
        "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
        "  <thead>\n" +
        "    <tr>\n" +
        "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\n" +
        "      <th colspan=\"{{::columns - 2}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
        "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></button></th>\n" +
        "    </tr>\n" +
        "  </thead>\n" +
        "  <tbody>\n" +
        "    <tr class=\"uib-years\" ng-repeat=\"row in rows track by $index\" role=\"row\">\n" +
        "      <td ng-repeat=\"dt in row\" class=\"uib-year text-center\" role=\"gridcell\"\n" +
        "        id=\"{{::dt.uid}}\"\n" +
        "        ng-class=\"::dt.customClass\">\n" +
        "        <button type=\"button\" class=\"btn btn-default\"\n" +
        "          uib-is-class=\"\n" +
        "            'btn-info' for selectedDt,\n" +
        "            'active' for activeDt\n" +
        "            on dt\"\n" +
        "          ng-click=\"select(dt.date)\"\n" +
        "          ng-disabled=\"::dt.disabled\"\n" +
        "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
        "      </td>\n" +
        "    </tr>\n" +
        "  </tbody>\n" +
        "</table>\n" +
        "");
}]);

angular.module("uib/template/datepickerPopup/popup.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/datepickerPopup/popup.html",
        "<ul role=\"presentation\" class=\"uib-datepicker-popup dropdown-menu uib-position-measure\" dropdown-nested ng-if=\"isOpen\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" +
        "  <li ng-transclude></li>\n" +
        "  <li ng-if=\"showButtonBar\" class=\"uib-button-bar\">\n" +
        "    <span class=\"btn-group pull-left\">\n" +
        "      <button type=\"button\" class=\"btn btn-sm btn-info uib-datepicker-current\" ng-click=\"select('today', $event)\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" +
        "      <button type=\"button\" class=\"btn btn-sm btn-danger uib-clear\" ng-click=\"select(null, $event)\">{{ getText('clear') }}</button>\n" +
        "    </span>\n" +
        "    <button type=\"button\" class=\"btn btn-sm btn-success pull-right uib-close\" ng-click=\"close($event)\">{{ getText('close') }}</button>\n" +
        "  </li>\n" +
        "</ul>\n" +
        "");
}]);

angular.module("uib/template/modal/window.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/modal/window.html",
        "<div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n" +
        "");
}]);

angular.module("uib/template/pager/pager.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/pager/pager.html",
        "<li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\n" +
        "<li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\n" +
        "");
}]);

angular.module("uib/template/pagination/pagination.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/pagination/pagination.html",
        "<li role=\"menuitem\" ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('first')}}</a></li>\n" +
        "<li role=\"menuitem\" ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\n" +
        "<li role=\"menuitem\" ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\" ng-disabled=\"ngDisabled&&!page.active\" uib-tabindex-toggle>{{page.text}}</a></li>\n" +
        "<li role=\"menuitem\" ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\n" +
        "<li role=\"menuitem\" ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('last')}}</a></li>\n" +
        "");
}]);

angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-html-popup.html",
        "<div class=\"tooltip-arrow\"></div>\n" +
        "<div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" +
        "");
}]);

angular.module("uib/template/tooltip/tooltip-popup.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-popup.html",
        "<div class=\"tooltip-arrow\"></div>\n" +
        "<div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
        "");
}]);

angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-template-popup.html",
        "<div class=\"tooltip-arrow\"></div>\n" +
        "<div class=\"tooltip-inner\"\n" +
        "  uib-tooltip-template-transclude=\"contentExp()\"\n" +
        "  tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
        "");
}]);

angular.module("uib/template/popover/popover-html.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/popover/popover-html.html",
        "<div class=\"arrow\"></div>\n" +
        "\n" +
        "<div class=\"popover-inner\">\n" +
        "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" +
        "    <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\n" +
        "</div>\n" +
        "");
}]);

angular.module("uib/template/popover/popover-template.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/popover/popover-template.html",
        "<div class=\"arrow\"></div>\n" +
        "\n" +
        "<div class=\"popover-inner\">\n" +
        "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" +
        "    <div class=\"popover-content\"\n" +
        "      uib-tooltip-template-transclude=\"contentExp()\"\n" +
        "      tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
        "</div>\n" +
        "");
}]);

angular.module("uib/template/popover/popover.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/popover/popover.html",
        "<div class=\"arrow\"></div>\n" +
        "\n" +
        "<div class=\"popover-inner\">\n" +
        "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" +
        "    <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
        "</div>\n" +
        "");
}]);

angular.module("uib/template/progressbar/bar.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/progressbar/bar.html",
        "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" +
        "");
}]);

angular.module("uib/template/progressbar/progress.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/progressbar/progress.html",
        "<div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"></div>");
}]);

angular.module("uib/template/progressbar/progressbar.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/progressbar/progressbar.html",
        "<div class=\"progress\">\n" +
        "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" +
        "</div>\n" +
        "");
}]);

angular.module("uib/template/rating/rating.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/rating/rating.html",
        "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\" aria-valuetext=\"{{title}}\">\n" +
        "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" +
        "    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\"></i>\n" +
        "</span>\n" +
        "");
}]);

angular.module("uib/template/tabs/tab.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/tabs/tab.html",
        "<li ng-class=\"[{active: active, disabled: disabled}, classes]\" class=\"uib-tab nav-item\">\n" +
        "  <a href ng-click=\"select($event)\" class=\"nav-link\" uib-tab-heading-transclude>{{heading}}</a>\n" +
        "</li>\n" +
        "");
}]);

angular.module("uib/template/tabs/tabset.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/tabs/tabset.html",
        "<div>\n" +
        "  <ul class=\"nav nav-{{tabset.type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" +
        "  <div class=\"tab-content\">\n" +
        "    <div class=\"tab-pane\"\n" +
        "         ng-repeat=\"tab in tabset.tabs\"\n" +
        "         ng-class=\"{active: tabset.active === tab.index}\"\n" +
        "         uib-tab-content-transclude=\"tab\">\n" +
        "    </div>\n" +
        "  </div>\n" +
        "</div>\n" +
        "");
}]);

angular.module("uib/template/timepicker/timepicker.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/timepicker/timepicker.html",
        "<table class=\"uib-timepicker\">\n" +
        "  <tbody>\n" +
        "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
        "      <td class=\"uib-increment hours\"><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
        "      <td>&nbsp;</td>\n" +
        "      <td class=\"uib-increment minutes\"><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
        "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
        "      <td ng-show=\"showSeconds\" class=\"uib-increment seconds\"><a ng-click=\"incrementSeconds()\" ng-class=\"{disabled: noIncrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementSeconds()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
        "      <td ng-show=\"showMeridian\"></td>\n" +
        "    </tr>\n" +
        "    <tr>\n" +
        "      <td class=\"form-group uib-time hours\" ng-class=\"{'has-error': invalidHours}\">\n" +
        "        <input type=\"text\" placeholder=\"HH\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementHours()\" ng-blur=\"blur()\">\n" +
        "      </td>\n" +
        "      <td class=\"uib-separator\">:</td>\n" +
        "      <td class=\"form-group uib-time minutes\" ng-class=\"{'has-error': invalidMinutes}\">\n" +
        "        <input type=\"text\" placeholder=\"MM\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementMinutes()\" ng-blur=\"blur()\">\n" +
        "      </td>\n" +
        "      <td ng-show=\"showSeconds\" class=\"uib-separator\">:</td>\n" +
        "      <td class=\"form-group uib-time seconds\" ng-class=\"{'has-error': invalidSeconds}\" ng-show=\"showSeconds\">\n" +
        "        <input type=\"text\" placeholder=\"SS\" ng-model=\"seconds\" ng-change=\"updateSeconds()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementSeconds()\" ng-blur=\"blur()\">\n" +
        "      </td>\n" +
        "      <td ng-show=\"showMeridian\" class=\"uib-time am-pm\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\n" +
        "    </tr>\n" +
        "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
        "      <td class=\"uib-decrement hours\"><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
        "      <td>&nbsp;</td>\n" +
        "      <td class=\"uib-decrement minutes\"><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
        "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
        "      <td ng-show=\"showSeconds\" class=\"uib-decrement seconds\"><a ng-click=\"decrementSeconds()\" ng-class=\"{disabled: noDecrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementSeconds()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
        "      <td ng-show=\"showMeridian\"></td>\n" +
        "    </tr>\n" +
        "  </tbody>\n" +
        "</table>\n" +
        "");
}]);

angular.module("uib/template/typeahead/typeahead-match.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/typeahead/typeahead-match.html",
        "<a href\n" +
        "   tabindex=\"-1\"\n" +
        "   ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"\n" +
        "   ng-attr-title=\"{{match.label}}\"></a>\n" +
        "");
}]);

angular.module("uib/template/typeahead/typeahead-popup.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/typeahead/typeahead-popup.html",
        "<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" +
        "    <li class=\"uib-typeahead-match\" ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index, $event)\" role=\"option\" id=\"{{::match.id}}\">\n" +
        "        <div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" +
        "    </li>\n" +
        "</ul>\n" +
        "");
}]);
angular.module('ui.bootstrap.carousel').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'); angular.$$uibCarouselCss = true; });
angular.module('ui.bootstrap.datepicker').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>'); angular.$$uibDatepickerCss = true; });
angular.module('ui.bootstrap.position').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'); angular.$$uibPositionCss = true; });
angular.module('ui.bootstrap.datepickerPopup').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>'); angular.$$uibDatepickerpopupCss = true; });
angular.module('ui.bootstrap.tooltip').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'); angular.$$uibTooltipCss = true; });
angular.module('ui.bootstrap.timepicker').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-time input{width:50px;}</style>'); angular.$$uibTimepickerCss = true; });
angular.module('ui.bootstrap.typeahead').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'); angular.$$uibTypeaheadCss = true; });
/*!
 * Bootstrap v3.3.1 (http://getbootstrap.com)
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */
if ("undefined" == typeof jQuery) throw new Error("Bootstrap's JavaScript requires jQuery"); +function (a) { var b = a.fn.jquery.split(" ")[0].split("."); if (b[0] < 2 && b[1] < 9 || 1 == b[0] && 9 == b[1] && b[2] < 1) throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher") }(jQuery), +function (a) { "use strict"; function b() { var a = document.createElement("bootstrap"), b = { WebkitTransition: "webkitTransitionEnd", MozTransition: "transitionend", OTransition: "oTransitionEnd otransitionend", transition: "transitionend" }; for (var c in b) if (void 0 !== a.style[c]) return { end: b[c] }; return !1 } a.fn.emulateTransitionEnd = function (b) { var c = !1, d = this; a(this).one("bsTransitionEnd", function () { c = !0 }); var e = function () { c || a(d).trigger(a.support.transition.end) }; return setTimeout(e, b), this }, a(function () { a.support.transition = b(), a.support.transition && (a.event.special.bsTransitionEnd = { bindType: a.support.transition.end, delegateType: a.support.transition.end, handle: function (b) { return a(b.target).is(this) ? b.handleObj.handler.apply(this, arguments) : void 0 } }) }) }(jQuery), +function (a) { "use strict"; function b(b) { return this.each(function () { var c = a(this), e = c.data("bs.alert"); e || c.data("bs.alert", e = new d(this)), "string" == typeof b && e[b].call(c) }) } var c = '[data-dismiss="alert"]', d = function (b) { a(b).on("click", c, this.close) }; d.VERSION = "3.3.1", d.TRANSITION_DURATION = 150, d.prototype.close = function (b) { function c() { g.detach().trigger("closed.bs.alert").remove() } var e = a(this), f = e.attr("data-target"); f || (f = e.attr("href"), f = f && f.replace(/.*(?=#[^\s]*$)/, "")); var g = a(f); b && b.preventDefault(), g.length || (g = e.closest(".alert")), g.trigger(b = a.Event("close.bs.alert")), b.isDefaultPrevented() || (g.removeClass("in"), a.support.transition && g.hasClass("fade") ? g.one("bsTransitionEnd", c).emulateTransitionEnd(d.TRANSITION_DURATION) : c()) }; var e = a.fn.alert; a.fn.alert = b, a.fn.alert.Constructor = d, a.fn.alert.noConflict = function () { return a.fn.alert = e, this }, a(document).on("click.bs.alert.data-api", c, d.prototype.close) }(jQuery), +function (a) { "use strict"; function b(b) { return this.each(function () { var d = a(this), e = d.data("bs.button"), f = "object" == typeof b && b; e || d.data("bs.button", e = new c(this, f)), "toggle" == b ? e.toggle() : b && e.setState(b) }) } var c = function (b, d) { this.$element = a(b), this.options = a.extend({}, c.DEFAULTS, d), this.isLoading = !1 }; c.VERSION = "3.3.1", c.DEFAULTS = { loadingText: "loading..." }, c.prototype.setState = function (b) { var c = "disabled", d = this.$element, e = d.is("input") ? "val" : "html", f = d.data(); b += "Text", null == f.resetText && d.data("resetText", d[e]()), setTimeout(a.proxy(function () { d[e](null == f[b] ? this.options[b] : f[b]), "loadingText" == b ? (this.isLoading = !0, d.addClass(c).attr(c, c)) : this.isLoading && (this.isLoading = !1, d.removeClass(c).removeAttr(c)) }, this), 0) }, c.prototype.toggle = function () { var a = !0, b = this.$element.closest('[data-toggle="buttons"]'); if (b.length) { var c = this.$element.find("input"); "radio" == c.prop("type") && (c.prop("checked") && this.$element.hasClass("active") ? a = !1 : b.find(".active").removeClass("active")), a && c.prop("checked", !this.$element.hasClass("active")).trigger("change") } else this.$element.attr("aria-pressed", !this.$element.hasClass("active")); a && this.$element.toggleClass("active") }; var d = a.fn.button; a.fn.button = b, a.fn.button.Constructor = c, a.fn.button.noConflict = function () { return a.fn.button = d, this }, a(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function (c) { var d = a(c.target); d.hasClass("btn") || (d = d.closest(".btn")), b.call(d, "toggle"), c.preventDefault() }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function (b) { a(b.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(b.type)) }) }(jQuery), +function (a) { "use strict"; function b(b) { return this.each(function () { var d = a(this), e = d.data("bs.carousel"), f = a.extend({}, c.DEFAULTS, d.data(), "object" == typeof b && b), g = "string" == typeof b ? b : f.slide; e || d.data("bs.carousel", e = new c(this, f)), "number" == typeof b ? e.to(b) : g ? e[g]() : f.interval && e.pause().cycle() }) } var c = function (b, c) { this.$element = a(b), this.$indicators = this.$element.find(".carousel-indicators"), this.options = c, this.paused = this.sliding = this.interval = this.$active = this.$items = null, this.options.keyboard && this.$element.on("keydown.bs.carousel", a.proxy(this.keydown, this)), "hover" == this.options.pause && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", a.proxy(this.pause, this)).on("mouseleave.bs.carousel", a.proxy(this.cycle, this)) }; c.VERSION = "3.3.1", c.TRANSITION_DURATION = 600, c.DEFAULTS = { interval: 5e3, pause: "hover", wrap: !0, keyboard: !0 }, c.prototype.keydown = function (a) { if (!/input|textarea/i.test(a.target.tagName)) { switch (a.which) { case 37: this.prev(); break; case 39: this.next(); break; default: return }a.preventDefault() } }, c.prototype.cycle = function (b) { return b || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval(a.proxy(this.next, this), this.options.interval)), this }, c.prototype.getItemIndex = function (a) { return this.$items = a.parent().children(".item"), this.$items.index(a || this.$active) }, c.prototype.getItemForDirection = function (a, b) { var c = this.getItemIndex(b), d = "prev" == a && 0 === c || "next" == a && c == this.$items.length - 1; if (d && !this.options.wrap) return b; var e = "prev" == a ? -1 : 1, f = (c + e) % this.$items.length; return this.$items.eq(f) }, c.prototype.to = function (a) { var b = this, c = this.getItemIndex(this.$active = this.$element.find(".item.active")); return a > this.$items.length - 1 || 0 > a ? void 0 : this.sliding ? this.$element.one("slid.bs.carousel", function () { b.to(a) }) : c == a ? this.pause().cycle() : this.slide(a > c ? "next" : "prev", this.$items.eq(a)) }, c.prototype.pause = function (b) { return b || (this.paused = !0), this.$element.find(".next, .prev").length && a.support.transition && (this.$element.trigger(a.support.transition.end), this.cycle(!0)), this.interval = clearInterval(this.interval), this }, c.prototype.next = function () { return this.sliding ? void 0 : this.slide("next") }, c.prototype.prev = function () { return this.sliding ? void 0 : this.slide("prev") }, c.prototype.slide = function (b, d) { var e = this.$element.find(".item.active"), f = d || this.getItemForDirection(b, e), g = this.interval, h = "next" == b ? "left" : "right", i = this; if (f.hasClass("active")) return this.sliding = !1; var j = f[0], k = a.Event("slide.bs.carousel", { relatedTarget: j, direction: h }); if (this.$element.trigger(k), !k.isDefaultPrevented()) { if (this.sliding = !0, g && this.pause(), this.$indicators.length) { this.$indicators.find(".active").removeClass("active"); var l = a(this.$indicators.children()[this.getItemIndex(f)]); l && l.addClass("active") } var m = a.Event("slid.bs.carousel", { relatedTarget: j, direction: h }); return a.support.transition && this.$element.hasClass("slide") ? (f.addClass(b), f[0].offsetWidth, e.addClass(h), f.addClass(h), e.one("bsTransitionEnd", function () { f.removeClass([b, h].join(" ")).addClass("active"), e.removeClass(["active", h].join(" ")), i.sliding = !1, setTimeout(function () { i.$element.trigger(m) }, 0) }).emulateTransitionEnd(c.TRANSITION_DURATION)) : (e.removeClass("active"), f.addClass("active"), this.sliding = !1, this.$element.trigger(m)), g && this.cycle(), this } }; var d = a.fn.carousel; a.fn.carousel = b, a.fn.carousel.Constructor = c, a.fn.carousel.noConflict = function () { return a.fn.carousel = d, this }; var e = function (c) { var d, e = a(this), f = a(e.attr("data-target") || (d = e.attr("href")) && d.replace(/.*(?=#[^\s]+$)/, "")); if (f.hasClass("carousel")) { var g = a.extend({}, f.data(), e.data()), h = e.attr("data-slide-to"); h && (g.interval = !1), b.call(f, g), h && f.data("bs.carousel").to(h), c.preventDefault() } }; a(document).on("click.bs.carousel.data-api", "[data-slide]", e).on("click.bs.carousel.data-api", "[data-slide-to]", e), a(window).on("load", function () { a('[data-ride="carousel"]').each(function () { var c = a(this); b.call(c, c.data()) }) }) }(jQuery), +function (a) { "use strict"; function b(b) { var c, d = b.attr("data-target") || (c = b.attr("href")) && c.replace(/.*(?=#[^\s]+$)/, ""); return a(d) } function c(b) { return this.each(function () { var c = a(this), e = c.data("bs.collapse"), f = a.extend({}, d.DEFAULTS, c.data(), "object" == typeof b && b); !e && f.toggle && "show" == b && (f.toggle = !1), e || c.data("bs.collapse", e = new d(this, f)), "string" == typeof b && e[b]() }) } var d = function (b, c) { this.$element = a(b), this.options = a.extend({}, d.DEFAULTS, c), this.$trigger = a(this.options.trigger).filter('[href="#' + b.id + '"], [data-target="#' + b.id + '"]'), this.transitioning = null, this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger), this.options.toggle && this.toggle() }; d.VERSION = "3.3.1", d.TRANSITION_DURATION = 350, d.DEFAULTS = { toggle: !0, trigger: '[data-toggle="collapse"]' }, d.prototype.dimension = function () { var a = this.$element.hasClass("width"); return a ? "width" : "height" }, d.prototype.show = function () { if (!this.transitioning && !this.$element.hasClass("in")) { var b, e = this.$parent && this.$parent.children(".panel").children(".in, .collapsing"); if (!(e && e.length && (b = e.data("bs.collapse"), b && b.transitioning))) { var f = a.Event("show.bs.collapse"); if (this.$element.trigger(f), !f.isDefaultPrevented()) { e && e.length && (c.call(e, "hide"), b || e.data("bs.collapse", null)); var g = this.dimension(); this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded", !0), this.$trigger.removeClass("collapsed").attr("aria-expanded", !0), this.transitioning = 1; var h = function () { this.$element.removeClass("collapsing").addClass("collapse in")[g](""), this.transitioning = 0, this.$element.trigger("shown.bs.collapse") }; if (!a.support.transition) return h.call(this); var i = a.camelCase(["scroll", g].join("-")); this.$element.one("bsTransitionEnd", a.proxy(h, this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i]) } } } }, d.prototype.hide = function () { if (!this.transitioning && this.$element.hasClass("in")) { var b = a.Event("hide.bs.collapse"); if (this.$element.trigger(b), !b.isDefaultPrevented()) { var c = this.dimension(); this.$element[c](this.$element[c]())[0].offsetHeight, this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", !1), this.$trigger.addClass("collapsed").attr("aria-expanded", !1), this.transitioning = 1; var e = function () { this.transitioning = 0, this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse") }; return a.support.transition ? void this.$element[c](0).one("bsTransitionEnd", a.proxy(e, this)).emulateTransitionEnd(d.TRANSITION_DURATION) : e.call(this) } } }, d.prototype.toggle = function () { this[this.$element.hasClass("in") ? "hide" : "show"]() }, d.prototype.getParent = function () { return a(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each(a.proxy(function (c, d) { var e = a(d); this.addAriaAndCollapsedClass(b(e), e) }, this)).end() }, d.prototype.addAriaAndCollapsedClass = function (a, b) { var c = a.hasClass("in"); a.attr("aria-expanded", c), b.toggleClass("collapsed", !c).attr("aria-expanded", c) }; var e = a.fn.collapse; a.fn.collapse = c, a.fn.collapse.Constructor = d, a.fn.collapse.noConflict = function () { return a.fn.collapse = e, this }, a(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function (d) { var e = a(this); e.attr("data-target") || d.preventDefault(); var f = b(e), g = f.data("bs.collapse"), h = g ? "toggle" : a.extend({}, e.data(), { trigger: this }); c.call(f, h) }) }(jQuery), +function (a) { "use strict"; function b(b) { b && 3 === b.which || (a(e).remove(), a(f).each(function () { var d = a(this), e = c(d), f = { relatedTarget: this }; e.hasClass("open") && (e.trigger(b = a.Event("hide.bs.dropdown", f)), b.isDefaultPrevented() || (d.attr("aria-expanded", "false"), e.removeClass("open").trigger("hidden.bs.dropdown", f))) })) } function c(b) { var c = b.attr("data-target"); c || (c = b.attr("href"), c = c && /#[A-Za-z]/.test(c) && c.replace(/.*(?=#[^\s]*$)/, "")); var d = c && a(c); return d && d.length ? d : b.parent() } function d(b) { return this.each(function () { var c = a(this), d = c.data("bs.dropdown"); d || c.data("bs.dropdown", d = new g(this)), "string" == typeof b && d[b].call(c) }) } var e = ".dropdown-backdrop", f = '[data-toggle="dropdown"]', g = function (b) { a(b).on("click.bs.dropdown", this.toggle) }; g.VERSION = "3.3.1", g.prototype.toggle = function (d) { var e = a(this); if (!e.is(".disabled, :disabled")) { var f = c(e), g = f.hasClass("open"); if (b(), !g) { "ontouchstart" in document.documentElement && !f.closest(".navbar-nav").length && a('<div class="dropdown-backdrop"/>').insertAfter(a(this)).on("click", b); var h = { relatedTarget: this }; if (f.trigger(d = a.Event("show.bs.dropdown", h)), d.isDefaultPrevented()) return; e.trigger("focus").attr("aria-expanded", "true"), f.toggleClass("open").trigger("shown.bs.dropdown", h) } return !1 } }, g.prototype.keydown = function (b) { if (/(38|40|27|32)/.test(b.which) && !/input|textarea/i.test(b.target.tagName)) { var d = a(this); if (b.preventDefault(), b.stopPropagation(), !d.is(".disabled, :disabled")) { var e = c(d), g = e.hasClass("open"); if (!g && 27 != b.which || g && 27 == b.which) return 27 == b.which && e.find(f).trigger("focus"), d.trigger("click"); var h = " li:not(.divider):visible a", i = e.find('[role="menu"]' + h + ', [role="listbox"]' + h); if (i.length) { var j = i.index(b.target); 38 == b.which && j > 0 && j-- , 40 == b.which && j < i.length - 1 && j++ , ~j || (j = 0), i.eq(j).trigger("focus") } } } }; var h = a.fn.dropdown; a.fn.dropdown = d, a.fn.dropdown.Constructor = g, a.fn.dropdown.noConflict = function () { return a.fn.dropdown = h, this }, a(document).on("click.bs.dropdown.data-api", b).on("click.bs.dropdown.data-api", ".dropdown form", function (a) { a.stopPropagation() }).on("click.bs.dropdown.data-api", f, g.prototype.toggle).on("keydown.bs.dropdown.data-api", f, g.prototype.keydown).on("keydown.bs.dropdown.data-api", '[role="menu"]', g.prototype.keydown).on("keydown.bs.dropdown.data-api", '[role="listbox"]', g.prototype.keydown) }(jQuery), +function (a) { "use strict"; function b(b, d) { return this.each(function () { var e = a(this), f = e.data("bs.modal"), g = a.extend({}, c.DEFAULTS, e.data(), "object" == typeof b && b); f || e.data("bs.modal", f = new c(this, g)), "string" == typeof b ? f[b](d) : g.show && f.show(d) }) } var c = function (b, c) { this.options = c, this.$body = a(document.body), this.$element = a(b), this.$backdrop = this.isShown = null, this.scrollbarWidth = 0, this.options.remote && this.$element.find(".modal-content").load(this.options.remote, a.proxy(function () { this.$element.trigger("loaded.bs.modal") }, this)) }; c.VERSION = "3.3.1", c.TRANSITION_DURATION = 300, c.BACKDROP_TRANSITION_DURATION = 150, c.DEFAULTS = { backdrop: !0, keyboard: !0, show: !0 }, c.prototype.toggle = function (a) { return this.isShown ? this.hide() : this.show(a) }, c.prototype.show = function (b) { var d = this, e = a.Event("show.bs.modal", { relatedTarget: b }); this.$element.trigger(e), this.isShown || e.isDefaultPrevented() || (this.isShown = !0, this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), this.resize(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', a.proxy(this.hide, this)), this.backdrop(function () { var e = a.support.transition && d.$element.hasClass("fade"); d.$element.parent().length || d.$element.appendTo(d.$body), d.$element.show().scrollTop(0), d.options.backdrop && d.adjustBackdrop(), d.adjustDialog(), e && d.$element[0].offsetWidth, d.$element.addClass("in").attr("aria-hidden", !1), d.enforceFocus(); var f = a.Event("shown.bs.modal", { relatedTarget: b }); e ? d.$element.find(".modal-dialog").one("bsTransitionEnd", function () { d.$element.trigger("focus").trigger(f) }).emulateTransitionEnd(c.TRANSITION_DURATION) : d.$element.trigger("focus").trigger(f) })) }, c.prototype.hide = function (b) { b && b.preventDefault(), b = a.Event("hide.bs.modal"), this.$element.trigger(b), this.isShown && !b.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), a(document).off("focusin.bs.modal"), this.$element.removeClass("in").attr("aria-hidden", !0).off("click.dismiss.bs.modal"), a.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", a.proxy(this.hideModal, this)).emulateTransitionEnd(c.TRANSITION_DURATION) : this.hideModal()) }, c.prototype.enforceFocus = function () { a(document).off("focusin.bs.modal").on("focusin.bs.modal", a.proxy(function (a) { this.$element[0] === a.target || this.$element.has(a.target).length || this.$element.trigger("focus") }, this)) }, c.prototype.escape = function () { this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", a.proxy(function (a) { 27 == a.which && this.hide() }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal") }, c.prototype.resize = function () { this.isShown ? a(window).on("resize.bs.modal", a.proxy(this.handleUpdate, this)) : a(window).off("resize.bs.modal") }, c.prototype.hideModal = function () { var a = this; this.$element.hide(), this.backdrop(function () { a.$body.removeClass("modal-open"), a.resetAdjustments(), a.resetScrollbar(), a.$element.trigger("hidden.bs.modal") }) }, c.prototype.removeBackdrop = function () { this.$backdrop && this.$backdrop.remove(), this.$backdrop = null }, c.prototype.backdrop = function (b) { var d = this, e = this.$element.hasClass("fade") ? "fade" : ""; if (this.isShown && this.options.backdrop) { var f = a.support.transition && e; if (this.$backdrop = a('<div class="modal-backdrop ' + e + '" />').prependTo(this.$element).on("click.dismiss.bs.modal", a.proxy(function (a) { a.target === a.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus.call(this.$element[0]) : this.hide.call(this)) }, this)), f && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), !b) return; f ? this.$backdrop.one("bsTransitionEnd", b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : b() } else if (!this.isShown && this.$backdrop) { this.$backdrop.removeClass("in"); var g = function () { d.removeBackdrop(), b && b() }; a.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : g() } else b && b() }, c.prototype.handleUpdate = function () { this.options.backdrop && this.adjustBackdrop(), this.adjustDialog() }, c.prototype.adjustBackdrop = function () { this.$backdrop.css("height", 0).css("height", this.$element[0].scrollHeight) }, c.prototype.adjustDialog = function () { var a = this.$element[0].scrollHeight > document.documentElement.clientHeight; this.$element.css({ paddingLeft: !this.bodyIsOverflowing && a ? this.scrollbarWidth : "", paddingRight: this.bodyIsOverflowing && !a ? this.scrollbarWidth : "" }) }, c.prototype.resetAdjustments = function () { this.$element.css({ paddingLeft: "", paddingRight: "" }) }, c.prototype.checkScrollbar = function () { this.bodyIsOverflowing = document.body.scrollHeight > document.documentElement.clientHeight, this.scrollbarWidth = this.measureScrollbar() }, c.prototype.setScrollbar = function () { var a = parseInt(this.$body.css("padding-right") || 0, 10); this.bodyIsOverflowing && this.$body.css("padding-right", a + this.scrollbarWidth) }, c.prototype.resetScrollbar = function () { this.$body.css("padding-right", "") }, c.prototype.measureScrollbar = function () { var a = document.createElement("div"); a.className = "modal-scrollbar-measure", this.$body.append(a); var b = a.offsetWidth - a.clientWidth; return this.$body[0].removeChild(a), b }; var d = a.fn.modal; a.fn.modal = b, a.fn.modal.Constructor = c, a.fn.modal.noConflict = function () { return a.fn.modal = d, this }, a(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function (c) { var d = a(this), e = d.attr("href"), f = a(d.attr("data-target") || e && e.replace(/.*(?=#[^\s]+$)/, "")), g = f.data("bs.modal") ? "toggle" : a.extend({ remote: !/#/.test(e) && e }, f.data(), d.data()); d.is("a") && c.preventDefault(), f.one("show.bs.modal", function (a) { a.isDefaultPrevented() || f.one("hidden.bs.modal", function () { d.is(":visible") && d.trigger("focus") }) }), b.call(f, g, this) }) }(jQuery), +function (a) { "use strict"; function b(b) { return this.each(function () { var d = a(this), e = d.data("bs.tooltip"), f = "object" == typeof b && b, g = f && f.selector; (e || "destroy" != b) && (g ? (e || d.data("bs.tooltip", e = {}), e[g] || (e[g] = new c(this, f))) : e || d.data("bs.tooltip", e = new c(this, f)), "string" == typeof b && e[b]()) }) } var c = function (a, b) { this.type = this.options = this.enabled = this.timeout = this.hoverState = this.$element = null, this.init("tooltip", a, b) }; c.VERSION = "3.3.1", c.TRANSITION_DURATION = 150, c.DEFAULTS = { animation: !0, placement: "top", selector: !1, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', trigger: "hover focus", title: "", delay: 0, html: !1, container: !1, viewport: { selector: "body", padding: 0 } }, c.prototype.init = function (b, c, d) { this.enabled = !0, this.type = b, this.$element = a(c), this.options = this.getOptions(d), this.$viewport = this.options.viewport && a(this.options.viewport.selector || this.options.viewport); for (var e = this.options.trigger.split(" "), f = e.length; f--;) { var g = e[f]; if ("click" == g) this.$element.on("click." + this.type, this.options.selector, a.proxy(this.toggle, this)); else if ("manual" != g) { var h = "hover" == g ? "mouseenter" : "focusin", i = "hover" == g ? "mouseleave" : "focusout"; this.$element.on(h + "." + this.type, this.options.selector, a.proxy(this.enter, this)), this.$element.on(i + "." + this.type, this.options.selector, a.proxy(this.leave, this)) } } this.options.selector ? this._options = a.extend({}, this.options, { trigger: "manual", selector: "" }) : this.fixTitle() }, c.prototype.getDefaults = function () { return c.DEFAULTS }, c.prototype.getOptions = function (b) { return b = a.extend({}, this.getDefaults(), this.$element.data(), b), b.delay && "number" == typeof b.delay && (b.delay = { show: b.delay, hide: b.delay }), b }, c.prototype.getDelegateOptions = function () { var b = {}, c = this.getDefaults(); return this._options && a.each(this._options, function (a, d) { c[a] != d && (b[a] = d) }), b }, c.prototype.enter = function (b) { var c = b instanceof this.constructor ? b : a(b.currentTarget).data("bs." + this.type); return c && c.$tip && c.$tip.is(":visible") ? void (c.hoverState = "in") : (c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)), clearTimeout(c.timeout), c.hoverState = "in", c.options.delay && c.options.delay.show ? void (c.timeout = setTimeout(function () { "in" == c.hoverState && c.show() }, c.options.delay.show)) : c.show()) }, c.prototype.leave = function (b) { var c = b instanceof this.constructor ? b : a(b.currentTarget).data("bs." + this.type); return c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)), clearTimeout(c.timeout), c.hoverState = "out", c.options.delay && c.options.delay.hide ? void (c.timeout = setTimeout(function () { "out" == c.hoverState && c.hide() }, c.options.delay.hide)) : c.hide() }, c.prototype.show = function () { var b = a.Event("show.bs." + this.type); if (this.hasContent() && this.enabled) { this.$element.trigger(b); var d = a.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]); if (b.isDefaultPrevented() || !d) return; var e = this, f = this.tip(), g = this.getUID(this.type); this.setContent(), f.attr("id", g), this.$element.attr("aria-describedby", g), this.options.animation && f.addClass("fade"); var h = "function" == typeof this.options.placement ? this.options.placement.call(this, f[0], this.$element[0]) : this.options.placement, i = /\s?auto?\s?/i, j = i.test(h); j && (h = h.replace(i, "") || "top"), f.detach().css({ top: 0, left: 0, display: "block" }).addClass(h).data("bs." + this.type, this), this.options.container ? f.appendTo(this.options.container) : f.insertAfter(this.$element); var k = this.getPosition(), l = f[0].offsetWidth, m = f[0].offsetHeight; if (j) { var n = h, o = this.options.container ? a(this.options.container) : this.$element.parent(), p = this.getPosition(o); h = "bottom" == h && k.bottom + m > p.bottom ? "top" : "top" == h && k.top - m < p.top ? "bottom" : "right" == h && k.right + l > p.width ? "left" : "left" == h && k.left - l < p.left ? "right" : h, f.removeClass(n).addClass(h) } var q = this.getCalculatedOffset(h, k, l, m); this.applyPlacement(q, h); var r = function () { var a = e.hoverState; e.$element.trigger("shown.bs." + e.type), e.hoverState = null, "out" == a && e.leave(e) }; a.support.transition && this.$tip.hasClass("fade") ? f.one("bsTransitionEnd", r).emulateTransitionEnd(c.TRANSITION_DURATION) : r() } }, c.prototype.applyPlacement = function (b, c) { var d = this.tip(), e = d[0].offsetWidth, f = d[0].offsetHeight, g = parseInt(d.css("margin-top"), 10), h = parseInt(d.css("margin-left"), 10); isNaN(g) && (g = 0), isNaN(h) && (h = 0), b.top = b.top + g, b.left = b.left + h, a.offset.setOffset(d[0], a.extend({ using: function (a) { d.css({ top: Math.round(a.top), left: Math.round(a.left) }) } }, b), 0), d.addClass("in"); var i = d[0].offsetWidth, j = d[0].offsetHeight; "top" == c && j != f && (b.top = b.top + f - j); var k = this.getViewportAdjustedDelta(c, b, i, j); k.left ? b.left += k.left : b.top += k.top; var l = /top|bottom/.test(c), m = l ? 2 * k.left - e + i : 2 * k.top - f + j, n = l ? "offsetWidth" : "offsetHeight"; d.offset(b), this.replaceArrow(m, d[0][n], l) }, c.prototype.replaceArrow = function (a, b, c) { this.arrow().css(c ? "left" : "top", 50 * (1 - a / b) + "%").css(c ? "top" : "left", "") }, c.prototype.setContent = function () { var a = this.tip(), b = this.getTitle(); a.find(".tooltip-inner")[this.options.html ? "html" : "text"](b), a.removeClass("fade in top bottom left right") }, c.prototype.hide = function (b) { function d() { "in" != e.hoverState && f.detach(), e.$element.removeAttr("aria-describedby").trigger("hidden.bs." + e.type), b && b() } var e = this, f = this.tip(), g = a.Event("hide.bs." + this.type); return this.$element.trigger(g), g.isDefaultPrevented() ? void 0 : (f.removeClass("in"), a.support.transition && this.$tip.hasClass("fade") ? f.one("bsTransitionEnd", d).emulateTransitionEnd(c.TRANSITION_DURATION) : d(), this.hoverState = null, this) }, c.prototype.fixTitle = function () { var a = this.$element; (a.attr("title") || "string" != typeof a.attr("data-original-title")) && a.attr("data-original-title", a.attr("title") || "").attr("title", "") }, c.prototype.hasContent = function () { return this.getTitle() }, c.prototype.getPosition = function (b) { b = b || this.$element; var c = b[0], d = "BODY" == c.tagName, e = c.getBoundingClientRect(); null == e.width && (e = a.extend({}, e, { width: e.right - e.left, height: e.bottom - e.top })); var f = d ? { top: 0, left: 0 } : b.offset(), g = { scroll: d ? document.documentElement.scrollTop || document.body.scrollTop : b.scrollTop() }, h = d ? { width: a(window).width(), height: a(window).height() } : null; return a.extend({}, e, g, h, f) }, c.prototype.getCalculatedOffset = function (a, b, c, d) { return "bottom" == a ? { top: b.top + b.height, left: b.left + b.width / 2 - c / 2 } : "top" == a ? { top: b.top - d, left: b.left + b.width / 2 - c / 2 } : "left" == a ? { top: b.top + b.height / 2 - d / 2, left: b.left - c } : { top: b.top + b.height / 2 - d / 2, left: b.left + b.width } }, c.prototype.getViewportAdjustedDelta = function (a, b, c, d) { var e = { top: 0, left: 0 }; if (!this.$viewport) return e; var f = this.options.viewport && this.options.viewport.padding || 0, g = this.getPosition(this.$viewport); if (/right|left/.test(a)) { var h = b.top - f - g.scroll, i = b.top + f - g.scroll + d; h < g.top ? e.top = g.top - h : i > g.top + g.height && (e.top = g.top + g.height - i) } else { var j = b.left - f, k = b.left + f + c; j < g.left ? e.left = g.left - j : k > g.width && (e.left = g.left + g.width - k) } return e }, c.prototype.getTitle = function () { var a, b = this.$element, c = this.options; return a = b.attr("data-original-title") || ("function" == typeof c.title ? c.title.call(b[0]) : c.title) }, c.prototype.getUID = function (a) { do a += ~~(1e6 * Math.random()); while (document.getElementById(a)); return a }, c.prototype.tip = function () { return this.$tip = this.$tip || a(this.options.template) }, c.prototype.arrow = function () { return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow") }, c.prototype.enable = function () { this.enabled = !0 }, c.prototype.disable = function () { this.enabled = !1 }, c.prototype.toggleEnabled = function () { this.enabled = !this.enabled }, c.prototype.toggle = function (b) { var c = this; b && (c = a(b.currentTarget).data("bs." + this.type), c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c))), c.tip().hasClass("in") ? c.leave(c) : c.enter(c) }, c.prototype.destroy = function () { var a = this; clearTimeout(this.timeout), this.hide(function () { a.$element.off("." + a.type).removeData("bs." + a.type) }) }; var d = a.fn.tooltip; a.fn.tooltip = b, a.fn.tooltip.Constructor = c, a.fn.tooltip.noConflict = function () { return a.fn.tooltip = d, this } }(jQuery), +function (a) { "use strict"; function b(b) { return this.each(function () { var d = a(this), e = d.data("bs.popover"), f = "object" == typeof b && b, g = f && f.selector; (e || "destroy" != b) && (g ? (e || d.data("bs.popover", e = {}), e[g] || (e[g] = new c(this, f))) : e || d.data("bs.popover", e = new c(this, f)), "string" == typeof b && e[b]()) }) } var c = function (a, b) { this.init("popover", a, b) }; if (!a.fn.tooltip) throw new Error("Popover requires tooltip.js"); c.VERSION = "3.3.1", c.DEFAULTS = a.extend({}, a.fn.tooltip.Constructor.DEFAULTS, { placement: "right", trigger: "click", content: "", template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>' }), c.prototype = a.extend({}, a.fn.tooltip.Constructor.prototype), c.prototype.constructor = c, c.prototype.getDefaults = function () { return c.DEFAULTS }, c.prototype.setContent = function () { var a = this.tip(), b = this.getTitle(), c = this.getContent(); a.find(".popover-title")[this.options.html ? "html" : "text"](b), a.find(".popover-content").children().detach().end()[this.options.html ? "string" == typeof c ? "html" : "append" : "text"](c), a.removeClass("fade top bottom left right in"), a.find(".popover-title").html() || a.find(".popover-title").hide() }, c.prototype.hasContent = function () { return this.getTitle() || this.getContent() }, c.prototype.getContent = function () { var a = this.$element, b = this.options; return a.attr("data-content") || ("function" == typeof b.content ? b.content.call(a[0]) : b.content) }, c.prototype.arrow = function () { return this.$arrow = this.$arrow || this.tip().find(".arrow") }, c.prototype.tip = function () { return this.$tip || (this.$tip = a(this.options.template)), this.$tip }; var d = a.fn.popover; a.fn.popover = b, a.fn.popover.Constructor = c, a.fn.popover.noConflict = function () { return a.fn.popover = d, this } }(jQuery), +function (a) { "use strict"; function b(c, d) { var e = a.proxy(this.process, this); this.$body = a("body"), this.$scrollElement = a(a(c).is("body") ? window : c), this.options = a.extend({}, b.DEFAULTS, d), this.selector = (this.options.target || "") + " .nav li > a", this.offsets = [], this.targets = [], this.activeTarget = null, this.scrollHeight = 0, this.$scrollElement.on("scroll.bs.scrollspy", e), this.refresh(), this.process() } function c(c) { return this.each(function () { var d = a(this), e = d.data("bs.scrollspy"), f = "object" == typeof c && c; e || d.data("bs.scrollspy", e = new b(this, f)), "string" == typeof c && e[c]() }) } b.VERSION = "3.3.1", b.DEFAULTS = { offset: 10 }, b.prototype.getScrollHeight = function () { return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight) }, b.prototype.refresh = function () { var b = "offset", c = 0; a.isWindow(this.$scrollElement[0]) || (b = "position", c = this.$scrollElement.scrollTop()), this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight(); var d = this; this.$body.find(this.selector).map(function () { var d = a(this), e = d.data("target") || d.attr("href"), f = /^#./.test(e) && a(e); return f && f.length && f.is(":visible") && [[f[b]().top + c, e]] || null }).sort(function (a, b) { return a[0] - b[0] }).each(function () { d.offsets.push(this[0]), d.targets.push(this[1]) }) }, b.prototype.process = function () { var a, b = this.$scrollElement.scrollTop() + this.options.offset, c = this.getScrollHeight(), d = this.options.offset + c - this.$scrollElement.height(), e = this.offsets, f = this.targets, g = this.activeTarget; if (this.scrollHeight != c && this.refresh(), b >= d) return g != (a = f[f.length - 1]) && this.activate(a); if (g && b < e[0]) return this.activeTarget = null, this.clear(); for (a = e.length; a--;)g != f[a] && b >= e[a] && (!e[a + 1] || b <= e[a + 1]) && this.activate(f[a]) }, b.prototype.activate = function (b) { this.activeTarget = b, this.clear(); var c = this.selector + '[data-target="' + b + '"],' + this.selector + '[href="' + b + '"]', d = a(c).parents("li").addClass("active"); d.parent(".dropdown-menu").length && (d = d.closest("li.dropdown").addClass("active")), d.trigger("activate.bs.scrollspy") }, b.prototype.clear = function () { a(this.selector).parentsUntil(this.options.target, ".active").removeClass("active") }; var d = a.fn.scrollspy; a.fn.scrollspy = c, a.fn.scrollspy.Constructor = b, a.fn.scrollspy.noConflict = function () { return a.fn.scrollspy = d, this }, a(window).on("load.bs.scrollspy.data-api", function () { a('[data-spy="scroll"]').each(function () { var b = a(this); c.call(b, b.data()) }) }) }(jQuery), +function (a) {
    "use strict"; function b(b) { return this.each(function () { var d = a(this), e = d.data("bs.tab"); e || d.data("bs.tab", e = new c(this)), "string" == typeof b && e[b]() }) } var c = function (b) { this.element = a(b) }; c.VERSION = "3.3.1", c.TRANSITION_DURATION = 150, c.prototype.show = function () {
        var b = this.element, c = b.closest("ul:not(.dropdown-menu)"), d = b.data("target"); if (d || (d = b.attr("href"), d = d && d.replace(/.*(?=#[^\s]*$)/, "")), !b.parent("li").hasClass("active")) {
            var e = c.find(".active:last a"), f = a.Event("hide.bs.tab", { relatedTarget: b[0] }), g = a.Event("show.bs.tab", { relatedTarget: e[0] }); if (e.trigger(f), b.trigger(g), !g.isDefaultPrevented() && !f.isDefaultPrevented()) {
                var h = a(d); this.activate(b.closest("li"), c), this.activate(h, h.parent(), function () {
                    e.trigger({ type: "hidden.bs.tab", relatedTarget: b[0] }), b.trigger({ type: "shown.bs.tab", relatedTarget: e[0] })
                })
            }
        }
    }, c.prototype.activate = function (b, d, e) { function f() { g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !1), b.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", !0), h ? (b[0].offsetWidth, b.addClass("in")) : b.removeClass("fade"), b.parent(".dropdown-menu") && b.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !0), e && e() } var g = d.find("> .active"), h = e && a.support.transition && (g.length && g.hasClass("fade") || !!d.find("> .fade").length); g.length && h ? g.one("bsTransitionEnd", f).emulateTransitionEnd(c.TRANSITION_DURATION) : f(), g.removeClass("in") }; var d = a.fn.tab; a.fn.tab = b, a.fn.tab.Constructor = c, a.fn.tab.noConflict = function () { return a.fn.tab = d, this }; var e = function (c) { c.preventDefault(), b.call(a(this), "show") }; a(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', e).on("click.bs.tab.data-api", '[data-toggle="pill"]', e)
}(jQuery), +function (a) { "use strict"; function b(b) { return this.each(function () { var d = a(this), e = d.data("bs.affix"), f = "object" == typeof b && b; e || d.data("bs.affix", e = new c(this, f)), "string" == typeof b && e[b]() }) } var c = function (b, d) { this.options = a.extend({}, c.DEFAULTS, d), this.$target = a(this.options.target).on("scroll.bs.affix.data-api", a.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", a.proxy(this.checkPositionWithEventLoop, this)), this.$element = a(b), this.affixed = this.unpin = this.pinnedOffset = null, this.checkPosition() }; c.VERSION = "3.3.1", c.RESET = "affix affix-top affix-bottom", c.DEFAULTS = { offset: 0, target: window }, c.prototype.getState = function (a, b, c, d) { var e = this.$target.scrollTop(), f = this.$element.offset(), g = this.$target.height(); if (null != c && "top" == this.affixed) return c > e ? "top" : !1; if ("bottom" == this.affixed) return null != c ? e + this.unpin <= f.top ? !1 : "bottom" : a - d >= e + g ? !1 : "bottom"; var h = null == this.affixed, i = h ? e : f.top, j = h ? g : b; return null != c && c >= e ? "top" : null != d && i + j >= a - d ? "bottom" : !1 }, c.prototype.getPinnedOffset = function () { if (this.pinnedOffset) return this.pinnedOffset; this.$element.removeClass(c.RESET).addClass("affix"); var a = this.$target.scrollTop(), b = this.$element.offset(); return this.pinnedOffset = b.top - a }, c.prototype.checkPositionWithEventLoop = function () { setTimeout(a.proxy(this.checkPosition, this), 1) }, c.prototype.checkPosition = function () { if (this.$element.is(":visible")) { var b = this.$element.height(), d = this.options.offset, e = d.top, f = d.bottom, g = a("body").height(); "object" != typeof d && (f = e = d), "function" == typeof e && (e = d.top(this.$element)), "function" == typeof f && (f = d.bottom(this.$element)); var h = this.getState(g, b, e, f); if (this.affixed != h) { null != this.unpin && this.$element.css("top", ""); var i = "affix" + (h ? "-" + h : ""), j = a.Event(i + ".bs.affix"); if (this.$element.trigger(j), j.isDefaultPrevented()) return; this.affixed = h, this.unpin = "bottom" == h ? this.getPinnedOffset() : null, this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix", "affixed") + ".bs.affix") } "bottom" == h && this.$element.offset({ top: g - b - f }) } }; var d = a.fn.affix; a.fn.affix = b, a.fn.affix.Constructor = c, a.fn.affix.noConflict = function () { return a.fn.affix = d, this }, a(window).on("load", function () { a('[data-spy="affix"]').each(function () { var c = a(this), d = c.data(); d.offset = d.offset || {}, null != d.offsetBottom && (d.offset.bottom = d.offsetBottom), null != d.offsetTop && (d.offset.top = d.offsetTop), b.call(c, d) }) }) }(jQuery);
/**
 *	Xenon API Functions
 *
 *	Theme by: www.laborator.co
 **/


function rtl() // checks whether the content is in RTL mode
{
    if (typeof window.isRTL == 'boolean')
        return window.isRTL;

    window.isRTL = jQuery("html").get(0).dir == 'rtl' ? true : false;

    return window.isRTL;
}



// Page Loader
function show_loading_bar(options) {
    var defaults = {
        pct: 0,
        delay: 1.3,
        wait: 0,
        before: function () { },
        finish: function () { },
        resetOnEnd: true
    };

    if (typeof options == 'object')
        defaults = jQuery.extend(defaults, options);
    else
        if (typeof options == 'number')
            defaults.pct = options;


    if (defaults.pct > 100)
        defaults.pct = 100;
    else
        if (defaults.pct < 0)
            defaults.pct = 0;

    var $ = jQuery,
        $loading_bar = $(".xenon-loading-bar");

    if ($loading_bar.length == 0) {
        $loading_bar = $('<div class="xenon-loading-bar progress-is-hidden"><span data-pct="0"></span></div>');
        public_vars.$body.append($loading_bar);
    }

    var $pct = $loading_bar.find('span'),
        current_pct = $pct.data('pct'),
        is_regress = current_pct > defaults.pct;


    defaults.before(current_pct);

    TweenMax.to($pct, defaults.delay, {
        css: { width: defaults.pct + '%' }, delay: defaults.wait, ease: is_regress ? Expo.easeOut : Expo.easeIn,
        onStart: function () {
            $loading_bar.removeClass('progress-is-hidden');
        },
        onComplete: function () {
            var pct = $pct.data('pct');

            if (pct == 100 && defaults.resetOnEnd) {
                hide_loading_bar();
            }

            defaults.finish(pct);
        },
        onUpdate: function () {
            $pct.data('pct', parseInt($pct.get(0).style.width, 10));
        }
    });
}

function hide_loading_bar() {
    var $ = jQuery,
        $loading_bar = $(".xenon-loading-bar"),
        $pct = $loading_bar.find('span');

    $loading_bar.addClass('progress-is-hidden');
    $pct.width(0).data('pct', 0);
}
/*!
 * VERSION: 1.13.1
 * DATE: 2014-07-19
 * UPDATES AND DOCS AT: http://www.greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2014, GreenSock. All rights reserved.
 * This work is subject to the terms at http://www.greensock.com/terms_of_use.html or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window; (_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () {
    "use strict"; _gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (t, e, i) { var s = function (t) { var e, i = [], s = t.length; for (e = 0; e !== s; i.push(t[e++])); return i }, r = function (t, e, s) { i.call(this, t, e, s), this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._dirty = !0, this.render = r.prototype.render }, n = 1e-10, a = i._internals, o = a.isSelector, h = a.isArray, l = r.prototype = i.to({}, .1, {}), _ = []; r.version = "1.13.1", l.constructor = r, l.kill()._gc = !1, r.killTweensOf = r.killDelayedCallsTo = i.killTweensOf, r.getTweensOf = i.getTweensOf, r.lagSmoothing = i.lagSmoothing, r.ticker = i.ticker, r.render = i.render, l.invalidate = function () { return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), i.prototype.invalidate.call(this) }, l.updateTo = function (t, e) { var s, r = this.ratio; e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay)); for (s in t) this.vars[s] = t[s]; if (this._initted) if (e) this._initted = !1; else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && i._onPluginEvent("_onDisable", this), this._time / this._duration > .998) { var n = this._time; this.render(0, !0, !1), this._initted = !1, this.render(n, !0, !1) } else if (this._time > 0) { this._initted = !1, this._init(); for (var a, o = 1 / (1 - r), h = this._firstPT; h;)a = h.s + h.c, h.c *= o, h.s = a - h.c, h = h._next } return this }, l.render = function (t, e, i) { this._initted || 0 === this._duration && this.vars.repeat && this.invalidate(); var s, r, o, h, l, u, p, c, f = this._dirty ? this.totalDuration() : this._totalDuration, m = this._time, d = this._totalTime, g = this._cycle, v = this._duration, y = this._rawPrevTime; if (t >= f ? (this._totalTime = f, this._cycle = this._repeat, this._yoyo && 0 !== (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = v, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (s = !0, r = "onComplete"), 0 === v && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (0 === t || 0 > y || y === n) && y !== t && (i = !0, y > n && (r = "onReverseComplete")), this._rawPrevTime = c = !e || t || y === t ? t : n)) : 1e-7 > t ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== d || 0 === v && y > 0 && y !== n) && (r = "onReverseComplete", s = this._reversed), 0 > t ? (this._active = !1, 0 === v && (this._initted || !this.vars.lazy || i) && (y >= 0 && (i = !0), this._rawPrevTime = c = !e || t || y === t ? t : n)) : this._initted || (i = !0)) : (this._totalTime = this._time = t, 0 !== this._repeat && (h = v + this._repeatDelay, this._cycle = this._totalTime / h >> 0, 0 !== this._cycle && this._cycle === this._totalTime / h && this._cycle-- , this._time = this._totalTime - this._cycle * h, this._yoyo && 0 !== (1 & this._cycle) && (this._time = v - this._time), this._time > v ? this._time = v : 0 > this._time && (this._time = 0)), this._easeType ? (l = this._time / v, u = this._easeType, p = this._easePower, (1 === u || 3 === u && l >= .5) && (l = 1 - l), 3 === u && (l *= 2), 1 === p ? l *= l : 2 === p ? l *= l * l : 3 === p ? l *= l * l * l : 4 === p && (l *= l * l * l * l), this.ratio = 1 === u ? 1 - l : 2 === u ? l : .5 > this._time / v ? l / 2 : 1 - l / 2) : this.ratio = this._ease.getRatio(this._time / v)), m === this._time && !i && g === this._cycle) return d !== this._totalTime && this._onUpdate && (e || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _)), void 0; if (!this._initted) { if (this._init(), !this._initted || this._gc) return; if (!i && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = m, this._totalTime = d, this._rawPrevTime = y, this._cycle = g, a.lazyTweens.push(this), this._lazy = t, void 0; this._time && !s ? this.ratio = this._ease.getRatio(this._time / v) : s && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) } for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== m && t >= 0 && (this._active = !0), 0 === d && (2 === this._initted && t > 0 && this._init(), this._startAt && (t >= 0 ? this._startAt.render(t, e, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 !== this._totalTime || 0 === v) && (e || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _))), o = this._firstPT; o;)o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next; this._onUpdate && (0 > t && this._startAt && this._startTime && this._startAt.render(t, e, i), e || (this._totalTime !== d || s) && this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _)), this._cycle !== g && (e || this._gc || this.vars.onRepeat && this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || _)), r && (!this._gc || i) && (0 > t && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, e, i), s && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this.vars[r].apply(this.vars[r + "Scope"] || this, this.vars[r + "Params"] || _), 0 === v && this._rawPrevTime === n && c !== n && (this._rawPrevTime = 0)) }, r.to = function (t, e, i) { return new r(t, e, i) }, r.from = function (t, e, i) { return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new r(t, e, i) }, r.fromTo = function (t, e, i, s) { return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, new r(t, e, s) }, r.staggerTo = r.allTo = function (t, e, n, a, l, u, p) { a = a || 0; var c, f, m, d, g = n.delay || 0, v = [], y = function () { n.onComplete && n.onComplete.apply(n.onCompleteScope || this, arguments), l.apply(p || this, u || _) }; for (h(t) || ("string" == typeof t && (t = i.selector(t) || t), o(t) && (t = s(t))), c = t.length, m = 0; c > m; m++) { f = {}; for (d in n) f[d] = n[d]; f.delay = g, m === c - 1 && l && (f.onComplete = y), v[m] = new r(t[m], e, f), g += a } return v }, r.staggerFrom = r.allFrom = function (t, e, i, s, n, a, o) { return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, r.staggerTo(t, e, i, s, n, a, o) }, r.staggerFromTo = r.allFromTo = function (t, e, i, s, n, a, o, h) { return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, r.staggerTo(t, e, s, n, a, o, h) }, r.delayedCall = function (t, e, i, s, n) { return new r(e, 0, { delay: t, onComplete: e, onCompleteParams: i, onCompleteScope: s, onReverseComplete: e, onReverseCompleteParams: i, onReverseCompleteScope: s, immediateRender: !1, useFrames: n, overwrite: 0 }) }, r.set = function (t, e) { return new r(t, 0, e) }, r.isTweening = function (t) { return i.getTweensOf(t, !0).length > 0 }; var u = function (t, e) { for (var s = [], r = 0, n = t._first; n;)n instanceof i ? s[r++] = n : (e && (s[r++] = n), s = s.concat(u(n, e)), r = s.length), n = n._next; return s }, p = r.getAllTweens = function (e) { return u(t._rootTimeline, e).concat(u(t._rootFramesTimeline, e)) }; r.killAll = function (t, i, s, r) { null == i && (i = !0), null == s && (s = !0); var n, a, o, h = p(0 != r), l = h.length, _ = i && s && r; for (o = 0; l > o; o++)a = h[o], (_ || a instanceof e || (n = a.target === a.vars.onComplete) && s || i && !n) && (t ? a.totalTime(a._reversed ? 0 : a.totalDuration()) : a._enabled(!1, !1)) }, r.killChildTweensOf = function (t, e) { if (null != t) { var n, l, _, u, p, c = a.tweenLookup; if ("string" == typeof t && (t = i.selector(t) || t), o(t) && (t = s(t)), h(t)) for (u = t.length; --u > -1;)r.killChildTweensOf(t[u], e); else { n = []; for (_ in c) for (l = c[_].target.parentNode; l;)l === t && (n = n.concat(c[_].tweens)), l = l.parentNode; for (p = n.length, u = 0; p > u; u++)e && n[u].totalTime(n[u].totalDuration()), n[u]._enabled(!1, !1) } } }; var c = function (t, i, s, r) { i = i !== !1, s = s !== !1, r = r !== !1; for (var n, a, o = p(r), h = i && s && r, l = o.length; --l > -1;)a = o[l], (h || a instanceof e || (n = a.target === a.vars.onComplete) && s || i && !n) && a.paused(t) }; return r.pauseAll = function (t, e, i) { c(!0, t, e, i) }, r.resumeAll = function (t, e, i) { c(!1, t, e, i) }, r.globalTimeScale = function (e) { var s = t._rootTimeline, r = i.ticker.time; return arguments.length ? (e = e || n, s._startTime = r - (r - s._startTime) * s._timeScale / e, s = t._rootFramesTimeline, r = i.ticker.frame, s._startTime = r - (r - s._startTime) * s._timeScale / e, s._timeScale = t._rootTimeline._timeScale = e, e) : s._timeScale }, l.progress = function (t) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration() }, l.totalProgress = function (t) { return arguments.length ? this.totalTime(this.totalDuration() * t, !1) : this._totalTime / this.totalDuration() }, l.time = function (t, e) { return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time }, l.duration = function (e) { return arguments.length ? t.prototype.duration.call(this, e) : this._duration }, l.totalDuration = function (t) { return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration) }, l.repeat = function (t) { return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat }, l.repeatDelay = function (t) { return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay }, l.yoyo = function (t) { return arguments.length ? (this._yoyo = t, this) : this._yoyo }, r }, !0), _gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (t, e, i) { var s = function (t) { e.call(this, t), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren === !0, this.smoothChildTiming = this.vars.smoothChildTiming === !0, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate; var i, s, r = this.vars; for (s in r) i = r[s], o(i) && -1 !== i.join("").indexOf("{self}") && (r[s] = this._swapSelfInParams(i)); o(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger) }, r = 1e-10, n = i._internals, a = n.isSelector, o = n.isArray, h = n.lazyTweens, l = n.lazyRender, _ = [], u = _gsScope._gsDefine.globals, p = function (t) { var e, i = {}; for (e in t) i[e] = t[e]; return i }, c = function (t, e, i, s) { t._timeline.pause(t._startTime), e && e.apply(s || t._timeline, i || _) }, f = function (t) { var e, i = [], s = t.length; for (e = 0; e !== s; i.push(t[e++])); return i }, m = s.prototype = new e; return s.version = "1.13.1", m.constructor = s, m.kill()._gc = !1, m.to = function (t, e, s, r) { var n = s.repeat && u.TweenMax || i; return e ? this.add(new n(t, e, s), r) : this.set(t, s, r) }, m.from = function (t, e, s, r) { return this.add((s.repeat && u.TweenMax || i).from(t, e, s), r) }, m.fromTo = function (t, e, s, r, n) { var a = r.repeat && u.TweenMax || i; return e ? this.add(a.fromTo(t, e, s, r), n) : this.set(t, r, n) }, m.staggerTo = function (t, e, r, n, o, h, l, _) { var u, c = new s({ onComplete: h, onCompleteParams: l, onCompleteScope: _, smoothChildTiming: this.smoothChildTiming }); for ("string" == typeof t && (t = i.selector(t) || t), a(t) && (t = f(t)), n = n || 0, u = 0; t.length > u; u++)r.startAt && (r.startAt = p(r.startAt)), c.to(t[u], e, p(r), u * n); return this.add(c, o) }, m.staggerFrom = function (t, e, i, s, r, n, a, o) { return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(t, e, i, s, r, n, a, o) }, m.staggerFromTo = function (t, e, i, s, r, n, a, o, h) { return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, this.staggerTo(t, e, s, r, n, a, o, h) }, m.call = function (t, e, s, r) { return this.add(i.delayedCall(0, t, e, s), r) }, m.set = function (t, e, s) { return s = this._parseTimeOrLabel(s, 0, !0), null == e.immediateRender && (e.immediateRender = s === this._time && !this._paused), this.add(new i(t, 0, e), s) }, s.exportRoot = function (t, e) { t = t || {}, null == t.smoothChildTiming && (t.smoothChildTiming = !0); var r, n, a = new s(t), o = a._timeline; for (null == e && (e = !0), o._remove(a, !0), a._startTime = 0, a._rawPrevTime = a._time = a._totalTime = o._time, r = o._first; r;)n = r._next, e && r instanceof i && r.target === r.vars.onComplete || a.add(r, r._startTime - r._delay), r = n; return o.add(a, 0), a }, m.add = function (r, n, a, h) { var l, _, u, p, c, f; if ("number" != typeof n && (n = this._parseTimeOrLabel(n, 0, !0, r)), !(r instanceof t)) { if (r instanceof Array || r && r.push && o(r)) { for (a = a || "normal", h = h || 0, l = n, _ = r.length, u = 0; _ > u; u++)o(p = r[u]) && (p = new s({ tweens: p })), this.add(p, l), "string" != typeof p && "function" != typeof p && ("sequence" === a ? l = p._startTime + p.totalDuration() / p._timeScale : "start" === a && (p._startTime -= p.delay())), l += h; return this._uncache(!0) } if ("string" == typeof r) return this.addLabel(r, n); if ("function" != typeof r) throw "Cannot add " + r + " into the timeline; it is not a tween, timeline, function, or string."; r = i.delayedCall(0, r) } if (e.prototype.add.call(this, r, n), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration()) for (c = this, f = c.rawTime() > r._startTime; c._timeline;)f && c._timeline.smoothChildTiming ? c.totalTime(c._totalTime, !0) : c._gc && c._enabled(!0, !1), c = c._timeline; return this }, m.remove = function (e) { if (e instanceof t) return this._remove(e, !1); if (e instanceof Array || e && e.push && o(e)) { for (var i = e.length; --i > -1;)this.remove(e[i]); return this } return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e) }, m._remove = function (t, i) { e.prototype._remove.call(this, t, i); var s = this._last; return s ? this._time > s._startTime + s._totalDuration / s._timeScale && (this._time = this.duration(), this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this }, m.append = function (t, e) { return this.add(t, this._parseTimeOrLabel(null, e, !0, t)) }, m.insert = m.insertMultiple = function (t, e, i, s) { return this.add(t, e || 0, i, s) }, m.appendMultiple = function (t, e, i, s) { return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, s) }, m.addLabel = function (t, e) { return this._labels[t] = this._parseTimeOrLabel(e), this }, m.addPause = function (t, e, i, s) { return this.call(c, ["{self}", e, i, s], this, t) }, m.removeLabel = function (t) { return delete this._labels[t], this }, m.getLabelTime = function (t) { return null != this._labels[t] ? this._labels[t] : -1 }, m._parseTimeOrLabel = function (e, i, s, r) { var n; if (r instanceof t && r.timeline === this) this.remove(r); else if (r && (r instanceof Array || r.push && o(r))) for (n = r.length; --n > -1;)r[n] instanceof t && r[n].timeline === this && this.remove(r[n]); if ("string" == typeof i) return this._parseTimeOrLabel(i, s && "number" == typeof e && null == this._labels[i] ? e - this.duration() : 0, s); if (i = i || 0, "string" != typeof e || !isNaN(e) && null == this._labels[e]) null == e && (e = this.duration()); else { if (n = e.indexOf("="), -1 === n) return null == this._labels[e] ? s ? this._labels[e] = this.duration() + i : i : this._labels[e] + i; i = parseInt(e.charAt(n - 1) + "1", 10) * Number(e.substr(n + 1)), e = n > 1 ? this._parseTimeOrLabel(e.substr(0, n - 1), 0, s) : this.duration() } return Number(e) + i }, m.seek = function (t, e) { return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), e !== !1) }, m.stop = function () { return this.paused(!0) }, m.gotoAndPlay = function (t, e) { return this.play(t, e) }, m.gotoAndStop = function (t, e) { return this.pause(t, e) }, m.render = function (t, e, i) { this._gc && this._enabled(!0, !1); var s, n, a, o, u, p = this._dirty ? this.totalDuration() : this._totalDuration, c = this._time, f = this._startTime, m = this._timeScale, d = this._paused; if (t >= p ? (this._totalTime = this._time = p, this._reversed || this._hasPausedChild() || (n = !0, o = "onComplete", 0 === this._duration && (0 === t || 0 > this._rawPrevTime || this._rawPrevTime === r) && this._rawPrevTime !== t && this._first && (u = !0, this._rawPrevTime > r && (o = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r, t = p + 1e-4) : 1e-7 > t ? (this._totalTime = this._time = 0, (0 !== c || 0 === this._duration && this._rawPrevTime !== r && (this._rawPrevTime > 0 || 0 > t && this._rawPrevTime >= 0)) && (o = "onReverseComplete", n = this._reversed), 0 > t ? (this._active = !1, this._rawPrevTime >= 0 && this._first && (u = !0), this._rawPrevTime = t) : (this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r, t = 0, this._initted || (u = !0))) : this._totalTime = this._time = this._rawPrevTime = t, this._time !== c && this._first || i || u) { if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== c && t > 0 && (this._active = !0), 0 === c && this.vars.onStart && 0 !== this._time && (e || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _)), this._time >= c) for (s = this._first; s && (a = s._next, !this._paused || d);)(s._active || s._startTime <= this._time && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = a; else for (s = this._last; s && (a = s._prev, !this._paused || d);)(s._active || c >= s._startTime && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = a; this._onUpdate && (e || (h.length && l(), this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _))), o && (this._gc || (f === this._startTime || m !== this._timeScale) && (0 === this._time || p >= this.totalDuration()) && (n && (h.length && l(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[o] && this.vars[o].apply(this.vars[o + "Scope"] || this, this.vars[o + "Params"] || _))) } }, m._hasPausedChild = function () { for (var t = this._first; t;) { if (t._paused || t instanceof s && t._hasPausedChild()) return !0; t = t._next } return !1 }, m.getChildren = function (t, e, s, r) { r = r || -9999999999; for (var n = [], a = this._first, o = 0; a;)r > a._startTime || (a instanceof i ? e !== !1 && (n[o++] = a) : (s !== !1 && (n[o++] = a), t !== !1 && (n = n.concat(a.getChildren(!0, e, s)), o = n.length))), a = a._next; return n }, m.getTweensOf = function (t, e) { var s, r, n = this._gc, a = [], o = 0; for (n && this._enabled(!0, !0), s = i.getTweensOf(t), r = s.length; --r > -1;)(s[r].timeline === this || e && this._contains(s[r])) && (a[o++] = s[r]); return n && this._enabled(!1, !0), a }, m._contains = function (t) { for (var e = t.timeline; e;) { if (e === this) return !0; e = e.timeline } return !1 }, m.shiftChildren = function (t, e, i) { i = i || 0; for (var s, r = this._first, n = this._labels; r;)r._startTime >= i && (r._startTime += t), r = r._next; if (e) for (s in n) n[s] >= i && (n[s] += t); return this._uncache(!0) }, m._kill = function (t, e) { if (!t && !e) return this._enabled(!1, !1); for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), s = i.length, r = !1; --s > -1;)i[s]._kill(t, e) && (r = !0); return r }, m.clear = function (t) { var e = this.getChildren(!1, !0, !0), i = e.length; for (this._time = this._totalTime = 0; --i > -1;)e[i]._enabled(!1, !1); return t !== !1 && (this._labels = {}), this._uncache(!0) }, m.invalidate = function () { for (var t = this._first; t;)t.invalidate(), t = t._next; return this }, m._enabled = function (t, i) { if (t === this._gc) for (var s = this._first; s;)s._enabled(t, !0), s = s._next; return e.prototype._enabled.call(this, t, i) }, m.duration = function (t) { return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration) }, m.totalDuration = function (t) { if (!arguments.length) { if (this._dirty) { for (var e, i, s = 0, r = this._last, n = 999999999999; r;)e = r._prev, r._dirty && r.totalDuration(), r._startTime > n && this._sortChildren && !r._paused ? this.add(r, r._startTime - r._delay) : n = r._startTime, 0 > r._startTime && !r._paused && (s -= r._startTime, this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale), this.shiftChildren(-r._startTime, !1, -9999999999), n = 0), i = r._startTime + r._totalDuration / r._timeScale, i > s && (s = i), r = e; this._duration = this._totalDuration = s, this._dirty = !1 } return this._totalDuration } return 0 !== this.totalDuration() && 0 !== t && this.timeScale(this._totalDuration / t), this }, m.usesFrames = function () { for (var e = this._timeline; e._timeline;)e = e._timeline; return e === t._rootFramesTimeline }, m.rawTime = function () { return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale }, s }, !0), _gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function (t, e, i) { var s = function (e) { t.call(this, e), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._dirty = !0 }, r = 1e-10, n = [], a = e._internals, o = a.lazyTweens, h = a.lazyRender, l = new i(null, null, 1, 0), _ = s.prototype = new t; return _.constructor = s, _.kill()._gc = !1, s.version = "1.13.1", _.invalidate = function () { return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), t.prototype.invalidate.call(this) }, _.addCallback = function (t, i, s, r) { return this.add(e.delayedCall(0, t, s, r), i) }, _.removeCallback = function (t, e) { if (t) if (null == e) this._kill(null, t); else for (var i = this.getTweensOf(t, !1), s = i.length, r = this._parseTimeOrLabel(e); --s > -1;)i[s]._startTime === r && i[s]._enabled(!1, !1); return this }, _.tweenTo = function (t, i) { i = i || {}; var s, r, a, o = { ease: l, overwrite: i.delay ? 2 : 1, useFrames: this.usesFrames(), immediateRender: !1 }; for (r in i) o[r] = i[r]; return o.time = this._parseTimeOrLabel(t), s = Math.abs(Number(o.time) - this._time) / this._timeScale || .001, a = new e(this, s, o), o.onStart = function () { a.target.paused(!0), a.vars.time !== a.target.time() && s === a.duration() && a.duration(Math.abs(a.vars.time - a.target.time()) / a.target._timeScale), i.onStart && i.onStart.apply(i.onStartScope || a, i.onStartParams || n) }, a }, _.tweenFromTo = function (t, e, i) { i = i || {}, t = this._parseTimeOrLabel(t), i.startAt = { onComplete: this.seek, onCompleteParams: [t], onCompleteScope: this }, i.immediateRender = i.immediateRender !== !1; var s = this.tweenTo(e, i); return s.duration(Math.abs(s.vars.time - t) / this._timeScale || .001) }, _.render = function (t, e, i) { this._gc && this._enabled(!0, !1); var s, a, l, _, u, p, c = this._dirty ? this.totalDuration() : this._totalDuration, f = this._duration, m = this._time, d = this._totalTime, g = this._startTime, v = this._timeScale, y = this._rawPrevTime, T = this._paused, w = this._cycle; if (t >= c ? (this._locked || (this._totalTime = c, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (a = !0, _ = "onComplete", 0 === this._duration && (0 === t || 0 > y || y === r) && y !== t && this._first && (u = !0, y > r && (_ = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r, this._yoyo && 0 !== (1 & this._cycle) ? this._time = t = 0 : (this._time = f, t = f + 1e-4)) : 1e-7 > t ? (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== m || 0 === f && y !== r && (y > 0 || 0 > t && y >= 0) && !this._locked) && (_ = "onReverseComplete", a = this._reversed), 0 > t ? (this._active = !1, y >= 0 && this._first && (u = !0), this._rawPrevTime = t) : (this._rawPrevTime = f || !e || t || this._rawPrevTime === t ? t : r, t = 0, this._initted || (u = !0))) : (0 === f && 0 > y && (u = !0), this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, 0 !== this._repeat && (p = f + this._repeatDelay, this._cycle = this._totalTime / p >> 0, 0 !== this._cycle && this._cycle === this._totalTime / p && this._cycle-- , this._time = this._totalTime - this._cycle * p, this._yoyo && 0 !== (1 & this._cycle) && (this._time = f - this._time), this._time > f ? (this._time = f, t = f + 1e-4) : 0 > this._time ? this._time = t = 0 : t = this._time))), this._cycle !== w && !this._locked) { var x = this._yoyo && 0 !== (1 & w), b = x === (this._yoyo && 0 !== (1 & this._cycle)), P = this._totalTime, S = this._cycle, k = this._rawPrevTime, R = this._time; if (this._totalTime = w * f, w > this._cycle ? x = !x : this._totalTime += f, this._time = m, this._rawPrevTime = 0 === f ? y - 1e-4 : y, this._cycle = w, this._locked = !0, m = x ? 0 : f, this.render(m, e, 0 === f), e || this._gc || this.vars.onRepeat && this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || n), b && (m = x ? f + 1e-4 : -1e-4, this.render(m, !0, !1)), this._locked = !1, this._paused && !T) return; this._time = R, this._totalTime = P, this._cycle = S, this._rawPrevTime = k } if (!(this._time !== m && this._first || i || u)) return d !== this._totalTime && this._onUpdate && (e || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || n)), void 0; if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== d && t > 0 && (this._active = !0), 0 === d && this.vars.onStart && 0 !== this._totalTime && (e || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || n)), this._time >= m) for (s = this._first; s && (l = s._next, !this._paused || T);)(s._active || s._startTime <= this._time && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = l; else for (s = this._last; s && (l = s._prev, !this._paused || T);)(s._active || m >= s._startTime && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = l; this._onUpdate && (e || (o.length && h(), this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || n))), _ && (this._locked || this._gc || (g === this._startTime || v !== this._timeScale) && (0 === this._time || c >= this.totalDuration()) && (a && (o.length && h(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[_] && this.vars[_].apply(this.vars[_ + "Scope"] || this, this.vars[_ + "Params"] || n))) }, _.getActive = function (t, e, i) { null == t && (t = !0), null == e && (e = !0), null == i && (i = !1); var s, r, n = [], a = this.getChildren(t, e, i), o = 0, h = a.length; for (s = 0; h > s; s++)r = a[s], r.isActive() && (n[o++] = r); return n }, _.getLabelAfter = function (t) { t || 0 !== t && (t = this._time); var e, i = this.getLabelsArray(), s = i.length; for (e = 0; s > e; e++)if (i[e].time > t) return i[e].name; return null }, _.getLabelBefore = function (t) { null == t && (t = this._time); for (var e = this.getLabelsArray(), i = e.length; --i > -1;)if (t > e[i].time) return e[i].name; return null }, _.getLabelsArray = function () { var t, e = [], i = 0; for (t in this._labels) e[i++] = { time: this._labels[t], name: t }; return e.sort(function (t, e) { return t.time - e.time }), e }, _.progress = function (t) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration() }, _.totalProgress = function (t) { return arguments.length ? this.totalTime(this.totalDuration() * t, !1) : this._totalTime / this.totalDuration() }, _.totalDuration = function (e) { return arguments.length ? -1 === this._repeat ? this : this.duration((e - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (t.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration) }, _.time = function (t, e) { return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time }, _.repeat = function (t) { return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat }, _.repeatDelay = function (t) { return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay }, _.yoyo = function (t) { return arguments.length ? (this._yoyo = t, this) : this._yoyo }, _.currentLabel = function (t) { return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8) }, s }, !0), function () {
        var t = 180 / Math.PI, e = [], i = [], s = [], r = {}, n = function (t, e, i, s) { this.a = t, this.b = e, this.c = i, this.d = s, this.da = s - t, this.ca = i - t, this.ba = e - t }, a = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", o = function (t, e, i, s) { var r = { a: t }, n = {}, a = {}, o = { c: s }, h = (t + e) / 2, l = (e + i) / 2, _ = (i + s) / 2, u = (h + l) / 2, p = (l + _) / 2, c = (p - u) / 8; return r.b = h + (t - h) / 4, n.b = u + c, r.c = n.a = (r.b + n.b) / 2, n.c = a.a = (u + p) / 2, a.b = p - c, o.b = _ + (s - _) / 4, a.c = o.a = (a.b + o.b) / 2, [r, n, a, o] }, h = function (t, r, n, a, h) { var l, _, u, p, c, f, m, d, g, v, y, T, w, x = t.length - 1, b = 0, P = t[0].a; for (l = 0; x > l; l++)c = t[b], _ = c.a, u = c.d, p = t[b + 1].d, h ? (y = e[l], T = i[l], w = .25 * (T + y) * r / (a ? .5 : s[l] || .5), f = u - (u - _) * (a ? .5 * r : 0 !== y ? w / y : 0), m = u + (p - u) * (a ? .5 * r : 0 !== T ? w / T : 0), d = u - (f + ((m - f) * (3 * y / (y + T) + .5) / 4 || 0))) : (f = u - .5 * (u - _) * r, m = u + .5 * (p - u) * r, d = u - (f + m) / 2), f += d, m += d, c.c = g = f, c.b = 0 !== l ? P : P = c.a + .6 * (c.c - c.a), c.da = u - _, c.ca = g - _, c.ba = P - _, n ? (v = o(_, P, g, u), t.splice(b, 1, v[0], v[1], v[2], v[3]), b += 4) : b++ , P = m; c = t[b], c.b = P, c.c = P + .4 * (c.d - P), c.da = c.d - c.a, c.ca = c.c - c.a, c.ba = P - c.a, n && (v = o(c.a, P, c.c, c.d), t.splice(b, 1, v[0], v[1], v[2], v[3])) }, l = function (t, s, r, a) { var o, h, l, _, u, p, c = []; if (a) for (t = [a].concat(t), h = t.length; --h > -1;)"string" == typeof (p = t[h][s]) && "=" === p.charAt(1) && (t[h][s] = a[s] + Number(p.charAt(0) + p.substr(2))); if (o = t.length - 2, 0 > o) return c[0] = new n(t[0][s], 0, 0, t[-1 > o ? 0 : 1][s]), c; for (h = 0; o > h; h++)l = t[h][s], _ = t[h + 1][s], c[h] = new n(l, 0, 0, _), r && (u = t[h + 2][s], e[h] = (e[h] || 0) + (_ - l) * (_ - l), i[h] = (i[h] || 0) + (u - _) * (u - _)); return c[h] = new n(t[h][s], 0, 0, t[h + 1][s]), c }, _ = function (t, n, o, _, u, p) { var c, f, m, d, g, v, y, T, w = {}, x = [], b = p || t[0]; u = "string" == typeof u ? "," + u + "," : a, null == n && (n = 1); for (f in t[0]) x.push(f); if (t.length > 1) { for (T = t[t.length - 1], y = !0, c = x.length; --c > -1;)if (f = x[c], Math.abs(b[f] - T[f]) > .05) { y = !1; break } y && (t = t.concat(), p && t.unshift(p), t.push(t[1]), p = t[t.length - 3]) } for (e.length = i.length = s.length = 0, c = x.length; --c > -1;)f = x[c], r[f] = -1 !== u.indexOf("," + f + ","), w[f] = l(t, f, r[f], p); for (c = e.length; --c > -1;)e[c] = Math.sqrt(e[c]), i[c] = Math.sqrt(i[c]); if (!_) { for (c = x.length; --c > -1;)if (r[f]) for (m = w[x[c]], v = m.length - 1, d = 0; v > d; d++)g = m[d + 1].da / i[d] + m[d].da / e[d], s[d] = (s[d] || 0) + g * g; for (c = s.length; --c > -1;)s[c] = Math.sqrt(s[c]) } for (c = x.length, d = o ? 4 : 1; --c > -1;)f = x[c], m = w[f], h(m, n, o, _, r[f]), y && (m.splice(0, d), m.splice(m.length - d, d)); return w }, u = function (t, e, i) { e = e || "soft"; var s, r, a, o, h, l, _, u, p, c, f, m = {}, d = "cubic" === e ? 3 : 2, g = "soft" === e, v = []; if (g && i && (t = [i].concat(t)), null == t || d + 1 > t.length) throw "invalid Bezier data"; for (p in t[0]) v.push(p); for (l = v.length; --l > -1;) { for (p = v[l], m[p] = h = [], c = 0, u = t.length, _ = 0; u > _; _++)s = null == i ? t[_][p] : "string" == typeof (f = t[_][p]) && "=" === f.charAt(1) ? i[p] + Number(f.charAt(0) + f.substr(2)) : Number(f), g && _ > 1 && u - 1 > _ && (h[c++] = (s + h[c - 2]) / 2), h[c++] = s; for (u = c - d + 1, c = 0, _ = 0; u > _; _ += d)s = h[_], r = h[_ + 1], a = h[_ + 2], o = 2 === d ? 0 : h[_ + 3], h[c++] = f = 3 === d ? new n(s, r, a, o) : new n(s, (2 * r + s) / 3, (2 * r + a) / 3, a); h.length = c } return m }, p = function (t, e, i) { for (var s, r, n, a, o, h, l, _, u, p, c, f = 1 / i, m = t.length; --m > -1;)for (p = t[m], n = p.a, a = p.d - n, o = p.c - n, h = p.b - n, s = r = 0, _ = 1; i >= _; _++)l = f * _, u = 1 - l, s = r - (r = (l * l * a + 3 * u * (l * o + u * h)) * l), c = m * i + _ - 1, e[c] = (e[c] || 0) + s * s }, c = function (t, e) { e = e >> 0 || 6; var i, s, r, n, a = [], o = [], h = 0, l = 0, _ = e - 1, u = [], c = []; for (i in t) p(t[i], a, e); for (r = a.length, s = 0; r > s; s++)h += Math.sqrt(a[s]), n = s % e, c[n] = h, n === _ && (l += h, n = s / e >> 0, u[n] = c, o[n] = l, h = 0, c = []); return { length: l, lengths: o, segments: u } }, f = _gsScope._gsDefine.plugin({
            propName: "bezier", priority: -1, version: "1.3.3", API: 2, global: !0, init: function (t, e, i) { this._target = t, e instanceof Array && (e = { values: e }), this._func = {}, this._round = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10); var s, r, n, a, o, h = e.values || [], l = {}, p = h[0], f = e.autoRotate || i.vars.orientToBezier; this._autoRotate = f ? f instanceof Array ? f : [["x", "y", "rotation", f === !0 ? 0 : Number(f) || 0]] : null; for (s in p) this._props.push(s); for (n = this._props.length; --n > -1;)s = this._props[n], this._overwriteProps.push(s), r = this._func[s] = "function" == typeof t[s], l[s] = r ? t[s.indexOf("set") || "function" != typeof t["get" + s.substr(3)] ? s : "get" + s.substr(3)]() : parseFloat(t[s]), o || l[s] !== h[0][s] && (o = l); if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? _(h, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, o) : u(h, e.type, l), this._segCount = this._beziers[s].length, this._timeRes) { var m = c(this._beziers, this._timeRes); this._length = m.length, this._lengths = m.lengths, this._segments = m.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length } if (f = this._autoRotate) for (this._initialRotations = [], f[0] instanceof Array || (this._autoRotate = f = [f]), n = f.length; --n > -1;) { for (a = 0; 3 > a; a++)s = f[n][a], this._func[s] = "function" == typeof t[s] ? t[s.indexOf("set") || "function" != typeof t["get" + s.substr(3)] ? s : "get" + s.substr(3)] : !1; s = f[n][2], this._initialRotations[n] = this._func[s] ? this._func[s].call(this._target) : this._target[s] } return this._startRatio = i.vars.runBackwards ? 1 : 0, !0 }, set: function (e) {
                var i, s, r, n, a, o, h, l, _, u, p = this._segCount, c = this._func, f = this._target, m = e !== this._startRatio; if (this._timeRes) { if (_ = this._lengths, u = this._curSeg, e *= this._length, r = this._li, e > this._l2 && p - 1 > r) { for (l = p - 1; l > r && e >= (this._l2 = _[++r]);); this._l1 = _[r - 1], this._li = r, this._curSeg = u = this._segments[r], this._s2 = u[this._s1 = this._si = 0] } else if (this._l1 > e && r > 0) { for (; r > 0 && (this._l1 = _[--r]) >= e;); 0 === r && this._l1 > e ? this._l1 = 0 : r++ , this._l2 = _[r], this._li = r, this._curSeg = u = this._segments[r], this._s1 = u[(this._si = u.length - 1) - 1] || 0, this._s2 = u[this._si] } if (i = r, e -= this._l1, r = this._si, e > this._s2 && u.length - 1 > r) { for (l = u.length - 1; l > r && e >= (this._s2 = u[++r]);); this._s1 = u[r - 1], this._si = r } else if (this._s1 > e && r > 0) { for (; r > 0 && (this._s1 = u[--r]) >= e;); 0 === r && this._s1 > e ? this._s1 = 0 : r++ , this._s2 = u[r], this._si = r } o = (r + (e - this._s1) / (this._s2 - this._s1)) * this._prec } else i = 0 > e ? 0 : e >= 1 ? p - 1 : p * e >> 0, o = (e - i * (1 / p)) * p; for (s = 1 - o, r = this._props.length; --r > -1;)n = this._props[r], a = this._beziers[n][i], h = (o * o * a.da + 3 * s * (o * a.ca + s * a.ba)) * o + a.a, this._round[n] && (h = Math.round(h)), c[n] ? f[n](h) : f[n] = h; if (this._autoRotate) {
                    var d, g, v, y, T, w, x, b = this._autoRotate;
                    for (r = b.length; --r > -1;)n = b[r][2], w = b[r][3] || 0, x = b[r][4] === !0 ? 1 : t, a = this._beziers[b[r][0]], d = this._beziers[b[r][1]], a && d && (a = a[i], d = d[i], g = a.a + (a.b - a.a) * o, y = a.b + (a.c - a.b) * o, g += (y - g) * o, y += (a.c + (a.d - a.c) * o - y) * o, v = d.a + (d.b - d.a) * o, T = d.b + (d.c - d.b) * o, v += (T - v) * o, T += (d.c + (d.d - d.c) * o - T) * o, h = m ? Math.atan2(T - v, y - g) * x + w : this._initialRotations[r], c[n] ? f[n](h) : f[n] = h)
                }
            }
        }), m = f.prototype; f.bezierThrough = _, f.cubicToQuadratic = o, f._autoCSS = !0, f.quadraticToCubic = function (t, e, i) { return new n(t, (2 * e + t) / 3, (2 * e + i) / 3, i) }, f._cssRegister = function () { var t = _gsScope._gsDefine.globals.CSSPlugin; if (t) { var e = t._internals, i = e._parseToProxy, s = e._setPluginRatio, r = e.CSSPropTween; e._registerComplexSpecialProp("bezier", { parser: function (t, e, n, a, o, h) { e instanceof Array && (e = { values: e }), h = new f; var l, _, u, p = e.values, c = p.length - 1, m = [], d = {}; if (0 > c) return o; for (l = 0; c >= l; l++)u = i(t, p[l], a, o, h, c !== l), m[l] = u.end; for (_ in e) d[_] = e[_]; return d.values = m, o = new r(t, "bezier", 0, 0, u.pt, 2), o.data = u, o.plugin = h, o.setRatio = s, 0 === d.autoRotate && (d.autoRotate = !0), !d.autoRotate || d.autoRotate instanceof Array || (l = d.autoRotate === !0 ? 0 : Number(d.autoRotate), d.autoRotate = null != u.end.left ? [["left", "top", "rotation", l, !1]] : null != u.end.x ? [["x", "y", "rotation", l, !1]] : !1), d.autoRotate && (a._transform || a._enableTransforms(!1), u.autoRotate = a._target._gsTransform), h._onInitTween(u.proxy, d, a._tween), o } }) } }, m._roundProps = function (t, e) { for (var i = this._overwriteProps, s = i.length; --s > -1;)(t[i[s]] || t.bezier || t.bezierThrough) && (this._round[i[s]] = e) }, m._kill = function (t) { var e, i, s = this._props; for (e in this._beziers) if (e in t) for (delete this._beziers[e], delete this._func[e], i = s.length; --i > -1;)s[i] === e && s.splice(i, 1); return this._super._kill.call(this, t) }
    }(), _gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function (t, e) {
        var i, s, r, n, a = function () { t.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = a.prototype.setRatio }, o = {}, h = a.prototype = new t("css"); h.constructor = a, a.version = "1.13.1", a.API = 2, a.defaultTransformPerspective = 0, a.defaultSkewType = "compensated", h = "px", a.suffixMap = { top: h, right: h, bottom: h, left: h, width: h, height: h, fontSize: h, padding: h, margin: h, perspective: h, lineHeight: "" }; var l, _, u, p, c, f, m = /(?:\d|\-\d|\.\d|\-\.\d)+/g, d = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g, g = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, v = /[^\d\-\.]/g, y = /(?:\d|\-|\+|=|#|\.)*/g, T = /opacity *= *([^)]*)/i, w = /opacity:([^;]*)/i, x = /alpha\(opacity *=.+?\)/i, b = /^(rgb|hsl)/, P = /([A-Z])/g, S = /-([a-z])/gi, k = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, R = function (t, e) { return e.toUpperCase() }, A = /(?:Left|Right|Width)/i, C = /(M11|M12|M21|M22)=[\d\-\.e]+/gi, O = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, D = /,(?=[^\)]*(?:\(|$))/gi, M = Math.PI / 180, z = 180 / Math.PI, I = {}, E = document, L = E.createElement("div"), F = E.createElement("img"), N = a._internals = { _specialProps: o }, X = navigator.userAgent, U = function () { var t, e = X.indexOf("Android"), i = E.createElement("div"); return u = -1 !== X.indexOf("Safari") && -1 === X.indexOf("Chrome") && (-1 === e || Number(X.substr(e + 8, 1)) > 3), c = u && 6 > Number(X.substr(X.indexOf("Version/") + 8, 1)), p = -1 !== X.indexOf("Firefox"), /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(X) && (f = parseFloat(RegExp.$1)), i.innerHTML = "<a style='top:1px;opacity:.55;'>a</a>", t = i.getElementsByTagName("a")[0], t ? /^0.55/.test(t.style.opacity) : !1 }(), Y = function (t) { return T.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1 }, j = function (t) { window.console && console.log(t) }, B = "", q = "", V = function (t, e) { e = e || L; var i, s, r = e.style; if (void 0 !== r[t]) return t; for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], s = 5; --s > -1 && void 0 === r[i[s] + t];); return s >= 0 ? (q = 3 === s ? "ms" : i[s], B = "-" + q.toLowerCase() + "-", q + t) : null }, G = E.defaultView ? E.defaultView.getComputedStyle : function () { }, W = a.getStyle = function (t, e, i, s, r) { var n; return U || "opacity" !== e ? (!s && t.style[e] ? n = t.style[e] : (i = i || G(t)) ? n = i[e] || i.getPropertyValue(e) || i.getPropertyValue(e.replace(P, "-$1").toLowerCase()) : t.currentStyle && (n = t.currentStyle[e]), null == r || n && "none" !== n && "auto" !== n && "auto auto" !== n ? n : r) : Y(t) }, Q = N.convertToPixels = function (t, i, s, r, n) { if ("px" === r || !r) return s; if ("auto" === r || !s) return 0; var o, h, l, _ = A.test(i), u = t, p = L.style, c = 0 > s; if (c && (s = -s), "%" === r && -1 !== i.indexOf("border")) o = s / 100 * (_ ? t.clientWidth : t.clientHeight); else { if (p.cssText = "border:0 solid red;position:" + W(t, "position") + ";line-height:0;", "%" !== r && u.appendChild) p[_ ? "borderLeftWidth" : "borderTopWidth"] = s + r; else { if (u = t.parentNode || E.body, h = u._gsCache, l = e.ticker.frame, h && _ && h.time === l) return h.width * s / 100; p[_ ? "width" : "height"] = s + r } u.appendChild(L), o = parseFloat(L[_ ? "offsetWidth" : "offsetHeight"]), u.removeChild(L), _ && "%" === r && a.cacheWidths !== !1 && (h = u._gsCache = u._gsCache || {}, h.time = l, h.width = 100 * (o / s)), 0 !== o || n || (o = Q(t, i, s, r, !0)) } return c ? -o : o }, Z = N.calculateOffset = function (t, e, i) { if ("absolute" !== W(t, "position", i)) return 0; var s = "left" === e ? "Left" : "Top", r = W(t, "margin" + s, i); return t["offset" + s] - (Q(t, e, parseFloat(r), r.replace(y, "")) || 0) }, $ = function (t, e) { var i, s, r = {}; if (e = e || G(t, null)) if (i = e.length) for (; --i > -1;)r[e[i].replace(S, R)] = e.getPropertyValue(e[i]); else for (i in e) r[i] = e[i]; else if (e = t.currentStyle || t.style) for (i in e) "string" == typeof i && void 0 === r[i] && (r[i.replace(S, R)] = e[i]); return U || (r.opacity = Y(t)), s = Pe(t, e, !1), r.rotation = s.rotation, r.skewX = s.skewX, r.scaleX = s.scaleX, r.scaleY = s.scaleY, r.x = s.x, r.y = s.y, xe && (r.z = s.z, r.rotationX = s.rotationX, r.rotationY = s.rotationY, r.scaleZ = s.scaleZ), r.filters && delete r.filters, r }, H = function (t, e, i, s, r) { var n, a, o, h = {}, l = t.style; for (a in i) "cssText" !== a && "length" !== a && isNaN(a) && (e[a] !== (n = i[a]) || r && r[a]) && -1 === a.indexOf("Origin") && ("number" == typeof n || "string" == typeof n) && (h[a] = "auto" !== n || "left" !== a && "top" !== a ? "" !== n && "auto" !== n && "none" !== n || "string" != typeof e[a] || "" === e[a].replace(v, "") ? n : 0 : Z(t, a), void 0 !== l[a] && (o = new ue(l, a, l[a], o))); if (s) for (a in s) "className" !== a && (h[a] = s[a]); return { difs: h, firstMPT: o } }, K = { width: ["Left", "Right"], height: ["Top", "Bottom"] }, J = ["marginLeft", "marginRight", "marginTop", "marginBottom"], te = function (t, e, i) { var s = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight), r = K[e], n = r.length; for (i = i || G(t, null); --n > -1;)s -= parseFloat(W(t, "padding" + r[n], i, !0)) || 0, s -= parseFloat(W(t, "border" + r[n] + "Width", i, !0)) || 0; return s }, ee = function (t, e) { (null == t || "" === t || "auto" === t || "auto auto" === t) && (t = "0 0"); var i = t.split(" "), s = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : i[0], r = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : i[1]; return null == r ? r = "0" : "center" === r && (r = "50%"), ("center" === s || isNaN(parseFloat(s)) && -1 === (s + "").indexOf("=")) && (s = "50%"), e && (e.oxp = -1 !== s.indexOf("%"), e.oyp = -1 !== r.indexOf("%"), e.oxr = "=" === s.charAt(1), e.oyr = "=" === r.charAt(1), e.ox = parseFloat(s.replace(v, "")), e.oy = parseFloat(r.replace(v, ""))), s + " " + r + (i.length > 2 ? " " + i[2] : "") }, ie = function (t, e) { return "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e) }, se = function (t, e) { return null == t ? e : "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * Number(t.substr(2)) + e : parseFloat(t) }, re = function (t, e, i, s) { var r, n, a, o, h = 1e-6; return null == t ? o = e : "number" == typeof t ? o = t : (r = 360, n = t.split("_"), a = Number(n[0].replace(v, "")) * (-1 === t.indexOf("rad") ? 1 : z) - ("=" === t.charAt(1) ? 0 : e), n.length && (s && (s[i] = e + a), -1 !== t.indexOf("short") && (a %= r, a !== a % (r / 2) && (a = 0 > a ? a + r : a - r)), -1 !== t.indexOf("_cw") && 0 > a ? a = (a + 9999999999 * r) % r - (0 | a / r) * r : -1 !== t.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * r) % r - (0 | a / r) * r)), o = e + a), h > o && o > -h && (o = 0), o }, ne = { aqua: [0, 255, 255], lime: [0, 255, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, 255], navy: [0, 0, 128], white: [255, 255, 255], fuchsia: [255, 0, 255], olive: [128, 128, 0], yellow: [255, 255, 0], orange: [255, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [255, 0, 0], pink: [255, 192, 203], cyan: [0, 255, 255], transparent: [255, 255, 255, 0] }, ae = function (t, e, i) { return t = 0 > t ? t + 1 : t > 1 ? t - 1 : t, 0 | 255 * (1 > 6 * t ? e + 6 * (i - e) * t : .5 > t ? i : 2 > 3 * t ? e + 6 * (i - e) * (2 / 3 - t) : e) + .5 }, oe = function (t) { var e, i, s, r, n, a; return t && "" !== t ? "number" == typeof t ? [t >> 16, 255 & t >> 8, 255 & t] : ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), ne[t] ? ne[t] : "#" === t.charAt(0) ? (4 === t.length && (e = t.charAt(1), i = t.charAt(2), s = t.charAt(3), t = "#" + e + e + i + i + s + s), t = parseInt(t.substr(1), 16), [t >> 16, 255 & t >> 8, 255 & t]) : "hsl" === t.substr(0, 3) ? (t = t.match(m), r = Number(t[0]) % 360 / 360, n = Number(t[1]) / 100, a = Number(t[2]) / 100, i = .5 >= a ? a * (n + 1) : a + n - a * n, e = 2 * a - i, t.length > 3 && (t[3] = Number(t[3])), t[0] = ae(r + 1 / 3, e, i), t[1] = ae(r, e, i), t[2] = ae(r - 1 / 3, e, i), t) : (t = t.match(m) || ne.transparent, t[0] = Number(t[0]), t[1] = Number(t[1]), t[2] = Number(t[2]), t.length > 3 && (t[3] = Number(t[3])), t)) : ne.black }, he = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b"; for (h in ne) he += "|" + h + "\\b"; he = RegExp(he + ")", "gi"); var le = function (t, e, i, s) { if (null == t) return function (t) { return t }; var r, n = e ? (t.match(he) || [""])[0] : "", a = t.split(n).join("").match(g) || [], o = t.substr(0, t.indexOf(a[0])), h = ")" === t.charAt(t.length - 1) ? ")" : "", l = -1 !== t.indexOf(" ") ? " " : ",", _ = a.length, u = _ > 0 ? a[0].replace(m, "") : ""; return _ ? r = e ? function (t) { var e, p, c, f; if ("number" == typeof t) t += u; else if (s && D.test(t)) { for (f = t.replace(D, "|").split("|"), c = 0; f.length > c; c++)f[c] = r(f[c]); return f.join(",") } if (e = (t.match(he) || [n])[0], p = t.split(e).join("").match(g) || [], c = p.length, _ > c--) for (; _ > ++c;)p[c] = i ? p[0 | (c - 1) / 2] : a[c]; return o + p.join(l) + l + e + h + (-1 !== t.indexOf("inset") ? " inset" : "") } : function (t) { var e, n, p; if ("number" == typeof t) t += u; else if (s && D.test(t)) { for (n = t.replace(D, "|").split("|"), p = 0; n.length > p; p++)n[p] = r(n[p]); return n.join(",") } if (e = t.match(g) || [], p = e.length, _ > p--) for (; _ > ++p;)e[p] = i ? e[0 | (p - 1) / 2] : a[p]; return o + e.join(l) + h } : function (t) { return t } }, _e = function (t) { return t = t.split(","), function (e, i, s, r, n, a, o) { var h, l = (i + "").split(" "); for (o = {}, h = 0; 4 > h; h++)o[t[h]] = l[h] = l[h] || l[(h - 1) / 2 >> 0]; return r.parse(e, o, n, a) } }, ue = (N._setPluginRatio = function (t) { this.plugin.setRatio(t); for (var e, i, s, r, n = this.data, a = n.proxy, o = n.firstMPT, h = 1e-6; o;)e = a[o.v], o.r ? e = Math.round(e) : h > e && e > -h && (e = 0), o.t[o.p] = e, o = o._next; if (n.autoRotate && (n.autoRotate.rotation = a.rotation), 1 === t) for (o = n.firstMPT; o;) { if (i = o.t, i.type) { if (1 === i.type) { for (r = i.xs0 + i.s + i.xs1, s = 1; i.l > s; s++)r += i["xn" + s] + i["xs" + (s + 1)]; i.e = r } } else i.e = i.s + i.xs0; o = o._next } }, function (t, e, i, s, r) { this.t = t, this.p = e, this.v = i, this.r = r, s && (s._prev = this, this._next = s) }), pe = (N._parseToProxy = function (t, e, i, s, r, n) { var a, o, h, l, _, u = s, p = {}, c = {}, f = i._transform, m = I; for (i._transform = null, I = e, s = _ = i.parse(t, e, s, r), I = m, n && (i._transform = f, u && (u._prev = null, u._prev && (u._prev._next = null))); s && s !== u;) { if (1 >= s.type && (o = s.p, c[o] = s.s + s.c, p[o] = s.s, n || (l = new ue(s, "s", o, l, s.r), s.c = 0), 1 === s.type)) for (a = s.l; --a > 0;)h = "xn" + a, o = s.p + "_" + h, c[o] = s.data[h], p[o] = s[h], n || (l = new ue(s, h, o, l, s.rxp[h])); s = s._next } return { proxy: p, end: c, firstMPT: l, pt: _ } }, N.CSSPropTween = function (t, e, s, r, a, o, h, l, _, u, p) { this.t = t, this.p = e, this.s = s, this.c = r, this.n = h || e, t instanceof pe || n.push(this.n), this.r = l, this.type = o || 0, _ && (this.pr = _, i = !0), this.b = void 0 === u ? s : u, this.e = void 0 === p ? s + r : p, a && (this._next = a, a._prev = this) }), ce = a.parseComplex = function (t, e, i, s, r, n, a, o, h, _) { i = i || n || "", a = new pe(t, e, 0, 0, a, _ ? 2 : 1, null, !1, o, i, s), s += ""; var u, p, c, f, g, v, y, T, w, x, P, S, k = i.split(", ").join(",").split(" "), R = s.split(", ").join(",").split(" "), A = k.length, C = l !== !1; for ((-1 !== s.indexOf(",") || -1 !== i.indexOf(",")) && (k = k.join(" ").replace(D, ", ").split(" "), R = R.join(" ").replace(D, ", ").split(" "), A = k.length), A !== R.length && (k = (n || "").split(" "), A = k.length), a.plugin = h, a.setRatio = _, u = 0; A > u; u++)if (f = k[u], g = R[u], T = parseFloat(f), T || 0 === T) a.appendXtra("", T, ie(g, T), g.replace(d, ""), C && -1 !== g.indexOf("px"), !0); else if (r && ("#" === f.charAt(0) || ne[f] || b.test(f))) S = "," === g.charAt(g.length - 1) ? ")," : ")", f = oe(f), g = oe(g), w = f.length + g.length > 6, w && !U && 0 === g[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(R[u]).join("transparent")) : (U || (w = !1), a.appendXtra(w ? "rgba(" : "rgb(", f[0], g[0] - f[0], ",", !0, !0).appendXtra("", f[1], g[1] - f[1], ",", !0).appendXtra("", f[2], g[2] - f[2], w ? "," : S, !0), w && (f = 4 > f.length ? 1 : f[3], a.appendXtra("", f, (4 > g.length ? 1 : g[3]) - f, S, !1))); else if (v = f.match(m)) { if (y = g.match(d), !y || y.length !== v.length) return a; for (c = 0, p = 0; v.length > p; p++)P = v[p], x = f.indexOf(P, c), a.appendXtra(f.substr(c, x - c), Number(P), ie(y[p], P), "", C && "px" === f.substr(x + P.length, 2), 0 === p), c = x + P.length; a["xs" + a.l] += f.substr(c) } else a["xs" + a.l] += a.l ? " " + f : f; if (-1 !== s.indexOf("=") && a.data) { for (S = a.xs0 + a.data.s, u = 1; a.l > u; u++)S += a["xs" + u] + a.data["xn" + u]; a.e = S + a["xs" + u] } return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a }, fe = 9; for (h = pe.prototype, h.l = h.pr = 0; --fe > 0;)h["xn" + fe] = 0, h["xs" + fe] = ""; h.xs0 = "", h._next = h._prev = h.xfirst = h.data = h.plugin = h.setRatio = h.rxp = null, h.appendXtra = function (t, e, i, s, r, n) { var a = this, o = a.l; return a["xs" + o] += n && o ? " " + t : t || "", i || 0 === o || a.plugin ? (a.l++ , a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = s || "", o > 0 ? (a.data["xn" + o] = e + i, a.rxp["xn" + o] = r, a["xn" + o] = e, a.plugin || (a.xfirst = new pe(a, "xn" + o, e, i, a.xfirst || a, 0, a.n, r, a.pr), a.xfirst.xs0 = 0), a) : (a.data = { s: e + i }, a.rxp = {}, a.s = e, a.c = i, a.r = r, a)) : (a["xs" + o] += e + (s || ""), a) }; var me = function (t, e) { e = e || {}, this.p = e.prefix ? V(t) || t : t, o[t] = o[this.p] = this, this.format = e.formatter || le(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0 }, de = N._registerComplexSpecialProp = function (t, e, i) { "object" != typeof e && (e = { parser: i }); var s, r, n = t.split(","), a = e.defaultValue; for (i = i || [a], s = 0; n.length > s; s++)e.prefix = 0 === s && e.prefix, e.defaultValue = i[s] || a, r = new me(n[s], e) }, ge = function (t) { if (!o[t]) { var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin"; de(t, { parser: function (t, i, s, r, n, a, h) { var l = (_gsScope.GreenSockGlobals || _gsScope).com.greensock.plugins[e]; return l ? (l._cssRegister(), o[s].parse(t, i, s, r, n, a, h)) : (j("Error: " + e + " js file not loaded."), n) } }) } }; h = me.prototype, h.parseComplex = function (t, e, i, s, r, n) { var a, o, h, l, _, u, p = this.keyword; if (this.multi && (D.test(i) || D.test(e) ? (o = e.replace(D, "|").split("|"), h = i.replace(D, "|").split("|")) : p && (o = [e], h = [i])), h) { for (l = h.length > o.length ? h.length : o.length, a = 0; l > a; a++)e = o[a] = o[a] || this.dflt, i = h[a] = h[a] || this.dflt, p && (_ = e.indexOf(p), u = i.indexOf(p), _ !== u && (i = -1 === u ? h : o, i[a] += " " + p)); e = o.join(", "), i = h.join(", ") } return ce(t, this.p, e, i, this.clrs, this.dflt, s, this.pr, r, n) }, h.parse = function (t, e, i, s, n, a) { return this.parseComplex(t.style, this.format(W(t, this.p, r, !1, this.dflt)), this.format(e), n, a) }, a.registerSpecialProp = function (t, e, i) { de(t, { parser: function (t, s, r, n, a, o) { var h = new pe(t, r, 0, 0, a, 2, r, !1, i); return h.plugin = o, h.setRatio = e(t, s, n._tween, r), h }, priority: i }) }; var ve = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","), ye = V("transform"), Te = B + "transform", we = V("transformOrigin"), xe = null !== V("perspective"), be = N.Transform = function () { this.skewY = 0 }, Pe = N.getTransform = function (t, e, i, s) { if (t._gsTransform && i && !s) return t._gsTransform; var r, n, o, h, l, _, u, p, c, f, m, d, g, v = i ? t._gsTransform || new be : new be, y = 0 > v.scaleX, T = 2e-5, w = 1e5, x = 179.99, b = x * M, P = xe ? parseFloat(W(t, we, e, !1, "0 0 0").split(" ")[2]) || v.zOrigin || 0 : 0; if (ye ? r = W(t, Te, e, !0) : t.currentStyle && (r = t.currentStyle.filter.match(C), r = r && 4 === r.length ? [r[0].substr(4), Number(r[2].substr(4)), Number(r[1].substr(4)), r[3].substr(4), v.x || 0, v.y || 0].join(",") : ""), r && "none" !== r && "matrix(1, 0, 0, 1, 0, 0)" !== r) { for (n = (r || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [], o = n.length; --o > -1;)h = Number(n[o]), n[o] = (l = h - (h |= 0)) ? (0 | l * w + (0 > l ? -.5 : .5)) / w + h : h; if (16 === n.length) { var S = n[8], k = n[9], R = n[10], A = n[12], O = n[13], D = n[14]; if (v.zOrigin && (D = -v.zOrigin, A = S * D - n[12], O = k * D - n[13], D = R * D + v.zOrigin - n[14]), !i || s || null == v.rotationX) { var I, E, L, F, N, X, U, Y = n[0], j = n[1], B = n[2], q = n[3], V = n[4], G = n[5], Q = n[6], Z = n[7], $ = n[11], H = Math.atan2(Q, R), K = -b > H || H > b; v.rotationX = H * z, H && (F = Math.cos(-H), N = Math.sin(-H), I = V * F + S * N, E = G * F + k * N, L = Q * F + R * N, S = V * -N + S * F, k = G * -N + k * F, R = Q * -N + R * F, $ = Z * -N + $ * F, V = I, G = E, Q = L), H = Math.atan2(S, Y), v.rotationY = H * z, H && (X = -b > H || H > b, F = Math.cos(-H), N = Math.sin(-H), I = Y * F - S * N, E = j * F - k * N, L = B * F - R * N, k = j * N + k * F, R = B * N + R * F, $ = q * N + $ * F, Y = I, j = E, B = L), H = Math.atan2(j, G), v.rotation = H * z, H && (U = -b > H || H > b, F = Math.cos(-H), N = Math.sin(-H), Y = Y * F + V * N, E = j * F + G * N, G = j * -N + G * F, Q = B * -N + Q * F, j = E), U && K ? v.rotation = v.rotationX = 0 : U && X ? v.rotation = v.rotationY = 0 : X && K && (v.rotationY = v.rotationX = 0), v.scaleX = (0 | Math.sqrt(Y * Y + j * j) * w + .5) / w, v.scaleY = (0 | Math.sqrt(G * G + k * k) * w + .5) / w, v.scaleZ = (0 | Math.sqrt(Q * Q + R * R) * w + .5) / w, v.skewX = 0, v.perspective = $ ? 1 / (0 > $ ? -$ : $) : 0, v.x = A, v.y = O, v.z = D } } else if (!(xe && !s && n.length && v.x === n[4] && v.y === n[5] && (v.rotationX || v.rotationY) || void 0 !== v.x && "none" === W(t, "display", e))) { var J = n.length >= 6, te = J ? n[0] : 1, ee = n[1] || 0, ie = n[2] || 0, se = J ? n[3] : 1; v.x = n[4] || 0, v.y = n[5] || 0, _ = Math.sqrt(te * te + ee * ee), u = Math.sqrt(se * se + ie * ie), p = te || ee ? Math.atan2(ee, te) * z : v.rotation || 0, c = ie || se ? Math.atan2(ie, se) * z + p : v.skewX || 0, f = _ - Math.abs(v.scaleX || 0), m = u - Math.abs(v.scaleY || 0), Math.abs(c) > 90 && 270 > Math.abs(c) && (y ? (_ *= -1, c += 0 >= p ? 180 : -180, p += 0 >= p ? 180 : -180) : (u *= -1, c += 0 >= c ? 180 : -180)), d = (p - v.rotation) % 180, g = (c - v.skewX) % 180, (void 0 === v.skewX || f > T || -T > f || m > T || -T > m || d > -x && x > d && false | d * w || g > -x && x > g && false | g * w) && (v.scaleX = _, v.scaleY = u, v.rotation = p, v.skewX = c), xe && (v.rotationX = v.rotationY = v.z = 0, v.perspective = parseFloat(a.defaultTransformPerspective) || 0, v.scaleZ = 1) } v.zOrigin = P; for (o in v) T > v[o] && v[o] > -T && (v[o] = 0) } else v = { x: 0, y: 0, z: 0, scaleX: 1, scaleY: 1, scaleZ: 1, skewX: 0, perspective: 0, rotation: 0, rotationX: 0, rotationY: 0, zOrigin: 0 }; return i && (t._gsTransform = v), v.xPercent = v.yPercent = 0, v }, Se = function (t) { var e, i, s = this.data, r = -s.rotation * M, n = r + s.skewX * M, a = 1e5, o = (0 | Math.cos(r) * s.scaleX * a) / a, h = (0 | Math.sin(r) * s.scaleX * a) / a, l = (0 | Math.sin(n) * -s.scaleY * a) / a, _ = (0 | Math.cos(n) * s.scaleY * a) / a, u = this.t.style, p = this.t.currentStyle; if (p) { i = h, h = -l, l = -i, e = p.filter, u.filter = ""; var c, m, d = this.t.offsetWidth, g = this.t.offsetHeight, v = "absolute" !== p.position, w = "progid:DXImageTransform.Microsoft.Matrix(M11=" + o + ", M12=" + h + ", M21=" + l + ", M22=" + _, x = s.x + d * s.xPercent / 100, b = s.y + g * s.yPercent / 100; if (null != s.ox && (c = (s.oxp ? .01 * d * s.ox : s.ox) - d / 2, m = (s.oyp ? .01 * g * s.oy : s.oy) - g / 2, x += c - (c * o + m * h), b += m - (c * l + m * _)), v ? (c = d / 2, m = g / 2, w += ", Dx=" + (c - (c * o + m * h) + x) + ", Dy=" + (m - (c * l + m * _) + b) + ")") : w += ", sizingMethod='auto expand')", u.filter = -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? e.replace(O, w) : w + " " + e, (0 === t || 1 === t) && 1 === o && 0 === h && 0 === l && 1 === _ && (v && -1 === w.indexOf("Dx=0, Dy=0") || T.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf("gradient(" && e.indexOf("Alpha")) && u.removeAttribute("filter")), !v) { var P, S, k, R = 8 > f ? 1 : -1; for (c = s.ieOffsetX || 0, m = s.ieOffsetY || 0, s.ieOffsetX = Math.round((d - ((0 > o ? -o : o) * d + (0 > h ? -h : h) * g)) / 2 + x), s.ieOffsetY = Math.round((g - ((0 > _ ? -_ : _) * g + (0 > l ? -l : l) * d)) / 2 + b), fe = 0; 4 > fe; fe++)S = J[fe], P = p[S], i = -1 !== P.indexOf("px") ? parseFloat(P) : Q(this.t, S, parseFloat(P), P.replace(y, "")) || 0, k = i !== s[S] ? 2 > fe ? -s.ieOffsetX : -s.ieOffsetY : 2 > fe ? c - s.ieOffsetX : m - s.ieOffsetY, u[S] = (s[S] = Math.round(i - k * (0 === fe || 2 === fe ? 1 : R))) + "px" } } }, ke = N.set3DTransformRatio = function (t) { var e, i, s, r, n, a, o, h, l, _, u, c, f, m, d, g, v, y, T, w, x, b, P, S = this.data, k = this.t.style, R = S.rotation * M, A = S.scaleX, C = S.scaleY, O = S.scaleZ, D = S.x, z = S.y, I = S.z, E = S.perspective; if (!(1 !== t && 0 !== t || "auto" !== S.force3D || S.rotationY || S.rotationX || 1 !== O || E || I)) return Re.call(this, t), void 0; if (p) { var L = 1e-4; L > A && A > -L && (A = O = 2e-5), L > C && C > -L && (C = O = 2e-5), !E || S.z || S.rotationX || S.rotationY || (E = 0) } if (R || S.skewX) y = Math.cos(R), T = Math.sin(R), e = y, n = T, S.skewX && (R -= S.skewX * M, y = Math.cos(R), T = Math.sin(R), "simple" === S.skewType && (w = Math.tan(S.skewX * M), w = Math.sqrt(1 + w * w), y *= w, T *= w)), i = -T, a = y; else { if (!(S.rotationY || S.rotationX || 1 !== O || E)) return k[ye] = (S.xPercent || S.yPercent ? "translate(" + S.xPercent + "%," + S.yPercent + "%) translate3d(" : "translate3d(") + D + "px," + z + "px," + I + "px)" + (1 !== A || 1 !== C ? " scale(" + A + "," + C + ")" : ""), void 0; e = a = 1, i = n = 0 } u = 1, s = r = o = h = l = _ = c = f = m = 0, d = E ? -1 / E : 0, g = S.zOrigin, v = 1e5, R = S.rotationY * M, R && (y = Math.cos(R), T = Math.sin(R), l = u * -T, f = d * -T, s = e * T, o = n * T, u *= y, d *= y, e *= y, n *= y), R = S.rotationX * M, R && (y = Math.cos(R), T = Math.sin(R), w = i * y + s * T, x = a * y + o * T, b = _ * y + u * T, P = m * y + d * T, s = i * -T + s * y, o = a * -T + o * y, u = _ * -T + u * y, d = m * -T + d * y, i = w, a = x, _ = b, m = P), 1 !== O && (s *= O, o *= O, u *= O, d *= O), 1 !== C && (i *= C, a *= C, _ *= C, m *= C), 1 !== A && (e *= A, n *= A, l *= A, f *= A), g && (c -= g, r = s * c, h = o * c, c = u * c + g), r = (w = (r += D) - (r |= 0)) ? (0 | w * v + (0 > w ? -.5 : .5)) / v + r : r, h = (w = (h += z) - (h |= 0)) ? (0 | w * v + (0 > w ? -.5 : .5)) / v + h : h, c = (w = (c += I) - (c |= 0)) ? (0 | w * v + (0 > w ? -.5 : .5)) / v + c : c, k[ye] = (S.xPercent || S.yPercent ? "translate(" + S.xPercent + "%," + S.yPercent + "%) matrix3d(" : "matrix3d(") + [(0 | e * v) / v, (0 | n * v) / v, (0 | l * v) / v, (0 | f * v) / v, (0 | i * v) / v, (0 | a * v) / v, (0 | _ * v) / v, (0 | m * v) / v, (0 | s * v) / v, (0 | o * v) / v, (0 | u * v) / v, (0 | d * v) / v, r, h, c, E ? 1 + -c / E : 1].join(",") + ")" }, Re = N.set2DTransformRatio = function (t) { var e, i, s, r, n, a = this.data, o = this.t, h = o.style, l = a.x, _ = a.y; return a.rotationX || a.rotationY || a.z || a.force3D === !0 || "auto" === a.force3D && 1 !== t && 0 !== t ? (this.setRatio = ke, ke.call(this, t), void 0) : (a.rotation || a.skewX ? (e = a.rotation * M, i = e - a.skewX * M, s = 1e5, r = a.scaleX * s, n = a.scaleY * s, h[ye] = (a.xPercent || a.yPercent ? "translate(" + a.xPercent + "%," + a.yPercent + "%) matrix(" : "matrix(") + (0 | Math.cos(e) * r) / s + "," + (0 | Math.sin(e) * r) / s + "," + (0 | Math.sin(i) * -n) / s + "," + (0 | Math.cos(i) * n) / s + "," + l + "," + _ + ")") : h[ye] = (a.xPercent || a.yPercent ? "translate(" + a.xPercent + "%," + a.yPercent + "%) matrix(" : "matrix(") + a.scaleX + ",0,0," + a.scaleY + "," + l + "," + _ + ")", void 0) }; de("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent", { parser: function (t, e, i, s, n, o, h) { if (s._transform) return n; var l, _, u, p, c, f, m, d = s._transform = Pe(t, r, !0, h.parseTransform), g = t.style, v = 1e-6, y = ve.length, T = h, w = {}; if ("string" == typeof T.transform && ye) u = L.style, u[ye] = T.transform, u.display = "block", u.position = "absolute", E.body.appendChild(L), l = Pe(L, null, !1), E.body.removeChild(L); else if ("object" == typeof T) { if (l = { scaleX: se(null != T.scaleX ? T.scaleX : T.scale, d.scaleX), scaleY: se(null != T.scaleY ? T.scaleY : T.scale, d.scaleY), scaleZ: se(T.scaleZ, d.scaleZ), x: se(T.x, d.x), y: se(T.y, d.y), z: se(T.z, d.z), xPercent: se(T.xPercent, d.xPercent), yPercent: se(T.yPercent, d.yPercent), perspective: se(T.transformPerspective, d.perspective) }, m = T.directionalRotation, null != m) if ("object" == typeof m) for (u in m) T[u] = m[u]; else T.rotation = m; "string" == typeof T.x && -1 !== T.x.indexOf("%") && (l.x = 0, l.xPercent = se(T.x, d.xPercent)), "string" == typeof T.y && -1 !== T.y.indexOf("%") && (l.y = 0, l.yPercent = se(T.y, d.yPercent)), l.rotation = re("rotation" in T ? T.rotation : "shortRotation" in T ? T.shortRotation + "_short" : "rotationZ" in T ? T.rotationZ : d.rotation, d.rotation, "rotation", w), xe && (l.rotationX = re("rotationX" in T ? T.rotationX : "shortRotationX" in T ? T.shortRotationX + "_short" : d.rotationX || 0, d.rotationX, "rotationX", w), l.rotationY = re("rotationY" in T ? T.rotationY : "shortRotationY" in T ? T.shortRotationY + "_short" : d.rotationY || 0, d.rotationY, "rotationY", w)), l.skewX = null == T.skewX ? d.skewX : re(T.skewX, d.skewX), l.skewY = null == T.skewY ? d.skewY : re(T.skewY, d.skewY), (_ = l.skewY - d.skewY) && (l.skewX += _, l.rotation += _) } for (xe && null != T.force3D && (d.force3D = T.force3D, f = !0), d.skewType = T.skewType || d.skewType || a.defaultSkewType, c = d.force3D || d.z || d.rotationX || d.rotationY || l.z || l.rotationX || l.rotationY || l.perspective, c || null == T.scale || (l.scaleZ = 1); --y > -1;)i = ve[y], p = l[i] - d[i], (p > v || -v > p || null != I[i]) && (f = !0, n = new pe(d, i, d[i], p, n), i in w && (n.e = w[i]), n.xs0 = 0, n.plugin = o, s._overwriteProps.push(n.n)); return p = T.transformOrigin, (p || xe && c && d.zOrigin) && (ye ? (f = !0, i = we, p = (p || W(t, i, r, !1, "50% 50%")) + "", n = new pe(g, i, 0, 0, n, -1, "transformOrigin"), n.b = g[i], n.plugin = o, xe ? (u = d.zOrigin, p = p.split(" "), d.zOrigin = (p.length > 2 && (0 === u || "0px" !== p[2]) ? parseFloat(p[2]) : u) || 0, n.xs0 = n.e = p[0] + " " + (p[1] || "50%") + " 0px", n = new pe(d, "zOrigin", 0, 0, n, -1, n.n), n.b = u, n.xs0 = n.e = d.zOrigin) : n.xs0 = n.e = p) : ee(p + "", d)), f && (s._transformType = c || 3 === this._transformType ? 3 : 2), n }, prefix: !0 }), de("boxShadow", { defaultValue: "0px 0px 0px 0px #999", prefix: !0, color: !0, multi: !0, keyword: "inset" }), de("borderRadius", { defaultValue: "0px", parser: function (t, e, i, n, a) { e = this.format(e); var o, h, l, _, u, p, c, f, m, d, g, v, y, T, w, x, b = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"], P = t.style; for (m = parseFloat(t.offsetWidth), d = parseFloat(t.offsetHeight), o = e.split(" "), h = 0; b.length > h; h++)this.p.indexOf("border") && (b[h] = V(b[h])), u = _ = W(t, b[h], r, !1, "0px"), -1 !== u.indexOf(" ") && (_ = u.split(" "), u = _[0], _ = _[1]), p = l = o[h], c = parseFloat(u), v = u.substr((c + "").length), y = "=" === p.charAt(1), y ? (f = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), f *= parseFloat(p), g = p.substr((f + "").length - (0 > f ? 1 : 0)) || "") : (f = parseFloat(p), g = p.substr((f + "").length)), "" === g && (g = s[i] || v), g !== v && (T = Q(t, "borderLeft", c, v), w = Q(t, "borderTop", c, v), "%" === g ? (u = 100 * (T / m) + "%", _ = 100 * (w / d) + "%") : "em" === g ? (x = Q(t, "borderLeft", 1, "em"), u = T / x + "em", _ = w / x + "em") : (u = T + "px", _ = w + "px"), y && (p = parseFloat(u) + f + g, l = parseFloat(_) + f + g)), a = ce(P, b[h], u + " " + _, p + " " + l, !1, "0px", a); return a }, prefix: !0, formatter: le("0px 0px 0px 0px", !1, !0) }), de("backgroundPosition", { defaultValue: "0 0", parser: function (t, e, i, s, n, a) { var o, h, l, _, u, p, c = "background-position", m = r || G(t, null), d = this.format((m ? f ? m.getPropertyValue(c + "-x") + " " + m.getPropertyValue(c + "-y") : m.getPropertyValue(c) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"), g = this.format(e); if (-1 !== d.indexOf("%") != (-1 !== g.indexOf("%")) && (p = W(t, "backgroundImage").replace(k, ""), p && "none" !== p)) { for (o = d.split(" "), h = g.split(" "), F.setAttribute("src", p), l = 2; --l > -1;)d = o[l], _ = -1 !== d.indexOf("%"), _ !== (-1 !== h[l].indexOf("%")) && (u = 0 === l ? t.offsetWidth - F.width : t.offsetHeight - F.height, o[l] = _ ? parseFloat(d) / 100 * u + "px" : 100 * (parseFloat(d) / u) + "%"); d = o.join(" ") } return this.parseComplex(t.style, d, g, n, a) }, formatter: ee }), de("backgroundSize", { defaultValue: "0 0", formatter: ee }), de("perspective", { defaultValue: "0px", prefix: !0 }), de("perspectiveOrigin", { defaultValue: "50% 50%", prefix: !0 }), de("transformStyle", { prefix: !0 }), de("backfaceVisibility", { prefix: !0 }), de("userSelect", { prefix: !0 }), de("margin", { parser: _e("marginTop,marginRight,marginBottom,marginLeft") }), de("padding", { parser: _e("paddingTop,paddingRight,paddingBottom,paddingLeft") }), de("clip", { defaultValue: "rect(0px,0px,0px,0px)", parser: function (t, e, i, s, n, a) { var o, h, l; return 9 > f ? (h = t.currentStyle, l = 8 > f ? " " : ",", o = "rect(" + h.clipTop + l + h.clipRight + l + h.clipBottom + l + h.clipLeft + ")", e = this.format(e).split(",").join(l)) : (o = this.format(W(t, this.p, r, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, o, e, n, a) } }), de("textShadow", { defaultValue: "0px 0px 0px #999", color: !0, multi: !0 }), de("autoRound,strictUnits", { parser: function (t, e, i, s, r) { return r } }), de("border", { defaultValue: "0px solid #000", parser: function (t, e, i, s, n, a) { return this.parseComplex(t.style, this.format(W(t, "borderTopWidth", r, !1, "0px") + " " + W(t, "borderTopStyle", r, !1, "solid") + " " + W(t, "borderTopColor", r, !1, "#000")), this.format(e), n, a) }, color: !0, formatter: function (t) { var e = t.split(" "); return e[0] + " " + (e[1] || "solid") + " " + (t.match(he) || ["#000"])[0] } }), de("borderWidth", { parser: _e("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth") }), de("float,cssFloat,styleFloat", { parser: function (t, e, i, s, r) { var n = t.style, a = "cssFloat" in n ? "cssFloat" : "styleFloat"; return new pe(n, a, 0, 0, r, -1, i, !1, 0, n[a], e) } }); var Ae = function (t) { var e, i = this.t, s = i.filter || W(this.data, "filter"), r = 0 | this.s + this.c * t; 100 === r && (-1 === s.indexOf("atrix(") && -1 === s.indexOf("radient(") && -1 === s.indexOf("oader(") ? (i.removeAttribute("filter"), e = !W(this.data, "filter")) : (i.filter = s.replace(x, ""), e = !0)), e || (this.xn1 && (i.filter = s = s || "alpha(opacity=" + r + ")"), -1 === s.indexOf("pacity") ? 0 === r && this.xn1 || (i.filter = s + " alpha(opacity=" + r + ")") : i.filter = s.replace(T, "opacity=" + r)) }; de("opacity,alpha,autoAlpha", { defaultValue: "1", parser: function (t, e, i, s, n, a) { var o = parseFloat(W(t, "opacity", r, !1, "1")), h = t.style, l = "autoAlpha" === i; return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + o), l && 1 === o && "hidden" === W(t, "visibility", r) && 0 !== e && (o = 0), U ? n = new pe(h, "opacity", o, e - o, n) : (n = new pe(h, "opacity", 100 * o, 100 * (e - o), n), n.xn1 = l ? 1 : 0, h.zoom = 1, n.type = 2, n.b = "alpha(opacity=" + n.s + ")", n.e = "alpha(opacity=" + (n.s + n.c) + ")", n.data = t, n.plugin = a, n.setRatio = Ae), l && (n = new pe(h, "visibility", 0, 0, n, -1, null, !1, 0, 0 !== o ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit"), n.xs0 = "inherit", s._overwriteProps.push(n.n), s._overwriteProps.push(i)), n } }); var Ce = function (t, e) { e && (t.removeProperty ? ("ms" === e.substr(0, 2) && (e = "M" + e.substr(1)), t.removeProperty(e.replace(P, "-$1").toLowerCase())) : t.removeAttribute(e)) }, Oe = function (t) { if (this.t._gsClassPT = this, 1 === t || 0 === t) { this.t.setAttribute("class", 0 === t ? this.b : this.e); for (var e = this.data, i = this.t.style; e;)e.v ? i[e.p] = e.v : Ce(i, e.p), e = e._next; 1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null) } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e) }; de("className", { parser: function (t, e, s, n, a, o, h) { var l, _, u, p, c, f = t.getAttribute("class") || "", m = t.style.cssText; if (a = n._classNamePT = new pe(t, s, 0, 0, a, 2), a.setRatio = Oe, a.pr = -11, i = !0, a.b = f, _ = $(t, r), u = t._gsClassPT) { for (p = {}, c = u.data; c;)p[c.p] = 1, c = c._next; u.setRatio(1) } return t._gsClassPT = a, a.e = "=" !== e.charAt(1) ? e : f.replace(RegExp("\\s*\\b" + e.substr(2) + "\\b"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), n._tween._duration && (t.setAttribute("class", a.e), l = H(t, _, $(t), h, p), t.setAttribute("class", f), a.data = l.firstMPT, t.style.cssText = m, a = a.xfirst = n.parse(t, l.difs, a, o)), a } }); var De = function (t) { if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) { var e, i, s, r, n = this.t.style, a = o.transform.parse; if ("all" === this.e) n.cssText = "", r = !0; else for (e = this.e.split(","), s = e.length; --s > -1;)i = e[s], o[i] && (o[i].parse === a ? r = !0 : i = "transformOrigin" === i ? we : o[i].p), Ce(n, i); r && (Ce(n, ye), this.t._gsTransform && delete this.t._gsTransform) } }; for (de("clearProps", { parser: function (t, e, s, r, n) { return n = new pe(t, s, 0, 0, n, 2), n.setRatio = De, n.e = e, n.pr = -10, n.data = r._tween, i = !0, n } }), h = "bezier,throwProps,physicsProps,physics2D".split(","), fe = h.length; fe--;)ge(h[fe]); h = a.prototype, h._firstPT = null, h._onInitTween = function (t, e, o) { if (!t.nodeType) return !1; this._target = t, this._tween = o, this._vars = e, l = e.autoRound, i = !1, s = e.suffixMap || a.suffixMap, r = G(t, ""), n = this._overwriteProps; var h, p, f, m, d, g, v, y, T, x = t.style; if (_ && "" === x.zIndex && (h = W(t, "zIndex", r), ("auto" === h || "" === h) && this._addLazySet(x, "zIndex", 0)), "string" == typeof e && (m = x.cssText, h = $(t, r), x.cssText = m + ";" + e, h = H(t, h, $(t)).difs, !U && w.test(e) && (h.opacity = parseFloat(RegExp.$1)), e = h, x.cssText = m), this._firstPT = p = this.parse(t, e, null), this._transformType) { for (T = 3 === this._transformType, ye ? u && (_ = !0, "" === x.zIndex && (v = W(t, "zIndex", r), ("auto" === v || "" === v) && this._addLazySet(x, "zIndex", 0)), c && this._addLazySet(x, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (T ? "visible" : "hidden"))) : x.zoom = 1, f = p; f && f._next;)f = f._next; y = new pe(t, "transform", 0, 0, null, 2), this._linkCSSP(y, null, f), y.setRatio = T && xe ? ke : ye ? Re : Se, y.data = this._transform || Pe(t, r, !0), n.pop() } if (i) { for (; p;) { for (g = p._next, f = m; f && f.pr > p.pr;)f = f._next; (p._prev = f ? f._prev : d) ? p._prev._next = p : m = p, (p._next = f) ? f._prev = p : d = p, p = g } this._firstPT = m } return !0 }, h.parse = function (t, e, i, n) {
            var a, h, _, u, p, c, f, m, d, g, v = t.style; for (a in e) c = e[a], h = o[a], h ? i = h.parse(t, c, a, this, i, n, e) : (p = W(t, a, r) + "", d = "string" == typeof c, "color" === a || "fill" === a || "stroke" === a || -1 !== a.indexOf("Color") || d && b.test(c) ? (d || (c = oe(c), c = (c.length > 3 ? "rgba(" : "rgb(") + c.join(",") + ")"), i = ce(v, a, p, c, !0, "transparent", i, 0, n)) : !d || -1 === c.indexOf(" ") && -1 === c.indexOf(",") ? (_ = parseFloat(p), f = _ || 0 === _ ? p.substr((_ + "").length) : "", ("" === p || "auto" === p) && ("width" === a || "height" === a ? (_ = te(t, a, r), f = "px") : "left" === a || "top" === a ? (_ = Z(t, a, r), f = "px") : (_ = "opacity" !== a ? 0 : 1, f = "")), g = d && "=" === c.charAt(1), g ? (u = parseInt(c.charAt(0) + "1", 10), c = c.substr(2), u *= parseFloat(c), m = c.replace(y, "")) : (u = parseFloat(c), m = d ? c.substr((u + "").length) || "" : ""), "" === m && (m = a in s ? s[a] : f), c = u || 0 === u ? (g ? u + _ : u) + m : e[a], f !== m && "" !== m && (u || 0 === u) && _ && (_ = Q(t, a, _, f), "%" === m ? (_ /= Q(t, a, 100, "%") / 100, e.strictUnits !== !0 && (p = _ + "%")) : "em" === m ? _ /= Q(t, a, 1, "em") : "px" !== m && (u = Q(t, a, u, m), m = "px"), g && (u || 0 === u) && (c = u + _ + m)), g && (u += _), !_ && 0 !== _ || !u && 0 !== u ? void 0 !== v[a] && (c || "NaN" != c + "" && null != c) ? (i = new pe(v, a, u || _ || 0, 0, i, -1, a, !1, 0, p, c), i.xs0 = "none" !== c || "display" !== a && -1 === a.indexOf("Style") ? c : p) : j("invalid " + a + " tween value: " + e[a]) : (i = new pe(v, a, _, u - _, i, 0, a, l !== !1 && ("px" === m || "zIndex" === a), 0, p, c), i.xs0 = m)) : i = ce(v, a, p, c, !0, null, i, 0, n)), n && i && !i.plugin && (i.plugin = n);
            return i
        }, h.setRatio = function (t) { var e, i, s, r = this._firstPT, n = 1e-6; if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time) if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6) for (; r;) { if (e = r.c * t + r.s, r.r ? e = Math.round(e) : n > e && e > -n && (e = 0), r.type) if (1 === r.type) if (s = r.l, 2 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2; else if (3 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3; else if (4 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4; else if (5 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5; else { for (i = r.xs0 + e + r.xs1, s = 1; r.l > s; s++)i += r["xn" + s] + r["xs" + (s + 1)]; r.t[r.p] = i } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t); else r.t[r.p] = e + r.xs0; r = r._next } else for (; r;)2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t), r = r._next; else for (; r;)2 !== r.type ? r.t[r.p] = r.e : r.setRatio(t), r = r._next }, h._enableTransforms = function (t) { this._transformType = t || 3 === this._transformType ? 3 : 2, this._transform = this._transform || Pe(this._target, r, !0) }; var Me = function () { this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0) }; h._addLazySet = function (t, e, i) { var s = this._firstPT = new pe(t, e, 0, 0, this._firstPT, 2); s.e = i, s.setRatio = Me, s.data = this }, h._linkCSSP = function (t, e, i, s) { return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, s = !0), i ? i._next = t : s || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t }, h._kill = function (e) { var i, s, r, n = e; if (e.autoAlpha || e.alpha) { n = {}; for (s in e) n[s] = e[s]; n.opacity = 1, n.autoAlpha && (n.visibility = 1) } return e.className && (i = this._classNamePT) && (r = i.xfirst, r && r._prev ? this._linkCSSP(r._prev, i._next, r._prev._prev) : r === this._firstPT && (this._firstPT = i._next), i._next && this._linkCSSP(i._next, i._next._next, r._prev), this._classNamePT = null), t.prototype._kill.call(this, n) }; var ze = function (t, e, i) { var s, r, n, a; if (t.slice) for (r = t.length; --r > -1;)ze(t[r], e, i); else for (s = t.childNodes, r = s.length; --r > -1;)n = s[r], a = n.type, n.style && (e.push($(n)), i && i.push(n)), 1 !== a && 9 !== a && 11 !== a || !n.childNodes.length || ze(n, e, i) }; return a.cascadeTo = function (t, i, s) { var r, n, a, o = e.to(t, i, s), h = [o], l = [], _ = [], u = [], p = e._internals.reservedProps; for (t = o._targets || o.target, ze(t, l, u), o.render(i, !0), ze(t, _), o.render(0, !0), o._enabled(!0), r = u.length; --r > -1;)if (n = H(u[r], l[r], _[r]), n.firstMPT) { n = n.difs; for (a in s) p[a] && (n[a] = s[a]); h.push(e.to(u[r], i, n)) } return h }, t.activate([a]), a
    }, !0), function () { var t = _gsScope._gsDefine.plugin({ propName: "roundProps", priority: -1, API: 2, init: function (t, e, i) { return this._tween = i, !0 } }), e = t.prototype; e._onInitAllProps = function () { for (var t, e, i, s = this._tween, r = s.vars.roundProps instanceof Array ? s.vars.roundProps : s.vars.roundProps.split(","), n = r.length, a = {}, o = s._propLookup.roundProps; --n > -1;)a[r[n]] = 1; for (n = r.length; --n > -1;)for (t = r[n], e = s._firstPT; e;)i = e._next, e.pg ? e.t._roundProps(a, !0) : e.n === t && (this._add(e.t, t, e.s, e.c), i && (i._prev = e._prev), e._prev ? e._prev._next = i : s._firstPT === e && (s._firstPT = i), e._next = e._prev = null, s._propLookup[t] = o), e = i; return !1 }, e._add = function (t, e, i, s) { this._addTween(t, e, i, i + s, e, !0), this._overwriteProps.push(e) } }(), _gsScope._gsDefine.plugin({ propName: "attr", API: 2, version: "0.3.3", init: function (t, e) { var i, s, r; if ("function" != typeof t.setAttribute) return !1; this._target = t, this._proxy = {}, this._start = {}, this._end = {}; for (i in e) this._start[i] = this._proxy[i] = s = t.getAttribute(i), r = this._addTween(this._proxy, i, parseFloat(s), e[i], i), this._end[i] = r ? r.s + r.c : e[i], this._overwriteProps.push(i); return !0 }, set: function (t) { this._super.setRatio.call(this, t); for (var e, i = this._overwriteProps, s = i.length, r = 1 === t ? this._end : t ? this._proxy : this._start; --s > -1;)e = i[s], this._target.setAttribute(e, r[e] + "") } }), _gsScope._gsDefine.plugin({ propName: "directionalRotation", version: "0.2.1", API: 2, init: function (t, e) { "object" != typeof e && (e = { rotation: e }), this.finals = {}; var i, s, r, n, a, o, h = e.useRadians === !0 ? 2 * Math.PI : 360, l = 1e-6; for (i in e) "useRadians" !== i && (o = (e[i] + "").split("_"), s = o[0], r = parseFloat("function" != typeof t[i] ? t[i] : t[i.indexOf("set") || "function" != typeof t["get" + i.substr(3)] ? i : "get" + i.substr(3)]()), n = this.finals[i] = "string" == typeof s && "=" === s.charAt(1) ? r + parseInt(s.charAt(0) + "1", 10) * Number(s.substr(2)) : Number(s) || 0, a = n - r, o.length && (s = o.join("_"), -1 !== s.indexOf("short") && (a %= h, a !== a % (h / 2) && (a = 0 > a ? a + h : a - h)), -1 !== s.indexOf("_cw") && 0 > a ? a = (a + 9999999999 * h) % h - (0 | a / h) * h : -1 !== s.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * h) % h - (0 | a / h) * h)), (a > l || -l > a) && (this._addTween(t, i, r, r + a, i), this._overwriteProps.push(i))); return !0 }, set: function (t) { var e; if (1 !== t) this._super.setRatio.call(this, t); else for (e = this._firstPT; e;)e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next } })._autoCSS = !0, _gsScope._gsDefine("easing.Back", ["easing.Ease"], function (t) { var e, i, s, r = _gsScope.GreenSockGlobals || _gsScope, n = r.com.greensock, a = 2 * Math.PI, o = Math.PI / 2, h = n._class, l = function (e, i) { var s = h("easing." + e, function () { }, !0), r = s.prototype = new t; return r.constructor = s, r.getRatio = i, s }, _ = t.register || function () { }, u = function (t, e, i, s) { var r = h("easing." + t, { easeOut: new e, easeIn: new i, easeInOut: new s }, !0); return _(r, t), r }, p = function (t, e, i) { this.t = t, this.v = e, i && (this.next = i, i.prev = this, this.c = i.v - e, this.gap = i.t - t) }, c = function (e, i) { var s = h("easing." + e, function (t) { this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1 }, !0), r = s.prototype = new t; return r.constructor = s, r.getRatio = i, r.config = function (t) { return new s(t) }, s }, f = u("Back", c("BackOut", function (t) { return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1 }), c("BackIn", function (t) { return t * t * ((this._p1 + 1) * t - this._p1) }), c("BackInOut", function (t) { return 1 > (t *= 2) ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2) })), m = h("easing.SlowMo", function (t, e, i) { e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = i === !0 }, !0), d = m.prototype = new t; return d.constructor = m, d.getRatio = function (t) { var e = t + (.5 - t) * this._p; return this._p1 > t ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e }, m.ease = new m(.7, .7), d.config = m.config = function (t, e, i) { return new m(t, e, i) }, e = h("easing.SteppedEase", function (t) { t = t || 1, this._p1 = 1 / t, this._p2 = t + 1 }, !0), d = e.prototype = new t, d.constructor = e, d.getRatio = function (t) { return 0 > t ? t = 0 : t >= 1 && (t = .999999999), (this._p2 * t >> 0) * this._p1 }, d.config = e.config = function (t) { return new e(t) }, i = h("easing.RoughEase", function (e) { e = e || {}; for (var i, s, r, n, a, o, h = e.taper || "none", l = [], _ = 0, u = 0 | (e.points || 20), c = u, f = e.randomize !== !1, m = e.clamp === !0, d = e.template instanceof t ? e.template : null, g = "number" == typeof e.strength ? .4 * e.strength : .4; --c > -1;)i = f ? Math.random() : 1 / u * c, s = d ? d.getRatio(i) : i, "none" === h ? r = g : "out" === h ? (n = 1 - i, r = n * n * g) : "in" === h ? r = i * i * g : .5 > i ? (n = 2 * i, r = .5 * n * n * g) : (n = 2 * (1 - i), r = .5 * n * n * g), f ? s += Math.random() * r - .5 * r : c % 2 ? s += .5 * r : s -= .5 * r, m && (s > 1 ? s = 1 : 0 > s && (s = 0)), l[_++] = { x: i, y: s }; for (l.sort(function (t, e) { return t.x - e.x }), o = new p(1, 1, null), c = u; --c > -1;)a = l[c], o = new p(a.x, a.y, o); this._prev = new p(0, 0, 0 !== o.t ? o : o.next) }, !0), d = i.prototype = new t, d.constructor = i, d.getRatio = function (t) { var e = this._prev; if (t > e.t) { for (; e.next && t >= e.t;)e = e.next; e = e.prev } else for (; e.prev && e.t >= t;)e = e.prev; return this._prev = e, e.v + (t - e.t) / e.gap * e.c }, d.config = function (t) { return new i(t) }, i.ease = new i, u("Bounce", l("BounceOut", function (t) { return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375 }), l("BounceIn", function (t) { return 1 / 2.75 > (t = 1 - t) ? 1 - 7.5625 * t * t : 2 / 2.75 > t ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : 2.5 / 2.75 > t ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375) }), l("BounceInOut", function (t) { var e = .5 > t; return t = e ? 1 - 2 * t : 2 * t - 1, t = 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5 })), u("Circ", l("CircOut", function (t) { return Math.sqrt(1 - (t -= 1) * t) }), l("CircIn", function (t) { return -(Math.sqrt(1 - t * t) - 1) }), l("CircInOut", function (t) { return 1 > (t *= 2) ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1) })), s = function (e, i, s) { var r = h("easing." + e, function (t, e) { this._p1 = t || 1, this._p2 = e || s, this._p3 = this._p2 / a * (Math.asin(1 / this._p1) || 0) }, !0), n = r.prototype = new t; return n.constructor = r, n.getRatio = i, n.config = function (t, e) { return new r(t, e) }, r }, u("Elastic", s("ElasticOut", function (t) { return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * a / this._p2) + 1 }, .3), s("ElasticIn", function (t) { return -(this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * a / this._p2)) }, .3), s("ElasticInOut", function (t) { return 1 > (t *= 2) ? -.5 * this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * a / this._p2) : .5 * this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * a / this._p2) + 1 }, .45)), u("Expo", l("ExpoOut", function (t) { return 1 - Math.pow(2, -10 * t) }), l("ExpoIn", function (t) { return Math.pow(2, 10 * (t - 1)) - .001 }), l("ExpoInOut", function (t) { return 1 > (t *= 2) ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1))) })), u("Sine", l("SineOut", function (t) { return Math.sin(t * o) }), l("SineIn", function (t) { return -Math.cos(t * o) + 1 }), l("SineInOut", function (t) { return -.5 * (Math.cos(Math.PI * t) - 1) })), h("easing.EaseLookup", { find: function (e) { return t.map[e] } }, !0), _(r.SlowMo, "SlowMo", "ease,"), _(i, "RoughEase", "ease,"), _(e, "SteppedEase", "ease,"), f }, !0)
}), _gsScope._gsDefine && _gsScope._gsQueue.pop()(), function (t, e) {
    "use strict"; var i = t.GreenSockGlobals = t.GreenSockGlobals || t; if (!i.TweenLite) {
        var s, r, n, a, o, h = function (t) { var e, s = t.split("."), r = i; for (e = 0; s.length > e; e++)r[s[e]] = r = r[s[e]] || {}; return r }, l = h("com.greensock"), _ = 1e-10, u = function (t) { var e, i = [], s = t.length; for (e = 0; e !== s; i.push(t[e++])); return i }, p = function () { }, c = function () { var t = Object.prototype.toString, e = t.call([]); return function (i) { return null != i && (i instanceof Array || "object" == typeof i && !!i.push && t.call(i) === e) } }(), f = {}, m = function (s, r, n, a) { this.sc = f[s] ? f[s].sc : [], f[s] = this, this.gsClass = null, this.func = n; var o = []; this.check = function (l) { for (var _, u, p, c, d = r.length, g = d; --d > -1;)(_ = f[r[d]] || new m(r[d], [])).gsClass ? (o[d] = _.gsClass, g--) : l && _.sc.push(this); if (0 === g && n) for (u = ("com.greensock." + s).split("."), p = u.pop(), c = h(u.join("."))[p] = this.gsClass = n.apply(n, o), a && (i[p] = c, "function" == typeof define && define.amd ? define((t.GreenSockAMDPath ? t.GreenSockAMDPath + "/" : "") + s.split(".").pop(), [], function () { return c }) : s === e && "undefined" != typeof module && module.exports && (module.exports = c)), d = 0; this.sc.length > d; d++)this.sc[d].check() }, this.check(!0) }, d = t._gsDefine = function (t, e, i, s) { return new m(t, e, i, s) }, g = l._class = function (t, e, i) { return e = e || function () { }, d(t, [], function () { return e }, i), e }; d.globals = i; var v = [0, 0, 1, 1], y = [], T = g("easing.Ease", function (t, e, i, s) { this._func = t, this._type = i || 0, this._power = s || 0, this._params = e ? v.concat(e) : v }, !0), w = T.map = {}, x = T.register = function (t, e, i, s) { for (var r, n, a, o, h = e.split(","), _ = h.length, u = (i || "easeIn,easeOut,easeInOut").split(","); --_ > -1;)for (n = h[_], r = s ? g("easing." + n, null, !0) : l.easing[n] || {}, a = u.length; --a > -1;)o = u[a], w[n + "." + o] = w[o + n] = r[o] = t.getRatio ? t : t[o] || new t }; for (n = T.prototype, n._calcEnd = !1, n.getRatio = function (t) { if (this._func) return this._params[0] = t, this._func.apply(null, this._params); var e = this._type, i = this._power, s = 1 === e ? 1 - t : 2 === e ? t : .5 > t ? 2 * t : 2 * (1 - t); return 1 === i ? s *= s : 2 === i ? s *= s * s : 3 === i ? s *= s * s * s : 4 === i && (s *= s * s * s * s), 1 === e ? 1 - s : 2 === e ? s : .5 > t ? s / 2 : 1 - s / 2 }, s = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], r = s.length; --r > -1;)n = s[r] + ",Power" + r, x(new T(null, null, 1, r), n, "easeOut", !0), x(new T(null, null, 2, r), n, "easeIn" + (0 === r ? ",easeNone" : "")), x(new T(null, null, 3, r), n, "easeInOut"); w.linear = l.easing.Linear.easeIn, w.swing = l.easing.Quad.easeInOut; var b = g("events.EventDispatcher", function (t) { this._listeners = {}, this._eventTarget = t || this }); n = b.prototype, n.addEventListener = function (t, e, i, s, r) { r = r || 0; var n, h, l = this._listeners[t], _ = 0; for (null == l && (this._listeners[t] = l = []), h = l.length; --h > -1;)n = l[h], n.c === e && n.s === i ? l.splice(h, 1) : 0 === _ && r > n.pr && (_ = h + 1); l.splice(_, 0, { c: e, s: i, up: s, pr: r }), this !== a || o || a.wake() }, n.removeEventListener = function (t, e) { var i, s = this._listeners[t]; if (s) for (i = s.length; --i > -1;)if (s[i].c === e) return s.splice(i, 1), void 0 }, n.dispatchEvent = function (t) { var e, i, s, r = this._listeners[t]; if (r) for (e = r.length, i = this._eventTarget; --e > -1;)s = r[e], s.up ? s.c.call(s.s || i, { type: t, target: i }) : s.c.call(s.s || i) }; var P = t.requestAnimationFrame, S = t.cancelAnimationFrame, k = Date.now || function () { return (new Date).getTime() }, R = k(); for (s = ["ms", "moz", "webkit", "o"], r = s.length; --r > -1 && !P;)P = t[s[r] + "RequestAnimationFrame"], S = t[s[r] + "CancelAnimationFrame"] || t[s[r] + "CancelRequestAnimationFrame"]; g("Ticker", function (t, e) { var i, s, r, n, h, l = this, u = k(), c = e !== !1 && P, f = 500, m = 33, d = function (t) { var e, a, o = k() - R; o > f && (u += o - m), R += o, l.time = (R - u) / 1e3, e = l.time - h, (!i || e > 0 || t === !0) && (l.frame++ , h += e + (e >= n ? .004 : n - e), a = !0), t !== !0 && (r = s(d)), a && l.dispatchEvent("tick") }; b.call(l), l.time = l.frame = 0, l.tick = function () { d(!0) }, l.lagSmoothing = function (t, e) { f = t || 1 / _, m = Math.min(e, f, 0) }, l.sleep = function () { null != r && (c && S ? S(r) : clearTimeout(r), s = p, r = null, l === a && (o = !1)) }, l.wake = function () { null !== r ? l.sleep() : l.frame > 10 && (R = k() - f + 5), s = 0 === i ? p : c && P ? P : function (t) { return setTimeout(t, 0 | 1e3 * (h - l.time) + 1) }, l === a && (o = !0), d(2) }, l.fps = function (t) { return arguments.length ? (i = t, n = 1 / (i || 60), h = this.time + n, l.wake(), void 0) : i }, l.useRAF = function (t) { return arguments.length ? (l.sleep(), c = t, l.fps(i), void 0) : c }, l.fps(t), setTimeout(function () { c && (!r || 5 > l.frame) && l.useRAF(!1) }, 1500) }), n = l.Ticker.prototype = new l.events.EventDispatcher, n.constructor = l.Ticker; var A = g("core.Animation", function (t, e) { if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = e.immediateRender === !0, this.data = e.data, this._reversed = e.reversed === !0, B) { o || a.wake(); var i = this.vars.useFrames ? j : B; i.add(this, i._time), this.vars.paused && this.paused(!0) } }); a = A.ticker = new l.Ticker, n = A.prototype, n._dirty = n._gc = n._initted = n._paused = !1, n._totalTime = n._time = 0, n._rawPrevTime = -1, n._next = n._last = n._onUpdate = n._timeline = n.timeline = null, n._paused = !1; var C = function () { o && k() - R > 2e3 && a.wake(), setTimeout(C, 2e3) }; C(), n.play = function (t, e) { return null != t && this.seek(t, e), this.reversed(!1).paused(!1) }, n.pause = function (t, e) { return null != t && this.seek(t, e), this.paused(!0) }, n.resume = function (t, e) { return null != t && this.seek(t, e), this.paused(!1) }, n.seek = function (t, e) { return this.totalTime(Number(t), e !== !1) }, n.restart = function (t, e) { return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, e !== !1, !0) }, n.reverse = function (t, e) { return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1) }, n.render = function () { }, n.invalidate = function () { return this }, n.isActive = function () { var t, e = this._timeline, i = this._startTime; return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime()) >= i && i + this.totalDuration() / this._timeScale > t }, n._enabled = function (t, e) { return o || a.wake(), this._gc = !t, this._active = this.isActive(), e !== !0 && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1 }, n._kill = function () { return this._enabled(!1, !1) }, n.kill = function (t, e) { return this._kill(t, e), this }, n._uncache = function (t) { for (var e = t ? this : this.timeline; e;)e._dirty = !0, e = e.timeline; return this }, n._swapSelfInParams = function (t) { for (var e = t.length, i = t.concat(); --e > -1;)"{self}" === t[e] && (i[e] = this); return i }, n.eventCallback = function (t, e, i, s) { if ("on" === (t || "").substr(0, 2)) { var r = this.vars; if (1 === arguments.length) return r[t]; null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = c(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[t + "Scope"] = s), "onUpdate" === t && (this._onUpdate = e) } return this }, n.delay = function (t) { return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay }, n.duration = function (t) { return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration) }, n.totalDuration = function (t) { return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration }, n.time = function (t, e) { return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time }, n.totalTime = function (t, e, i) { if (o || a.wake(), !arguments.length) return this._totalTime; if (this._timeline) { if (0 > t && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) { this._dirty && this.totalDuration(); var s = this._totalDuration, r = this._timeline; if (t > s && !i && (t = s), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? s - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline) for (; r._timeline;)r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline } this._gc && this._enabled(!0, !1), (this._totalTime !== t || 0 === this._duration) && (this.render(t, e, !1), I.length && q()) } return this }, n.progress = n.totalProgress = function (t, e) { return arguments.length ? this.totalTime(this.duration() * t, e) : this._time / this.duration() }, n.startTime = function (t) { return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime }, n.timeScale = function (t) { if (!arguments.length) return this._timeScale; if (t = t || _, this._timeline && this._timeline.smoothChildTiming) { var e = this._pauseTime, i = e || 0 === e ? e : this._timeline.totalTime(); this._startTime = i - (i - this._startTime) * this._timeScale / t } return this._timeScale = t, this._uncache(!1) }, n.reversed = function (t) { return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed }, n.paused = function (t) { if (!arguments.length) return this._paused; if (t != this._paused && this._timeline) { o || t || a.wake(); var e = this._timeline, i = e.rawTime(), s = i - this._pauseTime; !t && e.smoothChildTiming && (this._startTime += s, this._uncache(!1)), this._pauseTime = t ? i : null, this._paused = t, this._active = this.isActive(), !t && 0 !== s && this._initted && this.duration() && this.render(e.smoothChildTiming ? this._totalTime : (i - this._startTime) / this._timeScale, !0, !0) } return this._gc && !t && this._enabled(!0, !1), this }; var O = g("core.SimpleTimeline", function (t) { A.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0 }); n = O.prototype = new A, n.constructor = O, n.kill()._gc = !1, n._first = n._last = null, n._sortChildren = !1, n.add = n.insert = function (t, e) { var i, s; if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = t._startTime + (this.rawTime() - t._startTime) / t._timeScale), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), i = this._last, this._sortChildren) for (s = t._startTime; i && i._startTime > s;)i = i._prev; return i ? (t._next = i._next, i._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = i, this._timeline && this._uncache(!0), this }, n._remove = function (t, e) { return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, this._timeline && this._uncache(!0)), this }, n.render = function (t, e, i) { var s, r = this._first; for (this._totalTime = this._time = this._rawPrevTime = t; r;)s = r._next, (r._active || t >= r._startTime && !r._paused) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = s }, n.rawTime = function () { return o || a.wake(), this._totalTime }; var D = g("TweenLite", function (e, i, s) { if (A.call(this, i, s), this.render = D.prototype.render, null == e) throw "Cannot tween a null target."; this.target = e = "string" != typeof e ? e : D.selector(e) || e; var r, n, a, o = e.jquery || e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType), h = this.vars.overwrite; if (this._overwrite = h = null == h ? Y[D.defaultOverwrite] : "number" == typeof h ? h >> 0 : Y[h], (o || e instanceof Array || e.push && c(e)) && "number" != typeof e[0]) for (this._targets = a = u(e), this._propLookup = [], this._siblings = [], r = 0; a.length > r; r++)n = a[r], n ? "string" != typeof n ? n.length && n !== t && n[0] && (n[0] === t || n[0].nodeType && n[0].style && !n.nodeType) ? (a.splice(r--, 1), this._targets = a = a.concat(u(n))) : (this._siblings[r] = V(n, this, !1), 1 === h && this._siblings[r].length > 1 && G(n, this, null, 1, this._siblings[r])) : (n = a[r--] = D.selector(n), "string" == typeof n && a.splice(r + 1, 1)) : a.splice(r--, 1); else this._propLookup = {}, this._siblings = V(e, this, !1), 1 === h && this._siblings.length > 1 && G(e, this, null, 1, this._siblings); (this.vars.immediateRender || 0 === i && 0 === this._delay && this.vars.immediateRender !== !1) && (this._time = -_, this.render(-this._delay)) }, !0), M = function (e) { return e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType) }, z = function (t, e) { var i, s = {}; for (i in t) U[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!F[i] || F[i] && F[i]._autoCSS) || (s[i] = t[i], delete t[i]); t.css = s }; n = D.prototype = new A, n.constructor = D, n.kill()._gc = !1, n.ratio = 0, n._firstPT = n._targets = n._overwrittenProps = n._startAt = null, n._notifyPluginsOfEnabled = n._lazy = !1, D.version = "1.13.1", D.defaultEase = n._ease = new T(null, null, 1, 1), D.defaultOverwrite = "auto", D.ticker = a, D.autoSleep = !0, D.lagSmoothing = function (t, e) { a.lagSmoothing(t, e) }, D.selector = t.$ || t.jQuery || function (e) { var i = t.$ || t.jQuery; return i ? (D.selector = i, i(e)) : "undefined" == typeof document ? e : document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById("#" === e.charAt(0) ? e.substr(1) : e) }; var I = [], E = {}, L = D._internals = { isArray: c, isSelector: M, lazyTweens: I }, F = D._plugins = {}, N = L.tweenLookup = {}, X = 0, U = L.reservedProps = { ease: 1, delay: 1, overwrite: 1, onComplete: 1, onCompleteParams: 1, onCompleteScope: 1, useFrames: 1, runBackwards: 1, startAt: 1, onUpdate: 1, onUpdateParams: 1, onUpdateScope: 1, onStart: 1, onStartParams: 1, onStartScope: 1, onReverseComplete: 1, onReverseCompleteParams: 1, onReverseCompleteScope: 1, onRepeat: 1, onRepeatParams: 1, onRepeatScope: 1, easeParams: 1, yoyo: 1, immediateRender: 1, repeat: 1, repeatDelay: 1, data: 1, paused: 1, reversed: 1, autoCSS: 1, lazy: 1 }, Y = { none: 0, all: 1, auto: 2, concurrent: 3, allOnStart: 4, preexisting: 5, "true": 1, "false": 0 }, j = A._rootFramesTimeline = new O, B = A._rootTimeline = new O, q = L.lazyRender = function () { var t = I.length; for (E = {}; --t > -1;)s = I[t], s && s._lazy !== !1 && (s.render(s._lazy, !1, !0), s._lazy = !1); I.length = 0 }; B._startTime = a.time, j._startTime = a.frame, B._active = j._active = !0, setTimeout(q, 1), A._updateRoot = D.render = function () { var t, e, i; if (I.length && q(), B.render((a.time - B._startTime) * B._timeScale, !1, !1), j.render((a.frame - j._startTime) * j._timeScale, !1, !1), I.length && q(), !(a.frame % 120)) { for (i in N) { for (e = N[i].tweens, t = e.length; --t > -1;)e[t]._gc && e.splice(t, 1); 0 === e.length && delete N[i] } if (i = B._first, (!i || i._paused) && D.autoSleep && !j._first && 1 === a._listeners.tick.length) { for (; i && i._paused;)i = i._next; i || a.sleep() } } }, a.addEventListener("tick", A._updateRoot); var V = function (t, e, i) { var s, r, n = t._gsTweenID; if (N[n || (t._gsTweenID = n = "t" + X++)] || (N[n] = { target: t, tweens: [] }), e && (s = N[n].tweens, s[r = s.length] = e, i)) for (; --r > -1;)s[r] === e && s.splice(r, 1); return N[n].tweens }, G = function (t, e, i, s, r) { var n, a, o, h; if (1 === s || s >= 4) { for (h = r.length, n = 0; h > n; n++)if ((o = r[n]) !== e) o._gc || o._enabled(!1, !1) && (a = !0); else if (5 === s) break; return a } var l, u = e._startTime + _, p = [], c = 0, f = 0 === e._duration; for (n = r.length; --n > -1;)(o = r[n]) === e || o._gc || o._paused || (o._timeline !== e._timeline ? (l = l || W(e, 0, f), 0 === W(o, l, f) && (p[c++] = o)) : u >= o._startTime && o._startTime + o.totalDuration() / o._timeScale > u && ((f || !o._initted) && 2e-10 >= u - o._startTime || (p[c++] = o))); for (n = c; --n > -1;)o = p[n], 2 === s && o._kill(i, t) && (a = !0), (2 !== s || !o._firstPT && o._initted) && o._enabled(!1, !1) && (a = !0); return a }, W = function (t, e, i) { for (var s = t._timeline, r = s._timeScale, n = t._startTime; s._timeline;) { if (n += s._startTime, r *= s._timeScale, s._paused) return -100; s = s._timeline } return n /= r, n > e ? n - e : i && n === e || !t._initted && 2 * _ > n - e ? _ : (n += t.totalDuration() / t._timeScale / r) > e + _ ? 0 : n - e - _ }; n._init = function () { var t, e, i, s, r, n = this.vars, a = this._overwrittenProps, o = this._duration, h = !!n.immediateRender, l = n.ease; if (n.startAt) { this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), r = {}; for (s in n.startAt) r[s] = n.startAt[s]; if (r.overwrite = !1, r.immediateRender = !0, r.lazy = h && n.lazy !== !1, r.startAt = r.delay = null, this._startAt = D.to(this.target, 0, r), h) if (this._time > 0) this._startAt = null; else if (0 !== o) return } else if (n.runBackwards && 0 !== o) if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null; else { i = {}; for (s in n) U[s] && "autoCSS" !== s || (i[s] = n[s]); if (i.overwrite = 0, i.data = "isFromStart", i.lazy = h && n.lazy !== !1, i.immediateRender = h, this._startAt = D.to(this.target, 0, i), h) { if (0 === this._time) return } else this._startAt._init(), this._startAt._enabled(!1) } if (this._ease = l = l ? l instanceof T ? l : "function" == typeof l ? new T(l, n.easeParams) : w[l] || D.defaultEase : D.defaultEase, n.easeParams instanceof Array && l.config && (this._ease = l.config.apply(l, n.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets) for (t = this._targets.length; --t > -1;)this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], a ? a[t] : null) && (e = !0); else e = this._initProps(this.target, this._propLookup, this._siblings, a); if (e && D._onPluginEvent("_onInitAllProps", this), a && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), n.runBackwards) for (i = this._firstPT; i;)i.s += i.c, i.c = -i.c, i = i._next; this._onUpdate = n.onUpdate, this._initted = !0 }, n._initProps = function (e, i, s, r) { var n, a, o, h, l, _; if (null == e) return !1; E[e._gsTweenID] && q(), this.vars.css || e.style && e !== t && e.nodeType && F.css && this.vars.autoCSS !== !1 && z(this.vars, e); for (n in this.vars) { if (_ = this.vars[n], U[n]) _ && (_ instanceof Array || _.push && c(_)) && -1 !== _.join("").indexOf("{self}") && (this.vars[n] = _ = this._swapSelfInParams(_, this)); else if (F[n] && (h = new F[n])._onInitTween(e, this.vars[n], this)) { for (this._firstPT = l = { _next: this._firstPT, t: h, p: "setRatio", s: 0, c: 1, f: !0, n: n, pg: !0, pr: h._priority }, a = h._overwriteProps.length; --a > -1;)i[h._overwriteProps[a]] = this._firstPT; (h._priority || h._onInitAllProps) && (o = !0), (h._onDisable || h._onEnable) && (this._notifyPluginsOfEnabled = !0) } else this._firstPT = i[n] = l = { _next: this._firstPT, t: e, p: n, f: "function" == typeof e[n], n: n, pg: !1, pr: 0 }, l.s = l.f ? e[n.indexOf("set") || "function" != typeof e["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(e[n]), l.c = "string" == typeof _ && "=" === _.charAt(1) ? parseInt(_.charAt(0) + "1", 10) * Number(_.substr(2)) : Number(_) - l.s || 0; l && l._next && (l._next._prev = l) } return r && this._kill(r, e) ? this._initProps(e, i, s, r) : this._overwrite > 1 && this._firstPT && s.length > 1 && G(e, this, i, this._overwrite, s) ? (this._kill(i, e), this._initProps(e, i, s, r)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (E[e._gsTweenID] = !0), o) }, n.render = function (t, e, i) { var s, r, n, a, o = this._time, h = this._duration, l = this._rawPrevTime; if (t >= h) this._totalTime = this._time = h, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (s = !0, r = "onComplete"), 0 === h && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (0 === t || 0 > l || l === _) && l !== t && (i = !0, l > _ && (r = "onReverseComplete")), this._rawPrevTime = a = !e || t || l === t ? t : _); else if (1e-7 > t) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== o || 0 === h && l > 0 && l !== _) && (r = "onReverseComplete", s = this._reversed), 0 > t ? (this._active = !1, 0 === h && (this._initted || !this.vars.lazy || i) && (l >= 0 && (i = !0), this._rawPrevTime = a = !e || t || l === t ? t : _)) : this._initted || (i = !0); else if (this._totalTime = this._time = t, this._easeType) { var u = t / h, p = this._easeType, c = this._easePower; (1 === p || 3 === p && u >= .5) && (u = 1 - u), 3 === p && (u *= 2), 1 === c ? u *= u : 2 === c ? u *= u * u : 3 === c ? u *= u * u * u : 4 === c && (u *= u * u * u * u), this.ratio = 1 === p ? 1 - u : 2 === p ? u : .5 > t / h ? u / 2 : 1 - u / 2 } else this.ratio = this._ease.getRatio(t / h); if (this._time !== o || i) { if (!this._initted) { if (this._init(), !this._initted || this._gc) return; if (!i && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = o, this._rawPrevTime = l, I.push(this), this._lazy = t, void 0; this._time && !s ? this.ratio = this._ease.getRatio(this._time / h) : s && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) } for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== o && t >= 0 && (this._active = !0), 0 === o && (this._startAt && (t >= 0 ? this._startAt.render(t, e, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 !== this._time || 0 === h) && (e || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || y))), n = this._firstPT; n;)n.f ? n.t[n.p](n.c * this.ratio + n.s) : n.t[n.p] = n.c * this.ratio + n.s, n = n._next; this._onUpdate && (0 > t && this._startAt && this._startTime && this._startAt.render(t, e, i), e || (this._time !== o || s) && this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || y)), r && (!this._gc || i) && (0 > t && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, e, i), s && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this.vars[r].apply(this.vars[r + "Scope"] || this, this.vars[r + "Params"] || y), 0 === h && this._rawPrevTime === _ && a !== _ && (this._rawPrevTime = 0)) } }, n._kill = function (t, e) { if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1); e = "string" != typeof e ? e || this._targets || this.target : D.selector(e) || e; var i, s, r, n, a, o, h, l; if ((c(e) || M(e)) && "number" != typeof e[0]) for (i = e.length; --i > -1;)this._kill(t, e[i]) && (o = !0); else { if (this._targets) { for (i = this._targets.length; --i > -1;)if (e === this._targets[i]) { a = this._propLookup[i] || {}, this._overwrittenProps = this._overwrittenProps || [], s = this._overwrittenProps[i] = t ? this._overwrittenProps[i] || {} : "all"; break } } else { if (e !== this.target) return !1; a = this._propLookup, s = this._overwrittenProps = t ? this._overwrittenProps || {} : "all" } if (a) { h = t || a, l = t !== s && "all" !== s && t !== a && ("object" != typeof t || !t._tempKill); for (r in h) (n = a[r]) && (n.pg && n.t._kill(h) && (o = !0), n.pg && 0 !== n.t._overwriteProps.length || (n._prev ? n._prev._next = n._next : n === this._firstPT && (this._firstPT = n._next), n._next && (n._next._prev = n._prev), n._next = n._prev = null), delete a[r]), l && (s[r] = 1); !this._firstPT && this._initted && this._enabled(!1, !1) } } return o }, n.invalidate = function () { return this._notifyPluginsOfEnabled && D._onPluginEvent("_onDisable", this), this._firstPT = null, this._overwrittenProps = null, this._onUpdate = null, this._startAt = null, this._initted = this._active = this._notifyPluginsOfEnabled = this._lazy = !1, this._propLookup = this._targets ? {} : [], this }, n._enabled = function (t, e) { if (o || a.wake(), t && this._gc) { var i, s = this._targets; if (s) for (i = s.length; --i > -1;)this._siblings[i] = V(s[i], this, !0); else this._siblings = V(this.target, this, !0) } return A.prototype._enabled.call(this, t, e), this._notifyPluginsOfEnabled && this._firstPT ? D._onPluginEvent(t ? "_onEnable" : "_onDisable", this) : !1 }, D.to = function (t, e, i) { return new D(t, e, i) }, D.from = function (t, e, i) { return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new D(t, e, i) }, D.fromTo = function (t, e, i, s) { return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, new D(t, e, s) }, D.delayedCall = function (t, e, i, s, r) { return new D(e, 0, { delay: t, onComplete: e, onCompleteParams: i, onCompleteScope: s, onReverseComplete: e, onReverseCompleteParams: i, onReverseCompleteScope: s, immediateRender: !1, useFrames: r, overwrite: 0 }) }, D.set = function (t, e) { return new D(t, 0, e) }, D.getTweensOf = function (t, e) { if (null == t) return []; t = "string" != typeof t ? t : D.selector(t) || t; var i, s, r, n; if ((c(t) || M(t)) && "number" != typeof t[0]) { for (i = t.length, s = []; --i > -1;)s = s.concat(D.getTweensOf(t[i], e)); for (i = s.length; --i > -1;)for (n = s[i], r = i; --r > -1;)n === s[r] && s.splice(i, 1) } else for (s = V(t).concat(), i = s.length; --i > -1;)(s[i]._gc || e && !s[i].isActive()) && s.splice(i, 1); return s }, D.killTweensOf = D.killDelayedCallsTo = function (t, e, i) { "object" == typeof e && (i = e, e = !1); for (var s = D.getTweensOf(t, e), r = s.length; --r > -1;)s[r]._kill(i, t) }; var Q = g("plugins.TweenPlugin", function (t, e) { this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = Q.prototype }, !0); if (n = Q.prototype, Q.version = "1.10.1", Q.API = 2, n._firstPT = null, n._addTween = function (t, e, i, s, r, n) {
            var a, o;
            return null != s && (a = "number" == typeof s || "=" !== s.charAt(1) ? Number(s) - i : parseInt(s.charAt(0) + "1", 10) * Number(s.substr(2))) ? (this._firstPT = o = { _next: this._firstPT, t: t, p: e, s: i, c: a, f: "function" == typeof t[e], n: r || e, r: n }, o._next && (o._next._prev = o), o) : void 0
        }, n.setRatio = function (t) { for (var e, i = this._firstPT, s = 1e-6; i;)e = i.c * t + i.s, i.r ? e = Math.round(e) : s > e && e > -s && (e = 0), i.f ? i.t[i.p](e) : i.t[i.p] = e, i = i._next }, n._kill = function (t) { var e, i = this._overwriteProps, s = this._firstPT; if (null != t[this._propName]) this._overwriteProps = []; else for (e = i.length; --e > -1;)null != t[i[e]] && i.splice(e, 1); for (; s;)null != t[s.n] && (s._next && (s._next._prev = s._prev), s._prev ? (s._prev._next = s._next, s._prev = null) : this._firstPT === s && (this._firstPT = s._next)), s = s._next; return !1 }, n._roundProps = function (t, e) { for (var i = this._firstPT; i;)(t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")]) && (i.r = e), i = i._next }, D._onPluginEvent = function (t, e) { var i, s, r, n, a, o = e._firstPT; if ("_onInitAllProps" === t) { for (; o;) { for (a = o._next, s = r; s && s.pr > o.pr;)s = s._next; (o._prev = s ? s._prev : n) ? o._prev._next = o : r = o, (o._next = s) ? s._prev = o : n = o, o = a } o = e._firstPT = r } for (; o;)o.pg && "function" == typeof o.t[t] && o.t[t]() && (i = !0), o = o._next; return i }, Q.activate = function (t) { for (var e = t.length; --e > -1;)t[e].API === Q.API && (F[(new t[e])._propName] = t[e]); return !0 }, d.plugin = function (t) { if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition."; var e, i = t.propName, s = t.priority || 0, r = t.overwriteProps, n = { init: "_onInitTween", set: "setRatio", kill: "_kill", round: "_roundProps", initAll: "_onInitAllProps" }, a = g("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function () { Q.call(this, i, s), this._overwriteProps = r || [] }, t.global === !0), o = a.prototype = new Q(i); o.constructor = a, a.API = t.API; for (e in n) "function" == typeof t[e] && (o[n[e]] = t[e]); return a.version = t.version, Q.activate([a]), a }, s = t._gsQueue) { for (r = 0; s.length > r; r++)s[r](); for (n in f) f[n].func || t.console.log("GSAP encountered missing dependency: com.greensock." + n) } o = !1
    }
}("undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window, "TweenMax");
/**
 *	Neon Notes Script
 *
 *	Developed by Arlind Nushi - www.laborator.co
 */

var xenonNotes = xenonNotes || {};

; (function ($, window, undefined) {
    "use strict";

    $(window).load(function () {
        xenonNotes.$container = $(".notes-env");

        $.extend(xenonNotes, {
            isPresent: xenonNotes.$container.length > 0,

            noTitleText: "Untitled",
            noDescriptionText: "(No content)",


            $currentNote: $(null),
            $currentNoteTitle: $(null),
            $currentNoteDescription: $(null),
            $currentNoteContent: $(null),

            addNote: function () {
                var $note = $('<li><a href="#"><strong></strong><span></li></a></li>');

                $note.append('<div class="content"></div>').append('<button class="note-close">&times;</button>');

                $note.find('strong').html(xenonNotes.noTitleText);
                $note.find('span').html(xenonNotes.noDescriptionText);

                xenonNotes.$notesList.prepend($note);

                TweenMax.set($note, { autoAlpha: 0 });

                var tl = new TimelineMax();

                tl.append(TweenMax.to($note, .10, { css: { autoAlpha: 1 } }));
                tl.append(TweenMax.to($note, .15, { css: { autoAlpha: .8 } }));
                tl.append(TweenMax.to($note, .15, { css: { autoAlpha: 1 } }));

                xenonNotes.$notesList.find('li').removeClass('current');
                $note.addClass('current');

                xenonNotes.$writePadTxt.focus();

                xenonNotes.checkCurrentNote();
            },

            checkCurrentNote: function () {
                var $current_note = xenonNotes.$notesList.find('li.current').first();

                if ($current_note.length) {
                    xenonNotes.$currentNote = $current_note;
                    xenonNotes.$currentNoteTitle = $current_note.find('strong');
                    xenonNotes.$currentNoteDescription = $current_note.find('span');
                    xenonNotes.$currentNoteContent = $current_note.find('.content');

                    xenonNotes.$writePadTxt.val($.trim(xenonNotes.$currentNoteContent.html())).trigger('autosize.resize');;
                }
                else {
                    var first = xenonNotes.$notesList.find('li:first:not(.no-notes)');

                    if (first.length) {
                        first.addClass('current');
                        xenonNotes.checkCurrentNote();
                    }
                    else {
                        xenonNotes.$writePadTxt.val('');
                        xenonNotes.$currentNote = $(null);
                        xenonNotes.$currentNoteTitle = $(null);
                        xenonNotes.$currentNoteDescription = $(null);
                        xenonNotes.$currentNoteContent = $(null);
                    }
                }
            },

            updateCurrentNoteText: function () {
                var text = $.trim(xenonNotes.$writePadTxt.val());

                if (xenonNotes.$currentNote.length) {
                    var title = '',
                        description = '';

                    if (text.length) {
                        var _text = text.split("\n"), currline = 1;

                        for (var i = 0; i < _text.length; i++) {
                            if (_text[i]) {
                                if (currline == 1) {
                                    title = _text[i];
                                }
                                else
                                    if (currline == 2) {
                                        description = _text[i];
                                    }

                                currline++;
                            }

                            if (currline > 2)
                                break;
                        }
                    }

                    xenonNotes.$currentNoteTitle.text(title.length ? title : xenonNotes.noTitleText);
                    xenonNotes.$currentNoteDescription.text(description.length ? description : xenonNotes.noDescriptionText);
                    xenonNotes.$currentNoteContent.text(text);
                }
                else
                    if (text.length) {
                        xenonNotes.addNote();
                    }
            }
        });

        // Mail Container Height fit with the document
        if (xenonNotes.isPresent) {
            xenonNotes.$notesList = xenonNotes.$container.find('.list-of-notes');
            xenonNotes.$writePad = xenonNotes.$container.find('.write-pad');
            xenonNotes.$writePadTxt = xenonNotes.$writePad.find('textarea');

            xenonNotes.$addNote = xenonNotes.$container.find('#add-note');

            xenonNotes.$addNote.on('click', function (ev) {
                xenonNotes.addNote();
            });

            xenonNotes.$writePadTxt.on('keyup', function (ev) {
                xenonNotes.updateCurrentNoteText();
            });

            xenonNotes.checkCurrentNote();

            xenonNotes.$notesList.on('click', 'li a', function (ev) {
                ev.preventDefault();

                xenonNotes.$notesList.find('li').removeClass('current');
                $(this).parent().addClass('current');

                xenonNotes.checkCurrentNote();


            });

            xenonNotes.$notesList.on('click', 'li .note-close', function (ev) {
                ev.preventDefault();

                var $note = $(this).parent();

                var tl = new TimelineMax();

                tl.append(
                    TweenMax.to($note, .15, {
                        css: { autoAlpha: 0 }, onComplete: function () {
                            $note.remove();
                            xenonNotes.checkCurrentNote();
                        }
                    })
                );
            });
        }
    });

})(jQuery, window);


/**
 *	Toggles
 *
 *	Non-animation
 */


; (function ($, window, undefined) {
    "use strict";

    $(document).ready(function () {

        // Chat Toggler
        $('a[data-toggle="chat"]').each(function (i, el) {
            $(el).on('click', function (ev) {
                ev.preventDefault();

                public_vars.$body.toggleClass('chat-open');

                if ($.isFunction($.fn.perfectScrollbar)) {
                    setTimeout(function () {
                        public_vars.$chat.find('.chat_inner').perfectScrollbar('update');
                        $(window).trigger('xenon.resize');
                    }, 1);
                }
            });
        });


        // Settings Pane Toggler
        $('a[data-toggle="settings-pane"]').each(function (i, el) {
            $(el).on('click', function (ev) {
                ev.preventDefault();

                var use_animation = attrDefault($(el), 'animate', false) && !isxs();

                var scroll = {
                    top: $(document).scrollTop(),
                    toTop: 0
                };

                if (public_vars.$body.hasClass('settings-pane-open')) {
                    scroll.toTop = scroll.top;
                }

                TweenMax.to(scroll, (use_animation ? .1 : 0), {
                    top: scroll.toTop, roundProps: ['top'], ease: scroll.toTop < 10 ? null : Sine.easeOut, onUpdate: function () {
                        $(window).scrollTop(scroll.top);
                    },
                    onComplete: function () {
                        if (use_animation) {
                            // With Animation
                            public_vars.$settingsPaneIn.addClass('with-animation');

                            // Opening
                            if (!public_vars.$settingsPane.is(':visible')) {
                                public_vars.$body.addClass('settings-pane-open');

                                var height = public_vars.$settingsPane.outerHeight(true);

                                public_vars.$settingsPane.css({
                                    height: 0
                                });

                                TweenMax.to(public_vars.$settingsPane, .25, {
                                    css: { height: height }, ease: Circ.easeInOut, onComplete: function () {
                                        public_vars.$settingsPane.css({ height: '' });
                                    }
                                });

                                public_vars.$settingsPaneIn.addClass('visible');
                            }
                            // Closing
                            else {
                                public_vars.$settingsPaneIn.addClass('closing');

                                TweenMax.to(public_vars.$settingsPane, .25, {
                                    css: { height: 0 }, delay: .15, ease: Power1.easeInOut, onComplete: function () {
                                        public_vars.$body.removeClass('settings-pane-open');
                                        public_vars.$settingsPane.css({ height: '' });
                                        public_vars.$settingsPaneIn.removeClass('closing visible');
                                    }
                                });
                            }
                        }
                        else {
                            // Without Animation
                            public_vars.$body.toggleClass('settings-pane-open');
                            public_vars.$settingsPaneIn.removeClass('visible');
                            public_vars.$settingsPaneIn.removeClass('with-animation');
                        }
                    }
                });
            });
        });



        // Sidebar Toggle
        $('a[data-toggle="sidebar"]').each(function (i, el) {
            $(el).on('click', function (ev) {
                ev.preventDefault();


                if (public_vars.$sidebarMenu.hasClass('collapsed')) {
                    public_vars.$sidebarMenu.removeClass('collapsed');
                    ps_init();
                }
                else {
                    public_vars.$sidebarMenu.addClass('collapsed');
                    ps_destroy();
                }

                $(window).trigger('xenon.resize');
            });
        });



        // Mobile Menu Trigger
        $('a[data-toggle="mobile-menu"]').on('click', function (ev) {
            ev.preventDefault();

            public_vars.$mainMenu.add(public_vars.$sidebarProfile).toggleClass('mobile-is-visible');
            ps_destroy();
        });



        // Mobile Menu Trigger for Horizontal Menu
        $('a[data-toggle="mobile-menu-horizontal"]').on('click', function (ev) {
            ev.preventDefault();

            public_vars.$horizontalMenu.toggleClass('mobile-is-visible');

        });



        // Mobile Menu Trigger for Sidebar & Horizontal Menu
        $('a[data-toggle="mobile-menu-both"]').on('click', function (ev) {
            ev.preventDefault();

            public_vars.$mainMenu.toggleClass('mobile-is-visible both-menus-visible');
            public_vars.$horizontalMenu.toggleClass('mobile-is-visible both-menus-visible');

        });



        // Mobile User Info Menu Trigger
        $('a[data-toggle="user-info-menu"]').on('click', function (ev) {
            ev.preventDefault();

            public_vars.$userInfoMenu.toggleClass('mobile-is-visible');

        });



        // Mobile User Info Menu Trigger for Horizontal Menu
        $('a[data-toggle="user-info-menu-horizontal"]').on('click', function (ev) {
            ev.preventDefault();

            public_vars.$userInfoMenuHor.find('.nav.nav-userinfo').toggleClass('mobile-is-visible');

        });



        // Panel Close
        $('body').on('click', '.panel a[data-toggle="remove"]', function (ev) {
            ev.preventDefault();

            var $panel = $(this).closest('.panel'),
                $panel_parent = $panel.parent();

            $panel.remove();

            if ($panel_parent.children().length == 0) {
                $panel_parent.remove();
            }
        });



        // Panel Reload
        $('body').on('click', '.panel a[data-toggle="reload"]', function (ev) {
            ev.preventDefault();

            var $panel = $(this).closest('.panel');

            // This is just a simulation, nothing is going to be reloaded
            $panel.append('<div class="panel-disabled"><div class="loader-1"></div></div>');

            var $pd = $panel.find('.panel-disabled');

            setTimeout(function () {
                $pd.fadeOut('fast', function () {
                    $pd.remove();
                });

            }, 500 + 300 * (Math.random() * 5));
        });



        // Panel Expand/Collapse Toggle
        $('body').on('click', '.panel a[data-toggle="panel"]', function (ev) {
            ev.preventDefault();

            var $panel = $(this).closest('.panel');

            $panel.toggleClass('collapsed');
        });



        // Loading Text toggle
        $('[data-loading-text]').each(function (i, el) // Temporary for demo purpose only
        {
            var $this = $(el);

            $this.on('click', function (ev) {
                $this.button('loading');

                setTimeout(function () { $this.button('reset'); }, 1800);
            });
        });




        // Popovers and tooltips
        $('[data-toggle="popover"]').each(function (i, el) {
            var $this = $(el),
                placement = attrDefault($this, 'placement', 'right'),
                trigger = attrDefault($this, 'trigger', 'click'),
                popover_class = $this.get(0).className.match(/(popover-[a-z0-9]+)/i);

            $this.popover({
                placement: placement,
                trigger: trigger
            });

            if (popover_class) {
                $this.removeClass(popover_class[1]);

                $this.on('show.bs.popover', function (ev) {
                    setTimeout(function () {
                        var $popover = $this.next();
                        $popover.addClass(popover_class[1]);

                    }, 0);
                });
            }
        });

        $('[data-toggle="tooltip"]').each(function (i, el) {
            var $this = $(el),
                placement = attrDefault($this, 'placement', 'top'),
                trigger = attrDefault($this, 'trigger', 'hover'),
                tooltip_class = $this.get(0).className.match(/(tooltip-[a-z0-9]+)/i);

            $this.tooltip({
                placement: placement,
                trigger: trigger
            });

            if (tooltip_class) {
                $this.removeClass(tooltip_class[1]);

                $this.on('show.bs.tooltip', function (ev) {
                    setTimeout(function () {
                        var $tooltip = $this.next();
                        $tooltip.addClass(tooltip_class[1]);

                    }, 0);
                });
            }
        });

    });

})(jQuery, window);
/**
 *	Xenon Widgets
 *
 *	Theme by: www.laborator.co
 **/

; (function ($, window, undefined) {

    "use strict";

    $(document).ready(function () {
        if ($('.page-loading-overlay').length) {
            $(window).on('load', function () {
                setTimeout(setupWidgets, 200);
            });
        }
        else {
            setupWidgets();
        }
    });


    var setupWidgets = function () {
        // Count Anything
        $("[data-from][data-to]").each(function (i, el) {
            var $el = $(el),
                sm = scrollMonitor.create(el);

            sm.fullyEnterViewport(function () {
                var opts = {
                    useEasing: attrDefault($el, 'easing', true),
                    useGrouping: attrDefault($el, 'grouping', true),
                    separator: attrDefault($el, 'separator', ','),
                    decimal: attrDefault($el, 'decimal', '.'),
                    prefix: attrDefault($el, 'prefix', ''),
                    suffix: attrDefault($el, 'suffix', ''),
                },
                    $count = attrDefault($el, 'count', 'this') == 'this' ? $el : $el.find($el.data('count')),
                    from = attrDefault($el, 'from', 0),
                    to = attrDefault($el, 'to', 100),
                    duration = attrDefault($el, 'duration', 2.5),
                    delay = attrDefault($el, 'delay', 0),
                    decimals = new String(to).match(/\.([0-9]+)/) ? new String(to).match(/\.([0-9]+)$/)[1].length : 0,
                    counter = new countUp($count.get(0), from, to, decimals, duration, opts);

                setTimeout(function () { counter.start(); }, delay * 1000);

                sm.destroy();
            });
        });


        // Fill Anything
        $("[data-fill-from][data-fill-to]").each(function (i, el) {
            var $el = $(el),
                sm = scrollMonitor.create(el);

            sm.fullyEnterViewport(function () {
                var fill = {
                    current: null,
                    from: attrDefault($el, 'fill-from', 0),
                    to: attrDefault($el, 'fill-to', 100),
                    property: attrDefault($el, 'fill-property', 'width'),
                    unit: attrDefault($el, 'fill-unit', '%'),
                },
                    opts = {
                        current: fill.to, onUpdate: function () {
                            $el.css(fill.property, fill.current + fill.unit);
                        },
                        delay: attrDefault($el, 'delay', 0),
                    },
                    easing = attrDefault($el, 'fill-easing', true),
                    duration = attrDefault($el, 'fill-duration', 2.5);

                if (easing) {
                    opts.ease = Sine.easeOut;
                }

                // Set starting point
                fill.current = fill.from;

                TweenMax.to(fill, duration, opts);

                sm.destroy();
            });
        });


        // Todo List
        $(".xe-todo-list").on('change', 'input[type="checkbox"]', function (ev) {
            var $cb = $(this),
                $li = $cb.closest('li');

            $li.removeClass('done');

            if ($cb.is(':checked')) {
                $li.addClass('done');
            }
        });


        $(".xe-status-update").each(function (i, el) {
            var $el = $(el),
                $nav = $el.find('.xe-nav a'),
                $status_list = $el.find('.xe-body li'),
                index = $status_list.filter('.active').index(),
                auto_switch = attrDefault($el, 'auto-switch', 0),
                as_interval = 0;

            if (auto_switch > 0) {
                as_interval = setInterval(function () {
                    goTo(1);

                }, auto_switch * 1000);

                $el.hover(function () {
                    window.clearInterval(as_interval);
                },
                    function () {
                        as_interval = setInterval(function () {
                            goTo(1);

                        }, auto_switch * 1000);;
                    });
            }

            function goTo(plus_one) {
                index = (index + plus_one) % $status_list.length;

                if (index < 0)
                    index = $status_list.length - 1;

                var $to_hide = $status_list.filter('.active'),
                    $to_show = $status_list.eq(index);

                $to_hide.removeClass('active');
                $to_show.addClass('active').fadeTo(0, 0).fadeTo(320, 1);
            }

            $nav.on('click', function (ev) {
                ev.preventDefault();

                var plus_one = $(this).hasClass('xe-prev') ? -1 : 1;

                goTo(plus_one);
            });
        });
    }


})(jQuery, window);
/**
 * oclazyload - Load modules on demand (lazy load) with angularJS
 * @version v0.3.8
 * @link https://github.com/ocombe/ocLazyLoad
 * @license MIT
 * @author Olivier Combe <olivier.combe@gmail.com>
 */
(function () {
    'use strict';
    var regModules = ['ng'],
        regInvokes = [],
        regConfigs = [],
        justLoaded = [],
        ocLazyLoad = angular.module('oc.lazyLoad', ['ng']),
        broadcast = angular.noop;

    ocLazyLoad.provider('$ocLazyLoad', ['$controllerProvider', '$provide', '$compileProvider', '$filterProvider', '$injector', '$animateProvider',
        function ($controllerProvider, $provide, $compileProvider, $filterProvider, $injector, $animateProvider) {
            var modules = {},
                providers = {
                    $controllerProvider: $controllerProvider,
                    $compileProvider: $compileProvider,
                    $filterProvider: $filterProvider,
                    $provide: $provide, // other things
                    $injector: $injector,
                    $animateProvider: $animateProvider
                },
                anchor = document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0],
                jsLoader, cssLoader, templatesLoader,
                debug = false,
                events = false;

            // Let's get the list of loaded modules & components
            init(angular.element(window.document));

            this.$get = ['$timeout', '$log', '$q', '$templateCache', '$http', '$rootElement', '$rootScope', '$cacheFactory', function ($timeout, $log, $q, $templateCache, $http, $rootElement, $rootScope, $cacheFactory) {
                var instanceInjector,
                    filesCache = $cacheFactory('ocLazyLoad');

                if (!debug) {
                    $log = {};
                    $log['error'] = angular.noop;
                    $log['warn'] = angular.noop;
                    $log['info'] = angular.noop;
                }

                // Make this lazy because at the moment that $get() is called the instance injector hasn't been assigned to the rootElement yet
                providers.getInstanceInjector = function () {
                    return (instanceInjector) ? instanceInjector : (instanceInjector = $rootElement.data('$injector'));
                };

                broadcast = function broadcast(eventName, params) {
                    if (events) {
                        $rootScope.$broadcast(eventName, params);
                    }
                    if (debug) {
                        $log.info(eventName, params);
                    }
                }

				/**
				 * Load a js/css file
				 * @param type
				 * @param path
				 * @returns promise
				 */
                var buildElement = function buildElement(type, path, params) {
                    var deferred = $q.defer(),
                        el, loaded,
                        cacheBuster = function cacheBuster(url) {
                            var dc = new Date().getTime();
                            if (url.indexOf('?') >= 0) {
                                if (url.substring(0, url.length - 1) === '&') {
                                    return url + '_dc=' + dc;
                                }
                                return url + '&_dc=' + dc;
                            } else {
                                return url + '?_dc=' + dc;
                            }
                        };

                    // Store the promise early so the file load can be detected by other parallel lazy loads
                    // (ie: multiple routes on one page) a 'true' value isn't sufficient
                    // as it causes false positive load results.
                    if (angular.isUndefined(filesCache.get(path))) {
                        filesCache.put(path, deferred.promise);
                    }

                    // Switch in case more content types are added later
                    switch (type) {
                        case 'css':
                            el = document.createElement('link');
                            el.type = 'text/css';
                            el.rel = 'stylesheet';
                            el.href = params.cache === false ? cacheBuster(path) : path;
                            break;
                        case 'js':
                            el = document.createElement('script');
                            el.src = params.cache === false ? cacheBuster(path) : path;
                            break;
                        default:
                            deferred.reject(new Error('Requested type "' + type + '" is not known. Could not inject "' + path + '"'));
                            break;
                    }
                    el.onload = el['onreadystatechange'] = function (e) {
                        if ((el['readyState'] && !(/^c|loade/.test(el['readyState']))) || loaded) return;
                        el.onload = el['onreadystatechange'] = null
                        loaded = 1;
                        broadcast('ocLazyLoad.fileLoaded', path);
                        deferred.resolve();
                    }
                    el.onerror = function (e) {
                        deferred.reject(new Error('Unable to load ' + path));
                    }
                    el.async = 1;
                    anchor.insertBefore(el, anchor.lastChild);

                    return deferred.promise;
                }

                if (angular.isUndefined(jsLoader)) {
					/**
					 * jsLoader function
					 * @type Function
					 * @param paths array list of js files to load
					 * @param callback to call when everything is loaded. We use a callback and not a promise
					 * @param params object config parameters
					 * because the user can overwrite jsLoader and it will probably not use promises :(
					 */
                    jsLoader = function (paths, callback, params) {
                        var promises = [];
                        angular.forEach(paths, function loading(path) {
                            promises.push(buildElement('js', path, params));
                        });
                        $q.all(promises).then(function success() {
                            callback();
                        }, function error(err) {
                            callback(err);
                        });
                    }
                    jsLoader.ocLazyLoadLoader = true;
                }

                if (angular.isUndefined(cssLoader)) {
					/**
					 * cssLoader function
					 * @type Function
					 * @param paths array list of css files to load
					 * @param callback to call when everything is loaded. We use a callback and not a promise
					 * @param params object config parameters
					 * because the user can overwrite cssLoader and it will probably not use promises :(
					 */
                    cssLoader = function (paths, callback, params) {
                        var promises = [];
                        angular.forEach(paths, function loading(path) {
                            promises.push(buildElement('css', path, params));
                        });
                        $q.all(promises).then(function success() {
                            callback();
                        }, function error(err) {
                            callback(err);
                        });
                    }
                    cssLoader.ocLazyLoadLoader = true;
                }

                if (angular.isUndefined(templatesLoader)) {
					/**
					 * templatesLoader function
					 * @type Function
					 * @param paths array list of css files to load
					 * @param callback to call when everything is loaded. We use a callback and not a promise
					 * @param params object config parameters for $http
					 * because the user can overwrite templatesLoader and it will probably not use promises :(
					 */
                    templatesLoader = function (paths, callback, params) {
                        if (angular.isString(paths)) {
                            paths = [paths];
                        }
                        var promises = [];
                        angular.forEach(paths, function (url) {
                            var deferred = $q.defer();
                            promises.push(deferred.promise);
                            $http.get(url, params).success(function (data) {
                                angular.forEach(angular.element(data), function (node) {
                                    if (node.nodeName === 'SCRIPT' && node.type === 'text/ng-template') {
                                        $templateCache.put(node.id, node.innerHTML);
                                    }
                                });
                                if (angular.isUndefined(filesCache.get(url))) {
                                    filesCache.put(url, true);
                                }
                                deferred.resolve();
                            }).error(function (data) {
                                var err = 'Error load template "' + url + '": ' + data;
                                $log.error(err);
                                deferred.reject(new Error(err));
                            });
                        });
                        return $q.all(promises).then(function success() {
                            callback();
                        }, function error(err) {
                            callback(err);
                        });
                    }
                    templatesLoader.ocLazyLoadLoader = true;
                }

                var filesLoader = function (config, params) {
                    var cssFiles = [],
                        templatesFiles = [],
                        jsFiles = [],
                        promises = [],
                        cachePromise = null;

                    angular.extend(params || {}, config);

                    angular.forEach(params.files, function (path) {
                        cachePromise = filesCache.get(path);
                        if (angular.isUndefined(cachePromise) || params.cache === false) {
                            if (/\.css[^\.]*$/.test(path) && cssFiles.indexOf(path) === -1) {
                                cssFiles.push(path);
                            } else if (/\.(htm|html)[^\.]*$/.test(path) && templatesFiles.indexOf(path) === -1) {
                                templatesFiles.push(path);
                            } else if (jsFiles.indexOf(path) === -1) {
                                jsFiles.push(path);
                            }
                        } else if (cachePromise) {
                            promises.push(cachePromise);
                        }
                    });

                    if (cssFiles.length > 0) {
                        var cssDeferred = $q.defer();
                        cssLoader(cssFiles, function (err) {
                            if (angular.isDefined(err) && cssLoader.hasOwnProperty('ocLazyLoadLoader')) {
                                $log.error(err);
                                cssDeferred.reject(err);
                            } else {
                                cssDeferred.resolve();
                            }
                        }, params);
                        promises.push(cssDeferred.promise);
                    }

                    if (templatesFiles.length > 0) {
                        var templatesDeferred = $q.defer();
                        templatesLoader(templatesFiles, function (err) {
                            if (angular.isDefined(err) && templatesLoader.hasOwnProperty('ocLazyLoadLoader')) {
                                $log.error(err);
                                templatesDeferred.reject(err);
                            } else {
                                templatesDeferred.resolve();
                            }
                        }, params);
                        promises.push(templatesDeferred.promise);
                    }

                    if (jsFiles.length > 0) {
                        var jsDeferred = $q.defer();
                        jsLoader(jsFiles, function (err) {
                            if (angular.isDefined(err) && jsLoader.hasOwnProperty('ocLazyLoadLoader')) {
                                $log.error(err);
                                jsDeferred.reject(err);
                            } else {
                                jsDeferred.resolve();
                            }
                        }, params);
                        promises.push(jsDeferred.promise);
                    }

                    return $q.all(promises);
                }

                return {
                    getModuleConfig: function (name) {
                        if (!modules[name]) {
                            return null;
                        }
                        return modules[name];
                    },

                    setModuleConfig: function (module) {
                        modules[module.name] = module;
                        return module;
                    },

                    getModules: function () {
                        return regModules;
                    },

                    // deprecated
                    loadTemplateFile: function (paths, params) {
                        return filesLoader({ files: paths }, params);
                    },

                    load: function (module, params) {
                        var self = this,
                            config = null,
                            moduleCache = [],
                            deferredList = [],
                            deferred = $q.defer(),
                            moduleName,
                            errText;

                        if (angular.isUndefined(params)) {
                            params = {};
                        }

                        // If module is an array, break it down
                        if (angular.isArray(module)) {
                            // Resubmit each entry as a single module
                            angular.forEach(module, function (m) {
                                if (m) {
                                    deferredList.push(self.load(m, params));
                                }
                            });

                            // Resolve the promise once everything has loaded
                            $q.all(deferredList).then(function success() {
                                deferred.resolve(module);
                            }, function error(err) {
                                deferred.reject(err);
                            });

                            return deferred.promise;
                        }

                        moduleName = getModuleName(module);

                        // Get or Set a configuration depending on what was passed in
                        if (typeof module === 'string') {
                            config = self.getModuleConfig(module);
                            if (!config) {
                                config = {
                                    files: [module]
                                };
                                moduleName = null;
                            }
                        } else if (typeof module === 'object') {
                            config = self.setModuleConfig(module);
                        }

                        if (config === null) {
                            errText = 'Module "' + moduleName + '" is not configured, cannot load.';
                            $log.error(errText);
                            deferred.reject(new Error(errText));
                        } else {
                            // deprecated
                            if (angular.isDefined(config.template)) {
                                if (angular.isUndefined(config.files)) {
                                    config.files = [];
                                }
                                if (angular.isString(config.template)) {
                                    config.files.push(config.template);
                                } else if (angular.isArray(config.template)) {
                                    config.files.concat(config.template);
                                }
                            }
                        }

                        moduleCache.push = function (value) {
                            if (this.indexOf(value) === -1) {
                                Array.prototype.push.apply(this, arguments);
                            }
                        };

                        // If this module has been loaded before, re-use it.
                        if (angular.isDefined(moduleName) && moduleExists(moduleName) && regModules.indexOf(moduleName) !== -1) {
                            moduleCache.push(moduleName);

                            // if we don't want to load new files, resolve here
                            if (angular.isUndefined(config.files)) {
                                deferred.resolve();
                                return deferred.promise;
                            }
                        }

                        var loadDependencies = function loadDependencies(module) {
                            var moduleName,
                                loadedModule,
                                requires,
                                diff,
                                promisesList = [];

                            moduleName = getModuleName(module);
                            if (moduleName === null) {
                                return $q.when();
                            } else {
                                try {
                                    loadedModule = getModule(moduleName);
                                } catch (e) {
                                    var deferred = $q.defer();
                                    $log.error(e.message);
                                    deferred.reject(e);
                                    return deferred.promise;
                                }
                                requires = getRequires(loadedModule);
                            }

                            angular.forEach(requires, function (requireEntry) {
                                // If no configuration is provided, try and find one from a previous load.
                                // If there isn't one, bail and let the normal flow run
                                if (typeof requireEntry === 'string') {
                                    var config = self.getModuleConfig(requireEntry);
                                    if (config === null) {
                                        moduleCache.push(requireEntry); // We don't know about this module, but something else might, so push it anyway.
                                        return;
                                    }
                                    requireEntry = config;
                                }

                                // Check if this dependency has been loaded previously
                                if (moduleExists(requireEntry.name)) {
                                    if (typeof module !== 'string') {
                                        // compare against the already loaded module to see if the new definition adds any new files
                                        diff = requireEntry.files.filter(function (n) {
                                            return self.getModuleConfig(requireEntry.name).files.indexOf(n) < 0;
                                        });

                                        // If the module was redefined, advise via the console
                                        if (diff.length !== 0) {
                                            $log.warn('Module "', moduleName, '" attempted to redefine configuration for dependency. "', requireEntry.name, '"\n Additional Files Loaded:', diff);
                                        }

                                        // Push everything to the file loader, it will weed out the duplicates.
                                        promisesList.push(filesLoader(requireEntry.files, params).then(function () {
                                            return loadDependencies(requireEntry);
                                        }));
                                    }
                                    return;
                                } else if (typeof requireEntry === 'object') {
                                    if (requireEntry.hasOwnProperty('name') && requireEntry['name']) {
                                        // The dependency doesn't exist in the module cache and is a new configuration, so store and push it.
                                        self.setModuleConfig(requireEntry);
                                        moduleCache.push(requireEntry['name']);
                                    }

                                    // CSS Loading Handler
                                    if (requireEntry.hasOwnProperty('css') && requireEntry['css'].length !== 0) {
                                        // Locate the document insertion point
                                        angular.forEach(requireEntry['css'], function (path) {
                                            buildElement('css', path, params);
                                        });
                                    }
                                    // CSS End.
                                }

                                // Check if the dependency has any files that need to be loaded. If there are, push a new promise to the promise list.
                                if (requireEntry.hasOwnProperty('files') && requireEntry.files.length !== 0) {
                                    if (requireEntry.files) {
                                        promisesList.push(filesLoader(requireEntry, params).then(function () {
                                            return loadDependencies(requireEntry);
                                        }));
                                    }
                                }
                            });

                            // Create a wrapper promise to watch the promise list and resolve it once everything is done.
                            return $q.all(promisesList);
                        }

                        filesLoader(config, params).then(function success() {
                            if (moduleName === null) {
                                deferred.resolve(module);
                            } else {
                                moduleCache.push(moduleName);
                                loadDependencies(moduleName).then(function success() {
                                    try {
                                        justLoaded = [];
                                        register(providers, moduleCache, params);
                                    } catch (e) {
                                        $log.error(e.message);
                                        deferred.reject(e);
                                        return;
                                    }
                                    $timeout(function () {
                                        deferred.resolve(module);
                                    });
                                }, function error(err) {
                                    $timeout(function () {
                                        deferred.reject(err);
                                    });
                                });
                            }
                        }, function error(err) {
                            deferred.reject(err);
                        });

                        return deferred.promise;
                    }
                };
            }];

            this.config = function (config) {
                if (angular.isDefined(config.jsLoader) || angular.isDefined(config.asyncLoader)) {
                    jsLoader = config.jsLoader || config.asyncLoader;
                    if (!angular.isFunction(jsLoader)) {
                        throw ('The js loader needs to be a function');
                    }
                }

                if (angular.isDefined(config.cssLoader)) {
                    cssLoader = config.cssLoader;
                    if (!angular.isFunction(cssLoader)) {
                        throw ('The css loader needs to be a function');
                    }
                }

                if (angular.isDefined(config.templatesLoader)) {
                    templatesLoader = config.templatesLoader;
                    if (!angular.isFunction(templatesLoader)) {
                        throw ('The template loader needs to be a function');
                    }
                }

                // for bootstrap apps, we need to define the main module name
                if (angular.isDefined(config.loadedModules)) {
                    var addRegModule = function (loadedModule) {
                        if (regModules.indexOf(loadedModule) < 0) {
                            regModules.push(loadedModule);
                            angular.forEach(angular.module(loadedModule).requires, addRegModule);
                        }
                    };
                    angular.forEach(config.loadedModules, addRegModule);
                }

                // If we want to define modules configs
                if (angular.isDefined(config.modules)) {
                    if (angular.isArray(config.modules)) {
                        angular.forEach(config.modules, function (moduleConfig) {
                            modules[moduleConfig.name] = moduleConfig;
                        });
                    } else {
                        modules[config.modules.name] = config.modules;
                    }
                }

                if (angular.isDefined(config.debug)) {
                    debug = config.debug;
                }

                if (angular.isDefined(config.events)) {
                    events = config.events;
                }
            };
        }]);

    ocLazyLoad.directive('ocLazyLoad', ['$http', '$log', '$ocLazyLoad', '$compile', '$timeout', '$templateCache', '$animate',
        function ($http, $log, $ocLazyLoad, $compile, $timeout, $templateCache, $animate) {
            return {
                restrict: 'A',
                terminal: true,
                priority: 401, // 1 more than ngInclude
                transclude: 'element',
                controller: angular.noop,
                compile: function (element, attrs) {
                    return function ($scope, $element, $attr, ctrl, $transclude) {
                        var childScope,
                            evaluated = $scope.$eval($attr.ocLazyLoad),
                            onloadExp = evaluated && evaluated.onload ? evaluated.onload : '';

						/**
						 * Destroy the current scope of this element and empty the html
						 */
                        function clearContent() {
                            if (childScope) {
                                childScope.$destroy();
                                childScope = null;
                            }
                            $element.html('');
                        }

						/**
						 * Load a template from cache or url
						 * @param url
						 * @param callback
						 */
                        function loadTemplate(url, callback) {
                            var view;

                            if (typeof (view = $templateCache.get(url)) !== 'undefined') {
                                callback(view);
                            } else {
                                $http.get(url)
                                    .success(function (data) {
                                        $templateCache.put('view:' + url, data);
                                        callback(data);
                                    })
                                    .error(function (data) {
                                        $log.error('Error load template "' + url + '": ' + data);
                                    });
                            }
                        }

                        $scope.$watch($attr.ocLazyLoad, function (moduleName) {
                            if (angular.isDefined(moduleName)) {
                                $ocLazyLoad.load(moduleName).then(function (moduleConfig) {
                                    $transclude($scope, function cloneConnectFn(clone) {
                                        $animate.enter(clone, null, $element);
                                    });
                                });
                            } else {
                                clearContent();
                            }
                        }, true);
                    };
                }
				/*link: function($scope, $element, $attr) {

				 }*/
            };
        }]);

	/**
	 * Get the list of required modules/services/... for this module
	 * @param module
	 * @returns {Array}
	 */
    function getRequires(module) {
        var requires = [];
        angular.forEach(module.requires, function (requireModule) {
            if (regModules.indexOf(requireModule) === -1) {
                requires.push(requireModule);
            }
        });
        return requires;
    }

	/**
	 * Check if a module exists and returns it if it does
	 * @param moduleName
	 * @returns {boolean}
	 */
    function moduleExists(moduleName) {
        try {
            return angular.module(moduleName);
        } catch (e) {
            if (/No module/.test(e) || (e.message.indexOf('$injector:nomod') > -1)) {
                return false;
            }
        }
    }

    function getModule(moduleName) {
        try {
            return angular.module(moduleName);
        } catch (e) {
            // this error message really suxx
            if (/No module/.test(e) || (e.message.indexOf('$injector:nomod') > -1)) {
                e.message = 'The module "' + moduleName + '" that you are trying to load does not exist. ' + e.message
            }
            throw e;
        }
    }

    function invokeQueue(providers, queue, moduleName, reconfig) {
        if (!queue) {
            return;
        }

        var i, len, args, provider;
        for (i = 0, len = queue.length; i < len; i++) {
            args = queue[i];
            if (angular.isArray(args)) {
                if (providers !== null) {
                    if (providers.hasOwnProperty(args[0])) {
                        provider = providers[args[0]];
                    } else {
                        throw new Error('unsupported provider ' + args[0]);
                    }
                }
                var isNew = registerInvokeList(args[2][0]);
                if (args[1] !== 'invoke') {
                    if (isNew && angular.isDefined(provider)) {
                        provider[args[1]].apply(provider, args[2]);
                    }
                } else { // config block
                    var callInvoke = function (fct) {
                        var invoked = regConfigs.indexOf(moduleName + '-' + fct);
                        if (invoked === -1 || reconfig) {
                            if (invoked === -1) {
                                regConfigs.push(moduleName + '-' + fct);
                            }
                            if (angular.isDefined(provider)) {
                                provider[args[1]].apply(provider, args[2]);
                            }
                        }
                    }
                    if (angular.isFunction(args[2][0])) {
                        callInvoke(args[2][0]);
                    } else if (angular.isArray(args[2][0])) {
                        for (var j = 0, jlen = args[2][0].length; j < jlen; j++) {
                            if (angular.isFunction(args[2][0][j])) {
                                callInvoke(args[2][0][j]);
                            }
                        }
                    }
                }
            }
        }
    }

	/**
	 * Register a new module and load it
	 * @param providers
	 * @param registerModules
	 * @returns {*}
	 */
    function register(providers, registerModules, params) {
        if (registerModules) {
            var k, moduleName, moduleFn, runBlocks = [];
            for (k = registerModules.length - 1; k >= 0; k--) {
                moduleName = registerModules[k];
                if (typeof moduleName !== 'string') {
                    moduleName = getModuleName(moduleName);
                }
                if (!moduleName || justLoaded.indexOf(moduleName) !== -1) {
                    continue;
                }
                var newModule = regModules.indexOf(moduleName) === -1;
                moduleFn = angular.module(moduleName);
                if (newModule) { // new module
                    regModules.push(moduleName);
                    register(providers, moduleFn.requires, params);
                    runBlocks = runBlocks.concat(moduleFn._runBlocks);
                }
                invokeQueue(providers, moduleFn._invokeQueue, moduleName, params.reconfig);
                invokeQueue(providers, moduleFn._configBlocks, moduleName, params.reconfig); // angular 1.3+
                broadcast(newModule ? 'ocLazyLoad.moduleLoaded' : 'ocLazyLoad.moduleReloaded', moduleName);
                registerModules.pop();
                justLoaded.push(moduleName);
            }
            var instanceInjector = providers.getInstanceInjector();
            angular.forEach(runBlocks, function (fn) {
                instanceInjector.invoke(fn);
            });
        }
    }

	/**
	 * Register an invoke
	 * @param invokeList
	 * @returns {*}
	 */
    function registerInvokeList(invokeList) {
        var newInvoke = false;
        var onInvoke = function (invokeName) {
            newInvoke = true;
            regInvokes.push(invokeName);
            broadcast('ocLazyLoad.componentLoaded', invokeName);
        }
        if (angular.isString(invokeList)) {
            if (regInvokes.indexOf(invokeList) === -1) {
                onInvoke(invokeList);
            }
        } else if (angular.isObject(invokeList)) {
            angular.forEach(invokeList, function (invoke) {
                if (angular.isString(invoke) && regInvokes.indexOf(invoke) === -1) {
                    onInvoke(invoke);
                }
            });
        } else {
            return true;
        }
        return newInvoke;
    }

    function getModuleName(module) {
        if (module === null) {
            return null;
        }
        var moduleName = null;
        if (typeof module === 'string') {
            moduleName = module;
        } else if (typeof module === 'object' && module.hasOwnProperty('name') && typeof module.name === 'string') {
            moduleName = module.name;
        }
        return moduleName;
    }

	/**
	 * Get the list of existing registered modules
	 * @param element
	 */
    function init(element) {
        var elements = [element],
            appElement,
            moduleName,
            names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],
            NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;

        function append(elm) {
            return (elm && elements.push(elm));
        }

        angular.forEach(names, function (name) {
            names[name] = true;
            append(document.getElementById(name));
            name = name.replace(':', '\\:');
            if (element.querySelectorAll) {
                angular.forEach(element.querySelectorAll('.' + name), append);
                angular.forEach(element.querySelectorAll('.' + name + '\\:'), append);
                angular.forEach(element.querySelectorAll('[' + name + ']'), append);
            }
        });

        //TODO: search the script tags for angular.bootstrap
        angular.forEach(elements, function (elm) {
            if (!appElement) {
                var className = ' ' + element.className + ' ';
                var match = NG_APP_CLASS_REGEXP.exec(className);
                if (match) {
                    appElement = elm;
                    moduleName = (match[2] || '').replace(/\s+/g, ',');
                } else {
                    angular.forEach(elm.attributes, function (attr) {
                        if (!appElement && names[attr.name]) {
                            appElement = elm;
                            moduleName = attr.value;
                        }
                    });
                }
            }
        });

        if (appElement) {
            (function addReg(moduleName) {
                if (regModules.indexOf(moduleName) === -1) {
                    // register existing modules
                    regModules.push(moduleName);
                    var mainModule = angular.module(moduleName);

                    // register existing components (directives, services, ...)
                    invokeQueue(null, mainModule._invokeQueue, moduleName);
                    invokeQueue(null, mainModule._configBlocks, moduleName); // angular 1.3+

                    angular.forEach(mainModule.requires, addReg);
                }
            })(moduleName);
        }
    }

    // Array.indexOf polyfill for IE8
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (searchElement, fromIndex) {

            var k;

            // 1. Let O be the result of calling ToObject passing
            //    the this value as the argument.
            if (this == null) {
                throw new TypeError('"this" is null or not defined');
            }

            var O = Object(this);

            // 2. Let lenValue be the result of calling the Get
            //    internal method of O with the argument "length".
            // 3. Let len be ToUint32(lenValue).
            var len = O.length >>> 0;

            // 4. If len is 0, return -1.
            if (len === 0) {
                return -1;
            }

            // 5. If argument fromIndex was passed let n be
            //    ToInteger(fromIndex); else let n be 0.
            var n = +fromIndex || 0;

            if (Math.abs(n) === Infinity) {
                n = 0;
            }

            // 6. If n >= len, return -1.
            if (n >= len) {
                return -1;
            }

            // 7. If n >= 0, then Let k be n.
            // 8. Else, n<0, Let k be len - abs(n).
            //    If k is less than 0, then let k be 0.
            k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

            // 9. Repeat, while k < len
            while (k < len) {
                // a. Let Pk be ToString(k).
                //   This is implicit for LHS operands of the in operator
                // b. Let kPresent be the result of calling the
                //    HasProperty internal method of O with argument Pk.
                //   This step can be combined with c
                // c. If kPresent is true, then
                //    i.  Let elementK be the result of calling the Get
                //        internal method of O with the argument ToString(k).
                //   ii.  Let same be the result of applying the
                //        Strict Equality Comparison Algorithm to
                //        searchElement and elementK.
                //  iii.  If same is true, return k.
                if (k in O && O[k] === searchElement) {
                    return k;
                }
                k++;
            }
            return -1;
        };
    }
})();

/*
	This function will be called in the event when browser breakpoint changes
 */

var public_vars = public_vars || {};

jQuery.extend(public_vars, {

    breakpoints: {
        largescreen: [991, -1],
        tabletscreen: [768, 990],
        devicescreen: [420, 767],
        sdevicescreen: [0, 419]
    },

    lastBreakpoint: null
});


/* Main Function that will be called each time when the screen breakpoint changes */
function resizable(breakpoint) {
    var sb_with_animation;

    // Large Screen Specific Script
    if (is('largescreen')) {
    }


    // Tablet or larger screen
    if (ismdxl()) {
    }


    // Tablet Screen Specific Script
    if (is('tabletscreen')) {
    }


    // Tablet device screen
    if (is('tabletscreen')) {
        public_vars.$sidebarMenu.addClass('collapsed');
        ps_destroy();
    }


    // Tablet Screen Specific Script
    if (isxs()) {
    }


    // Trigger Event
    jQuery(window).trigger('xenon.resize');
}



/* Functions */

// Get current breakpoint
function get_current_breakpoint() {
    var width = jQuery(window).width(),
        breakpoints = public_vars.breakpoints;

    for (var breakpont_label in breakpoints) {
        var bp_arr = breakpoints[breakpont_label],
            min = bp_arr[0],
            max = bp_arr[1];

        if (max == -1)
            max = width;

        if (min <= width && max >= width) {
            return breakpont_label;
        }
    }

    return null;
}


// Check current screen breakpoint
function is(screen_label) {
    return get_current_breakpoint() == screen_label;
}


// Is xs device
function isxs() {
    return is('devicescreen') || is('sdevicescreen');
}

// Is md or xl
function ismdxl() {
    return is('tabletscreen') || is('largescreen');
}


// Trigger Resizable Function
function trigger_resizable() {
    if (public_vars.lastBreakpoint != get_current_breakpoint()) {
        public_vars.lastBreakpoint = get_current_breakpoint();
        resizable(public_vars.lastBreakpoint);
    }


    // Trigger Event (Repeated)
    jQuery(window).trigger('xenon.resized');
}
/**
 *	Xenon Main
 *
 *	Theme by: www.laborator.co
 **/

var public_vars = public_vars || {};

; (function ($, window, undefined) {

    "use strict";

    $(document).ready(function () {
        // Main Vars
        public_vars.$body = $("body");
        public_vars.$pageContainer = public_vars.$body.find(".page-container");
        public_vars.$chat = public_vars.$pageContainer.find("#chat");
        public_vars.$sidebarMenu = public_vars.$pageContainer.find('.sidebar-menu');
        public_vars.$sidebarProfile = public_vars.$sidebarMenu.find('.sidebar-user-info');
        public_vars.$mainMenu = public_vars.$sidebarMenu.find('.main-menu');

        public_vars.$horizontalNavbar = public_vars.$body.find('.navbar.horizontal-menu');
        public_vars.$horizontalMenu = public_vars.$horizontalNavbar.find('.navbar-nav');

        public_vars.$mainContent = public_vars.$pageContainer.find('.main-content');
        public_vars.$mainFooter = public_vars.$body.find('footer.main-footer');

        public_vars.$userInfoMenuHor = public_vars.$body.find('.navbar.horizontal-menu');
        public_vars.$userInfoMenu = public_vars.$body.find('nav.navbar.user-info-navbar');

        public_vars.$settingsPane = public_vars.$body.find('.settings-pane');
        public_vars.$settingsPaneIn = public_vars.$settingsPane.find('.settings-pane-inner');

        public_vars.wheelPropagation = true; // used in Main menu (sidebar)

        public_vars.$pageLoadingOverlay = public_vars.$body.find('.page-loading-overlay');

        public_vars.defaultColorsPalette = ['#68b828', '#7c38bc', '#0e62c7', '#fcd036', '#4fcdfc', '#00b19d', '#ff6264', '#f7aa47'];



        // Page Loading Overlay
        if (public_vars.$pageLoadingOverlay.length) {
            $(window).load(function () {
                public_vars.$pageLoadingOverlay.addClass('loaded');
            });
        }

        window.onerror = function () {
            // failsafe remove loading overlay
            public_vars.$pageLoadingOverlay.addClass('loaded');
        }


        // Setup Sidebar Menu
        setup_sidebar_menu();


        // Setup Horizontal Menu
        setup_horizontal_menu();


        // Sticky Footer
        if (public_vars.$mainFooter.hasClass('sticky')) {
            stickFooterToBottom();
            $(window).on('xenon.resized', stickFooterToBottom);
        }


        // Perfect Scrollbar
        if ($.isFunction($.fn.perfectScrollbar)) {
            if (public_vars.$sidebarMenu.hasClass('fixed'))
                ps_init();

            $(".ps-scrollbar").each(function (i, el) {
                var $el = $(el);

                if ($el.hasClass('ps-scroll-down')) {
                    $el.scrollTop($el.prop('scrollHeight'));
                }

                $el.perfectScrollbar({
                    wheelPropagation: false
                });
            });


            // Chat Scrollbar
            var $chat_inner = public_vars.$pageContainer.find('#chat .chat-inner');

            if ($chat_inner.parent().hasClass('fixed'))
                $chat_inner.css({ maxHeight: $(window).height() }).perfectScrollbar();


            // User info opening dropdown trigger PS update
            $(".dropdown:has(.ps-scrollbar)").each(function (i, el) {
                var $scrollbar = $(this).find('.ps-scrollbar');

                $(this).on('click', '[data-toggle="dropdown"]', function (ev) {
                    ev.preventDefault();

                    setTimeout(function () {
                        $scrollbar.perfectScrollbar('update');
                    }, 1);
                });
            });


            // Scrollable
            $("div.scrollable").each(function (i, el) {
                var $this = $(el),
                    max_height = parseInt(attrDefault($this, 'max-height', 200), 10);

                max_height = max_height < 0 ? 200 : max_height;

                $this.css({ maxHeight: max_height }).perfectScrollbar({
                    wheelPropagation: true
                });
            });
        }


        // User info search button
        var $uim_search_form = $(".user-info-menu .search-form, .nav.navbar-right .search-form");

        $uim_search_form.each(function (i, el) {
            var $uim_search_input = $(el).find('.form-control');

            $(el).on('click', '.btn', function (ev) {
                if ($uim_search_input.val().trim().length == 0) {
                    jQuery(el).addClass('focused');
                    setTimeout(function () { $uim_search_input.focus(); }, 100);
                    return false;
                }
            });

            $uim_search_input.on('blur', function () {
                jQuery(el).removeClass('focused');
            });
        });



        // Fixed Footer
        if (public_vars.$mainFooter.hasClass('fixed')) {
            public_vars.$mainContent.css({
                paddingBottom: public_vars.$mainFooter.outerHeight(true)
            });
        }



        // Go to top links
        $('body').on('click', 'a[rel="go-top"]', function (ev) {
            ev.preventDefault();

            var obj = { pos: $(window).scrollTop() };

            TweenLite.to(obj, .3, {
                pos: 0, ease: Power4.easeOut, onUpdate: function () {
                    $(window).scrollTop(obj.pos);
                }
            });
        });




        // User info navbar equal heights
        if (public_vars.$userInfoMenu.length) {
            public_vars.$userInfoMenu.find('.user-info-menu > li').css({
                minHeight: public_vars.$userInfoMenu.outerHeight() - 1
            });
        }



        // Autosize
        if ($.isFunction($.fn.autosize)) {
            $(".autosize, .autogrow").autosize();
        }


        // Custom Checkboxes & radios
        cbr_replace();



        // Auto hidden breadcrumbs
        $(".breadcrumb.auto-hidden").each(function (i, el) {
            var $bc = $(el),
                $as = $bc.find('li a'),
                collapsed_width = $as.width(),
                expanded_width = 0;

            $as.each(function (i, el) {
                var $a = $(el);

                expanded_width = $a.outerWidth(true) + 5;
                $a.addClass('collapsed').width(expanded_width);

                $a.hover(function () {
                    $a.removeClass('collapsed');
                },
                    function () {
                        $a.addClass('collapsed');
                    });
            });
        });



        // Close Modal on Escape Keydown
        $(window).on('keydown', function (ev) {
            // Escape
            if (ev.keyCode == 27) {
                // Close opened modal
                if (public_vars.$body.hasClass('modal-open'))
                    $(".modal-open .modal:visible").modal('hide');
            }
        });


        // Minimal Addon focus interaction
        $(".input-group.input-group-minimal:has(.form-control)").each(function (i, el) {
            var $this = $(el),
                $fc = $this.find('.form-control');

            $fc.on('focus', function () {
                $this.addClass('focused');
            }).on('blur', function () {
                $this.removeClass('focused');
            });
        });



        // Spinner
        $(".input-group.spinner").each(function (i, el) {
            var $ig = $(el),
                $dec = $ig.find('[data-type="decrement"]'),
                $inc = $ig.find('[data-type="increment"]'),
                $inp = $ig.find('.form-control'),

                step = attrDefault($ig, 'step', 1),
                min = attrDefault($ig, 'min', 0),
                max = attrDefault($ig, 'max', 0),
                umm = min < max;


            $dec.on('click', function (ev) {
                ev.preventDefault();

                var num = new Number($inp.val()) - step;

                if (umm && num <= min) {
                    num = min;
                }

                $inp.val(num);
            });

            $inc.on('click', function (ev) {
                ev.preventDefault();

                var num = new Number($inp.val()) + step;

                if (umm && num >= max) {
                    num = max;
                }

                $inp.val(num);
            });
        });




        // Select2 Dropdown replacement
        if ($.isFunction($.fn.select2)) {
            $(".select2").each(function (i, el) {
                var $this = $(el),
                    opts = {
                        allowClear: attrDefault($this, 'allowClear', false)
                    };

                $this.select2(opts);
                $this.addClass('visible');

                //$this.select2("open");
            });


            if ($.isFunction($.fn.niceScroll)) {
                $(".select2-results").niceScroll({
                    cursorcolor: '#d4d4d4',
                    cursorborder: '1px solid #ccc',
                    railpadding: { right: 3 }
                });
            }
        }




        // SelectBoxIt Dropdown replacement
        if ($.isFunction($.fn.selectBoxIt)) {
            $("select.selectboxit").each(function (i, el) {
                var $this = $(el),
                    opts = {
                        showFirstOption: attrDefault($this, 'first-option', true),
                        'native': attrDefault($this, 'native', false),
                        defaultText: attrDefault($this, 'text', ''),
                    };

                $this.addClass('visible');
                $this.selectBoxIt(opts);
            });
        }



        // Datepicker
        if ($.isFunction($.fn.datepicker)) {
            $(".datepicker").each(function (i, el) {
                var $this = $(el),
                    opts = {
                        format: attrDefault($this, 'format', 'mm/dd/yyyy'),
                        startDate: attrDefault($this, 'startDate', ''),
                        endDate: attrDefault($this, 'endDate', ''),
                        daysOfWeekDisabled: attrDefault($this, 'disabledDays', ''),
                        startView: attrDefault($this, 'startView', 0),
                        rtl: rtl()
                    },
                    $n = $this.next(),
                    $p = $this.prev();

                $this.datepicker(opts);

                if ($n.is('.input-group-addon') && $n.has('a')) {
                    $n.on('click', function (ev) {
                        ev.preventDefault();

                        $this.datepicker('show');
                    });
                }

                if ($p.is('.input-group-addon') && $p.has('a')) {
                    $p.on('click', function (ev) {
                        ev.preventDefault();

                        $this.datepicker('show');
                    });
                }
            });
        }



        // Date Range Picker
        if ($.isFunction($.fn.daterangepicker)) {
            $(".daterange").each(function (i, el) {
                // Change the range as you desire
                var ranges = {
                    'Today': [moment(), moment()],
                    'Yesterday': [moment().subtract('days', 1), moment().subtract('days', 1)],
                    'Last 7 Days': [moment().subtract('days', 6), moment()],
                    'Last 30 Days': [moment().subtract('days', 29), moment()],
                    'This Month': [moment().startOf('month'), moment().endOf('month')],
                    'Last Month': [moment().subtract('month', 1).startOf('month'), moment().subtract('month', 1).endOf('month')]
                };

                var $this = $(el),
                    opts = {
                        format: attrDefault($this, 'format', 'MM/DD/YYYY'),
                        timePicker: attrDefault($this, 'timePicker', false),
                        timePickerIncrement: attrDefault($this, 'timePickerIncrement', false),
                        separator: attrDefault($this, 'separator', ' - '),
                    },
                    min_date = attrDefault($this, 'minDate', ''),
                    max_date = attrDefault($this, 'maxDate', ''),
                    start_date = attrDefault($this, 'startDate', ''),
                    end_date = attrDefault($this, 'endDate', '');

                if ($this.hasClass('add-ranges')) {
                    opts['ranges'] = ranges;
                }

                if (min_date.length) {
                    opts['minDate'] = min_date;
                }

                if (max_date.length) {
                    opts['maxDate'] = max_date;
                }

                if (start_date.length) {
                    opts['startDate'] = start_date;
                }

                if (end_date.length) {
                    opts['endDate'] = end_date;
                }


                $this.daterangepicker(opts, function (start, end) {
                    var drp = $this.data('daterangepicker');

                    if ($this.is('[data-callback]')) {
                        //daterange_callback(start, end);
                        callback_test(start, end);
                    }

                    if ($this.hasClass('daterange-inline')) {
                        $this.find('span').html(start.format(drp.format) + drp.separator + end.format(drp.format));
                    }
                });

                if (typeof opts['ranges'] == 'object') {
                    $this.data('daterangepicker').container.removeClass('show-calendar');
                }
            });
        }



        // Timepicker
        if ($.isFunction($.fn.timepicker)) {
            $(".timepicker").each(function (i, el) {
                var $this = $(el),
                    opts = {
                        template: attrDefault($this, 'template', false),
                        showSeconds: attrDefault($this, 'showSeconds', false),
                        defaultTime: attrDefault($this, 'defaultTime', 'current'),
                        showMeridian: attrDefault($this, 'showMeridian', true),
                        minuteStep: attrDefault($this, 'minuteStep', 15),
                        secondStep: attrDefault($this, 'secondStep', 15)
                    },
                    $n = $this.next(),
                    $p = $this.prev();

                $this.timepicker(opts);

                if ($n.is('.input-group-addon') && $n.has('a')) {
                    $n.on('click', function (ev) {
                        ev.preventDefault();

                        $this.timepicker('showWidget');
                    });
                }

                if ($p.is('.input-group-addon') && $p.has('a')) {
                    $p.on('click', function (ev) {
                        ev.preventDefault();

                        $this.timepicker('showWidget');
                    });
                }
            });
        }



        // Colorpicker
        if ($.isFunction($.fn.colorpicker)) {
            $(".colorpicker").each(function (i, el) {
                var $this = $(el),
                    opts = {
                    },
                    $n = $this.next(),
                    $p = $this.prev(),

                    $preview = $this.siblings('.input-group-addon').find('.color-preview');

                $this.colorpicker(opts);

                if ($n.is('.input-group-addon') && $n.has('a')) {
                    $n.on('click', function (ev) {
                        ev.preventDefault();

                        $this.colorpicker('show');
                    });
                }

                if ($p.is('.input-group-addon') && $p.has('a')) {
                    $p.on('click', function (ev) {
                        ev.preventDefault();

                        $this.colorpicker('show');
                    });
                }

                if ($preview.length) {
                    $this.on('changeColor', function (ev) {

                        $preview.css('background-color', ev.color.toHex());
                    });

                    if ($this.val().length) {
                        $preview.css('background-color', $this.val());
                    }
                }
            });
        }




        // Form Validation
        if ($.isFunction($.fn.validate)) {
            $("form.validate").each(function (i, el) {
                var $this = $(el),
                    opts = {
                        rules: {},
                        messages: {},
                        errorElement: 'span',
                        errorClass: 'validate-has-error',
                        highlight: function (element) {
                            $(element).closest('.form-group').addClass('validate-has-error');
                        },
                        unhighlight: function (element) {
                            $(element).closest('.form-group').removeClass('validate-has-error');
                        },
                        errorPlacement: function (error, element) {
                            if (element.closest('.has-switch').length) {
                                error.insertAfter(element.closest('.has-switch'));
                            }
                            else
                                if (element.parent('.checkbox, .radio').length || element.parent('.input-group').length) {
                                    error.insertAfter(element.parent());
                                }
                                else {
                                    error.insertAfter(element);
                                }
                        }
                    },
                    $fields = $this.find('[data-validate]');


                $fields.each(function (j, el2) {
                    var $field = $(el2),
                        name = $field.attr('name'),
                        validate = attrDefault($field, 'validate', '').toString(),
                        _validate = validate.split(',');

                    for (var k in _validate) {
                        var rule = _validate[k],
                            params,
                            message;

                        if (typeof opts['rules'][name] == 'undefined') {
                            opts['rules'][name] = {};
                            opts['messages'][name] = {};
                        }

                        if ($.inArray(rule, ['required', 'url', 'email', 'number', 'date', 'creditcard']) != -1) {
                            opts['rules'][name][rule] = true;

                            message = $field.data('message-' + rule);

                            if (message) {
                                opts['messages'][name][rule] = message;
                            }
                        }
                        // Parameter Value (#1 parameter)
                        else
                            if (params = rule.match(/(\w+)\[(.*?)\]/i)) {
                                if ($.inArray(params[1], ['min', 'max', 'minlength', 'maxlength', 'equalTo']) != -1) {
                                    opts['rules'][name][params[1]] = params[2];


                                    message = $field.data('message-' + params[1]);

                                    if (message) {
                                        opts['messages'][name][params[1]] = message;
                                    }
                                }
                            }
                    }
                });

                $this.validate(opts);
            });
        }




        // Input Mask
        if ($.isFunction($.fn.inputmask)) {
            $("[data-mask]").each(function (i, el) {
                var $this = $(el),
                    mask = $this.data('mask').toString(),
                    opts = {
                        numericInput: attrDefault($this, 'numeric', false),
                        radixPoint: attrDefault($this, 'radixPoint', ''),
                        rightAlign: attrDefault($this, 'numericAlign', 'left') == 'right'
                    },
                    placeholder = attrDefault($this, 'placeholder', ''),
                    is_regex = attrDefault($this, 'isRegex', '');

                if (placeholder.length) {
                    opts[placeholder] = placeholder;
                }

                switch (mask.toLowerCase()) {
                    case "phone":
                        mask = "(999) 999-9999";
                        break;

                    case "currency":
                    case "rcurrency":

                        var sign = attrDefault($this, 'sign', '$');;

                        mask = "999,999,999.99";

                        if ($this.data('mask').toLowerCase() == 'rcurrency') {
                            mask += ' ' + sign;
                        }
                        else {
                            mask = sign + ' ' + mask;
                        }

                        opts.numericInput = true;
                        opts.rightAlignNumerics = false;
                        opts.radixPoint = '.';
                        break;

                    case "email":
                        mask = 'Regex';
                        opts.regex = "[a-zA-Z0-9._%-]+@[a-zA-Z0-9-]+\\.[a-zA-Z]{2,4}";
                        break;

                    case "fdecimal":
                        mask = 'decimal';
                        $.extend(opts, {
                            autoGroup: true,
                            groupSize: 3,
                            radixPoint: attrDefault($this, 'rad', '.'),
                            groupSeparator: attrDefault($this, 'dec', ',')
                        });
                }

                if (is_regex) {
                    opts.regex = mask;
                    mask = 'Regex';
                }

                $this.inputmask(mask, opts);
            });
        }



        // Form Wizard
        if ($.isFunction($.fn.bootstrapWizard)) {
            $(".form-wizard").each(function (i, el) {
                var $this = $(el),
                    $tabs = $this.find('> .tabs > li'),
                    $progress = $this.find(".progress-indicator"),
                    _index = $this.find('> ul > li.active').index();

                // Validation
                var checkFormWizardValidaion = function (tab, navigation, index) {
                    if ($this.hasClass('validate')) {
                        var $valid = $this.valid();

                        if (!$valid) {
                            $this.data('validator').focusInvalid();
                            return false;
                        }
                    }

                    return true;
                };

                // Setup Progress
                if (_index > 0) {
                    $progress.css({ width: _index / $tabs.length * 100 + '%' });
                    $tabs.removeClass('completed').slice(0, _index).addClass('completed');
                }

                $this.bootstrapWizard({
                    tabClass: "",
                    onTabShow: function ($tab, $navigation, index) {
                        var pct = $tabs.eq(index).position().left / $tabs.parent().width() * 100;

                        $tabs.removeClass('completed').slice(0, index).addClass('completed');
                        $progress.css({ width: pct + '%' });
                    },

                    onNext: checkFormWizardValidaion,
                    onTabClick: checkFormWizardValidaion
                });

                $this.data('bootstrapWizard').show(_index);

                $this.find('.pager a').on('click', function (ev) {
                    ev.preventDefault();
                });
            });
        }




        // Slider
        if ($.isFunction($.fn.slider)) {
            $(".slider").each(function (i, el) {
                var $this = $(el),
                    $label_1 = $('<span class="ui-label"></span>'),
                    $label_2 = $label_1.clone(),

                    orientation = attrDefault($this, 'vertical', 0) != 0 ? 'vertical' : 'horizontal',

                    prefix = attrDefault($this, 'prefix', ''),
                    postfix = attrDefault($this, 'postfix', ''),

                    fill = attrDefault($this, 'fill', ''),
                    $fill = $(fill),

                    step = attrDefault($this, 'step', 1),
                    value = attrDefault($this, 'value', 5),
                    min = attrDefault($this, 'min', 0),
                    max = attrDefault($this, 'max', 100),
                    min_val = attrDefault($this, 'min-val', 10),
                    max_val = attrDefault($this, 'max-val', 90),

                    is_range = $this.is('[data-min-val]') || $this.is('[data-max-val]'),

                    reps = 0;


                // Range Slider Options
                if (is_range) {
                    $this.slider({
                        range: true,
                        orientation: orientation,
                        min: min,
                        max: max,
                        values: [min_val, max_val],
                        step: step,
                        slide: function (e, ui) {
                            var min_val = (prefix ? prefix : '') + ui.values[0] + (postfix ? postfix : ''),
                                max_val = (prefix ? prefix : '') + ui.values[1] + (postfix ? postfix : '');

                            $label_1.html(min_val);
                            $label_2.html(max_val);

                            if (fill)
                                $fill.val(min_val + ',' + max_val);

                            reps++;
                        },
                        change: function (ev, ui) {
                            if (reps == 1) {
                                var min_val = (prefix ? prefix : '') + ui.values[0] + (postfix ? postfix : ''),
                                    max_val = (prefix ? prefix : '') + ui.values[1] + (postfix ? postfix : '');

                                $label_1.html(min_val);
                                $label_2.html(max_val);

                                if (fill)
                                    $fill.val(min_val + ',' + max_val);
                            }

                            reps = 0;
                        }
                    });

                    var $handles = $this.find('.ui-slider-handle');

                    $label_1.html((prefix ? prefix : '') + min_val + (postfix ? postfix : ''));
                    $handles.first().append($label_1);

                    $label_2.html((prefix ? prefix : '') + max_val + (postfix ? postfix : ''));
                    $handles.last().append($label_2);
                }
                // Normal Slider
                else {

                    $this.slider({
                        range: attrDefault($this, 'basic', 0) ? false : "min",
                        orientation: orientation,
                        min: min,
                        max: max,
                        value: value,
                        step: step,
                        slide: function (ev, ui) {
                            var val = (prefix ? prefix : '') + ui.value + (postfix ? postfix : '');

                            $label_1.html(val);


                            if (fill)
                                $fill.val(val);

                            reps++;
                        },
                        change: function (ev, ui) {
                            if (reps == 1) {
                                var val = (prefix ? prefix : '') + ui.value + (postfix ? postfix : '');

                                $label_1.html(val);

                                if (fill)
                                    $fill.val(val);
                            }

                            reps = 0;
                        }
                    });

                    var $handles = $this.find('.ui-slider-handle');
                    //$fill = $('<div class="ui-fill"></div>');

                    $label_1.html((prefix ? prefix : '') + value + (postfix ? postfix : ''));
                    $handles.html($label_1);

                    //$handles.parent().prepend( $fill );

                    //$fill.width($handles.get(0).style.left);
                }

            })
        }




        // jQuery Knob
        if ($.isFunction($.fn.knob)) {
            $(".knob").knob({
                change: function (value) {
                },
                release: function (value) {
                },
                cancel: function () {
                },
                draw: function () {

                    if (this.$.data('skin') == 'tron') {

                        var a = this.angle(this.cv) // Angle
                            ,
                            sa = this.startAngle // Previous start angle
                            ,
                            sat = this.startAngle // Start angle
                            ,
                            ea // Previous end angle
                            , eat = sat + a // End angle
                            ,
                            r = 1;

                        this.g.lineWidth = this.lineWidth;

                        this.o.cursor && (sat = eat - 0.3) && (eat = eat + 0.3);

                        if (this.o.displayPrevious) {
                            ea = this.startAngle + this.angle(this.v);
                            this.o.cursor && (sa = ea - 0.3) && (ea = ea + 0.3);
                            this.g.beginPath();
                            this.g.strokeStyle = this.pColor;
                            this.g.arc(this.xy, this.xy, this.radius - this.lineWidth, sa, ea, false);
                            this.g.stroke();
                        }

                        this.g.beginPath();
                        this.g.strokeStyle = r ? this.o.fgColor : this.fgColor;
                        this.g.arc(this.xy, this.xy, this.radius - this.lineWidth, sat, eat, false);
                        this.g.stroke();

                        this.g.lineWidth = 2;
                        this.g.beginPath();
                        this.g.strokeStyle = this.o.fgColor;
                        this.g.arc(this.xy, this.xy, this.radius - this.lineWidth + 1 + this.lineWidth * 2 / 3, 0, 2 * Math.PI, false);
                        this.g.stroke();

                        return false;
                    }
                }
            });
        }




        // Wysiwyg Editor
        if ($.isFunction($.fn.wysihtml5)) {
            $(".wysihtml5").each(function (i, el) {
                var $this = $(el),
                    stylesheets = attrDefault($this, 'stylesheet-url', '')

                $(".wysihtml5").wysihtml5({
                    size: 'white',
                    stylesheets: stylesheets.split(','),
                    "html": attrDefault($this, 'html', true),
                    "color": attrDefault($this, 'colors', true),
                });
            });
        }




        // CKeditor WYSIWYG
        if ($.isFunction($.fn.ckeditor)) {
            $(".ckeditor").ckeditor({
                contentsLangDirection: rtl() ? 'rtl' : 'ltr'
            });
        }



        // Dropzone is prezent
        if (typeof Dropzone != 'undefined') {
            Dropzone.autoDiscover = false;

            $(".dropzone[action]").each(function (i, el) {
                $(el).dropzone();
            });
        }




        // Tocify Table
        if ($.isFunction($.fn.tocify) && $("#toc").length) {
            $("#toc").tocify({
                context: '.tocify-content',
                selectors: "h2,h3,h4,h5"
            });


            var $this = $(".tocify"),
                watcher = scrollMonitor.create($this.get(0));

            $this.width($this.parent().width());

            watcher.lock();

            watcher.stateChange(function () {
                $($this.get(0)).toggleClass('fixed', this.isAboveViewport)
            });
        }



        // Login Form Label Focusing
        $(".login-form .form-group:has(label)").each(function (i, el) {
            var $this = $(el),
                $label = $this.find('label'),
                $input = $this.find('.form-control');

            $input.on('focus', function () {
                $this.addClass('is-focused');
            });

            $input.on('keydown', function () {
                $this.addClass('is-focused');
            });

            $input.on('blur', function () {
                $this.removeClass('is-focused');

                if ($input.val().trim().length > 0) {
                    $this.addClass('is-focused');
                }
            });

            $label.on('click', function () {
                $input.focus();
            });

            if ($input.val().trim().length > 0) {
                $this.addClass('is-focused');
            }
        });

    });


    // Enable/Disable Resizable Event
    var wid = 0;

    $(window).resize(function () {
        clearTimeout(wid);
        wid = setTimeout(trigger_resizable, 200);
    });


})(jQuery, window);



// Sideber Menu Setup function
var sm_duration = .2,
    sm_transition_delay = 150;

function setup_sidebar_menu() {
    if (public_vars.$sidebarMenu.length) {
        var $items_with_subs = public_vars.$sidebarMenu.find('li:has(> ul)'),
            toggle_others = public_vars.$sidebarMenu.hasClass('toggle-others');

        $items_with_subs.filter('.active').addClass('expanded');

        // On larger screens collapse sidebar when the window is tablet screen
        if (is('largescreen') && public_vars.$sidebarMenu.hasClass('collapsed') == false) {
            $(window).on('resize', function () {
                if (is('tabletscreen')) {
                    public_vars.$sidebarMenu.addClass('collapsed');
                    ps_destroy();
                }
                else
                    if (is('largescreen')) {
                        public_vars.$sidebarMenu.removeClass('collapsed');
                        ps_init();
                    }
            });
        }

        $items_with_subs.each(function (i, el) {
            var $li = jQuery(el),
                $a = $li.children('a'),
                $sub = $li.children('ul');

            $li.addClass('has-sub');

            $a.on('click', function (ev) {
                ev.preventDefault();

                if (toggle_others) {
                    sidebar_menu_close_items_siblings($li);
                }

                if ($li.hasClass('expanded') || $li.hasClass('opened'))
                    sidebar_menu_item_collapse($li, $sub);
                else
                    sidebar_menu_item_expand($li, $sub);
            });
        });
    }
}

function sidebar_menu_item_expand($li, $sub) {
    if ($li.data('is-busy') || ($li.parent('.main-menu').length && public_vars.$sidebarMenu.hasClass('collapsed')))
        return;

    $li.addClass('expanded').data('is-busy', true);
    $sub.show();

    var $sub_items = $sub.children(),
        sub_height = $sub.outerHeight(),

        win_y = jQuery(window).height(),
        total_height = $li.outerHeight(),
        current_y = public_vars.$sidebarMenu.scrollTop(),
        item_max_y = $li.position().top + current_y,
        fit_to_viewpport = public_vars.$sidebarMenu.hasClass('fit-in-viewport');

    $sub_items.addClass('is-hidden');
    $sub.height(0);


    TweenMax.to($sub, sm_duration, {
        css: { height: sub_height }, onUpdate: ps_update, onComplete: function () {
            $sub.height('');
        }
    });

    var interval_1 = $li.data('sub_i_1'),
        interval_2 = $li.data('sub_i_2');

    window.clearTimeout(interval_1);

    interval_1 = setTimeout(function () {
        $sub_items.each(function (i, el) {
            var $sub_item = jQuery(el);

            $sub_item.addClass('is-shown');
        });

        var finish_on = sm_transition_delay * $sub_items.length,
            t_duration = parseFloat($sub_items.eq(0).css('transition-duration')),
            t_delay = parseFloat($sub_items.last().css('transition-delay'));

        if (t_duration && t_delay) {
            finish_on = (t_duration + t_delay) * 1000;
        }

        // In the end
        window.clearTimeout(interval_2);

        interval_2 = setTimeout(function () {
            $sub_items.removeClass('is-hidden is-shown');

        }, finish_on);


        $li.data('is-busy', false);

    }, 0);

    $li.data('sub_i_1', interval_1),
        $li.data('sub_i_2', interval_2);
}

function sidebar_menu_item_collapse($li, $sub) {
    if ($li.data('is-busy'))
        return;

    var $sub_items = $sub.children();

    $li.removeClass('expanded').data('is-busy', true);
    $sub_items.addClass('hidden-item');

    TweenMax.to($sub, sm_duration, {
        css: { height: 0 }, onUpdate: ps_update, onComplete: function () {
            $li.data('is-busy', false).removeClass('opened');

            $sub.attr('style', '').hide();
            $sub_items.removeClass('hidden-item');

            $li.find('li.expanded ul').attr('style', '').hide().parent().removeClass('expanded');

            ps_update(true);
        }
    });
}

function sidebar_menu_close_items_siblings($li) {
    $li.siblings().not($li).filter('.expanded, .opened').each(function (i, el) {
        var $_li = jQuery(el),
            $_sub = $_li.children('ul');

        sidebar_menu_item_collapse($_li, $_sub);
    });
}


// Horizontal Menu
function setup_horizontal_menu() {
    if (public_vars.$horizontalMenu.length) {
        var $items_with_subs = public_vars.$horizontalMenu.find('li:has(> ul)'),
            click_to_expand = public_vars.$horizontalMenu.hasClass('click-to-expand');

        if (click_to_expand) {
            public_vars.$mainContent.add(public_vars.$sidebarMenu).on('click', function (ev) {
                $items_with_subs.removeClass('hover');
            });
        }

        $items_with_subs.each(function (i, el) {
            var $li = jQuery(el),
                $a = $li.children('a'),
                $sub = $li.children('ul'),
                is_root_element = $li.parent().is('.navbar-nav');

            $li.addClass('has-sub');

            // Mobile Only
            $a.on('click', function (ev) {
                if (isxs()) {
                    ev.preventDefault();

                    // Automatically will toggle other menu items in mobile view
                    if (true) {
                        sidebar_menu_close_items_siblings($li);
                    }

                    if ($li.hasClass('expanded') || $li.hasClass('opened'))
                        sidebar_menu_item_collapse($li, $sub);
                    else
                        sidebar_menu_item_expand($li, $sub);
                }
            });

            // Click To Expand
            if (click_to_expand) {
                $a.on('click', function (ev) {
                    ev.preventDefault();

                    if (isxs())
                        return;

                    // For parents only
                    if (is_root_element) {
                        $items_with_subs.filter(function (i, el) { return jQuery(el).parent().is('.navbar-nav'); }).not($li).removeClass('hover');
                        $li.toggleClass('hover');
                    }
                    // Sub menus
                    else {
                        var sub_height;

                        // To Expand
                        if ($li.hasClass('expanded') == false) {
                            $li.addClass('expanded');
                            $sub.addClass('is-visible');

                            sub_height = $sub.outerHeight();

                            $sub.height(0);

                            TweenLite.to($sub, .15, { css: { height: sub_height }, ease: Sine.easeInOut, onComplete: function () { $sub.attr('style', ''); } });

                            // Hide Existing in the list
                            $li.siblings().find('> ul.is-visible').not($sub).each(function (i, el) {
                                var $el = jQuery(el);

                                sub_height = $el.outerHeight();

                                $el.removeClass('is-visible').height(sub_height);
                                $el.parent().removeClass('expanded');

                                TweenLite.to($el, .15, { css: { height: 0 }, onComplete: function () { $el.attr('style', ''); } });
                            });
                        }
                        // To Collapse
                        else {
                            sub_height = $sub.outerHeight();

                            $li.removeClass('expanded');
                            $sub.removeClass('is-visible').height(sub_height);
                            TweenLite.to($sub, .15, { css: { height: 0 }, onComplete: function () { $sub.attr('style', ''); } });
                        }
                    }
                });
            }
            // Hover To Expand
            else {
                $li.hoverIntent({
                    over: function () {
                        if (isxs())
                            return;

                        if (is_root_element) {
                            $li.addClass('hover');
                        }
                        else {
                            $sub.addClass('is-visible');
                            sub_height = $sub.outerHeight();

                            $sub.height(0);

                            TweenLite.to($sub, .25, { css: { height: sub_height }, ease: Sine.easeInOut, onComplete: function () { $sub.attr('style', ''); } });
                        }
                    },
                    out: function () {
                        if (isxs())
                            return;

                        if (is_root_element) {
                            $li.removeClass('hover');
                        }
                        else {
                            sub_height = $sub.outerHeight();

                            $li.removeClass('expanded');
                            $sub.removeClass('is-visible').height(sub_height);
                            TweenLite.to($sub, .25, { css: { height: 0 }, onComplete: function () { $sub.attr('style', ''); } });
                        }
                    },
                    timeout: 200,
                    interval: is_root_element ? 10 : 100
                });
            }
        });
    }
}


function stickFooterToBottom() {
    public_vars.$mainFooter.add(public_vars.$mainContent).add(public_vars.$sidebarMenu).attr('style', '');

    if (isxs())
        return false;

    if (public_vars.$mainFooter.hasClass('sticky')) {
        var win_height = jQuery(window).height(),
            footer_height = public_vars.$mainFooter.outerHeight(true),
            main_content_height = public_vars.$mainFooter.position().top + footer_height,
            main_content_height_only = main_content_height - footer_height,
            extra_height = public_vars.$horizontalNavbar.outerHeight();


        if (win_height > main_content_height - parseInt(public_vars.$mainFooter.css('marginTop'), 10)) {
            public_vars.$mainFooter.css({
                marginTop: win_height - main_content_height - extra_height
            });
        }
    }
}


// Perfect scroll bar functions by Arlind Nushi
function ps_update(destroy_init) {
    if (isxs())
        return;

    if (jQuery.isFunction(jQuery.fn.perfectScrollbar)) {
        if (public_vars.$sidebarMenu.hasClass('collapsed')) {
            return;
        }

        public_vars.$sidebarMenu.find('.sidebar-menu-inner').perfectScrollbar('update');

        if (destroy_init) {
            ps_destroy();
            ps_init();
        }
    }
}


function ps_init() {
    if (isxs())
        return;

    if (jQuery.isFunction(jQuery.fn.perfectScrollbar)) {
        if (public_vars.$sidebarMenu.hasClass('collapsed') || !public_vars.$sidebarMenu.hasClass('fixed')) {
            return;
        }

        public_vars.$sidebarMenu.find('.sidebar-menu-inner').perfectScrollbar({
            wheelSpeed: 1,
            wheelPropagation: public_vars.wheelPropagation
        });
    }
}

function ps_destroy() {
    if (jQuery.isFunction(jQuery.fn.perfectScrollbar)) {
        public_vars.$sidebarMenu.find('.sidebar-menu-inner').perfectScrollbar('destroy');
    }
}



// Radio and Check box replacement by Arlind Nushi
function cbr_replace() {
    var $inputs = jQuery('input[type="checkbox"].cbr, input[type="radio"].cbr').filter(':not(.cbr-done)'),
        $wrapper = '<div class="cbr-replaced"><div class="cbr-input"></div><div class="cbr-state"><span></span></div></div>';

    $inputs.each(function (i, el) {
        var $el = jQuery(el),
            is_radio = $el.is(':radio'),
            is_checkbox = $el.is(':checkbox'),
            is_disabled = $el.is(':disabled'),
            styles = ['primary', 'secondary', 'success', 'danger', 'warning', 'info', 'purple', 'blue', 'red', 'gray', 'pink', 'yellow', 'orange', 'turquoise'];

        if (!is_radio && !is_checkbox)
            return;

        $el.after($wrapper);
        $el.addClass('cbr-done');

        var $wrp = $el.next();
        $wrp.find('.cbr-input').append($el);

        if (is_radio)
            $wrp.addClass('cbr-radio');

        if (is_disabled)
            $wrp.addClass('cbr-disabled');

        if ($el.is(':checked')) {
            $wrp.addClass('cbr-checked');
        }


        // Style apply
        jQuery.each(styles, function (key, val) {
            var cbr_class = 'cbr-' + val;

            if ($el.hasClass(cbr_class)) {
                $wrp.addClass(cbr_class);
                $el.removeClass(cbr_class);
            }
        });


        // Events
        $wrp.on('click', function (ev) {
            if (is_radio && $el.prop('checked') || $wrp.parent().is('label'))
                return;

            if (jQuery(ev.target).is($el) == false) {
                $el.prop('checked', !$el.is(':checked'));
                $el.trigger('change');
            }
        });

        $el.on('change', function (ev) {
            $wrp.removeClass('cbr-checked');

            if ($el.is(':checked'))
                $wrp.addClass('cbr-checked');

            cbr_recheck();
        });
    });
}


function cbr_recheck() {
    var $inputs = jQuery("input.cbr-done");

    $inputs.each(function (i, el) {
        var $el = jQuery(el),
            is_radio = $el.is(':radio'),
            is_checkbox = $el.is(':checkbox'),
            is_disabled = $el.is(':disabled'),
            $wrp = $el.closest('.cbr-replaced');

        if (is_disabled)
            $wrp.addClass('cbr-disabled');

        if (is_radio && !$el.prop('checked') && $wrp.hasClass('cbr-checked')) {
            $wrp.removeClass('cbr-checked');
        }
    });
}


// Element Attribute Helper
function attrDefault($el, data_var, default_val) {
    if (typeof $el.data(data_var) != 'undefined') {
        return $el.data(data_var);
    }

    return default_val;
}


// Test function
function callback_test() {
    alert("Callback function executed! No. of arguments: " + arguments.length + "\n\nSee console log for outputed of the arguments.");

    console.log(arguments);
}


// Date Formatter
function date(format, timestamp) {
    //	discuss at: http://phpjs.org/functions/date/
    // original by: Carlos R. L. Rodrigues (http://www.jsfromhell.com)
    // original by: gettimeofday
    //	parts by: Peter-Paul Koch (http://www.quirksmode.org/js/beat.html)
    // improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // improved by: MeEtc (http://yass.meetcweb.com)
    // improved by: Brad Touesnard
    // improved by: Tim Wiel
    // improved by: Bryan Elliott
    // improved by: David Randall
    // improved by: Theriault
    // improved by: Theriault
    // improved by: Brett Zamir (http://brett-zamir.me)
    // improved by: Theriault
    // improved by: Thomas Beaucourt (http://www.webapp.fr)
    // improved by: JT
    // improved by: Theriault
    // improved by: Rafał Kukawski (http://blog.kukawski.pl)
    // improved by: Theriault
    //	input by: Brett Zamir (http://brett-zamir.me)
    //	input by: majak
    //	input by: Alex
    //	input by: Martin
    //	input by: Alex Wilson
    //	input by: Haravikk
    // bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // bugfixed by: majak
    // bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // bugfixed by: Brett Zamir (http://brett-zamir.me)
    // bugfixed by: omid (http://phpjs.org/functions/380:380#comment_137122)
    // bugfixed by: Chris (http://www.devotis.nl/)
    //		note: Uses global: php_js to store the default timezone
    //		note: Although the function potentially allows timezone info (see notes), it currently does not set
    //		note: per a timezone specified by date_default_timezone_set(). Implementers might use
    //		note: this.php_js.currentTimezoneOffset and this.php_js.currentTimezoneDST set by that function
    //		note: in order to adjust the dates in this function (or our other date functions!) accordingly
    //	 example 1: date('H:m:s \\m \\i\\s \\m\\o\\n\\t\\h', 1062402400);
    //	 returns 1: '09:09:40 m is month'
    //	 example 2: date('F j, Y, g:i a', 1062462400);
    //	 returns 2: 'September 2, 2003, 2:26 am'
    //	 example 3: date('Y W o', 1062462400);
    //	 returns 3: '2003 36 2003'
    //	 example 4: x = date('Y m d', (new Date()).getTime()/1000);
    //	 example 4: (x+'').length == 10 // 2009 01 09
    //	 returns 4: true
    //	 example 5: date('W', 1104534000);
    //	 returns 5: '53'
    //	 example 6: date('B t', 1104534000);
    //	 returns 6: '999 31'
    //	 example 7: date('W U', 1293750000.82); // 2010-12-31
    //	 returns 7: '52 1293750000'
    //	 example 8: date('W', 1293836400); // 2011-01-01
    //	 returns 8: '52'
    //	 example 9: date('W Y-m-d', 1293974054); // 2011-01-02
    //	 returns 9: '52 2011-01-02'

    var that = this;
    var jsdate, f;
    // Keep this here (works, but for code commented-out below for file size reasons)
    // var tal= [];
    var txt_words = [
        'Sun', 'Mon', 'Tues', 'Wednes', 'Thurs', 'Fri', 'Satur',
        'January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'
    ];
    // trailing backslash -> (dropped)
    // a backslash followed by any character (including backslash) -> the character
    // empty string -> empty string
    var formatChr = /\\?(.?)/gi;
    var formatChrCb = function (t, s) {
        return f[t] ? f[t]() : s;
    };
    var _pad = function (n, c) {
        n = String(n);
        while (n.length < c) {
            n = '0' + n;
        }
        return n;
    };
    f = {
        // Day
        d: function () {
            // Day of month w/leading 0; 01..31
            return _pad(f.j(), 2);
        },
        D: function () {
            // Shorthand day name; Mon...Sun
            return f.l()
                .slice(0, 3);
        },
        j: function () {
            // Day of month; 1..31
            return jsdate.getDate();
        },
        l: function () {
            // Full day name; Monday...Sunday
            return txt_words[f.w()] + 'day';
        },
        N: function () {
            // ISO-8601 day of week; 1[Mon]..7[Sun]
            return f.w() || 7;
        },
        S: function () {
            // Ordinal suffix for day of month; st, nd, rd, th
            var j = f.j();
            var i = j % 10;
            if (i <= 3 && parseInt((j % 100) / 10, 10) == 1) {
                i = 0;
            }
            return ['st', 'nd', 'rd'][i - 1] || 'th';
        },
        w: function () {
            // Day of week; 0[Sun]..6[Sat]
            return jsdate.getDay();
        },
        z: function () {
            // Day of year; 0..365
            var a = new Date(f.Y(), f.n() - 1, f.j());
            var b = new Date(f.Y(), 0, 1);
            return Math.round((a - b) / 864e5);
        },

        // Week
        W: function () {
            // ISO-8601 week number
            var a = new Date(f.Y(), f.n() - 1, f.j() - f.N() + 3);
            var b = new Date(a.getFullYear(), 0, 4);
            return _pad(1 + Math.round((a - b) / 864e5 / 7), 2);
        },

        // Month
        F: function () {
            // Full month name; January...December
            return txt_words[6 + f.n()];
        },
        m: function () {
            // Month w/leading 0; 01...12
            return _pad(f.n(), 2);
        },
        M: function () {
            // Shorthand month name; Jan...Dec
            return f.F()
                .slice(0, 3);
        },
        n: function () {
            // Month; 1...12
            return jsdate.getMonth() + 1;
        },
        t: function () {
            // Days in month; 28...31
            return (new Date(f.Y(), f.n(), 0))
                .getDate();
        },

        // Year
        L: function () {
            // Is leap year?; 0 or 1
            var j = f.Y();
            return j % 4 === 0 & j % 100 !== 0 | j % 400 === 0;
        },
        o: function () {
            // ISO-8601 year
            var n = f.n();
            var W = f.W();
            var Y = f.Y();
            return Y + (n === 12 && W < 9 ? 1 : n === 1 && W > 9 ? -1 : 0);
        },
        Y: function () {
            // Full year; e.g. 1980...2010
            return jsdate.getFullYear();
        },
        y: function () {
            // Last two digits of year; 00...99
            return f.Y()
                .toString()
                .slice(-2);
        },

        // Time
        a: function () {
            // am or pm
            return jsdate.getHours() > 11 ? 'pm' : 'am';
        },
        A: function () {
            // AM or PM
            return f.a()
                .toUpperCase();
        },
        B: function () {
            // Swatch Internet time; 000..999
            var H = jsdate.getUTCHours() * 36e2;
            // Hours
            var i = jsdate.getUTCMinutes() * 60;
            // Minutes
            // Seconds
            var s = jsdate.getUTCSeconds();
            return _pad(Math.floor((H + i + s + 36e2) / 86.4) % 1e3, 3);
        },
        g: function () {
            // 12-Hours; 1..12
            return f.G() % 12 || 12;
        },
        G: function () {
            // 24-Hours; 0..23
            return jsdate.getHours();
        },
        h: function () {
            // 12-Hours w/leading 0; 01..12
            return _pad(f.g(), 2);
        },
        H: function () {
            // 24-Hours w/leading 0; 00..23
            return _pad(f.G(), 2);
        },
        i: function () {
            // Minutes w/leading 0; 00..59
            return _pad(jsdate.getMinutes(), 2);
        },
        s: function () {
            // Seconds w/leading 0; 00..59
            return _pad(jsdate.getSeconds(), 2);
        },
        u: function () {
            // Microseconds; 000000-999000
            return _pad(jsdate.getMilliseconds() * 1000, 6);
        },

        // Timezone
        e: function () {
            // Timezone identifier; e.g. Atlantic/Azores, ...
            // The following works, but requires inclusion of the very large
            // timezone_abbreviations_list() function.
            /*				return that.date_default_timezone_get();
             */
            throw 'Not supported (see source code of date() for timezone on how to add support)';
        },
        I: function () {
            // DST observed?; 0 or 1
            // Compares Jan 1 minus Jan 1 UTC to Jul 1 minus Jul 1 UTC.
            // If they are not equal, then DST is observed.
            var a = new Date(f.Y(), 0);
            // Jan 1
            var c = Date.UTC(f.Y(), 0);
            // Jan 1 UTC
            var b = new Date(f.Y(), 6);
            // Jul 1
            // Jul 1 UTC
            var d = Date.UTC(f.Y(), 6);
            return ((a - c) !== (b - d)) ? 1 : 0;
        },
        O: function () {
            // Difference to GMT in hour format; e.g. +0200
            var tzo = jsdate.getTimezoneOffset();
            var a = Math.abs(tzo);
            return (tzo > 0 ? '-' : '+') + _pad(Math.floor(a / 60) * 100 + a % 60, 4);
        },
        P: function () {
            // Difference to GMT w/colon; e.g. +02:00
            var O = f.O();
            return (O.substr(0, 3) + ':' + O.substr(3, 2));
        },
        T: function () {
            // Timezone abbreviation; e.g. EST, MDT, ...
            // The following works, but requires inclusion of the very
            // large timezone_abbreviations_list() function.
            /*				var abbr, i, os, _default;
            if (!tal.length) {
            tal = that.timezone_abbreviations_list();
            }
            if (that.php_js && that.php_js.default_timezone) {
            _default = that.php_js.default_timezone;
            for (abbr in tal) {
                for (i = 0; i < tal[abbr].length; i++) {
                if (tal[abbr][i].timezone_id === _default) {
                    return abbr.toUpperCase();
                }
                }
            }
            }
            for (abbr in tal) {
            for (i = 0; i < tal[abbr].length; i++) {
                os = -jsdate.getTimezoneOffset() * 60;
                if (tal[abbr][i].offset === os) {
                return abbr.toUpperCase();
                }
            }
            }
            */
            return 'UTC';
        },
        Z: function () {
            // Timezone offset in seconds (-43200...50400)
            return -jsdate.getTimezoneOffset() * 60;
        },

        // Full Date/Time
        c: function () {
            // ISO-8601 date.
            return 'Y-m-d\\TH:i:sP'.replace(formatChr, formatChrCb);
        },
        r: function () {
            // RFC 2822
            return 'D, d M Y H:i:s O'.replace(formatChr, formatChrCb);
        },
        U: function () {
            // Seconds since UNIX epoch
            return jsdate / 1000 | 0;
        }
    };

    this.date = function (format, timestamp) {
        that = this;
        jsdate = (timestamp === undefined ? new Date() : // Not provided
            (timestamp instanceof Date) ? new Date(timestamp) : // JS Date()
                new Date(timestamp * 1000) // UNIX timestamp (auto-convert to int)
        );
        return format.replace(formatChr, formatChrCb);
    };
    return this.date(format, timestamp);
}
/**!
 * AngularJS file upload directives and services. Supports: file upload/drop/paste, resume, cancel/abort,
 * progress, resize, thumbnail, preview, validation and CORS
 * FileAPI Flash shim for old browsers not supporting FormData
 * @author  Danial  <danial.farid@gmail.com>
 * @version 12.2.13
 */

(function () {
    /** @namespace FileAPI.noContentTimeout */

    function patchXHR(fnName, newFn) {
        window.XMLHttpRequest.prototype[fnName] = newFn(window.XMLHttpRequest.prototype[fnName]);
    }

    function redefineProp(xhr, prop, fn) {
        try {
            Object.defineProperty(xhr, prop, { get: fn });
        } catch (e) {/*ignore*/
        }
    }

    if (!window.FileAPI) {
        window.FileAPI = {};
    }

    if (!window.XMLHttpRequest) {
        throw 'AJAX is not supported. XMLHttpRequest is not defined.';
    }

    FileAPI.shouldLoad = !window.FormData || FileAPI.forceLoad;
    if (FileAPI.shouldLoad) {
        var initializeUploadListener = function (xhr) {
            if (!xhr.__listeners) {
                if (!xhr.upload) xhr.upload = {};
                xhr.__listeners = [];
                var origAddEventListener = xhr.upload.addEventListener;
                xhr.upload.addEventListener = function (t, fn) {
                    xhr.__listeners[t] = fn;
                    if (origAddEventListener) origAddEventListener.apply(this, arguments);
                };
            }
        };

        patchXHR('open', function (orig) {
            return function (m, url, b) {
                initializeUploadListener(this);
                this.__url = url;
                try {
                    orig.apply(this, [m, url, b]);
                } catch (e) {
                    if (e.message.indexOf('Access is denied') > -1) {
                        this.__origError = e;
                        orig.apply(this, [m, '_fix_for_ie_crossdomain__', b]);
                    }
                }
            };
        });

        patchXHR('getResponseHeader', function (orig) {
            return function (h) {
                return this.__fileApiXHR && this.__fileApiXHR.getResponseHeader ? this.__fileApiXHR.getResponseHeader(h) : (orig == null ? null : orig.apply(this, [h]));
            };
        });

        patchXHR('getAllResponseHeaders', function (orig) {
            return function () {
                return this.__fileApiXHR && this.__fileApiXHR.getAllResponseHeaders ? this.__fileApiXHR.getAllResponseHeaders() : (orig == null ? null : orig.apply(this));
            };
        });

        patchXHR('abort', function (orig) {
            return function () {
                return this.__fileApiXHR && this.__fileApiXHR.abort ? this.__fileApiXHR.abort() : (orig == null ? null : orig.apply(this));
            };
        });

        patchXHR('setRequestHeader', function (orig) {
            return function (header, value) {
                if (header === '__setXHR_') {
                    initializeUploadListener(this);
                    var val = value(this);
                    // fix for angular < 1.2.0
                    if (val instanceof Function) {
                        val(this);
                    }
                } else {
                    this.__requestHeaders = this.__requestHeaders || {};
                    this.__requestHeaders[header] = value;
                    orig.apply(this, arguments);
                }
            };
        });

        patchXHR('send', function (orig) {
            return function () {
                var xhr = this;
                if (arguments[0] && arguments[0].__isFileAPIShim) {
                    var formData = arguments[0];
                    var config = {
                        url: xhr.__url,
                        jsonp: false, //removes the callback form param
                        cache: true, //removes the ?fileapiXXX in the url
                        complete: function (err, fileApiXHR) {
                            if (err && angular.isString(err) && err.indexOf('#2174') !== -1) {
                                // this error seems to be fine the file is being uploaded properly.
                                err = null;
                            }
                            xhr.__completed = true;
                            if (!err && xhr.__listeners.load)
                                xhr.__listeners.load({
                                    type: 'load',
                                    loaded: xhr.__loaded,
                                    total: xhr.__total,
                                    target: xhr,
                                    lengthComputable: true
                                });
                            if (!err && xhr.__listeners.loadend)
                                xhr.__listeners.loadend({
                                    type: 'loadend',
                                    loaded: xhr.__loaded,
                                    total: xhr.__total,
                                    target: xhr,
                                    lengthComputable: true
                                });
                            if (err === 'abort' && xhr.__listeners.abort)
                                xhr.__listeners.abort({
                                    type: 'abort',
                                    loaded: xhr.__loaded,
                                    total: xhr.__total,
                                    target: xhr,
                                    lengthComputable: true
                                });
                            if (fileApiXHR.status !== undefined) redefineProp(xhr, 'status', function () {
                                return (fileApiXHR.status === 0 && err && err !== 'abort') ? 500 : fileApiXHR.status;
                            });
                            if (fileApiXHR.statusText !== undefined) redefineProp(xhr, 'statusText', function () {
                                return fileApiXHR.statusText;
                            });
                            redefineProp(xhr, 'readyState', function () {
                                return 4;
                            });
                            if (fileApiXHR.response !== undefined) redefineProp(xhr, 'response', function () {
                                return fileApiXHR.response;
                            });
                            var resp = fileApiXHR.responseText || (err && fileApiXHR.status === 0 && err !== 'abort' ? err : undefined);
                            redefineProp(xhr, 'responseText', function () {
                                return resp;
                            });
                            redefineProp(xhr, 'response', function () {
                                return resp;
                            });
                            if (err) redefineProp(xhr, 'err', function () {
                                return err;
                            });
                            xhr.__fileApiXHR = fileApiXHR;
                            if (xhr.onreadystatechange) xhr.onreadystatechange();
                            if (xhr.onload) xhr.onload();
                        },
                        progress: function (e) {
                            e.target = xhr;
                            if (xhr.__listeners.progress) xhr.__listeners.progress(e);
                            xhr.__total = e.total;
                            xhr.__loaded = e.loaded;
                            if (e.total === e.loaded) {
                                // fix flash issue that doesn't call complete if there is no response text from the server
                                var _this = this;
                                setTimeout(function () {
                                    if (!xhr.__completed) {
                                        xhr.getAllResponseHeaders = function () {
                                        };
                                        _this.complete(null, { status: 204, statusText: 'No Content' });
                                    }
                                }, FileAPI.noContentTimeout || 10000);
                            }
                        },
                        headers: xhr.__requestHeaders
                    };
                    config.data = {};
                    config.files = {};
                    for (var i = 0; i < formData.data.length; i++) {
                        var item = formData.data[i];
                        if (item.val != null && item.val.name != null && item.val.size != null && item.val.type != null) {
                            config.files[item.key] = item.val;
                        } else {
                            config.data[item.key] = item.val;
                        }
                    }

                    setTimeout(function () {
                        if (!FileAPI.hasFlash) {
                            throw 'Adode Flash Player need to be installed. To check ahead use "FileAPI.hasFlash"';
                        }
                        xhr.__fileApiXHR = FileAPI.upload(config);
                    }, 1);
                } else {
                    if (this.__origError) {
                        throw this.__origError;
                    }
                    orig.apply(xhr, arguments);
                }
            };
        });
        window.XMLHttpRequest.__isFileAPIShim = true;
        window.FormData = FormData = function () {
            return {
                append: function (key, val, name) {
                    if (val.__isFileAPIBlobShim) {
                        val = val.data[0];
                    }
                    this.data.push({
                        key: key,
                        val: val,
                        name: name
                    });
                },
                data: [],
                __isFileAPIShim: true
            };
        };

        window.Blob = Blob = function (b) {
            return {
                data: b,
                __isFileAPIBlobShim: true
            };
        };
    }

})();

(function () {
    /** @namespace FileAPI.forceLoad */
    /** @namespace window.FileAPI.jsUrl */
    /** @namespace window.FileAPI.jsPath */

    function isInputTypeFile(elem) {
        return elem[0].tagName.toLowerCase() === 'input' && elem.attr('type') && elem.attr('type').toLowerCase() === 'file';
    }

    function hasFlash() {
        try {
            var fo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
            if (fo) return true;
        } catch (e) {
            if (navigator.mimeTypes['application/x-shockwave-flash'] !== undefined) return true;
        }
        return false;
    }

    function getOffset(obj) {
        var left = 0, top = 0;

        if (window.jQuery) {
            return jQuery(obj).offset();
        }

        if (obj.offsetParent) {
            do {
                left += (obj.offsetLeft - obj.scrollLeft);
                top += (obj.offsetTop - obj.scrollTop);
                obj = obj.offsetParent;
            } while (obj);
        }
        return {
            left: left,
            top: top
        };
    }

    if (FileAPI.shouldLoad) {
        FileAPI.hasFlash = hasFlash();

        //load FileAPI
        if (FileAPI.forceLoad) {
            FileAPI.html5 = false;
        }

        if (!FileAPI.upload) {
            var jsUrl, basePath, script = document.createElement('script'), allScripts = document.getElementsByTagName('script'), i, index, src;
            if (window.FileAPI.jsUrl) {
                jsUrl = window.FileAPI.jsUrl;
            } else if (window.FileAPI.jsPath) {
                basePath = window.FileAPI.jsPath;
            } else {
                for (i = 0; i < allScripts.length; i++) {
                    src = allScripts[i].src;
                    index = src.search(/\/ng\-file\-upload[\-a-zA-z0-9\.]*\.js/);
                    if (index > -1) {
                        basePath = src.substring(0, index + 1);
                        break;
                    }
                }
            }

            if (FileAPI.staticPath == null) FileAPI.staticPath = basePath;
            script.setAttribute('src', jsUrl || basePath + 'FileAPI.min.js');
            document.getElementsByTagName('head')[0].appendChild(script);
        }

        FileAPI.ngfFixIE = function (elem, fileElem, changeFn) {
            if (!hasFlash()) {
                throw 'Adode Flash Player need to be installed. To check ahead use "FileAPI.hasFlash"';
            }
            var fixInputStyle = function () {
                var label = fileElem.parent();
                if (elem.attr('disabled')) {
                    if (label) label.removeClass('js-fileapi-wrapper');
                } else {
                    if (!fileElem.attr('__ngf_flash_')) {
                        fileElem.unbind('change');
                        fileElem.unbind('click');
                        fileElem.bind('change', function (evt) {
                            fileApiChangeFn.apply(this, [evt]);
                            changeFn.apply(this, [evt]);
                        });
                        fileElem.attr('__ngf_flash_', 'true');
                    }
                    label.addClass('js-fileapi-wrapper');
                    if (!isInputTypeFile(elem)) {
                        label.css('position', 'absolute')
                            .css('top', getOffset(elem[0]).top + 'px').css('left', getOffset(elem[0]).left + 'px')
                            .css('width', elem[0].offsetWidth + 'px').css('height', elem[0].offsetHeight + 'px')
                            .css('filter', 'alpha(opacity=0)').css('display', elem.css('display'))
                            .css('overflow', 'hidden').css('z-index', '900000')
                            .css('visibility', 'visible');
                        fileElem.css('width', elem[0].offsetWidth + 'px').css('height', elem[0].offsetHeight + 'px')
                            .css('position', 'absolute').css('top', '0px').css('left', '0px');
                    }
                }
            };

            elem.bind('mouseenter', fixInputStyle);

            var fileApiChangeFn = function (evt) {
                var files = FileAPI.getFiles(evt);
                //just a double check for #233
                for (var i = 0; i < files.length; i++) {
                    if (files[i].size === undefined) files[i].size = 0;
                    if (files[i].name === undefined) files[i].name = 'file';
                    if (files[i].type === undefined) files[i].type = 'undefined';
                }
                if (!evt.target) {
                    evt.target = {};
                }
                evt.target.files = files;
                // if evt.target.files is not writable use helper field
                if (evt.target.files !== files) {
                    evt.__files_ = files;
                }
                (evt.__files_ || evt.target.files).item = function (i) {
                    return (evt.__files_ || evt.target.files)[i] || null;
                };
            };
        };

        FileAPI.disableFileInput = function (elem, disable) {
            if (disable) {
                elem.removeClass('js-fileapi-wrapper');
            } else {
                elem.addClass('js-fileapi-wrapper');
            }
        };
    }
})();

if (!window.FileReader) {
    window.FileReader = function () {
        var _this = this, loadStarted = false;
        this.listeners = {};
        this.addEventListener = function (type, fn) {
            _this.listeners[type] = _this.listeners[type] || [];
            _this.listeners[type].push(fn);
        };
        this.removeEventListener = function (type, fn) {
            if (_this.listeners[type]) _this.listeners[type].splice(_this.listeners[type].indexOf(fn), 1);
        };
        this.dispatchEvent = function (evt) {
            var list = _this.listeners[evt.type];
            if (list) {
                for (var i = 0; i < list.length; i++) {
                    list[i].call(_this, evt);
                }
            }
        };
        this.onabort = this.onerror = this.onload = this.onloadstart = this.onloadend = this.onprogress = null;

        var constructEvent = function (type, evt) {
            var e = { type: type, target: _this, loaded: evt.loaded, total: evt.total, error: evt.error };
            if (evt.result != null) e.target.result = evt.result;
            return e;
        };
        var listener = function (evt) {
            if (!loadStarted) {
                loadStarted = true;
                if (_this.onloadstart) _this.onloadstart(constructEvent('loadstart', evt));
            }
            var e;
            if (evt.type === 'load') {
                if (_this.onloadend) _this.onloadend(constructEvent('loadend', evt));
                e = constructEvent('load', evt);
                if (_this.onload) _this.onload(e);
                _this.dispatchEvent(e);
            } else if (evt.type === 'progress') {
                e = constructEvent('progress', evt);
                if (_this.onprogress) _this.onprogress(e);
                _this.dispatchEvent(e);
            } else {
                e = constructEvent('error', evt);
                if (_this.onerror) _this.onerror(e);
                _this.dispatchEvent(e);
            }
        };
        this.readAsDataURL = function (file) {
            FileAPI.readAsDataURL(file, listener);
        };
        this.readAsText = function (file) {
            FileAPI.readAsText(file, listener);
        };
    };
}

/**!
 * AngularJS file upload directives and services. Supoorts: file upload/drop/paste, resume, cancel/abort,
 * progress, resize, thumbnail, preview, validation and CORS
 * @author  Danial  <danial.farid@gmail.com>
 * @version 12.2.13
 */

if (window.XMLHttpRequest && !(window.FileAPI && FileAPI.shouldLoad)) {
    window.XMLHttpRequest.prototype.setRequestHeader = (function (orig) {
        return function (header, value) {
            if (header === '__setXHR_') {
                var val = value(this);
                // fix for angular < 1.2.0
                if (val instanceof Function) {
                    val(this);
                }
            } else {
                orig.apply(this, arguments);
            }
        };
    })(window.XMLHttpRequest.prototype.setRequestHeader);
}

var ngFileUpload = angular.module('ngFileUpload', []);

ngFileUpload.version = '12.2.13';

ngFileUpload.service('UploadBase', ['$http', '$q', '$timeout', function ($http, $q, $timeout) {
    var upload = this;
    upload.promisesCount = 0;

    this.isResumeSupported = function () {
        return window.Blob && window.Blob.prototype.slice;
    };

    var resumeSupported = this.isResumeSupported();

    function sendHttp(config) {
        config.method = config.method || 'POST';
        config.headers = config.headers || {};

        var deferred = config._deferred = config._deferred || $q.defer();
        var promise = deferred.promise;

        function notifyProgress(e) {
            if (deferred.notify) {
                deferred.notify(e);
            }
            if (promise.progressFunc) {
                $timeout(function () {
                    promise.progressFunc(e);
                });
            }
        }

        function getNotifyEvent(n) {
            if (config._start != null && resumeSupported) {
                return {
                    loaded: n.loaded + config._start,
                    total: (config._file && config._file.size) || n.total,
                    type: n.type, config: config,
                    lengthComputable: true, target: n.target
                };
            } else {
                return n;
            }
        }

        if (!config.disableProgress) {
            config.headers.__setXHR_ = function () {
                return function (xhr) {
                    if (!xhr || !xhr.upload || !xhr.upload.addEventListener) return;
                    config.__XHR = xhr;
                    if (config.xhrFn) config.xhrFn(xhr);
                    xhr.upload.addEventListener('progress', function (e) {
                        e.config = config;
                        notifyProgress(getNotifyEvent(e));
                    }, false);
                    //fix for firefox not firing upload progress end, also IE8-9
                    xhr.upload.addEventListener('load', function (e) {
                        if (e.lengthComputable) {
                            e.config = config;
                            notifyProgress(getNotifyEvent(e));
                        }
                    }, false);
                };
            };
        }

        function uploadWithAngular() {
            $http(config).then(function (r) {
                if (resumeSupported && config._chunkSize && !config._finished && config._file) {
                    var fileSize = config._file && config._file.size || 0;
                    notifyProgress({
                        loaded: Math.min(config._end, fileSize),
                        total: fileSize,
                        config: config,
                        type: 'progress'
                    }
                    );
                    upload.upload(config, true);
                } else {
                    if (config._finished) delete config._finished;
                    deferred.resolve(r);
                }
            }, function (e) {
                deferred.reject(e);
            }, function (n) {
                deferred.notify(n);
            }
            );
        }

        if (!resumeSupported) {
            uploadWithAngular();
        } else if (config._chunkSize && config._end && !config._finished) {
            config._start = config._end;
            config._end += config._chunkSize;
            uploadWithAngular();
        } else if (config.resumeSizeUrl) {
            $http.get(config.resumeSizeUrl).then(function (resp) {
                if (config.resumeSizeResponseReader) {
                    config._start = config.resumeSizeResponseReader(resp.data);
                } else {
                    config._start = parseInt((resp.data.size == null ? resp.data : resp.data.size).toString());
                }
                if (config._chunkSize) {
                    config._end = config._start + config._chunkSize;
                }
                uploadWithAngular();
            }, function (e) {
                throw e;
            });
        } else if (config.resumeSize) {
            config.resumeSize().then(function (size) {
                config._start = size;
                if (config._chunkSize) {
                    config._end = config._start + config._chunkSize;
                }
                uploadWithAngular();
            }, function (e) {
                throw e;
            });
        } else {
            if (config._chunkSize) {
                config._start = 0;
                config._end = config._start + config._chunkSize;
            }
            uploadWithAngular();
        }


        promise.success = function (fn) {
            promise.then(function (response) {
                fn(response.data, response.status, response.headers, config);
            });
            return promise;
        };

        promise.error = function (fn) {
            promise.then(null, function (response) {
                fn(response.data, response.status, response.headers, config);
            });
            return promise;
        };

        promise.progress = function (fn) {
            promise.progressFunc = fn;
            promise.then(null, null, function (n) {
                fn(n);
            });
            return promise;
        };
        promise.abort = promise.pause = function () {
            if (config.__XHR) {
                $timeout(function () {
                    config.__XHR.abort();
                });
            }
            return promise;
        };
        promise.xhr = function (fn) {
            config.xhrFn = (function (origXhrFn) {
                return function () {
                    if (origXhrFn) origXhrFn.apply(promise, arguments);
                    fn.apply(promise, arguments);
                };
            })(config.xhrFn);
            return promise;
        };

        upload.promisesCount++;
        if (promise['finally'] && promise['finally'] instanceof Function) {
            promise['finally'](function () {
                upload.promisesCount--;
            });
        }
        return promise;
    }

    this.isUploadInProgress = function () {
        return upload.promisesCount > 0;
    };

    this.rename = function (file, name) {
        file.ngfName = name;
        return file;
    };

    this.jsonBlob = function (val) {
        if (val != null && !angular.isString(val)) {
            val = JSON.stringify(val);
        }
        var blob = new window.Blob([val], { type: 'application/json' });
        blob._ngfBlob = true;
        return blob;
    };

    this.json = function (val) {
        return angular.toJson(val);
    };

    function copy(obj) {
        var clone = {};
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                clone[key] = obj[key];
            }
        }
        return clone;
    }

    this.isFile = function (file) {
        return file != null && (file instanceof window.Blob || (file.flashId && file.name && file.size));
    };

    this.upload = function (config, internal) {
        function toResumeFile(file, formData) {
            if (file._ngfBlob) return file;
            config._file = config._file || file;
            if (config._start != null && resumeSupported) {
                if (config._end && config._end >= file.size) {
                    config._finished = true;
                    config._end = file.size;
                }
                var slice = file.slice(config._start, config._end || file.size);
                slice.name = file.name;
                slice.ngfName = file.ngfName;
                if (config._chunkSize) {
                    formData.append('_chunkSize', config._chunkSize);
                    formData.append('_currentChunkSize', config._end - config._start);
                    formData.append('_chunkNumber', Math.floor(config._start / config._chunkSize));
                    formData.append('_totalSize', config._file.size);
                }
                return slice;
            }
            return file;
        }

        function addFieldToFormData(formData, val, key) {
            if (val !== undefined) {
                if (angular.isDate(val)) {
                    val = val.toISOString();
                }
                if (angular.isString(val)) {
                    formData.append(key, val);
                } else if (upload.isFile(val)) {
                    var file = toResumeFile(val, formData);
                    var split = key.split(',');
                    if (split[1]) {
                        file.ngfName = split[1].replace(/^\s+|\s+$/g, '');
                        key = split[0];
                    }
                    config._fileKey = config._fileKey || key;
                    formData.append(key, file, file.ngfName || file.name);
                } else {
                    if (angular.isObject(val)) {
                        if (val.$$ngfCircularDetection) throw 'ngFileUpload: Circular reference in config.data. Make sure specified data for Upload.upload() has no circular reference: ' + key;

                        val.$$ngfCircularDetection = true;
                        try {
                            for (var k in val) {
                                if (val.hasOwnProperty(k) && k !== '$$ngfCircularDetection') {
                                    var objectKey = config.objectKey == null ? '[i]' : config.objectKey;
                                    if (val.length && parseInt(k) > -1) {
                                        objectKey = config.arrayKey == null ? objectKey : config.arrayKey;
                                    }
                                    addFieldToFormData(formData, val[k], key + objectKey.replace(/[ik]/g, k));
                                }
                            }
                        } finally {
                            delete val.$$ngfCircularDetection;
                        }
                    } else {
                        formData.append(key, val);
                    }
                }
            }
        }

        function digestConfig() {
            config._chunkSize = upload.translateScalars(config.resumeChunkSize);
            config._chunkSize = config._chunkSize ? parseInt(config._chunkSize.toString()) : null;

            config.headers = config.headers || {};
            config.headers['Content-Type'] = undefined;
            config.transformRequest = config.transformRequest ?
                (angular.isArray(config.transformRequest) ?
                    config.transformRequest : [config.transformRequest]) : [];
            config.transformRequest.push(function (data) {
                var formData = new window.FormData(), key;
                data = data || config.fields || {};
                if (config.file) {
                    data.file = config.file;
                }
                for (key in data) {
                    if (data.hasOwnProperty(key)) {
                        var val = data[key];
                        if (config.formDataAppender) {
                            config.formDataAppender(formData, key, val);
                        } else {
                            addFieldToFormData(formData, val, key);
                        }
                    }
                }

                return formData;
            });
        }

        if (!internal) config = copy(config);
        if (!config._isDigested) {
            config._isDigested = true;
            digestConfig();
        }

        return sendHttp(config);
    };

    this.http = function (config) {
        config = copy(config);
        config.transformRequest = config.transformRequest || function (data) {
            if ((window.ArrayBuffer && data instanceof window.ArrayBuffer) || data instanceof window.Blob) {
                return data;
            }
            return $http.defaults.transformRequest[0].apply(this, arguments);
        };
        config._chunkSize = upload.translateScalars(config.resumeChunkSize);
        config._chunkSize = config._chunkSize ? parseInt(config._chunkSize.toString()) : null;

        return sendHttp(config);
    };

    this.translateScalars = function (str) {
        if (angular.isString(str)) {
            if (str.search(/kb/i) === str.length - 2) {
                return parseFloat(str.substring(0, str.length - 2) * 1024);
            } else if (str.search(/mb/i) === str.length - 2) {
                return parseFloat(str.substring(0, str.length - 2) * 1048576);
            } else if (str.search(/gb/i) === str.length - 2) {
                return parseFloat(str.substring(0, str.length - 2) * 1073741824);
            } else if (str.search(/b/i) === str.length - 1) {
                return parseFloat(str.substring(0, str.length - 1));
            } else if (str.search(/s/i) === str.length - 1) {
                return parseFloat(str.substring(0, str.length - 1));
            } else if (str.search(/m/i) === str.length - 1) {
                return parseFloat(str.substring(0, str.length - 1) * 60);
            } else if (str.search(/h/i) === str.length - 1) {
                return parseFloat(str.substring(0, str.length - 1) * 3600);
            }
        }
        return str;
    };

    this.urlToBlob = function (url) {
        var defer = $q.defer();
        $http({ url: url, method: 'get', responseType: 'arraybuffer' }).then(function (resp) {
            var arrayBufferView = new Uint8Array(resp.data);
            var type = resp.headers('content-type') || 'image/WebP';
            var blob = new window.Blob([arrayBufferView], { type: type });
            var matches = url.match(/.*\/(.+?)(\?.*)?$/);
            if (matches.length > 1) {
                blob.name = matches[1];
            }
            defer.resolve(blob);
        }, function (e) {
            defer.reject(e);
        });
        return defer.promise;
    };

    this.setDefaults = function (defaults) {
        this.defaults = defaults || {};
    };

    this.defaults = {};
    this.version = ngFileUpload.version;
}

]);

ngFileUpload.service('Upload', ['$parse', '$timeout', '$compile', '$q', 'UploadExif', function ($parse, $timeout, $compile, $q, UploadExif) {
    var upload = UploadExif;
    upload.getAttrWithDefaults = function (attr, name) {
        if (attr[name] != null) return attr[name];
        var def = upload.defaults[name];
        return (def == null ? def : (angular.isString(def) ? def : JSON.stringify(def)));
    };

    upload.attrGetter = function (name, attr, scope, params) {
        var attrVal = this.getAttrWithDefaults(attr, name);
        if (scope) {
            try {
                if (params) {
                    return $parse(attrVal)(scope, params);
                } else {
                    return $parse(attrVal)(scope);
                }
            } catch (e) {
                // hangle string value without single qoute
                if (name.search(/min|max|pattern/i)) {
                    return attrVal;
                } else {
                    throw e;
                }
            }
        } else {
            return attrVal;
        }
    };

    upload.shouldUpdateOn = function (type, attr, scope) {
        var modelOptions = upload.attrGetter('ngfModelOptions', attr, scope);
        if (modelOptions && modelOptions.updateOn) {
            return modelOptions.updateOn.split(' ').indexOf(type) > -1;
        }
        return true;
    };

    upload.emptyPromise = function () {
        var d = $q.defer();
        var args = arguments;
        $timeout(function () {
            d.resolve.apply(d, args);
        });
        return d.promise;
    };

    upload.rejectPromise = function () {
        var d = $q.defer();
        var args = arguments;
        $timeout(function () {
            d.reject.apply(d, args);
        });
        return d.promise;
    };

    upload.happyPromise = function (promise, data) {
        var d = $q.defer();
        promise.then(function (result) {
            d.resolve(result);
        }, function (error) {
            $timeout(function () {
                throw error;
            });
            d.resolve(data);
        });
        return d.promise;
    };

    function applyExifRotations(files, attr, scope) {
        var promises = [upload.emptyPromise()];
        angular.forEach(files, function (f, i) {
            if (f.type.indexOf('image/jpeg') === 0 && upload.attrGetter('ngfFixOrientation', attr, scope, { $file: f })) {
                promises.push(upload.happyPromise(upload.applyExifRotation(f), f).then(function (fixedFile) {
                    files.splice(i, 1, fixedFile);
                }));
            }
        });
        return $q.all(promises);
    }

    function resizeFile(files, attr, scope, ngModel) {
        var resizeVal = upload.attrGetter('ngfResize', attr, scope);
        if (!resizeVal || !upload.isResizeSupported() || !files.length) return upload.emptyPromise();
        if (resizeVal instanceof Function) {
            var defer = $q.defer();
            return resizeVal(files).then(function (p) {
                resizeWithParams(p, files, attr, scope, ngModel).then(function (r) {
                    defer.resolve(r);
                }, function (e) {
                    defer.reject(e);
                });
            }, function (e) {
                defer.reject(e);
            });
        } else {
            return resizeWithParams(resizeVal, files, attr, scope, ngModel);
        }
    }

    function resizeWithParams(params, files, attr, scope, ngModel) {
        var promises = [upload.emptyPromise()];

        function handleFile(f, i) {
            if (f.type.indexOf('image') === 0) {
                if (params.pattern && !upload.validatePattern(f, params.pattern)) return;
                params.resizeIf = function (width, height) {
                    return upload.attrGetter('ngfResizeIf', attr, scope,
                        { $width: width, $height: height, $file: f });
                };
                var promise = upload.resize(f, params);
                promises.push(promise);
                promise.then(function (resizedFile) {
                    files.splice(i, 1, resizedFile);
                }, function (e) {
                    f.$error = 'resize';
                    (f.$errorMessages = (f.$errorMessages || {})).resize = true;
                    f.$errorParam = (e ? (e.message ? e.message : e) + ': ' : '') + (f && f.name);
                    ngModel.$ngfValidations.push({ name: 'resize', valid: false });
                    upload.applyModelValidation(ngModel, files);
                });
            }
        }

        for (var i = 0; i < files.length; i++) {
            handleFile(files[i], i);
        }
        return $q.all(promises);
    }

    upload.updateModel = function (ngModel, attr, scope, fileChange, files, evt, noDelay) {
        function update(files, invalidFiles, newFiles, dupFiles, isSingleModel) {
            attr.$$ngfPrevValidFiles = files;
            attr.$$ngfPrevInvalidFiles = invalidFiles;
            var file = files && files.length ? files[0] : null;
            var invalidFile = invalidFiles && invalidFiles.length ? invalidFiles[0] : null;

            if (ngModel) {
                upload.applyModelValidation(ngModel, files);
                ngModel.$setViewValue(isSingleModel ? file : files);
            }

            if (fileChange) {
                $parse(fileChange)(scope, {
                    $files: files,
                    $file: file,
                    $newFiles: newFiles,
                    $duplicateFiles: dupFiles,
                    $invalidFiles: invalidFiles,
                    $invalidFile: invalidFile,
                    $event: evt
                });
            }

            var invalidModel = upload.attrGetter('ngfModelInvalid', attr);
            if (invalidModel) {
                $timeout(function () {
                    $parse(invalidModel).assign(scope, isSingleModel ? invalidFile : invalidFiles);
                });
            }
            $timeout(function () {
                // scope apply changes
            });
        }

        var allNewFiles, dupFiles = [], prevValidFiles, prevInvalidFiles,
            invalids = [], valids = [];

        function removeDuplicates() {
            function equals(f1, f2) {
                return f1.name === f2.name && (f1.$ngfOrigSize || f1.size) === (f2.$ngfOrigSize || f2.size) &&
                    f1.type === f2.type;
            }

            function isInPrevFiles(f) {
                var j;
                for (j = 0; j < prevValidFiles.length; j++) {
                    if (equals(f, prevValidFiles[j])) {
                        return true;
                    }
                }
                for (j = 0; j < prevInvalidFiles.length; j++) {
                    if (equals(f, prevInvalidFiles[j])) {
                        return true;
                    }
                }
                return false;
            }

            if (files) {
                allNewFiles = [];
                dupFiles = [];
                for (var i = 0; i < files.length; i++) {
                    if (isInPrevFiles(files[i])) {
                        dupFiles.push(files[i]);
                    } else {
                        allNewFiles.push(files[i]);
                    }
                }
            }
        }

        function toArray(v) {
            return angular.isArray(v) ? v : [v];
        }

        function resizeAndUpdate() {
            function updateModel() {
                $timeout(function () {
                    update(keep ? prevValidFiles.concat(valids) : valids,
                        keep ? prevInvalidFiles.concat(invalids) : invalids,
                        files, dupFiles, isSingleModel);
                }, options && options.debounce ? options.debounce.change || options.debounce : 0);
            }

            var resizingFiles = validateAfterResize ? allNewFiles : valids;
            resizeFile(resizingFiles, attr, scope, ngModel).then(function () {
                if (validateAfterResize) {
                    upload.validate(allNewFiles, keep ? prevValidFiles.length : 0, ngModel, attr, scope)
                        .then(function (validationResult) {
                            valids = validationResult.validsFiles;
                            invalids = validationResult.invalidsFiles;
                            updateModel();
                        });
                } else {
                    updateModel();
                }
            }, function () {
                for (var i = 0; i < resizingFiles.length; i++) {
                    var f = resizingFiles[i];
                    if (f.$error === 'resize') {
                        var index = valids.indexOf(f);
                        if (index > -1) {
                            valids.splice(index, 1);
                            invalids.push(f);
                        }
                        updateModel();
                    }
                }
            });
        }

        prevValidFiles = attr.$$ngfPrevValidFiles || [];
        prevInvalidFiles = attr.$$ngfPrevInvalidFiles || [];
        if (ngModel && ngModel.$modelValue) {
            prevValidFiles = toArray(ngModel.$modelValue);
        }

        var keep = upload.attrGetter('ngfKeep', attr, scope);
        allNewFiles = (files || []).slice(0);
        if (keep === 'distinct' || upload.attrGetter('ngfKeepDistinct', attr, scope) === true) {
            removeDuplicates(attr, scope);
        }

        var isSingleModel = !keep && !upload.attrGetter('ngfMultiple', attr, scope) && !upload.attrGetter('multiple', attr);

        if (keep && !allNewFiles.length) return;

        upload.attrGetter('ngfBeforeModelChange', attr, scope, {
            $files: files,
            $file: files && files.length ? files[0] : null,
            $newFiles: allNewFiles,
            $duplicateFiles: dupFiles,
            $event: evt
        });

        var validateAfterResize = upload.attrGetter('ngfValidateAfterResize', attr, scope);

        var options = upload.attrGetter('ngfModelOptions', attr, scope);
        upload.validate(allNewFiles, keep ? prevValidFiles.length : 0, ngModel, attr, scope)
            .then(function (validationResult) {
                if (noDelay) {
                    update(allNewFiles, [], files, dupFiles, isSingleModel);
                } else {
                    if ((!options || !options.allowInvalid) && !validateAfterResize) {
                        valids = validationResult.validFiles;
                        invalids = validationResult.invalidFiles;
                    } else {
                        valids = allNewFiles;
                    }
                    if (upload.attrGetter('ngfFixOrientation', attr, scope) && upload.isExifSupported()) {
                        applyExifRotations(valids, attr, scope).then(function () {
                            resizeAndUpdate();
                        });
                    } else {
                        resizeAndUpdate();
                    }
                }
            });
    };

    return upload;
}]);

ngFileUpload.directive('ngfSelect', ['$parse', '$timeout', '$compile', 'Upload', function ($parse, $timeout, $compile, Upload) {
    var generatedElems = [];

    function isDelayedClickSupported(ua) {
        // fix for android native browser < 4.4 and safari windows
        var m = ua.match(/Android[^\d]*(\d+)\.(\d+)/);
        if (m && m.length > 2) {
            var v = Upload.defaults.androidFixMinorVersion || 4;
            return parseInt(m[1]) < 4 || (parseInt(m[1]) === v && parseInt(m[2]) < v);
        }

        // safari on windows
        return ua.indexOf('Chrome') === -1 && /.*Windows.*Safari.*/.test(ua);
    }

    function linkFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile, upload) {
        /** @namespace attr.ngfSelect */
        /** @namespace attr.ngfChange */
        /** @namespace attr.ngModel */
        /** @namespace attr.ngfModelOptions */
        /** @namespace attr.ngfMultiple */
        /** @namespace attr.ngfCapture */
        /** @namespace attr.ngfValidate */
        /** @namespace attr.ngfKeep */
        var attrGetter = function (name, scope) {
            return upload.attrGetter(name, attr, scope);
        };

        function isInputTypeFile() {
            return elem[0].tagName.toLowerCase() === 'input' && attr.type && attr.type.toLowerCase() === 'file';
        }

        function fileChangeAttr() {
            return attrGetter('ngfChange') || attrGetter('ngfSelect');
        }

        function changeFn(evt) {
            if (upload.shouldUpdateOn('change', attr, scope)) {
                var fileList = evt.__files_ || (evt.target && evt.target.files), files = [];
                /* Handle duplicate call in  IE11 */
                if (!fileList) return;
                for (var i = 0; i < fileList.length; i++) {
                    files.push(fileList[i]);
                }
                upload.updateModel(ngModel, attr, scope, fileChangeAttr(),
                    files.length ? files : null, evt);
            }
        }

        upload.registerModelChangeValidator(ngModel, attr, scope);

        var unwatches = [];
        if (attrGetter('ngfMultiple')) {
            unwatches.push(scope.$watch(attrGetter('ngfMultiple'), function () {
                fileElem.attr('multiple', attrGetter('ngfMultiple', scope));
            }));
        }
        if (attrGetter('ngfCapture')) {
            unwatches.push(scope.$watch(attrGetter('ngfCapture'), function () {
                fileElem.attr('capture', attrGetter('ngfCapture', scope));
            }));
        }
        if (attrGetter('ngfAccept')) {
            unwatches.push(scope.$watch(attrGetter('ngfAccept'), function () {
                fileElem.attr('accept', attrGetter('ngfAccept', scope));
            }));
        }
        unwatches.push(attr.$observe('accept', function () {
            fileElem.attr('accept', attrGetter('accept'));
        }));
        function bindAttrToFileInput(fileElem, label) {
            function updateId(val) {
                fileElem.attr('id', 'ngf-' + val);
                label.attr('id', 'ngf-label-' + val);
            }

            for (var i = 0; i < elem[0].attributes.length; i++) {
                var attribute = elem[0].attributes[i];
                if (attribute.name !== 'type' && attribute.name !== 'class' && attribute.name !== 'style') {
                    if (attribute.name === 'id') {
                        updateId(attribute.value);
                        unwatches.push(attr.$observe('id', updateId));
                    } else {
                        fileElem.attr(attribute.name, (!attribute.value && (attribute.name === 'required' ||
                            attribute.name === 'multiple')) ? attribute.name : attribute.value);
                    }
                }
            }
        }

        function createFileInput() {
            if (isInputTypeFile()) {
                return elem;
            }

            var fileElem = angular.element('<input type="file">');

            var label = angular.element('<label>upload</label>');
            label.css('visibility', 'hidden').css('position', 'absolute').css('overflow', 'hidden')
                .css('width', '0px').css('height', '0px').css('border', 'none')
                .css('margin', '0px').css('padding', '0px').attr('tabindex', '-1');
            bindAttrToFileInput(fileElem, label);

            generatedElems.push({ el: elem, ref: label });

            document.body.appendChild(label.append(fileElem)[0]);

            return fileElem;
        }

        function clickHandler(evt) {
            if (elem.attr('disabled')) return false;
            if (attrGetter('ngfSelectDisabled', scope)) return;

            var r = detectSwipe(evt);
            // prevent the click if it is a swipe
            if (r != null) return r;

            resetModel(evt);

            // fix for md when the element is removed from the DOM and added back #460
            try {
                if (!isInputTypeFile() && !document.body.contains(fileElem[0])) {
                    generatedElems.push({ el: elem, ref: fileElem.parent() });
                    document.body.appendChild(fileElem.parent()[0]);
                    fileElem.bind('change', changeFn);
                }
            } catch (e) {/*ignore*/
            }

            if (isDelayedClickSupported(navigator.userAgent)) {
                setTimeout(function () {
                    fileElem[0].click();
                }, 0);
            } else {
                fileElem[0].click();
            }

            return false;
        }


        var initialTouchStartY = 0;
        var initialTouchStartX = 0;

        function detectSwipe(evt) {
            var touches = evt.changedTouches || (evt.originalEvent && evt.originalEvent.changedTouches);
            if (touches) {
                if (evt.type === 'touchstart') {
                    initialTouchStartX = touches[0].clientX;
                    initialTouchStartY = touches[0].clientY;
                    return true; // don't block event default
                } else {
                    // prevent scroll from triggering event
                    if (evt.type === 'touchend') {
                        var currentX = touches[0].clientX;
                        var currentY = touches[0].clientY;
                        if ((Math.abs(currentX - initialTouchStartX) > 20) ||
                            (Math.abs(currentY - initialTouchStartY) > 20)) {
                            evt.stopPropagation();
                            evt.preventDefault();
                            return false;
                        }
                    }
                    return true;
                }
            }
        }

        var fileElem = elem;

        function resetModel(evt) {
            if (upload.shouldUpdateOn('click', attr, scope) && fileElem.val()) {
                fileElem.val(null);
                upload.updateModel(ngModel, attr, scope, fileChangeAttr(), null, evt, true);
            }
        }

        if (!isInputTypeFile()) {
            fileElem = createFileInput();
        }
        fileElem.bind('change', changeFn);

        if (!isInputTypeFile()) {
            elem.bind('click touchstart touchend', clickHandler);
        } else {
            elem.bind('click', resetModel);
        }

        function ie10SameFileSelectFix(evt) {
            if (fileElem && !fileElem.attr('__ngf_ie10_Fix_')) {
                if (!fileElem[0].parentNode) {
                    fileElem = null;
                    return;
                }
                evt.preventDefault();
                evt.stopPropagation();
                fileElem.unbind('click');
                var clone = fileElem.clone();
                fileElem.replaceWith(clone);
                fileElem = clone;
                fileElem.attr('__ngf_ie10_Fix_', 'true');
                fileElem.bind('change', changeFn);
                fileElem.bind('click', ie10SameFileSelectFix);
                fileElem[0].click();
                return false;
            } else {
                fileElem.removeAttr('__ngf_ie10_Fix_');
            }
        }

        if (navigator.appVersion.indexOf('MSIE 10') !== -1) {
            fileElem.bind('click', ie10SameFileSelectFix);
        }

        if (ngModel) ngModel.$formatters.push(function (val) {
            if (val == null || val.length === 0) {
                if (fileElem.val()) {
                    fileElem.val(null);
                }
            }
            return val;
        });

        scope.$on('$destroy', function () {
            if (!isInputTypeFile()) fileElem.parent().remove();
            angular.forEach(unwatches, function (unwatch) {
                unwatch();
            });
        });

        $timeout(function () {
            for (var i = 0; i < generatedElems.length; i++) {
                var g = generatedElems[i];
                if (!document.body.contains(g.el[0])) {
                    generatedElems.splice(i, 1);
                    g.ref.remove();
                }
            }
        });

        if (window.FileAPI && window.FileAPI.ngfFixIE) {
            window.FileAPI.ngfFixIE(elem, fileElem, changeFn);
        }
    }

    return {
        restrict: 'AEC',
        require: '?ngModel',
        link: function (scope, elem, attr, ngModel) {
            linkFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile, Upload);
        }
    };
}]);

(function () {

    ngFileUpload.service('UploadDataUrl', ['UploadBase', '$timeout', '$q', function (UploadBase, $timeout, $q) {
        var upload = UploadBase;
        upload.base64DataUrl = function (file) {
            if (angular.isArray(file)) {
                var d = $q.defer(), count = 0;
                angular.forEach(file, function (f) {
                    upload.dataUrl(f, true)['finally'](function () {
                        count++;
                        if (count === file.length) {
                            var urls = [];
                            angular.forEach(file, function (ff) {
                                urls.push(ff.$ngfDataUrl);
                            });
                            d.resolve(urls, file);
                        }
                    });
                });
                return d.promise;
            } else {
                return upload.dataUrl(file, true);
            }
        };
        upload.dataUrl = function (file, disallowObjectUrl) {
            if (!file) return upload.emptyPromise(file, file);
            if ((disallowObjectUrl && file.$ngfDataUrl != null) || (!disallowObjectUrl && file.$ngfBlobUrl != null)) {
                return upload.emptyPromise(disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl, file);
            }
            var p = disallowObjectUrl ? file.$$ngfDataUrlPromise : file.$$ngfBlobUrlPromise;
            if (p) return p;

            var deferred = $q.defer();
            $timeout(function () {
                if (window.FileReader && file &&
                    (!window.FileAPI || navigator.userAgent.indexOf('MSIE 8') === -1 || file.size < 20000) &&
                    (!window.FileAPI || navigator.userAgent.indexOf('MSIE 9') === -1 || file.size < 4000000)) {
                    //prefer URL.createObjectURL for handling refrences to files of all sizes
                    //since it doesn´t build a large string in memory
                    var URL = window.URL || window.webkitURL;
                    if (URL && URL.createObjectURL && !disallowObjectUrl) {
                        var url;
                        try {
                            url = URL.createObjectURL(file);
                        } catch (e) {
                            $timeout(function () {
                                file.$ngfBlobUrl = '';
                                deferred.reject();
                            });
                            return;
                        }
                        $timeout(function () {
                            file.$ngfBlobUrl = url;
                            if (url) {
                                deferred.resolve(url, file);
                                upload.blobUrls = upload.blobUrls || [];
                                upload.blobUrlsTotalSize = upload.blobUrlsTotalSize || 0;
                                upload.blobUrls.push({ url: url, size: file.size });
                                upload.blobUrlsTotalSize += file.size || 0;
                                var maxMemory = upload.defaults.blobUrlsMaxMemory || 268435456;
                                var maxLength = upload.defaults.blobUrlsMaxQueueSize || 200;
                                while ((upload.blobUrlsTotalSize > maxMemory || upload.blobUrls.length > maxLength) && upload.blobUrls.length > 1) {
                                    var obj = upload.blobUrls.splice(0, 1)[0];
                                    URL.revokeObjectURL(obj.url);
                                    upload.blobUrlsTotalSize -= obj.size;
                                }
                            }
                        });
                    } else {
                        var fileReader = new FileReader();
                        fileReader.onload = function (e) {
                            $timeout(function () {
                                file.$ngfDataUrl = e.target.result;
                                deferred.resolve(e.target.result, file);
                                $timeout(function () {
                                    delete file.$ngfDataUrl;
                                }, 1000);
                            });
                        };
                        fileReader.onerror = function () {
                            $timeout(function () {
                                file.$ngfDataUrl = '';
                                deferred.reject();
                            });
                        };
                        fileReader.readAsDataURL(file);
                    }
                } else {
                    $timeout(function () {
                        file[disallowObjectUrl ? '$ngfDataUrl' : '$ngfBlobUrl'] = '';
                        deferred.reject();
                    });
                }
            });

            if (disallowObjectUrl) {
                p = file.$$ngfDataUrlPromise = deferred.promise;
            } else {
                p = file.$$ngfBlobUrlPromise = deferred.promise;
            }
            p['finally'](function () {
                delete file[disallowObjectUrl ? '$$ngfDataUrlPromise' : '$$ngfBlobUrlPromise'];
            });
            return p;
        };
        return upload;
    }]);

    function getTagType(el) {
        if (el.tagName.toLowerCase() === 'img') return 'image';
        if (el.tagName.toLowerCase() === 'audio') return 'audio';
        if (el.tagName.toLowerCase() === 'video') return 'video';
        return /./;
    }

    function linkFileDirective(Upload, $timeout, scope, elem, attr, directiveName, resizeParams, isBackground) {
        function constructDataUrl(file) {
            var disallowObjectUrl = Upload.attrGetter('ngfNoObjectUrl', attr, scope);
            Upload.dataUrl(file, disallowObjectUrl)['finally'](function () {
                $timeout(function () {
                    var src = (disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl) || file.$ngfDataUrl;
                    if (isBackground) {
                        elem.css('background-image', 'url(\'' + (src || '') + '\')');
                    } else {
                        elem.attr('src', src);
                    }
                    if (src) {
                        elem.removeClass('ng-hide');
                    } else {
                        elem.addClass('ng-hide');
                    }
                });
            });
        }

        $timeout(function () {
            var unwatch = scope.$watch(attr[directiveName], function (file) {
                var size = resizeParams;
                if (directiveName === 'ngfThumbnail') {
                    if (!size) {
                        size = {
                            width: elem[0].naturalWidth || elem[0].clientWidth,
                            height: elem[0].naturalHeight || elem[0].clientHeight
                        };
                    }
                    if (size.width === 0 && window.getComputedStyle) {
                        var style = getComputedStyle(elem[0]);
                        if (style.width && style.width.indexOf('px') > -1 && style.height && style.height.indexOf('px') > -1) {
                            size = {
                                width: parseInt(style.width.slice(0, -2)),
                                height: parseInt(style.height.slice(0, -2))
                            };
                        }
                    }
                }

                if (angular.isString(file)) {
                    elem.removeClass('ng-hide');
                    if (isBackground) {
                        return elem.css('background-image', 'url(\'' + file + '\')');
                    } else {
                        return elem.attr('src', file);
                    }
                }
                if (file && file.type && file.type.search(getTagType(elem[0])) === 0 &&
                    (!isBackground || file.type.indexOf('image') === 0)) {
                    if (size && Upload.isResizeSupported()) {
                        size.resizeIf = function (width, height) {
                            return Upload.attrGetter('ngfResizeIf', attr, scope,
                                { $width: width, $height: height, $file: file });
                        };
                        Upload.resize(file, size).then(
                            function (f) {
                                constructDataUrl(f);
                            }, function (e) {
                                throw e;
                            }
                        );
                    } else {
                        constructDataUrl(file);
                    }
                } else {
                    elem.addClass('ng-hide');
                }
            });

            scope.$on('$destroy', function () {
                unwatch();
            });
        });
    }


    /** @namespace attr.ngfSrc */
    /** @namespace attr.ngfNoObjectUrl */
    ngFileUpload.directive('ngfSrc', ['Upload', '$timeout', function (Upload, $timeout) {
        return {
            restrict: 'AE',
            link: function (scope, elem, attr) {
                linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfSrc',
                    Upload.attrGetter('ngfResize', attr, scope), false);
            }
        };
    }]);

    /** @namespace attr.ngfBackground */
    /** @namespace attr.ngfNoObjectUrl */
    ngFileUpload.directive('ngfBackground', ['Upload', '$timeout', function (Upload, $timeout) {
        return {
            restrict: 'AE',
            link: function (scope, elem, attr) {
                linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfBackground',
                    Upload.attrGetter('ngfResize', attr, scope), true);
            }
        };
    }]);

    /** @namespace attr.ngfThumbnail */
    /** @namespace attr.ngfAsBackground */
    /** @namespace attr.ngfSize */
    /** @namespace attr.ngfNoObjectUrl */
    ngFileUpload.directive('ngfThumbnail', ['Upload', '$timeout', function (Upload, $timeout) {
        return {
            restrict: 'AE',
            link: function (scope, elem, attr) {
                var size = Upload.attrGetter('ngfSize', attr, scope);
                linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfThumbnail', size,
                    Upload.attrGetter('ngfAsBackground', attr, scope));
            }
        };
    }]);

    ngFileUpload.config(['$compileProvider', function ($compileProvider) {
        if ($compileProvider.imgSrcSanitizationWhitelist) $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|webcal|local|file|data|blob):/);
        if ($compileProvider.aHrefSanitizationWhitelist) $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|webcal|local|file|data|blob):/);
    }]);

    ngFileUpload.filter('ngfDataUrl', ['UploadDataUrl', '$sce', function (UploadDataUrl, $sce) {
        return function (file, disallowObjectUrl, trustedUrl) {
            if (angular.isString(file)) {
                return $sce.trustAsResourceUrl(file);
            }
            var src = file && ((disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl) || file.$ngfDataUrl);
            if (file && !src) {
                if (!file.$ngfDataUrlFilterInProgress && angular.isObject(file)) {
                    file.$ngfDataUrlFilterInProgress = true;
                    UploadDataUrl.dataUrl(file, disallowObjectUrl);
                }
                return '';
            }
            if (file) delete file.$ngfDataUrlFilterInProgress;
            return (file && src ? (trustedUrl ? $sce.trustAsResourceUrl(src) : src) : file) || '';
        };
    }]);

})();

ngFileUpload.service('UploadValidate', ['UploadDataUrl', '$q', '$timeout', function (UploadDataUrl, $q, $timeout) {
    var upload = UploadDataUrl;

    function globStringToRegex(str) {
        var regexp = '', excludes = [];
        if (str.length > 2 && str[0] === '/' && str[str.length - 1] === '/') {
            regexp = str.substring(1, str.length - 1);
        } else {
            var split = str.split(',');
            if (split.length > 1) {
                for (var i = 0; i < split.length; i++) {
                    var r = globStringToRegex(split[i]);
                    if (r.regexp) {
                        regexp += '(' + r.regexp + ')';
                        if (i < split.length - 1) {
                            regexp += '|';
                        }
                    } else {
                        excludes = excludes.concat(r.excludes);
                    }
                }
            } else {
                if (str.indexOf('!') === 0) {
                    excludes.push('^((?!' + globStringToRegex(str.substring(1)).regexp + ').)*$');
                } else {
                    if (str.indexOf('.') === 0) {
                        str = '*' + str;
                    }
                    regexp = '^' + str.replace(new RegExp('[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\-]', 'g'), '\\$&') + '$';
                    regexp = regexp.replace(/\\\*/g, '.*').replace(/\\\?/g, '.');
                }
            }
        }
        return { regexp: regexp, excludes: excludes };
    }

    upload.validatePattern = function (file, val) {
        if (!val) {
            return true;
        }
        var pattern = globStringToRegex(val), valid = true;
        if (pattern.regexp && pattern.regexp.length) {
            var regexp = new RegExp(pattern.regexp, 'i');
            valid = (file.type != null && regexp.test(file.type)) ||
                (file.name != null && regexp.test(file.name));
        }
        var len = pattern.excludes.length;
        while (len--) {
            var exclude = new RegExp(pattern.excludes[len], 'i');
            valid = valid && (file.type == null || exclude.test(file.type)) &&
                (file.name == null || exclude.test(file.name));
        }
        return valid;
    };

    upload.ratioToFloat = function (val) {
        var r = val.toString(), xIndex = r.search(/[x:]/i);
        if (xIndex > -1) {
            r = parseFloat(r.substring(0, xIndex)) / parseFloat(r.substring(xIndex + 1));
        } else {
            r = parseFloat(r);
        }
        return r;
    };

    upload.registerModelChangeValidator = function (ngModel, attr, scope) {
        if (ngModel) {
            ngModel.$formatters.push(function (files) {
                if (ngModel.$dirty) {
                    var filesArray = files;
                    if (files && !angular.isArray(files)) {
                        filesArray = [files];
                    }
                    upload.validate(filesArray, 0, ngModel, attr, scope).then(function () {
                        upload.applyModelValidation(ngModel, filesArray);
                    });
                }
                return files;
            });
        }
    };

    function markModelAsDirty(ngModel, files) {
        if (files != null && !ngModel.$dirty) {
            if (ngModel.$setDirty) {
                ngModel.$setDirty();
            } else {
                ngModel.$dirty = true;
            }
        }
    }

    upload.applyModelValidation = function (ngModel, files) {
        markModelAsDirty(ngModel, files);
        angular.forEach(ngModel.$ngfValidations, function (validation) {
            ngModel.$setValidity(validation.name, validation.valid);
        });
    };

    upload.getValidationAttr = function (attr, scope, name, validationName, file) {
        var dName = 'ngf' + name[0].toUpperCase() + name.substr(1);
        var val = upload.attrGetter(dName, attr, scope, { $file: file });
        if (val == null) {
            val = upload.attrGetter('ngfValidate', attr, scope, { $file: file });
            if (val) {
                var split = (validationName || name).split('.');
                val = val[split[0]];
                if (split.length > 1) {
                    val = val && val[split[1]];
                }
            }
        }
        return val;
    };

    upload.validate = function (files, prevLength, ngModel, attr, scope) {
        ngModel = ngModel || {};
        ngModel.$ngfValidations = ngModel.$ngfValidations || [];

        angular.forEach(ngModel.$ngfValidations, function (v) {
            v.valid = true;
        });

        var attrGetter = function (name, params) {
            return upload.attrGetter(name, attr, scope, params);
        };

        var ignoredErrors = (upload.attrGetter('ngfIgnoreInvalid', attr, scope) || '').split(' ');
        var runAllValidation = upload.attrGetter('ngfRunAllValidations', attr, scope);

        if (files == null || files.length === 0) {
            return upload.emptyPromise({ 'validFiles': files, 'invalidFiles': [] });
        }

        files = files.length === undefined ? [files] : files.slice(0);
        var invalidFiles = [];

        function validateSync(name, validationName, fn) {
            if (files) {
                var i = files.length, valid = null;
                while (i--) {
                    var file = files[i];
                    if (file) {
                        var val = upload.getValidationAttr(attr, scope, name, validationName, file);
                        if (val != null) {
                            if (!fn(file, val, i)) {
                                if (ignoredErrors.indexOf(name) === -1) {
                                    file.$error = name;
                                    (file.$errorMessages = (file.$errorMessages || {}))[name] = true;
                                    file.$errorParam = val;
                                    if (invalidFiles.indexOf(file) === -1) {
                                        invalidFiles.push(file);
                                    }
                                    if (!runAllValidation) {
                                        files.splice(i, 1);
                                    }
                                    valid = false;
                                } else {
                                    files.splice(i, 1);
                                }
                            }
                        }
                    }
                }
                if (valid !== null) {
                    ngModel.$ngfValidations.push({ name: name, valid: valid });
                }
            }
        }

        validateSync('pattern', null, upload.validatePattern);
        validateSync('minSize', 'size.min', function (file, val) {
            return file.size + 0.1 >= upload.translateScalars(val);
        });
        validateSync('maxSize', 'size.max', function (file, val) {
            return file.size - 0.1 <= upload.translateScalars(val);
        });
        var totalSize = 0;
        validateSync('maxTotalSize', null, function (file, val) {
            totalSize += file.size;
            if (totalSize > upload.translateScalars(val)) {
                files.splice(0, files.length);
                return false;
            }
            return true;
        });

        validateSync('validateFn', null, function (file, r) {
            return r === true || r === null || r === '';
        });

        if (!files.length) {
            return upload.emptyPromise({ 'validFiles': [], 'invalidFiles': invalidFiles });
        }

        function validateAsync(name, validationName, type, asyncFn, fn) {
            function resolveResult(defer, file, val) {
                function resolveInternal(fn) {
                    if (fn()) {
                        if (ignoredErrors.indexOf(name) === -1) {
                            file.$error = name;
                            (file.$errorMessages = (file.$errorMessages || {}))[name] = true;
                            file.$errorParam = val;
                            if (invalidFiles.indexOf(file) === -1) {
                                invalidFiles.push(file);
                            }
                            if (!runAllValidation) {
                                var i = files.indexOf(file);
                                if (i > -1) files.splice(i, 1);
                            }
                            defer.resolve(false);
                        } else {
                            var j = files.indexOf(file);
                            if (j > -1) files.splice(j, 1);
                            defer.resolve(true);
                        }
                    } else {
                        defer.resolve(true);
                    }
                }

                if (val != null) {
                    asyncFn(file, val).then(function (d) {
                        resolveInternal(function () {
                            return !fn(d, val);
                        });
                    }, function () {
                        resolveInternal(function () {
                            return attrGetter('ngfValidateForce', { $file: file });
                        });
                    });
                } else {
                    defer.resolve(true);
                }
            }

            var promises = [upload.emptyPromise(true)];
            if (files) {
                files = files.length === undefined ? [files] : files;
                angular.forEach(files, function (file) {
                    var defer = $q.defer();
                    promises.push(defer.promise);
                    if (type && (file.type == null || file.type.search(type) !== 0)) {
                        defer.resolve(true);
                        return;
                    }
                    if (name === 'dimensions' && upload.attrGetter('ngfDimensions', attr) != null) {
                        upload.imageDimensions(file).then(function (d) {
                            resolveResult(defer, file,
                                attrGetter('ngfDimensions', { $file: file, $width: d.width, $height: d.height }));
                        }, function () {
                            defer.resolve(false);
                        });
                    } else if (name === 'duration' && upload.attrGetter('ngfDuration', attr) != null) {
                        upload.mediaDuration(file).then(function (d) {
                            resolveResult(defer, file,
                                attrGetter('ngfDuration', { $file: file, $duration: d }));
                        }, function () {
                            defer.resolve(false);
                        });
                    } else {
                        resolveResult(defer, file,
                            upload.getValidationAttr(attr, scope, name, validationName, file));
                    }
                });
            }
            var deffer = $q.defer();
            $q.all(promises).then(function (values) {
                var isValid = true;
                for (var i = 0; i < values.length; i++) {
                    if (!values[i]) {
                        isValid = false;
                        break;
                    }
                }
                ngModel.$ngfValidations.push({ name: name, valid: isValid });
                deffer.resolve(isValid);
            });
            return deffer.promise;
        }

        var deffer = $q.defer();
        var promises = [];

        promises.push(validateAsync('maxHeight', 'height.max', /image/,
            this.imageDimensions, function (d, val) {
                return d.height <= val;
            }));
        promises.push(validateAsync('minHeight', 'height.min', /image/,
            this.imageDimensions, function (d, val) {
                return d.height >= val;
            }));
        promises.push(validateAsync('maxWidth', 'width.max', /image/,
            this.imageDimensions, function (d, val) {
                return d.width <= val;
            }));
        promises.push(validateAsync('minWidth', 'width.min', /image/,
            this.imageDimensions, function (d, val) {
                return d.width >= val;
            }));
        promises.push(validateAsync('dimensions', null, /image/,
            function (file, val) {
                return upload.emptyPromise(val);
            }, function (r) {
                return r;
            }));
        promises.push(validateAsync('ratio', null, /image/,
            this.imageDimensions, function (d, val) {
                var split = val.toString().split(','), valid = false;
                for (var i = 0; i < split.length; i++) {
                    if (Math.abs((d.width / d.height) - upload.ratioToFloat(split[i])) < 0.01) {
                        valid = true;
                    }
                }
                return valid;
            }));
        promises.push(validateAsync('maxRatio', 'ratio.max', /image/,
            this.imageDimensions, function (d, val) {
                return (d.width / d.height) - upload.ratioToFloat(val) < 0.0001;
            }));
        promises.push(validateAsync('minRatio', 'ratio.min', /image/,
            this.imageDimensions, function (d, val) {
                return (d.width / d.height) - upload.ratioToFloat(val) > -0.0001;
            }));
        promises.push(validateAsync('maxDuration', 'duration.max', /audio|video/,
            this.mediaDuration, function (d, val) {
                return d <= upload.translateScalars(val);
            }));
        promises.push(validateAsync('minDuration', 'duration.min', /audio|video/,
            this.mediaDuration, function (d, val) {
                return d >= upload.translateScalars(val);
            }));
        promises.push(validateAsync('duration', null, /audio|video/,
            function (file, val) {
                return upload.emptyPromise(val);
            }, function (r) {
                return r;
            }));

        promises.push(validateAsync('validateAsyncFn', null, null,
            function (file, val) {
                return val;
            }, function (r) {
                return r === true || r === null || r === '';
            }));

        $q.all(promises).then(function () {

            if (runAllValidation) {
                for (var i = 0; i < files.length; i++) {
                    var file = files[i];
                    if (file.$error) {
                        files.splice(i--, 1);
                    }
                }
            }

            runAllValidation = false;
            validateSync('maxFiles', null, function (file, val, i) {
                return prevLength + i < val;
            });

            deffer.resolve({ 'validFiles': files, 'invalidFiles': invalidFiles });
        });
        return deffer.promise;
    };

    upload.imageDimensions = function (file) {
        if (file.$ngfWidth && file.$ngfHeight) {
            var d = $q.defer();
            $timeout(function () {
                d.resolve({ width: file.$ngfWidth, height: file.$ngfHeight });
            });
            return d.promise;
        }
        if (file.$ngfDimensionPromise) return file.$ngfDimensionPromise;

        var deferred = $q.defer();
        $timeout(function () {
            if (file.type.indexOf('image') !== 0) {
                deferred.reject('not image');
                return;
            }
            upload.dataUrl(file).then(function (dataUrl) {
                var img = angular.element('<img>').attr('src', dataUrl)
                    .css('visibility', 'hidden').css('position', 'fixed')
                    .css('max-width', 'none !important').css('max-height', 'none !important');

                function success() {
                    var width = img[0].naturalWidth || img[0].clientWidth;
                    var height = img[0].naturalHeight || img[0].clientHeight;
                    img.remove();
                    file.$ngfWidth = width;
                    file.$ngfHeight = height;
                    deferred.resolve({ width: width, height: height });
                }

                function error() {
                    img.remove();
                    deferred.reject('load error');
                }

                img.on('load', success);
                img.on('error', error);

                var secondsCounter = 0;
                function checkLoadErrorInCaseOfNoCallback() {
                    $timeout(function () {
                        if (img[0].parentNode) {
                            if (img[0].clientWidth) {
                                success();
                            } else if (secondsCounter++ > 10) {
                                error();
                            } else {
                                checkLoadErrorInCaseOfNoCallback();
                            }
                        }
                    }, 1000);
                }

                checkLoadErrorInCaseOfNoCallback();

                angular.element(document.getElementsByTagName('body')[0]).append(img);
            }, function () {
                deferred.reject('load error');
            });
        });

        file.$ngfDimensionPromise = deferred.promise;
        file.$ngfDimensionPromise['finally'](function () {
            delete file.$ngfDimensionPromise;
        });
        return file.$ngfDimensionPromise;
    };

    upload.mediaDuration = function (file) {
        if (file.$ngfDuration) {
            var d = $q.defer();
            $timeout(function () {
                d.resolve(file.$ngfDuration);
            });
            return d.promise;
        }
        if (file.$ngfDurationPromise) return file.$ngfDurationPromise;

        var deferred = $q.defer();
        $timeout(function () {
            if (file.type.indexOf('audio') !== 0 && file.type.indexOf('video') !== 0) {
                deferred.reject('not media');
                return;
            }
            upload.dataUrl(file).then(function (dataUrl) {
                var el = angular.element(file.type.indexOf('audio') === 0 ? '<audio>' : '<video>')
                    .attr('src', dataUrl).css('visibility', 'none').css('position', 'fixed');

                function success() {
                    var duration = el[0].duration;
                    file.$ngfDuration = duration;
                    el.remove();
                    deferred.resolve(duration);
                }

                function error() {
                    el.remove();
                    deferred.reject('load error');
                }

                el.on('loadedmetadata', success);
                el.on('error', error);
                var count = 0;

                function checkLoadError() {
                    $timeout(function () {
                        if (el[0].parentNode) {
                            if (el[0].duration) {
                                success();
                            } else if (count > 10) {
                                error();
                            } else {
                                checkLoadError();
                            }
                        }
                    }, 1000);
                }

                checkLoadError();

                angular.element(document.body).append(el);
            }, function () {
                deferred.reject('load error');
            });
        });

        file.$ngfDurationPromise = deferred.promise;
        file.$ngfDurationPromise['finally'](function () {
            delete file.$ngfDurationPromise;
        });
        return file.$ngfDurationPromise;
    };
    return upload;
}
]);

ngFileUpload.service('UploadResize', ['UploadValidate', '$q', function (UploadValidate, $q) {
    var upload = UploadValidate;

    /**
     * Conserve aspect ratio of the original region. Useful when shrinking/enlarging
     * images to fit into a certain area.
     * Source:  http://stackoverflow.com/a/14731922
     *
     * @param {Number} srcWidth Source area width
     * @param {Number} srcHeight Source area height
     * @param {Number} maxWidth Nestable area maximum available width
     * @param {Number} maxHeight Nestable area maximum available height
     * @return {Object} { width, height }
     */
    var calculateAspectRatioFit = function (srcWidth, srcHeight, maxWidth, maxHeight, centerCrop) {
        var ratio = centerCrop ? Math.max(maxWidth / srcWidth, maxHeight / srcHeight) :
            Math.min(maxWidth / srcWidth, maxHeight / srcHeight);
        return {
            width: srcWidth * ratio, height: srcHeight * ratio,
            marginX: srcWidth * ratio - maxWidth, marginY: srcHeight * ratio - maxHeight
        };
    };

    // Extracted from https://github.com/romelgomez/angular-firebase-image-upload/blob/master/app/scripts/fileUpload.js#L89
    var resize = function (imagen, width, height, quality, type, ratio, centerCrop, resizeIf) {
        var deferred = $q.defer();
        var canvasElement = document.createElement('canvas');
        var imageElement = document.createElement('img');
        imageElement.setAttribute('style', 'visibility:hidden;position:fixed;z-index:-100000');
        document.body.appendChild(imageElement);

        imageElement.onload = function () {
            var imgWidth = imageElement.width, imgHeight = imageElement.height;
            imageElement.parentNode.removeChild(imageElement);
            if (resizeIf != null && resizeIf(imgWidth, imgHeight) === false) {
                deferred.reject('resizeIf');
                return;
            }
            try {
                if (ratio) {
                    var ratioFloat = upload.ratioToFloat(ratio);
                    var imgRatio = imgWidth / imgHeight;
                    if (imgRatio < ratioFloat) {
                        width = imgWidth;
                        height = width / ratioFloat;
                    } else {
                        height = imgHeight;
                        width = height * ratioFloat;
                    }
                }
                if (!width) {
                    width = imgWidth;
                }
                if (!height) {
                    height = imgHeight;
                }
                var dimensions = calculateAspectRatioFit(imgWidth, imgHeight, width, height, centerCrop);
                canvasElement.width = Math.min(dimensions.width, width);
                canvasElement.height = Math.min(dimensions.height, height);
                var context = canvasElement.getContext('2d');
                context.drawImage(imageElement,
                    Math.min(0, -dimensions.marginX / 2), Math.min(0, -dimensions.marginY / 2),
                    dimensions.width, dimensions.height);
                deferred.resolve(canvasElement.toDataURL(type || 'image/WebP', quality || 0.934));
            } catch (e) {
                deferred.reject(e);
            }
        };
        imageElement.onerror = function () {
            imageElement.parentNode.removeChild(imageElement);
            deferred.reject();
        };
        imageElement.src = imagen;
        return deferred.promise;
    };

    upload.dataUrltoBlob = function (dataurl, name, origSize) {
        var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
            bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
        while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
        }
        var blob = new window.Blob([u8arr], { type: mime });
        blob.name = name;
        blob.$ngfOrigSize = origSize;
        return blob;
    };

    upload.isResizeSupported = function () {
        var elem = document.createElement('canvas');
        return window.atob && elem.getContext && elem.getContext('2d') && window.Blob;
    };

    if (upload.isResizeSupported()) {
        // add name getter to the blob constructor prototype
        Object.defineProperty(window.Blob.prototype, 'name', {
            get: function () {
                return this.$ngfName;
            },
            set: function (v) {
                this.$ngfName = v;
            },
            configurable: true
        });
    }

    upload.resize = function (file, options) {
        if (file.type.indexOf('image') !== 0) return upload.emptyPromise(file);

        var deferred = $q.defer();
        upload.dataUrl(file, true).then(function (url) {
            resize(url, options.width, options.height, options.quality, options.type || file.type,
                options.ratio, options.centerCrop, options.resizeIf)
                .then(function (dataUrl) {
                    if (file.type === 'image/jpeg' && options.restoreExif !== false) {
                        try {
                            dataUrl = upload.restoreExif(url, dataUrl);
                        } catch (e) {
                            setTimeout(function () { throw e; }, 1);
                        }
                    }
                    try {
                        var blob = upload.dataUrltoBlob(dataUrl, file.name, file.size);
                        deferred.resolve(blob);
                    } catch (e) {
                        deferred.reject(e);
                    }
                }, function (r) {
                    if (r === 'resizeIf') {
                        deferred.resolve(file);
                    }
                    deferred.reject(r);
                });
        }, function (e) {
            deferred.reject(e);
        });
        return deferred.promise;
    };

    return upload;
}]);

(function () {
    ngFileUpload.directive('ngfDrop', ['$parse', '$timeout', '$window', 'Upload', '$http', '$q',
        function ($parse, $timeout, $window, Upload, $http, $q) {
            return {
                restrict: 'AEC',
                require: '?ngModel',
                link: function (scope, elem, attr, ngModel) {
                    linkDrop(scope, elem, attr, ngModel, $parse, $timeout, $window, Upload, $http, $q);
                }
            };
        }]);

    ngFileUpload.directive('ngfNoFileDrop', function () {
        return function (scope, elem) {
            if (dropAvailable()) elem.css('display', 'none');
        };
    });

    ngFileUpload.directive('ngfDropAvailable', ['$parse', '$timeout', 'Upload', function ($parse, $timeout, Upload) {
        return function (scope, elem, attr) {
            if (dropAvailable()) {
                var model = $parse(Upload.attrGetter('ngfDropAvailable', attr));
                $timeout(function () {
                    model(scope);
                    if (model.assign) {
                        model.assign(scope, true);
                    }
                });
            }
        };
    }]);

    function linkDrop(scope, elem, attr, ngModel, $parse, $timeout, $window, upload, $http, $q) {
        var available = dropAvailable();

        var attrGetter = function (name, scope, params) {
            return upload.attrGetter(name, attr, scope, params);
        };

        if (attrGetter('dropAvailable')) {
            $timeout(function () {
                if (scope[attrGetter('dropAvailable')]) {
                    scope[attrGetter('dropAvailable')].value = available;
                } else {
                    scope[attrGetter('dropAvailable')] = available;
                }
            });
        }
        if (!available) {
            if (attrGetter('ngfHideOnDropNotAvailable', scope) === true) {
                elem.css('display', 'none');
            }
            return;
        }

        function isDisabled() {
            return elem.attr('disabled') || attrGetter('ngfDropDisabled', scope);
        }

        if (attrGetter('ngfSelect') == null) {
            upload.registerModelChangeValidator(ngModel, attr, scope);
        }

        var leaveTimeout = null;
        var stopPropagation = $parse(attrGetter('ngfStopPropagation'));
        var dragOverDelay = 1;
        var actualDragOverClass;

        elem[0].addEventListener('dragover', function (evt) {
            if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope)) return;
            evt.preventDefault();
            if (stopPropagation(scope)) evt.stopPropagation();
            // handling dragover events from the Chrome download bar
            if (navigator.userAgent.indexOf('Chrome') > -1) {
                var b = evt.dataTransfer.effectAllowed;
                evt.dataTransfer.dropEffect = ('move' === b || 'linkMove' === b) ? 'move' : 'copy';
            }
            $timeout.cancel(leaveTimeout);
            if (!actualDragOverClass) {
                actualDragOverClass = 'C';
                calculateDragOverClass(scope, attr, evt, function (clazz) {
                    actualDragOverClass = clazz;
                    elem.addClass(actualDragOverClass);
                    attrGetter('ngfDrag', scope, { $isDragging: true, $class: actualDragOverClass, $event: evt });
                });
            }
        }, false);
        elem[0].addEventListener('dragenter', function (evt) {
            if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope)) return;
            evt.preventDefault();
            if (stopPropagation(scope)) evt.stopPropagation();
        }, false);
        elem[0].addEventListener('dragleave', function (evt) {
            if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope)) return;
            evt.preventDefault();
            if (stopPropagation(scope)) evt.stopPropagation();
            leaveTimeout = $timeout(function () {
                if (actualDragOverClass) elem.removeClass(actualDragOverClass);
                actualDragOverClass = null;
                attrGetter('ngfDrag', scope, { $isDragging: false, $event: evt });
            }, dragOverDelay || 100);
        }, false);
        elem[0].addEventListener('drop', function (evt) {
            if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope)) return;
            evt.preventDefault();
            if (stopPropagation(scope)) evt.stopPropagation();
            if (actualDragOverClass) elem.removeClass(actualDragOverClass);
            actualDragOverClass = null;
            extractFilesAndUpdateModel(evt.dataTransfer, evt, 'dropUrl');
        }, false);
        elem[0].addEventListener('paste', function (evt) {
            if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1 &&
                attrGetter('ngfEnableFirefoxPaste', scope)) {
                evt.preventDefault();
            }
            if (isDisabled() || !upload.shouldUpdateOn('paste', attr, scope)) return;
            extractFilesAndUpdateModel(evt.clipboardData || evt.originalEvent.clipboardData, evt, 'pasteUrl');
        }, false);

        if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1 &&
            attrGetter('ngfEnableFirefoxPaste', scope)) {
            elem.attr('contenteditable', true);
            elem.on('keypress', function (e) {
                if (!e.metaKey && !e.ctrlKey) {
                    e.preventDefault();
                }
            });
        }

        function extractFilesAndUpdateModel(source, evt, updateOnType) {
            if (!source) return;
            // html needs to be calculated on the same process otherwise the data will be wiped
            // after promise resolve or setTimeout.
            var html;
            try {
                html = source && source.getData && source.getData('text/html');
            } catch (e) {/* Fix IE11 that throw error calling getData */
            }
            extractFiles(source.items, source.files, attrGetter('ngfAllowDir', scope) !== false,
                attrGetter('multiple') || attrGetter('ngfMultiple', scope)).then(function (files) {
                    if (files.length) {
                        updateModel(files, evt);
                    } else {
                        extractFilesFromHtml(updateOnType, html).then(function (files) {
                            updateModel(files, evt);
                        });
                    }
                });
        }

        function updateModel(files, evt) {
            upload.updateModel(ngModel, attr, scope, attrGetter('ngfChange') || attrGetter('ngfDrop'), files, evt);
        }

        function extractFilesFromHtml(updateOn, html) {
            if (!upload.shouldUpdateOn(updateOn, attr, scope) || typeof html !== 'string') return upload.rejectPromise([]);
            var urls = [];
            html.replace(/<(img src|img [^>]* src) *=\"([^\"]*)\"/gi, function (m, n, src) {
                urls.push(src);
            });
            var promises = [], files = [];
            if (urls.length) {
                angular.forEach(urls, function (url) {
                    promises.push(upload.urlToBlob(url).then(function (blob) {
                        files.push(blob);
                    }));
                });
                var defer = $q.defer();
                $q.all(promises).then(function () {
                    defer.resolve(files);
                }, function (e) {
                    defer.reject(e);
                });
                return defer.promise;
            }
            return upload.emptyPromise();
        }

        function calculateDragOverClass(scope, attr, evt, callback) {
            var obj = attrGetter('ngfDragOverClass', scope, { $event: evt }), dClass = 'dragover';
            if (angular.isString(obj)) {
                dClass = obj;
            } else if (obj) {
                if (obj.delay) dragOverDelay = obj.delay;
                if (obj.accept || obj.reject) {
                    var items = evt.dataTransfer.items;
                    if (items == null || !items.length) {
                        dClass = obj.accept;
                    } else {
                        var pattern = obj.pattern || attrGetter('ngfPattern', scope, { $event: evt });
                        var len = items.length;
                        while (len--) {
                            if (!upload.validatePattern(items[len], pattern)) {
                                dClass = obj.reject;
                                break;
                            } else {
                                dClass = obj.accept;
                            }
                        }
                    }
                }
            }
            callback(dClass);
        }

        function extractFiles(items, fileList, allowDir, multiple) {
            var maxFiles = upload.getValidationAttr(attr, scope, 'maxFiles');
            if (maxFiles == null) {
                maxFiles = Number.MAX_VALUE;
            }
            var maxTotalSize = upload.getValidationAttr(attr, scope, 'maxTotalSize');
            if (maxTotalSize == null) {
                maxTotalSize = Number.MAX_VALUE;
            }
            var includeDir = attrGetter('ngfIncludeDir', scope);
            var files = [], totalSize = 0;

            function traverseFileTree(entry, path) {
                var defer = $q.defer();
                if (entry != null) {
                    if (entry.isDirectory) {
                        var promises = [upload.emptyPromise()];
                        if (includeDir) {
                            var file = { type: 'directory' };
                            file.name = file.path = (path || '') + entry.name;
                            files.push(file);
                        }
                        var dirReader = entry.createReader();
                        var entries = [];
                        var readEntries = function () {
                            dirReader.readEntries(function (results) {
                                try {
                                    if (!results.length) {
                                        angular.forEach(entries.slice(0), function (e) {
                                            if (files.length <= maxFiles && totalSize <= maxTotalSize) {
                                                promises.push(traverseFileTree(e, (path ? path : '') + entry.name + '/'));
                                            }
                                        });
                                        $q.all(promises).then(function () {
                                            defer.resolve();
                                        }, function (e) {
                                            defer.reject(e);
                                        });
                                    } else {
                                        entries = entries.concat(Array.prototype.slice.call(results || [], 0));
                                        readEntries();
                                    }
                                } catch (e) {
                                    defer.reject(e);
                                }
                            }, function (e) {
                                defer.reject(e);
                            });
                        };
                        readEntries();
                    } else {
                        entry.file(function (file) {
                            try {
                                file.path = (path ? path : '') + file.name;
                                if (includeDir) {
                                    file = upload.rename(file, file.path);
                                }
                                files.push(file);
                                totalSize += file.size;
                                defer.resolve();
                            } catch (e) {
                                defer.reject(e);
                            }
                        }, function (e) {
                            defer.reject(e);
                        });
                    }
                }
                return defer.promise;
            }

            var promises = [upload.emptyPromise()];

            if (items && items.length > 0 && $window.location.protocol !== 'file:') {
                for (var i = 0; i < items.length; i++) {
                    if (items[i].webkitGetAsEntry && items[i].webkitGetAsEntry() && items[i].webkitGetAsEntry().isDirectory) {
                        var entry = items[i].webkitGetAsEntry();
                        if (entry.isDirectory && !allowDir) {
                            continue;
                        }
                        if (entry != null) {
                            promises.push(traverseFileTree(entry));
                        }
                    } else {
                        var f = items[i].getAsFile();
                        if (f != null) {
                            files.push(f);
                            totalSize += f.size;
                        }
                    }
                    if (files.length > maxFiles || totalSize > maxTotalSize ||
                        (!multiple && files.length > 0)) break;
                }
            } else {
                if (fileList != null) {
                    for (var j = 0; j < fileList.length; j++) {
                        var file = fileList.item(j);
                        if (file.type || file.size > 0) {
                            files.push(file);
                            totalSize += file.size;
                        }
                        if (files.length > maxFiles || totalSize > maxTotalSize ||
                            (!multiple && files.length > 0)) break;
                    }
                }
            }

            var defer = $q.defer();
            $q.all(promises).then(function () {
                if (!multiple && !includeDir && files.length) {
                    var i = 0;
                    while (files[i] && files[i].type === 'directory') i++;
                    defer.resolve([files[i]]);
                } else {
                    defer.resolve(files);
                }
            }, function (e) {
                defer.reject(e);
            });

            return defer.promise;
        }
    }

    function dropAvailable() {
        var div = document.createElement('div');
        return ('draggable' in div) && ('ondrop' in div) && !/Edge\/12./i.test(navigator.userAgent);
    }

})();

// customized version of https://github.com/exif-js/exif-js
ngFileUpload.service('UploadExif', ['UploadResize', '$q', function (UploadResize, $q) {
    var upload = UploadResize;

    upload.isExifSupported = function () {
        return window.FileReader && new FileReader().readAsArrayBuffer && upload.isResizeSupported();
    };

    function applyTransform(ctx, orientation, width, height) {
        switch (orientation) {
            case 2:
                return ctx.transform(-1, 0, 0, 1, width, 0);
            case 3:
                return ctx.transform(-1, 0, 0, -1, width, height);
            case 4:
                return ctx.transform(1, 0, 0, -1, 0, height);
            case 5:
                return ctx.transform(0, 1, 1, 0, 0, 0);
            case 6:
                return ctx.transform(0, 1, -1, 0, height, 0);
            case 7:
                return ctx.transform(0, -1, -1, 0, height, width);
            case 8:
                return ctx.transform(0, -1, 1, 0, 0, width);
        }
    }

    upload.readOrientation = function (file) {
        var defer = $q.defer();
        var reader = new FileReader();
        var slicedFile = file.slice ? file.slice(0, 64 * 1024) : file;
        reader.readAsArrayBuffer(slicedFile);
        reader.onerror = function (e) {
            return defer.reject(e);
        };
        reader.onload = function (e) {
            var result = { orientation: 1 };
            var view = new DataView(this.result);
            if (view.getUint16(0, false) !== 0xFFD8) return defer.resolve(result);

            var length = view.byteLength,
                offset = 2;
            while (offset < length) {
                var marker = view.getUint16(offset, false);
                offset += 2;
                if (marker === 0xFFE1) {
                    if (view.getUint32(offset += 2, false) !== 0x45786966) return defer.resolve(result);

                    var little = view.getUint16(offset += 6, false) === 0x4949;
                    offset += view.getUint32(offset + 4, little);
                    var tags = view.getUint16(offset, little);
                    offset += 2;
                    for (var i = 0; i < tags; i++)
                        if (view.getUint16(offset + (i * 12), little) === 0x0112) {
                            var orientation = view.getUint16(offset + (i * 12) + 8, little);
                            if (orientation >= 2 && orientation <= 8) {
                                view.setUint16(offset + (i * 12) + 8, 1, little);
                                result.fixedArrayBuffer = e.target.result;
                            }
                            result.orientation = orientation;
                            return defer.resolve(result);
                        }
                } else if ((marker & 0xFF00) !== 0xFF00) break;
                else offset += view.getUint16(offset, false);
            }
            return defer.resolve(result);
        };
        return defer.promise;
    };

    function arrayBufferToBase64(buffer) {
        var binary = '';
        var bytes = new Uint8Array(buffer);
        var len = bytes.byteLength;
        for (var i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return window.btoa(binary);
    }

    upload.applyExifRotation = function (file) {
        if (file.type.indexOf('image/jpeg') !== 0) {
            return upload.emptyPromise(file);
        }

        var deferred = $q.defer();
        upload.readOrientation(file).then(function (result) {
            if (result.orientation < 2 || result.orientation > 8) {
                return deferred.resolve(file);
            }
            upload.dataUrl(file, true).then(function (url) {
                var canvas = document.createElement('canvas');
                var img = document.createElement('img');

                img.onload = function () {
                    try {
                        canvas.width = result.orientation > 4 ? img.height : img.width;
                        canvas.height = result.orientation > 4 ? img.width : img.height;
                        var ctx = canvas.getContext('2d');
                        applyTransform(ctx, result.orientation, img.width, img.height);
                        ctx.drawImage(img, 0, 0);
                        var dataUrl = canvas.toDataURL(file.type || 'image/WebP', 0.934);
                        dataUrl = upload.restoreExif(arrayBufferToBase64(result.fixedArrayBuffer), dataUrl);
                        var blob = upload.dataUrltoBlob(dataUrl, file.name);
                        deferred.resolve(blob);
                    } catch (e) {
                        return deferred.reject(e);
                    }
                };
                img.onerror = function () {
                    deferred.reject();
                };
                img.src = url;
            }, function (e) {
                deferred.reject(e);
            });
        }, function (e) {
            deferred.reject(e);
        });
        return deferred.promise;
    };

    upload.restoreExif = function (orig, resized) {
        var ExifRestorer = {};

        ExifRestorer.KEY_STR = 'ABCDEFGHIJKLMNOP' +
            'QRSTUVWXYZabcdef' +
            'ghijklmnopqrstuv' +
            'wxyz0123456789+/' +
            '=';

        ExifRestorer.encode64 = function (input) {
            var output = '',
                chr1, chr2, chr3 = '',
                enc1, enc2, enc3, enc4 = '',
                i = 0;

            do {
                chr1 = input[i++];
                chr2 = input[i++];
                chr3 = input[i++];

                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;

                if (isNaN(chr2)) {
                    enc3 = enc4 = 64;
                } else if (isNaN(chr3)) {
                    enc4 = 64;
                }

                output = output +
                    this.KEY_STR.charAt(enc1) +
                    this.KEY_STR.charAt(enc2) +
                    this.KEY_STR.charAt(enc3) +
                    this.KEY_STR.charAt(enc4);
                chr1 = chr2 = chr3 = '';
                enc1 = enc2 = enc3 = enc4 = '';
            } while (i < input.length);

            return output;
        };

        ExifRestorer.restore = function (origFileBase64, resizedFileBase64) {
            if (origFileBase64.match('data:image/jpeg;base64,')) {
                origFileBase64 = origFileBase64.replace('data:image/jpeg;base64,', '');
            }

            var rawImage = this.decode64(origFileBase64);
            var segments = this.slice2Segments(rawImage);

            var image = this.exifManipulation(resizedFileBase64, segments);

            return 'data:image/jpeg;base64,' + this.encode64(image);
        };


        ExifRestorer.exifManipulation = function (resizedFileBase64, segments) {
            var exifArray = this.getExifArray(segments),
                newImageArray = this.insertExif(resizedFileBase64, exifArray);
            return new Uint8Array(newImageArray);
        };


        ExifRestorer.getExifArray = function (segments) {
            var seg;
            for (var x = 0; x < segments.length; x++) {
                seg = segments[x];
                if (seg[0] === 255 & seg[1] === 225) //(ff e1)
                {
                    return seg;
                }
            }
            return [];
        };


        ExifRestorer.insertExif = function (resizedFileBase64, exifArray) {
            var imageData = resizedFileBase64.replace('data:image/jpeg;base64,', ''),
                buf = this.decode64(imageData),
                separatePoint = buf.indexOf(255, 3),
                mae = buf.slice(0, separatePoint),
                ato = buf.slice(separatePoint),
                array = mae;

            array = array.concat(exifArray);
            array = array.concat(ato);
            return array;
        };


        ExifRestorer.slice2Segments = function (rawImageArray) {
            var head = 0,
                segments = [];

            while (1) {
                if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) {
                    break;
                }
                if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) {
                    head += 2;
                }
                else {
                    var length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3],
                        endPoint = head + length + 2,
                        seg = rawImageArray.slice(head, endPoint);
                    segments.push(seg);
                    head = endPoint;
                }
                if (head > rawImageArray.length) {
                    break;
                }
            }

            return segments;
        };


        ExifRestorer.decode64 = function (input) {
            var chr1, chr2, chr3 = '',
                enc1, enc2, enc3, enc4 = '',
                i = 0,
                buf = [];

            // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
            var base64test = /[^A-Za-z0-9\+\/\=]/g;
            if (base64test.exec(input)) {
                console.log('There were invalid base64 characters in the input text.\n' +
                    'Valid base64 characters are A-Z, a-z, 0-9, ' + ', ' / ',and "="\n' +
                    'Expect errors in decoding.');
            }
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

            do {
                enc1 = this.KEY_STR.indexOf(input.charAt(i++));
                enc2 = this.KEY_STR.indexOf(input.charAt(i++));
                enc3 = this.KEY_STR.indexOf(input.charAt(i++));
                enc4 = this.KEY_STR.indexOf(input.charAt(i++));

                chr1 = (enc1 << 2) | (enc2 >> 4);
                chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                chr3 = ((enc3 & 3) << 6) | enc4;

                buf.push(chr1);

                if (enc3 !== 64) {
                    buf.push(chr2);
                }
                if (enc4 !== 64) {
                    buf.push(chr3);
                }

                chr1 = chr2 = chr3 = '';
                enc1 = enc2 = enc3 = enc4 = '';

            } while (i < input.length);

            return buf;
        };

        return ExifRestorer.restore(orig, resized);  //<= EXIF
    };

    return upload;
}]);


/*! 
 * angular-loading-bar v0.9.0
 * https://chieffancypants.github.io/angular-loading-bar
 * Copyright (c) 2016 Wes Cruver
 * License: MIT
 */
!function () { "use strict"; angular.module("angular-loading-bar", ["cfp.loadingBarInterceptor"]), angular.module("chieffancypants.loadingBar", ["cfp.loadingBarInterceptor"]), angular.module("cfp.loadingBarInterceptor", ["cfp.loadingBar"]).config(["$httpProvider", function (a) { var b = ["$q", "$cacheFactory", "$timeout", "$rootScope", "$log", "cfpLoadingBar", function (b, c, d, e, f, g) { function h() { d.cancel(j), g.complete(), l = 0, k = 0 } function i(b) { var d, e = c.get("$http"), f = a.defaults; !b.cache && !f.cache || b.cache === !1 || "GET" !== b.method && "JSONP" !== b.method || (d = angular.isObject(b.cache) ? b.cache : angular.isObject(f.cache) ? f.cache : e); var g = void 0 !== d ? void 0 !== d.get(b.url) : !1; return void 0 !== b.cached && g !== b.cached ? b.cached : (b.cached = g, g) } var j, k = 0, l = 0, m = g.latencyThreshold; return { request: function (a) { return a.ignoreLoadingBar || i(a) || (e.$broadcast("cfpLoadingBar:loading", { url: a.url }), 0 === k && (j = d(function () { g.start() }, m)), k++ , g.set(l / k)), a }, response: function (a) { return a && a.config ? (a.config.ignoreLoadingBar || i(a.config) || (l++ , e.$broadcast("cfpLoadingBar:loaded", { url: a.config.url, result: a }), l >= k ? h() : g.set(l / k)), a) : (f.error("Broken interceptor detected: Config object not supplied in response:\n https://github.com/chieffancypants/angular-loading-bar/pull/50"), a) }, responseError: function (a) { return a && a.config ? (a.config.ignoreLoadingBar || i(a.config) || (l++ , e.$broadcast("cfpLoadingBar:loaded", { url: a.config.url, result: a }), l >= k ? h() : g.set(l / k)), b.reject(a)) : (f.error("Broken interceptor detected: Config object not supplied in rejection:\n https://github.com/chieffancypants/angular-loading-bar/pull/50"), b.reject(a)) } } }]; a.interceptors.push(b) }]), angular.module("cfp.loadingBar", []).provider("cfpLoadingBar", function () { this.autoIncrement = !0, this.includeSpinner = !0, this.includeBar = !0, this.latencyThreshold = 100, this.startSize = .02, this.parentSelector = "body", this.spinnerTemplate = '<div id="loading-bar-spinner"><div class="spinner-icon"></div></div>', this.loadingBarTemplate = '<div id="loading-bar"><div class="bar"><div class="peg"></div></div></div>', this.$get = ["$injector", "$document", "$timeout", "$rootScope", function (a, b, c, d) { function e() { if (k || (k = a.get("$animate")), c.cancel(m), !r) { var e = b[0], g = e.querySelector ? e.querySelector(n) : b.find(n)[0]; g || (g = e.getElementsByTagName("body")[0]); var h = angular.element(g), i = g.lastChild && angular.element(g.lastChild); d.$broadcast("cfpLoadingBar:started"), r = !0, v && k.enter(o, h, i), u && k.enter(q, h, o), f(w) } } function f(a) { if (r) { var b = 100 * a + "%"; p.css("width", b), s = a, t && (c.cancel(l), l = c(function () { g() }, 250)) } } function g() { if (!(h() >= 1)) { var a = 0, b = h(); a = b >= 0 && .25 > b ? (3 * Math.random() + 3) / 100 : b >= .25 && .65 > b ? 3 * Math.random() / 100 : b >= .65 && .9 > b ? 2 * Math.random() / 100 : b >= .9 && .99 > b ? .005 : 0; var c = h() + a; f(c) } } function h() { return s } function i() { s = 0, r = !1 } function j() { k || (k = a.get("$animate")), d.$broadcast("cfpLoadingBar:completed"), f(1), c.cancel(m), m = c(function () { var a = k.leave(o, i); a && a.then && a.then(i), k.leave(q) }, 500) } var k, l, m, n = this.parentSelector, o = angular.element(this.loadingBarTemplate), p = o.find("div").eq(0), q = angular.element(this.spinnerTemplate), r = !1, s = 0, t = this.autoIncrement, u = this.includeSpinner, v = this.includeBar, w = this.startSize; return { start: e, set: f, status: h, inc: g, complete: j, autoIncrement: this.autoIncrement, includeSpinner: this.includeSpinner, latencyThreshold: this.latencyThreshold, parentSelector: this.parentSelector, startSize: this.startSize } }] }) }();
(function () {
    'use strict';

    angular.module('toastr', [])
        .factory('toastr', toastr);

    toastr.$inject = ['$animate', '$injector', '$document', '$rootScope', '$sce', 'toastrConfig', '$q'];

    function toastr($animate, $injector, $document, $rootScope, $sce, toastrConfig, $q) {
        var container;
        var index = 0;
        var toasts = [];

        var previousToastMessage = '';
        var openToasts = {};

        var containerDefer = $q.defer();

        var toast = {
            active: active,
            clear: clear,
            error: error,
            info: info,
            remove: remove,
            success: success,
            warning: warning,
            refreshTimer: refreshTimer
        };

        return toast;

        /* Public API */
        function active() {
            return toasts.length;
        }

        function clear(toast) {
            // Bit of a hack, I will remove this soon with a BC
            if (arguments.length === 1 && !toast) { return; }

            if (toast) {
                remove(toast.toastId);
            } else {
                for (var i = 0; i < toasts.length; i++) {
                    remove(toasts[i].toastId);
                }
            }
        }

        function error(message, title, optionsOverride) {
            var type = _getOptions().iconClasses.error;
            return _buildNotification(type, message, title, optionsOverride);
        }

        function info(message, title, optionsOverride) {
            var type = _getOptions().iconClasses.info;
            return _buildNotification(type, message, title, optionsOverride);
        }

        function success(message, title, optionsOverride) {
            var type = _getOptions().iconClasses.success;
            return _buildNotification(type, message, title, optionsOverride);
        }

        function warning(message, title, optionsOverride) {
            var type = _getOptions().iconClasses.warning;
            return _buildNotification(type, message, title, optionsOverride);
        }

        function refreshTimer(toast, newTime) {
            if (toast && toast.isOpened && toasts.indexOf(toast) >= 0) {
                toast.scope.refreshTimer(newTime);
            }
        }

        function remove(toastId, wasClicked) {
            var toast = findToast(toastId);

            if (toast && !toast.deleting) { // Avoid clicking when fading out
                toast.deleting = true;
                toast.isOpened = false;
                $animate.leave(toast.el).then(function () {
                    if (toast.scope.options.onHidden) {
                        toast.scope.options.onHidden(!!wasClicked, toast);
                    }
                    toast.scope.$destroy();
                    var index = toasts.indexOf(toast);
                    delete openToasts[toast.scope.message];
                    toasts.splice(index, 1);
                    var maxOpened = toastrConfig.maxOpened;
                    if (maxOpened && toasts.length >= maxOpened) {
                        toasts[maxOpened - 1].open.resolve();
                    }
                    if (lastToast()) {
                        container.remove();
                        container = null;
                        containerDefer = $q.defer();
                    }
                });
            }

            function findToast(toastId) {
                for (var i = 0; i < toasts.length; i++) {
                    if (toasts[i].toastId === toastId) {
                        return toasts[i];
                    }
                }
            }

            function lastToast() {
                return !toasts.length;
            }
        }

        /* Internal functions */
        function _buildNotification(type, message, title, optionsOverride) {
            if (angular.isObject(title)) {
                optionsOverride = title;
                title = null;
            }

            return _notify({
                iconClass: type,
                message: message,
                optionsOverride: optionsOverride,
                title: title
            });
        }

        function _getOptions() {
            return angular.extend({}, toastrConfig);
        }

        function _createOrGetContainer(options) {
            if (container) { return containerDefer.promise; }

            container = angular.element('<div></div>');
            container.attr('id', options.containerId);
            container.addClass(options.positionClass);
            container.css({ 'pointer-events': 'auto' });

            var target = angular.element(document.querySelector(options.target));

            if (!target || !target.length) {
                throw 'Target for toasts doesn\'t exist';
            }

            $animate.enter(container, target).then(function () {
                containerDefer.resolve();
            });

            return containerDefer.promise;
        }

        function _notify(map) {
            var options = _getOptions();

            if (shouldExit()) { return; }

            var newToast = createToast();

            toasts.push(newToast);

            if (ifMaxOpenedAndAutoDismiss()) {
                var oldToasts = toasts.slice(0, (toasts.length - options.maxOpened));
                for (var i = 0, len = oldToasts.length; i < len; i++) {
                    remove(oldToasts[i].toastId);
                }
            }

            if (maxOpenedNotReached()) {
                newToast.open.resolve();
            }

            newToast.open.promise.then(function () {
                _createOrGetContainer(options).then(function () {
                    newToast.isOpened = true;
                    if (options.newestOnTop) {
                        $animate.enter(newToast.el, container).then(function () {
                            newToast.scope.init();
                        });
                    } else {
                        var sibling = container[0].lastChild ? angular.element(container[0].lastChild) : null;
                        $animate.enter(newToast.el, container, sibling).then(function () {
                            newToast.scope.init();
                        });
                    }
                });
            });

            return newToast;

            function ifMaxOpenedAndAutoDismiss() {
                return options.autoDismiss && options.maxOpened && toasts.length > options.maxOpened;
            }

            function createScope(toast, map, options) {
                if (options.allowHtml) {
                    toast.scope.allowHtml = true;
                    toast.scope.title = $sce.trustAsHtml(map.title);
                    toast.scope.message = $sce.trustAsHtml(map.message);
                } else {
                    toast.scope.title = map.title;
                    toast.scope.message = map.message;
                }

                toast.scope.toastType = toast.iconClass;
                toast.scope.toastId = toast.toastId;
                toast.scope.extraData = options.extraData;

                toast.scope.options = {
                    extendedTimeOut: options.extendedTimeOut,
                    messageClass: options.messageClass,
                    onHidden: options.onHidden,
                    onShown: generateEvent('onShown'),
                    onTap: generateEvent('onTap'),
                    progressBar: options.progressBar,
                    tapToDismiss: options.tapToDismiss,
                    timeOut: options.timeOut,
                    titleClass: options.titleClass,
                    toastClass: options.toastClass
                };

                if (options.closeButton) {
                    toast.scope.options.closeHtml = options.closeHtml;
                }

                function generateEvent(event) {
                    if (options[event]) {
                        return function () {
                            options[event](toast);
                        };
                    }
                }
            }

            function createToast() {
                var newToast = {
                    toastId: index++,
                    isOpened: false,
                    scope: $rootScope.$new(),
                    open: $q.defer()
                };
                newToast.iconClass = map.iconClass;
                if (map.optionsOverride) {
                    angular.extend(options, cleanOptionsOverride(map.optionsOverride));
                    newToast.iconClass = map.optionsOverride.iconClass || newToast.iconClass;
                }

                createScope(newToast, map, options);

                newToast.el = createToastEl(newToast.scope);

                return newToast;

                function cleanOptionsOverride(options) {
                    var badOptions = ['containerId', 'iconClasses', 'maxOpened', 'newestOnTop',
                        'positionClass', 'preventDuplicates', 'preventOpenDuplicates', 'templates'];
                    for (var i = 0, l = badOptions.length; i < l; i++) {
                        delete options[badOptions[i]];
                    }

                    return options;
                }
            }

            function createToastEl(scope) {
                var angularDomEl = angular.element('<div toast></div>'),
                    $compile = $injector.get('$compile');
                return $compile(angularDomEl)(scope);
            }

            function maxOpenedNotReached() {
                return options.maxOpened && toasts.length <= options.maxOpened || !options.maxOpened;
            }

            function shouldExit() {
                var isDuplicateOfLast = options.preventDuplicates && map.message === previousToastMessage;
                var isDuplicateOpen = options.preventOpenDuplicates && openToasts[map.message];

                if (isDuplicateOfLast || isDuplicateOpen) {
                    return true;
                }

                previousToastMessage = map.message;
                openToasts[map.message] = true;

                return false;
            }
        }
    }
}());

(function () {
    'use strict';

    angular.module('toastr')
        .constant('toastrConfig', {
            allowHtml: false,
            autoDismiss: false,
            closeButton: false,
            closeHtml: '<button>&times;</button>',
            containerId: 'toast-container',
            extendedTimeOut: 1000,
            iconClasses: {
                error: 'toast-error',
                info: 'toast-info',
                success: 'toast-success',
                warning: 'toast-warning'
            },
            maxOpened: 0,
            messageClass: 'toast-message',
            newestOnTop: true,
            onHidden: null,
            onShown: null,
            onTap: null,
            positionClass: 'toast-top-right',
            preventDuplicates: false,
            preventOpenDuplicates: false,
            progressBar: false,
            tapToDismiss: true,
            target: 'body',
            templates: {
                toast: 'directives/toast/toast.html',
                progressbar: 'directives/progressbar/progressbar.html'
            },
            timeOut: 5000,
            titleClass: 'toast-title',
            toastClass: 'toast'
        });
}());

(function () {
    'use strict';

    angular.module('toastr')
        .directive('progressBar', progressBar);

    progressBar.$inject = ['toastrConfig'];

    function progressBar(toastrConfig) {
        return {
            require: '^toast',
            templateUrl: function () {
                return toastrConfig.templates.progressbar;
            },
            link: linkFunction
        };

        function linkFunction(scope, element, attrs, toastCtrl) {
            var intervalId, currentTimeOut, hideTime;

            toastCtrl.progressBar = scope;

            scope.start = function (duration) {
                if (intervalId) {
                    clearInterval(intervalId);
                }

                currentTimeOut = parseFloat(duration);
                hideTime = new Date().getTime() + currentTimeOut;
                intervalId = setInterval(updateProgress, 10);
            };

            scope.stop = function () {
                if (intervalId) {
                    clearInterval(intervalId);
                }
            };

            function updateProgress() {
                var percentage = ((hideTime - (new Date().getTime())) / currentTimeOut) * 100;
                element.css('width', percentage + '%');
            }

            scope.$on('$destroy', function () {
                // Failsafe stop
                clearInterval(intervalId);
            });
        }
    }
}());

(function () {
    'use strict';

    angular.module('toastr')
        .controller('ToastController', ToastController);

    function ToastController() {
        this.progressBar = null;

        this.startProgressBar = function (duration) {
            if (this.progressBar) {
                this.progressBar.start(duration);
            }
        };

        this.stopProgressBar = function () {
            if (this.progressBar) {
                this.progressBar.stop();
            }
        };
    }
}());

(function () {
    'use strict';

    angular.module('toastr')
        .directive('toast', toast);

    toast.$inject = ['$injector', '$interval', 'toastrConfig', 'toastr'];

    function toast($injector, $interval, toastrConfig, toastr) {
        return {
            templateUrl: function () {
                return toastrConfig.templates.toast;
            },
            controller: 'ToastController',
            link: toastLinkFunction
        };

        function toastLinkFunction(scope, element, attrs, toastCtrl) {
            var timeout;

            scope.toastClass = scope.options.toastClass;
            scope.titleClass = scope.options.titleClass;
            scope.messageClass = scope.options.messageClass;
            scope.progressBar = scope.options.progressBar;

            if (wantsCloseButton()) {
                var button = angular.element(scope.options.closeHtml),
                    $compile = $injector.get('$compile');
                button.addClass('toast-close-button');
                button.attr('ng-click', 'close(true, $event)');
                $compile(button)(scope);
                element.children().prepend(button);
            }

            scope.init = function () {
                if (scope.options.timeOut) {
                    timeout = createTimeout(scope.options.timeOut);
                }
                if (scope.options.onShown) {
                    scope.options.onShown();
                }
            };

            element.on('mouseenter', function () {
                hideAndStopProgressBar();
                if (timeout) {
                    $interval.cancel(timeout);
                }
            });

            scope.tapToast = function () {
                if (angular.isFunction(scope.options.onTap)) {
                    scope.options.onTap();
                }
                if (scope.options.tapToDismiss) {
                    scope.close(true);
                }
            };

            scope.close = function (wasClicked, $event) {
                if ($event && angular.isFunction($event.stopPropagation)) {
                    $event.stopPropagation();
                }
                toastr.remove(scope.toastId, wasClicked);
            };

            scope.refreshTimer = function (newTime) {
                if (timeout) {
                    $interval.cancel(timeout);
                    timeout = createTimeout(newTime || scope.options.timeOut);
                }
            };

            element.on('mouseleave', function () {
                if (scope.options.timeOut === 0 && scope.options.extendedTimeOut === 0) { return; }
                scope.$apply(function () {
                    scope.progressBar = scope.options.progressBar;
                });
                timeout = createTimeout(scope.options.extendedTimeOut);
            });

            function createTimeout(time) {
                toastCtrl.startProgressBar(time);
                return $interval(function () {
                    toastCtrl.stopProgressBar();
                    toastr.remove(scope.toastId);
                }, time, 1);
            }

            function hideAndStopProgressBar() {
                scope.progressBar = false;
                toastCtrl.stopProgressBar();
            }

            function wantsCloseButton() {
                return scope.options.closeHtml;
            }
        }
    }
}());

angular.module("toastr").run(["$templateCache", function ($templateCache) {
    $templateCache.put("directives/progressbar/progressbar.html", "<div class=\"toast-progress\"></div>\n");
    $templateCache.put("directives/toast/toast.html", "<div class=\"{{toastClass}} {{toastType}}\" ng-click=\"tapToast()\">\n  <div ng-switch on=\"allowHtml\">\n    <div ng-switch-default ng-if=\"title\" class=\"{{titleClass}}\" aria-label=\"{{title}}\">{{title}}</div>\n    <div ng-switch-default class=\"{{messageClass}}\" aria-label=\"{{message}}\">{{message}}</div>\n    <div ng-switch-when=\"true\" ng-if=\"title\" class=\"{{titleClass}}\" ng-bind-html=\"title\"></div>\n    <div ng-switch-when=\"true\" class=\"{{messageClass}}\" ng-bind-html=\"message\"></div>\n  </div>\n  <progress-bar ng-if=\"progressBar\"></progress-bar>\n</div>\n");
}]);
/*
 * ui-bootstrap-fontawesome
 * https://github.com/maxfierke/ui-bootstrap-fontawesome

 * Version: 0.3.0 - 2016-04-08
 * License: MIT
 */
angular.module("ui.bootstrap.fontawesome", ["ui.bootstrap.fontawesome.tpls", "ui.bootstrap.carousel", "ui.bootstrap.datepicker", "ui.bootstrap.rating", "ui.bootstrap.timepicker"]);
angular.module("ui.bootstrap.fontawesome.tpls", ["uib/template/carousel/carousel.html", "uib/template/datepicker/day.html", "uib/template/datepicker/month.html", "uib/template/datepicker/year.html", "uib/template/rating/rating.html", "uib/template/timepicker/timepicker.html"]);
angular.module("uib/template/carousel/carousel.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/carousel/carousel.html",
        "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\" ng-swipe-right=\"prev()\" ng-swipe-left=\"next()\">\n" +
        "  <div class=\"carousel-inner\" ng-transclude></div>\n" +
        "  <a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-show=\"slides.length > 1\">\n" +
        "    <span aria-hidden=\"true\" class=\"fa fa-chevron-left\"></span>\n" +
        "    <span class=\"sr-only\">previous</span>\n" +
        "  </a>\n" +
        "  <a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-show=\"slides.length > 1\">\n" +
        "    <span aria-hidden=\"true\" class=\"fa fa-chevron-right\"></span>\n" +
        "    <span class=\"sr-only\">next</span>\n" +
        "  </a>\n" +
        "  <ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" +
        "    <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" +
        "      <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" +
        "    </li>\n" +
        "  </ol>\n" +
        "</div>\n" +
        "");
}]);

angular.module("uib/template/datepicker/day.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/datepicker/day.html",
        "<table class=\"uib-daypicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
        "  <thead>\n" +
        "    <tr>\n" +
        "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"fa fa-chevron-left\"></i></button></th>\n" +
        "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
        "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"fa fa-chevron-right\"></i></button></th>\n" +
        "    </tr>\n" +
        "    <tr>\n" +
        "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" +
        "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" +
        "    </tr>\n" +
        "  </thead>\n" +
        "  <tbody>\n" +
        "    <tr class=\"uib-weeks\" ng-repeat=\"row in rows track by $index\">\n" +
        "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" +
        "      <td ng-repeat=\"dt in row\" class=\"uib-day text-center\" role=\"gridcell\"\n" +
        "        id=\"{{::dt.uid}}\"\n" +
        "        ng-class=\"::dt.customClass\">\n" +
        "        <button type=\"button\" class=\"btn btn-default btn-sm\"\n" +
        "          uib-is-class=\"\n" +
        "            'btn-info' for selectedDt,\n" +
        "            'active' for activeDt\n" +
        "            on dt\"\n" +
        "          ng-click=\"select(dt.date)\"\n" +
        "          ng-disabled=\"::dt.disabled\"\n" +
        "          tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
        "      </td>\n" +
        "    </tr>\n" +
        "  </tbody>\n" +
        "</table>\n" +
        "");
}]);

angular.module("uib/template/datepicker/month.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/datepicker/month.html",
        "<table class=\"uib-monthpicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
        "  <thead>\n" +
        "    <tr>\n" +
        "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"fa fa-chevron-left\"></i></button></th>\n" +
        "      <th><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
        "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"fa fa-chevron-right\"></i></button></th>\n" +
        "    </tr>\n" +
        "  </thead>\n" +
        "  <tbody>\n" +
        "    <tr class=\"uib-months\" ng-repeat=\"row in rows track by $index\">\n" +
        "      <td ng-repeat=\"dt in row\" class=\"uib-month text-center\" role=\"gridcell\"\n" +
        "        id=\"{{::dt.uid}}\"\n" +
        "        ng-class=\"::dt.customClass\">\n" +
        "        <button type=\"button\" class=\"btn btn-default\"\n" +
        "          uib-is-class=\"\n" +
        "            'btn-info' for selectedDt,\n" +
        "            'active' for activeDt\n" +
        "            on dt\"\n" +
        "          ng-click=\"select(dt.date)\"\n" +
        "          ng-disabled=\"::dt.disabled\"\n" +
        "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
        "      </td>\n" +
        "    </tr>\n" +
        "  </tbody>\n" +
        "</table>\n" +
        "");
}]);

angular.module("uib/template/datepicker/year.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/datepicker/year.html",
        "<table class=\"uib-yearpicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
        "  <thead>\n" +
        "    <tr>\n" +
        "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"fa fa-chevron-left\"></i></button></th>\n" +
        "      <th colspan=\"{{::columns - 2}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
        "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"fa fa-chevron-right\"></i></button></th>\n" +
        "    </tr>\n" +
        "  </thead>\n" +
        "  <tbody>\n" +
        "    <tr class=\"uib-years\" ng-repeat=\"row in rows track by $index\">\n" +
        "      <td ng-repeat=\"dt in row\" class=\"uib-year text-center\" role=\"gridcell\"\n" +
        "        id=\"{{::dt.uid}}\"\n" +
        "        ng-class=\"::dt.customClass\">\n" +
        "        <button type=\"button\" class=\"btn btn-default\"\n" +
        "          uib-is-class=\"\n" +
        "            'btn-info' for selectedDt,\n" +
        "            'active' for activeDt\n" +
        "            on dt\"\n" +
        "          ng-click=\"select(dt.date)\"\n" +
        "          ng-disabled=\"::dt.disabled\"\n" +
        "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
        "      </td>\n" +
        "    </tr>\n" +
        "  </tbody>\n" +
        "</table>\n" +
        "");
}]);

angular.module("uib/template/rating/rating.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/rating/rating.html",
        "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\" aria-valuetext=\"{{title}}\">\n" +
        "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" +
        "    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"fa\" ng-class=\"$index < value && (r.stateOn || 'fa-star') || (r.stateOff || 'fa-star-o')\" ng-attr-title=\"{{r.title}}\"></i>\n" +
        "</span>\n" +
        "");
}]);

angular.module("uib/template/timepicker/timepicker.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/timepicker/timepicker.html",
        "<table class=\"uib-timepicker\">\n" +
        "  <tbody>\n" +
        "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
        "      <td class=\"uib-increment hours\"><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"fa fa-chevron-up\"></span></a></td>\n" +
        "      <td>&nbsp;</td>\n" +
        "      <td class=\"uib-increment minutes\"><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"fa fa-chevron-up\"></span></a></td>\n" +
        "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
        "      <td ng-show=\"showSeconds\" class=\"uib-increment seconds\"><a ng-click=\"incrementSeconds()\" ng-class=\"{disabled: noIncrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementSeconds()\" tabindex=\"{{::tabindex}}\"><span class=\"fa fa-chevron-up\"></span></a></td>\n" +
        "      <td ng-show=\"showMeridian\"></td>\n" +
        "    </tr>\n" +
        "    <tr>\n" +
        "      <td class=\"form-group uib-time hours\" ng-class=\"{'has-error': invalidHours}\">\n" +
        "        <input style=\"width:50px;\" type=\"text\" placeholder=\"HH\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementHours()\" ng-blur=\"blur()\">\n" +
        "      </td>\n" +
        "      <td class=\"uib-separator\">:</td>\n" +
        "      <td class=\"form-group uib-time minutes\" ng-class=\"{'has-error': invalidMinutes}\">\n" +
        "        <input style=\"width:50px;\" type=\"text\" placeholder=\"MM\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementMinutes()\" ng-blur=\"blur()\">\n" +
        "      </td>\n" +
        "      <td ng-show=\"showSeconds\" class=\"uib-separator\">:</td>\n" +
        "      <td class=\"form-group uib-time seconds\" ng-class=\"{'has-error': invalidSeconds}\" ng-show=\"showSeconds\">\n" +
        "        <input style=\"width:50px;\" type=\"text\" placeholder=\"SS\" ng-model=\"seconds\" ng-change=\"updateSeconds()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementSeconds()\" ng-blur=\"blur()\">\n" +
        "      </td>\n" +
        "      <td ng-show=\"showMeridian\" class=\"uib-time am-pm\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\n" +
        "    </tr>\n" +
        "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
        "      <td class=\"uib-decrement hours\"><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"fa fa-chevron-down\"></span></a></td>\n" +
        "      <td>&nbsp;</td>\n" +
        "      <td class=\"uib-decrement minutes\"><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"fa fa-chevron-down\"></span></a></td>\n" +
        "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
        "      <td ng-show=\"showSeconds\" class=\"uib-decrement seconds\"><a ng-click=\"decrementSeconds()\" ng-class=\"{disabled: noDecrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementSeconds()\" tabindex=\"{{::tabindex}}\"><span class=\"fa fa-chevron-down\"></span></a></td>\n" +
        "      <td ng-show=\"showMeridian\"></td>\n" +
        "    </tr>\n" +
        "  </tbody>\n" +
        "</table>\n" +
        "");
}]);

/*! nanoScrollerJS - v0.8.7 - 2015
* http://jamesflorentino.github.com/nanoScrollerJS/
* Copyright (c) 2015 James Florentino; Licensed MIT */
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        return define(['jquery'], function ($) {
            return factory($, window, document);
        });
    } else if (typeof exports === 'object') {
        return module.exports = factory(require('jquery'), window, document);
    } else {
        return factory(jQuery, window, document);
    }
})(function ($, window, document) {
    "use strict";
    var BROWSER_IS_IE7, BROWSER_SCROLLBAR_WIDTH, DOMSCROLL, DOWN, DRAG, ENTER, KEYDOWN, KEYUP, MOUSEDOWN, MOUSEENTER, MOUSEMOVE, MOUSEUP, MOUSEWHEEL, NanoScroll, PANEDOWN, RESIZE, SCROLL, SCROLLBAR, TOUCHMOVE, UP, WHEEL, cAF, defaults, getBrowserScrollbarWidth, hasTransform, isFFWithBuggyScrollbar, rAF, transform, _elementStyle, _prefixStyle, _vendor;
    defaults = {

        /**
          a classname for the pane element.
          @property paneClass
          @type String
          @default 'nano-pane'
         */
        paneClass: 'nano-pane',

        /**
          a classname for the slider element.
          @property sliderClass
          @type String
          @default 'nano-slider'
         */
        sliderClass: 'nano-slider',

        /**
          a classname for the content element.
          @property contentClass
          @type String
          @default 'nano-content'
         */
        contentClass: 'nano-content',

        /**
          a setting to enable native scrolling in iOS devices.
          @property iOSNativeScrolling
          @type Boolean
          @default false
         */
        iOSNativeScrolling: false,

        /**
          a setting to prevent the rest of the page being
          scrolled when user scrolls the `.content` element.
          @property preventPageScrolling
          @type Boolean
          @default false
         */
        preventPageScrolling: false,

        /**
          a setting to disable binding to the resize event.
          @property disableResize
          @type Boolean
          @default false
         */
        disableResize: false,

        /**
          a setting to make the scrollbar always visible.
          @property alwaysVisible
          @type Boolean
          @default false
         */
        alwaysVisible: false,

        /**
          a default timeout for the `flash()` method.
          @property flashDelay
          @type Number
          @default 1500
         */
        flashDelay: 1500,

        /**
          a minimum height for the `.slider` element.
          @property sliderMinHeight
          @type Number
          @default 20
         */
        sliderMinHeight: 20,

        /**
          a maximum height for the `.slider` element.
          @property sliderMaxHeight
          @type Number
          @default null
         */
        sliderMaxHeight: null,

        /**
          an alternate document context.
          @property documentContext
          @type Document
          @default null
         */
        documentContext: null,

        /**
          an alternate window context.
          @property windowContext
          @type Window
          @default null
         */
        windowContext: null
    };

    /**
      @property SCROLLBAR
      @type String
      @static
      @final
      @private
     */
    SCROLLBAR = 'scrollbar';

    /**
      @property SCROLL
      @type String
      @static
      @final
      @private
     */
    SCROLL = 'scroll';

    /**
      @property MOUSEDOWN
      @type String
      @final
      @private
     */
    MOUSEDOWN = 'mousedown';

    /**
      @property MOUSEENTER
      @type String
      @final
      @private
     */
    MOUSEENTER = 'mouseenter';

    /**
      @property MOUSEMOVE
      @type String
      @static
      @final
      @private
     */
    MOUSEMOVE = 'mousemove';

    /**
      @property MOUSEWHEEL
      @type String
      @final
      @private
     */
    MOUSEWHEEL = 'mousewheel';

    /**
      @property MOUSEUP
      @type String
      @static
      @final
      @private
     */
    MOUSEUP = 'mouseup';

    /**
      @property RESIZE
      @type String
      @final
      @private
     */
    RESIZE = 'resize';

    /**
      @property DRAG
      @type String
      @static
      @final
      @private
     */
    DRAG = 'drag';

    /**
      @property ENTER
      @type String
      @static
      @final
      @private
     */
    ENTER = 'enter';

    /**
      @property UP
      @type String
      @static
      @final
      @private
     */
    UP = 'up';

    /**
      @property PANEDOWN
      @type String
      @static
      @final
      @private
     */
    PANEDOWN = 'panedown';

    /**
      @property DOMSCROLL
      @type String
      @static
      @final
      @private
     */
    DOMSCROLL = 'DOMMouseScroll';

    /**
      @property DOWN
      @type String
      @static
      @final
      @private
     */
    DOWN = 'down';

    /**
      @property WHEEL
      @type String
      @static
      @final
      @private
     */
    WHEEL = 'wheel';

    /**
      @property KEYDOWN
      @type String
      @static
      @final
      @private
     */
    KEYDOWN = 'keydown';

    /**
      @property KEYUP
      @type String
      @static
      @final
      @private
     */
    KEYUP = 'keyup';

    /**
      @property TOUCHMOVE
      @type String
      @static
      @final
      @private
     */
    TOUCHMOVE = 'touchmove';

    /**
      @property BROWSER_IS_IE7
      @type Boolean
      @static
      @final
      @private
     */
    BROWSER_IS_IE7 = window.navigator.appName === 'Microsoft Internet Explorer' && /msie 7./i.test(window.navigator.appVersion) && window.ActiveXObject;

    /**
      @property BROWSER_SCROLLBAR_WIDTH
      @type Number
      @static
      @default null
      @private
     */
    BROWSER_SCROLLBAR_WIDTH = null;
    rAF = window.requestAnimationFrame;
    cAF = window.cancelAnimationFrame;
    _elementStyle = document.createElement('div').style;
    _vendor = (function () {
        var i, transform, vendor, vendors, _i, _len;
        vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'];
        for (i = _i = 0, _len = vendors.length; _i < _len; i = ++_i) {
            vendor = vendors[i];
            transform = vendors[i] + 'ransform';
            if (transform in _elementStyle) {
                return vendors[i].substr(0, vendors[i].length - 1);
            }
        }
        return false;
    })();
    _prefixStyle = function (style) {
        if (_vendor === false) {
            return false;
        }
        if (_vendor === '') {
            return style;
        }
        return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
    };
    transform = _prefixStyle('transform');
    hasTransform = transform !== false;

    /**
      Returns browser's native scrollbar width
      @method getBrowserScrollbarWidth
      @return {Number} the scrollbar width in pixels
      @static
      @private
     */
    getBrowserScrollbarWidth = function () {
        var outer, outerStyle, scrollbarWidth;
        outer = document.createElement('div');
        outerStyle = outer.style;
        outerStyle.position = 'absolute';
        outerStyle.width = '100px';
        outerStyle.height = '100px';
        outerStyle.overflow = SCROLL;
        outerStyle.top = '-9999px';
        document.body.appendChild(outer);
        scrollbarWidth = outer.offsetWidth - outer.clientWidth;
        document.body.removeChild(outer);
        return scrollbarWidth;
    };
    isFFWithBuggyScrollbar = function () {
        var isOSXFF, ua, version;
        ua = window.navigator.userAgent;
        isOSXFF = /(?=.+Mac OS X)(?=.+Firefox)/.test(ua);
        if (!isOSXFF) {
            return false;
        }
        version = /Firefox\/\d{2}\./.exec(ua);
        if (version) {
            version = version[0].replace(/\D+/g, '');
        }
        return isOSXFF && +version > 23;
    };

    /**
      @class NanoScroll
      @param element {HTMLElement|Node} the main element
      @param options {Object} nanoScroller's options
      @constructor
     */
    NanoScroll = (function () {
        function NanoScroll(el, options) {
            this.el = el;
            this.options = options;
            BROWSER_SCROLLBAR_WIDTH || (BROWSER_SCROLLBAR_WIDTH = getBrowserScrollbarWidth());
            this.$el = $(this.el);
            this.doc = $(this.options.documentContext || document);
            this.win = $(this.options.windowContext || window);
            this.body = this.doc.find('body');
            this.$content = this.$el.children("." + this.options.contentClass);
            this.$content.attr('tabindex', this.options.tabIndex || 0);
            this.content = this.$content[0];
            this.previousPosition = 0;
            if (this.options.iOSNativeScrolling && (this.el.style.WebkitOverflowScrolling != null)) {
                this.nativeScrolling();
            } else {
                this.generate();
            }
            this.createEvents();
            this.addEvents();
            this.reset();
        }


        /**
          Prevents the rest of the page being scrolled
          when user scrolls the `.nano-content` element.
          @method preventScrolling
          @param event {Event}
          @param direction {String} Scroll direction (up or down)
          @private
         */

        NanoScroll.prototype.preventScrolling = function (e, direction) {
            if (!this.isActive) {
                return;
            }
            if (e.type === DOMSCROLL) {
                if (direction === DOWN && e.originalEvent.detail > 0 || direction === UP && e.originalEvent.detail < 0) {
                    e.preventDefault();
                }
            } else if (e.type === MOUSEWHEEL) {
                if (!e.originalEvent || !e.originalEvent.wheelDelta) {
                    return;
                }
                if (direction === DOWN && e.originalEvent.wheelDelta < 0 || direction === UP && e.originalEvent.wheelDelta > 0) {
                    e.preventDefault();
                }
            }
        };


        /**
          Enable iOS native scrolling
          @method nativeScrolling
          @private
         */

        NanoScroll.prototype.nativeScrolling = function () {
            this.$content.css({
                WebkitOverflowScrolling: 'touch'
            });
            this.iOSNativeScrolling = true;
            this.isActive = true;
        };


        /**
          Updates those nanoScroller properties that
          are related to current scrollbar position.
          @method updateScrollValues
          @private
         */

        NanoScroll.prototype.updateScrollValues = function () {
            var content, direction;
            content = this.content;
            this.maxScrollTop = content.scrollHeight - content.clientHeight;
            this.prevScrollTop = this.contentScrollTop || 0;
            this.contentScrollTop = content.scrollTop;
            direction = this.contentScrollTop > this.previousPosition ? "down" : this.contentScrollTop < this.previousPosition ? "up" : "same";
            this.previousPosition = this.contentScrollTop;
            if (direction !== "same") {
                this.$el.trigger('update', {
                    position: this.contentScrollTop,
                    maximum: this.maxScrollTop,
                    direction: direction
                });
            }
            if (!this.iOSNativeScrolling) {
                this.maxSliderTop = this.paneHeight - this.sliderHeight;
                this.sliderTop = this.maxScrollTop === 0 ? 0 : this.contentScrollTop * this.maxSliderTop / this.maxScrollTop;
            }
        };


        /**
          Updates CSS styles for current scroll position.
          Uses CSS 2d transfroms and `window.requestAnimationFrame` if available.
          @method setOnScrollStyles
          @private
         */

        NanoScroll.prototype.setOnScrollStyles = function () {
            var cssValue;
            if (hasTransform) {
                cssValue = {};
                cssValue[transform] = "translate(0, " + this.sliderTop + "px)";
            } else {
                cssValue = {
                    top: this.sliderTop
                };
            }
            if (rAF) {
                if (cAF && this.scrollRAF) {
                    cAF(this.scrollRAF);
                }
                this.scrollRAF = rAF((function (_this) {
                    return function () {
                        _this.scrollRAF = null;
                        return _this.slider.css(cssValue);
                    };
                })(this));
            } else {
                this.slider.css(cssValue);
            }
        };


        /**
          Creates event related methods
          @method createEvents
          @private
         */

        NanoScroll.prototype.createEvents = function () {
            this.events = {
                down: (function (_this) {
                    return function (e) {
                        _this.isBeingDragged = true;
                        _this.offsetY = e.pageY - _this.slider.offset().top;
                        if (!_this.slider.is(e.target)) {
                            _this.offsetY = 0;
                        }
                        _this.pane.addClass('active');
                        _this.doc.bind(MOUSEMOVE, _this.events[DRAG]).bind(MOUSEUP, _this.events[UP]);
                        _this.body.bind(MOUSEENTER, _this.events[ENTER]);
                        return false;
                    };
                })(this),
                drag: (function (_this) {
                    return function (e) {
                        _this.sliderY = e.pageY - _this.$el.offset().top - _this.paneTop - (_this.offsetY || _this.sliderHeight * 0.5);
                        _this.scroll();
                        if (_this.contentScrollTop >= _this.maxScrollTop && _this.prevScrollTop !== _this.maxScrollTop) {
                            _this.$el.trigger('scrollend');
                        } else if (_this.contentScrollTop === 0 && _this.prevScrollTop !== 0) {
                            _this.$el.trigger('scrolltop');
                        }
                        return false;
                    };
                })(this),
                up: (function (_this) {
                    return function (e) {
                        _this.isBeingDragged = false;
                        _this.pane.removeClass('active');
                        _this.doc.unbind(MOUSEMOVE, _this.events[DRAG]).unbind(MOUSEUP, _this.events[UP]);
                        _this.body.unbind(MOUSEENTER, _this.events[ENTER]);
                        return false;
                    };
                })(this),
                resize: (function (_this) {
                    return function (e) {
                        _this.reset();
                    };
                })(this),
                panedown: (function (_this) {
                    return function (e) {
                        _this.sliderY = (e.offsetY || e.originalEvent.layerY) - (_this.sliderHeight * 0.5);
                        _this.scroll();
                        _this.events.down(e);
                        return false;
                    };
                })(this),
                scroll: (function (_this) {
                    return function (e) {
                        _this.updateScrollValues();
                        if (_this.isBeingDragged) {
                            return;
                        }
                        if (!_this.iOSNativeScrolling) {
                            _this.sliderY = _this.sliderTop;
                            _this.setOnScrollStyles();
                        }
                        if (e == null) {
                            return;
                        }
                        if (_this.contentScrollTop >= _this.maxScrollTop) {
                            if (_this.options.preventPageScrolling) {
                                _this.preventScrolling(e, DOWN);
                            }
                            if (_this.prevScrollTop !== _this.maxScrollTop) {
                                _this.$el.trigger('scrollend');
                            }
                        } else if (_this.contentScrollTop === 0) {
                            if (_this.options.preventPageScrolling) {
                                _this.preventScrolling(e, UP);
                            }
                            if (_this.prevScrollTop !== 0) {
                                _this.$el.trigger('scrolltop');
                            }
                        }
                    };
                })(this),
                wheel: (function (_this) {
                    return function (e) {
                        var delta;
                        if (e == null) {
                            return;
                        }
                        delta = e.delta || e.wheelDelta || (e.originalEvent && e.originalEvent.wheelDelta) || -e.detail || (e.originalEvent && -e.originalEvent.detail);
                        if (delta) {
                            _this.sliderY += -delta / 3;
                        }
                        _this.scroll();
                        return false;
                    };
                })(this),
                enter: (function (_this) {
                    return function (e) {
                        var _ref;
                        if (!_this.isBeingDragged) {
                            return;
                        }
                        if ((e.buttons || e.which) !== 1) {
                            return (_ref = _this.events)[UP].apply(_ref, arguments);
                        }
                    };
                })(this)
            };
        };


        /**
          Adds event listeners with jQuery.
          @method addEvents
          @private
         */

        NanoScroll.prototype.addEvents = function () {
            var events;
            this.removeEvents();
            events = this.events;
            if (!this.options.disableResize) {
                this.win.bind(RESIZE, events[RESIZE]);
            }
            if (!this.iOSNativeScrolling) {
                this.slider.bind(MOUSEDOWN, events[DOWN]);
                this.pane.bind(MOUSEDOWN, events[PANEDOWN]).bind("" + MOUSEWHEEL + " " + DOMSCROLL, events[WHEEL]);
            }
            this.$content.bind("" + SCROLL + " " + MOUSEWHEEL + " " + DOMSCROLL + " " + TOUCHMOVE, events[SCROLL]);
        };


        /**
          Removes event listeners with jQuery.
          @method removeEvents
          @private
         */

        NanoScroll.prototype.removeEvents = function () {
            var events;
            events = this.events;
            this.win.unbind(RESIZE, events[RESIZE]);
            if (!this.iOSNativeScrolling) {
                this.slider.unbind();
                this.pane.unbind();
            }
            this.$content.unbind("" + SCROLL + " " + MOUSEWHEEL + " " + DOMSCROLL + " " + TOUCHMOVE, events[SCROLL]);
        };


        /**
          Generates nanoScroller's scrollbar and elements for it.
          @method generate
          @chainable
          @private
         */

        NanoScroll.prototype.generate = function () {
            var contentClass, cssRule, currentPadding, options, pane, paneClass, sliderClass;
            options = this.options;
            paneClass = options.paneClass, sliderClass = options.sliderClass, contentClass = options.contentClass;
            if (!(pane = this.$el.children("." + paneClass)).length && !pane.children("." + sliderClass).length) {
                this.$el.append("<div class=\"" + paneClass + "\"><div class=\"" + sliderClass + "\" /></div>");
            }
            this.pane = this.$el.children("." + paneClass);
            this.slider = this.pane.find("." + sliderClass);
            if (BROWSER_SCROLLBAR_WIDTH === 0 && isFFWithBuggyScrollbar()) {
                currentPadding = window.getComputedStyle(this.content, null).getPropertyValue('padding-right').replace(/[^0-9.]+/g, '');
                cssRule = {
                    right: -14,
                    paddingRight: +currentPadding + 14
                };
            } else if (BROWSER_SCROLLBAR_WIDTH) {
                cssRule = {
                    right: -BROWSER_SCROLLBAR_WIDTH
                };
                this.$el.addClass('has-scrollbar');
            }
            if (cssRule != null) {
                this.$content.css(cssRule);
            }
            return this;
        };


        /**
          @method restore
          @private
         */

        NanoScroll.prototype.restore = function () {
            this.stopped = false;
            if (!this.iOSNativeScrolling) {
                this.pane.show();
            }
            this.addEvents();
        };


        /**
          Resets nanoScroller's scrollbar.
          @method reset
          @chainable
          @example
              $(".nano").nanoScroller();
         */

        NanoScroll.prototype.reset = function () {
            var content, contentHeight, contentPosition, contentStyle, contentStyleOverflowY, paneBottom, paneHeight, paneOuterHeight, paneTop, parentMaxHeight, right, sliderHeight;
            if (this.iOSNativeScrolling) {
                this.contentHeight = this.content.scrollHeight;
                return;
            }
            if (!this.$el.find("." + this.options.paneClass).length) {
                this.generate().stop();
            }
            if (this.stopped) {
                this.restore();
            }
            content = this.content;
            contentStyle = content.style;
            contentStyleOverflowY = contentStyle.overflowY;
            if (BROWSER_IS_IE7) {
                this.$content.css({
                    height: this.$content.height()
                });
            }
            contentHeight = content.scrollHeight + BROWSER_SCROLLBAR_WIDTH;
            parentMaxHeight = parseInt(this.$el.css("max-height"), 10);
            if (parentMaxHeight > 0) {
                this.$el.height("");
                this.$el.height(content.scrollHeight > parentMaxHeight ? parentMaxHeight : content.scrollHeight);
            }
            paneHeight = this.pane.outerHeight(false);
            paneTop = parseInt(this.pane.css('top'), 10);
            paneBottom = parseInt(this.pane.css('bottom'), 10);
            paneOuterHeight = paneHeight + paneTop + paneBottom;
            sliderHeight = Math.round(paneOuterHeight / contentHeight * paneHeight);
            if (sliderHeight < this.options.sliderMinHeight) {
                sliderHeight = this.options.sliderMinHeight;
            } else if ((this.options.sliderMaxHeight != null) && sliderHeight > this.options.sliderMaxHeight) {
                sliderHeight = this.options.sliderMaxHeight;
            }
            if (contentStyleOverflowY === SCROLL && contentStyle.overflowX !== SCROLL) {
                sliderHeight += BROWSER_SCROLLBAR_WIDTH;
            }
            this.maxSliderTop = paneOuterHeight - sliderHeight;
            this.contentHeight = contentHeight;
            this.paneHeight = paneHeight;
            this.paneOuterHeight = paneOuterHeight;
            this.sliderHeight = sliderHeight;
            this.paneTop = paneTop;
            this.slider.height(sliderHeight);
            this.events.scroll();
            this.pane.show();
            this.isActive = true;
            if ((content.scrollHeight === content.clientHeight) || (this.pane.outerHeight(true) >= content.scrollHeight && contentStyleOverflowY !== SCROLL)) {
                this.pane.hide();
                this.isActive = false;
            } else if (this.el.clientHeight === content.scrollHeight && contentStyleOverflowY === SCROLL) {
                this.slider.hide();
            } else {
                this.slider.show();
            }
            this.pane.css({
                opacity: (this.options.alwaysVisible ? 1 : ''),
                visibility: (this.options.alwaysVisible ? 'visible' : '')
            });
            contentPosition = this.$content.css('position');
            if (contentPosition === 'static' || contentPosition === 'relative') {
                right = parseInt(this.$content.css('right'), 10);
                if (right) {
                    this.$content.css({
                        right: '',
                        marginRight: right
                    });
                }
            }
            return this;
        };


        /**
          @method scroll
          @private
          @example
              $(".nano").nanoScroller({ scroll: 'top' });
         */

        NanoScroll.prototype.scroll = function () {
            if (!this.isActive) {
                return;
            }
            this.sliderY = Math.max(0, this.sliderY);
            this.sliderY = Math.min(this.maxSliderTop, this.sliderY);
            this.$content.scrollTop(this.maxScrollTop * this.sliderY / this.maxSliderTop);
            if (!this.iOSNativeScrolling) {
                this.updateScrollValues();
                this.setOnScrollStyles();
            }
            return this;
        };


        /**
          Scroll at the bottom with an offset value
          @method scrollBottom
          @param offsetY {Number}
          @chainable
          @example
              $(".nano").nanoScroller({ scrollBottom: value });
         */

        NanoScroll.prototype.scrollBottom = function (offsetY) {
            if (!this.isActive) {
                return;
            }
            this.$content.scrollTop(this.contentHeight - this.$content.height() - offsetY).trigger(MOUSEWHEEL);
            this.stop().restore();
            return this;
        };


        /**
          Scroll at the top with an offset value
          @method scrollTop
          @param offsetY {Number}
          @chainable
          @example
              $(".nano").nanoScroller({ scrollTop: value });
         */

        NanoScroll.prototype.scrollTop = function (offsetY) {
            if (!this.isActive) {
                return;
            }
            this.$content.scrollTop(+offsetY).trigger(MOUSEWHEEL);
            this.stop().restore();
            return this;
        };


        /**
          Scroll to an element
          @method scrollTo
          @param node {Node} A node to scroll to.
          @chainable
          @example
              $(".nano").nanoScroller({ scrollTo: $('#a_node') });
         */

        NanoScroll.prototype.scrollTo = function (node) {
            if (!this.isActive) {
                return;
            }
            this.scrollTop(this.$el.find(node).get(0).offsetTop);
            return this;
        };


        /**
          To stop the operation.
          This option will tell the plugin to disable all event bindings and hide the gadget scrollbar from the UI.
          @method stop
          @chainable
          @example
              $(".nano").nanoScroller({ stop: true });
         */

        NanoScroll.prototype.stop = function () {
            if (cAF && this.scrollRAF) {
                cAF(this.scrollRAF);
                this.scrollRAF = null;
            }
            this.stopped = true;
            this.removeEvents();
            if (!this.iOSNativeScrolling) {
                this.pane.hide();
            }
            return this;
        };


        /**
          Destroys nanoScroller and restores browser's native scrollbar.
          @method destroy
          @chainable
          @example
              $(".nano").nanoScroller({ destroy: true });
         */

        NanoScroll.prototype.destroy = function () {
            if (!this.stopped) {
                this.stop();
            }
            if (!this.iOSNativeScrolling && this.pane.length) {
                this.pane.remove();
            }
            if (BROWSER_IS_IE7) {
                this.$content.height('');
            }
            this.$content.removeAttr('tabindex');
            if (this.$el.hasClass('has-scrollbar')) {
                this.$el.removeClass('has-scrollbar');
                this.$content.css({
                    right: ''
                });
            }
            return this;
        };


        /**
          To flash the scrollbar gadget for an amount of time defined in plugin settings (defaults to 1,5s).
          Useful if you want to show the user (e.g. on pageload) that there is more content waiting for him.
          @method flash
          @chainable
          @example
              $(".nano").nanoScroller({ flash: true });
         */

        NanoScroll.prototype.flash = function () {
            if (this.iOSNativeScrolling) {
                return;
            }
            if (!this.isActive) {
                return;
            }
            this.reset();
            this.pane.addClass('flashed');
            setTimeout((function (_this) {
                return function () {
                    _this.pane.removeClass('flashed');
                };
            })(this), this.options.flashDelay);
            return this;
        };

        return NanoScroll;

    })();
    $.fn.nanoScroller = function (settings) {
        return this.each(function () {
            var options, scrollbar;
            if (!(scrollbar = this.nanoscroller)) {
                options = $.extend({}, defaults, settings);
                this.nanoscroller = scrollbar = new NanoScroll(this, options);
            }
            if (settings && typeof settings === "object") {
                $.extend(scrollbar.options, settings);
                if (settings.scrollBottom != null) {
                    return scrollbar.scrollBottom(settings.scrollBottom);
                }
                if (settings.scrollTop != null) {
                    return scrollbar.scrollTop(settings.scrollTop);
                }
                if (settings.scrollTo) {
                    return scrollbar.scrollTo(settings.scrollTo);
                }
                if (settings.scroll === 'bottom') {
                    return scrollbar.scrollBottom(0);
                }
                if (settings.scroll === 'top') {
                    return scrollbar.scrollTop(0);
                }
                if (settings.scroll && settings.scroll instanceof $) {
                    return scrollbar.scrollTo(settings.scroll);
                }
                if (settings.stop) {
                    return scrollbar.stop();
                }
                if (settings.destroy) {
                    return scrollbar.destroy();
                }
                if (settings.flash) {
                    return scrollbar.flash();
                }
            }
            return scrollbar.reset();
        });
    };
    $.fn.nanoScroller.Constructor = NanoScroll;
});

//# sourceMappingURL=jquery.nanoscroller.js.map

;
(function (angular, $, undefined) {
    'use strict';
    if ($.fn['nanoScroller'] === undefined) {
        throw new Error("nanoScrollerJS is not defined in jQuery");
    }
    //jQuery must be used, cause angular method 'find' has different behavior
    if (angular.element !== $) {
        throw new Error("Angular must use jQuery not jqLite");
    }

    var AS_ELEMENT = 1, AS_ATTRIBUTE = 0;
    /**
     * Wrapper of nanoScrollerJS
     * @name sun.scrollable
     */
    var module = angular.module('sun.scrollable', ['ng']);

    /**
     * Configuration for the directive
     * @name scrollableConfig
     * @param scrollableConfig.template Template of the scroller
     * @param scrollableConfig.bottomMargin Available number of pixels from the bottom,
     *        in which it is considered that scroller is in bottom
     */
    module.constant("scrollableConfig", {
        template: '<div class="{nanoClass}"><div class="{contentClass}" ng-transclude></div></div>',
        bottomMargin: 40
    });

    /**
     * Default configuration of the nanoScroller
     * @name nanoScrollerDefaults
     */
    module.constant("nanoScrollerDefaults", {
        nanoClass: 'nano',
        contentClass: 'nano-content'
    });
    module.directive("scrollable", createScrollableDirective(AS_ELEMENT));
    module.directive("scrollable", createScrollableDirective(AS_ATTRIBUTE));

    /**
     * Create directive 'scrollable' specified by variable `type`.
     * If type equals to `AS_ELEMENT` directive will replace element, otherwise template will be appended.
     * @param type Type of the directive: `AS_ELEMENT` or `AS_ATTRIBUTE`
     * @returns {function} Directive creation function
     */
    function createScrollableDirective(type) {
        var directive = function ($timeout, scrollableConfig, nanoScrollerDefaults) {
            return {
                transclude: true,
                replace: type === AS_ELEMENT,
                restrict: type === AS_ELEMENT ? 'E' : 'A',
                priority: 1000,
                template: format(scrollableConfig.template, nanoScrollerDefaults),
                link: function (scope, element, attr) {
                    var oldHeight,
                        contentClass = nanoScrollerDefaults.contentClass,
                        nanoClass = nanoScrollerDefaults.nanoClass,
                        contentElement = element.find('.' + contentClass)[0],
                        parentElement = contentElement.parentElement,
                        $nanoElement = element.hasClass(nanoClass) ? element : element.find('.' + nanoClass),
                        options = angular.extend({}, nanoScrollerDefaults, convertStringToValue(attr), scope.$eval(attr['scrollable']));

                    function listener(newHeight, oldHeight) {
                        // If this is first run, create nanoScroller
                        if (newHeight === oldHeight) {
                            // First run must be async
                            scope.$evalAsync(function () {
                                $nanoElement.nanoScroller(options);
                                $nanoElement.nanoScroller();
                            });
                        }
                        //If scroller was on the bottom, scroll to bottom
                        else if (newHeight !== oldHeight && contentElement.scrollTop &&
                            (oldHeight - contentElement.scrollTop - parentElement.clientHeight) < scrollableConfig.bottomMargin) {
                            scope.$evalAsync(function () {
                                // To make right calculation scroller must be reseted
                                // See https://github.com/maxaon/angular-nanoscroller/issues/4
                                $nanoElement.nanoScroller();
                                $nanoElement.nanoScroller({ scroll: 'bottom' });
                            });

                        }
                        // Otherwise just update the pane
                        else {
                            $nanoElement.nanoScroller();
                        }
                    }

                    function collectionListener() {
                        var newHeight = contentElement.scrollHeight;
                        if (oldHeight === undefined) {
                            oldHeight = newHeight;
                        }
                        listener(newHeight, oldHeight);
                    }

                    if (attr['static']) {
                        // Call scroller after transclusion
                        listener();
                    }
                    else if (typeof attr['watch'] === 'string' || attr['watchCollection']) {
                        angular.forEach(splitter(attr['watch']), function (name) {
                            scope.$watch(name, collectionListener);
                        });
                        angular.forEach(splitter(attr['watchCollection']), function (name) {
                            scope.$watchCollection(name, collectionListener);
                        });
                    }
                    // If no watchers are supplied fall back to content element height check
                    else {
                        // http://jsperf.com/angular-watch-collection-vs-element-scroll-height
                        // Call nanoScroller, when height of content is changed
                        scope.$watch(function () {
                            return contentElement.scrollHeight;
                        },
                            listener);
                    }
                    scope.$on("$destroy", function () {
                        $nanoElement.nanoScroller({ destroy: true });
                        $nanoElement = contentElement = parentElement = null;
                    });
                }
            };
        };
        directive.$inject = ['$timeout', 'scrollableConfig', 'nanoScrollerDefaults'];
        return directive;
    }

    /**
     * Convert element attributes from stings to objects.
     * Also filter attribute (starting from '$' and class)
     * @param attr Attribute array
     * @returns {{}} Filtered object of converted attributes
     */
    function convertStringToValue(attr) {
        var result = {};
        angular.forEach(attr, function (value, key) {
            if (key.indexOf("$") === 0) {
                return;
            }
            switch (key) {
                case "true":
                    value = true;
                    break;
                case "false":
                    value = false;
                    break;
                case "null":
                    value = null;
                    break;
                case "class":
                    return;
            }
            result[key] = value;
        });
        return result;
    }

    /**
     * Split text in attribute by `,` or `;`
     * @param val Attribute value
     * @returns {Array} Array of name
     */
    function splitter(val) {
        if (!val) {
            return [];
        }
        return val.replace(",", ";").split(";");
    }

    /**
     * Format `str` in python way (only dictionary)
     * @param str Input string
     * @param params Replacing variables
     * @returns {String}
     */
    function format(str, params) {
        return str.replace(new RegExp("{.*?}", "g"), function (variable) {
            return params[variable.slice(1, -1)] || "";
        });
    }

}(angular, jQuery));

!function (a, b) { "object" == typeof exports && "undefined" != typeof module ? module.exports = b() : "function" == typeof define && define.amd ? define(b) : a.moment = b() }(this, function () {
    "use strict"; function a() { return re.apply(null, arguments) } function b(a) { re = a } function c(a) { return a instanceof Array || "[object Array]" === Object.prototype.toString.call(a) } function d(a) { return null != a && "[object Object]" === Object.prototype.toString.call(a) } function e(a) { var b; for (b in a) return !1; return !0 } function f(a) { return void 0 === a } function g(a) { return "number" == typeof a || "[object Number]" === Object.prototype.toString.call(a) } function h(a) { return a instanceof Date || "[object Date]" === Object.prototype.toString.call(a) } function i(a, b) { var c, d = []; for (c = 0; c < a.length; ++c)d.push(b(a[c], c)); return d } function j(a, b) { return Object.prototype.hasOwnProperty.call(a, b) } function k(a, b) { for (var c in b) j(b, c) && (a[c] = b[c]); return j(b, "toString") && (a.toString = b.toString), j(b, "valueOf") && (a.valueOf = b.valueOf), a } function l(a, b, c, d) { return sb(a, b, c, d, !0).utc() } function m() { return { empty: !1, unusedTokens: [], unusedInput: [], overflow: -2, charsLeftOver: 0, nullInput: !1, invalidMonth: null, invalidFormat: !1, userInvalidated: !1, iso: !1, parsedDateParts: [], meridiem: null, rfc2822: !1, weekdayMismatch: !1 } } function n(a) { return null == a._pf && (a._pf = m()), a._pf } function o(a) { if (null == a._isValid) { var b = n(a), c = te.call(b.parsedDateParts, function (a) { return null != a }), d = !isNaN(a._d.getTime()) && b.overflow < 0 && !b.empty && !b.invalidMonth && !b.invalidWeekday && !b.nullInput && !b.invalidFormat && !b.userInvalidated && (!b.meridiem || b.meridiem && c); if (a._strict && (d = d && 0 === b.charsLeftOver && 0 === b.unusedTokens.length && void 0 === b.bigHour), null != Object.isFrozen && Object.isFrozen(a)) return d; a._isValid = d } return a._isValid } function p(a) { var b = l(NaN); return null != a ? k(n(b), a) : n(b).userInvalidated = !0, b } function q(a, b) { var c, d, e; if (f(b._isAMomentObject) || (a._isAMomentObject = b._isAMomentObject), f(b._i) || (a._i = b._i), f(b._f) || (a._f = b._f), f(b._l) || (a._l = b._l), f(b._strict) || (a._strict = b._strict), f(b._tzm) || (a._tzm = b._tzm), f(b._isUTC) || (a._isUTC = b._isUTC), f(b._offset) || (a._offset = b._offset), f(b._pf) || (a._pf = n(b)), f(b._locale) || (a._locale = b._locale), ue.length > 0) for (c = 0; c < ue.length; c++)d = ue[c], e = b[d], f(e) || (a[d] = e); return a } function r(b) { q(this, b), this._d = new Date(null != b._d ? b._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), ve === !1 && (ve = !0, a.updateOffset(this), ve = !1) } function s(a) { return a instanceof r || null != a && null != a._isAMomentObject } function t(a) { return a < 0 ? Math.ceil(a) || 0 : Math.floor(a) } function u(a) { var b = +a, c = 0; return 0 !== b && isFinite(b) && (c = t(b)), c } function v(a, b, c) { var d, e = Math.min(a.length, b.length), f = Math.abs(a.length - b.length), g = 0; for (d = 0; d < e; d++)(c && a[d] !== b[d] || !c && u(a[d]) !== u(b[d])) && g++; return g + f } function w(b) { a.suppressDeprecationWarnings === !1 && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + b) } function x(b, c) { var d = !0; return k(function () { if (null != a.deprecationHandler && a.deprecationHandler(null, b), d) { for (var e, f = [], g = 0; g < arguments.length; g++) { if (e = "", "object" == typeof arguments[g]) { e += "\n[" + g + "] "; for (var h in arguments[0]) e += h + ": " + arguments[0][h] + ", "; e = e.slice(0, -2) } else e = arguments[g]; f.push(e) } w(b + "\nArguments: " + Array.prototype.slice.call(f).join("") + "\n" + (new Error).stack), d = !1 } return c.apply(this, arguments) }, c) } function y(b, c) { null != a.deprecationHandler && a.deprecationHandler(b, c), we[b] || (w(c), we[b] = !0) } function z(a) { return a instanceof Function || "[object Function]" === Object.prototype.toString.call(a) } function A(a) { var b, c; for (c in a) b = a[c], z(b) ? this[c] = b : this["_" + c] = b; this._config = a, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source) } function B(a, b) { var c, e = k({}, a); for (c in b) j(b, c) && (d(a[c]) && d(b[c]) ? (e[c] = {}, k(e[c], a[c]), k(e[c], b[c])) : null != b[c] ? e[c] = b[c] : delete e[c]); for (c in a) j(a, c) && !j(b, c) && d(a[c]) && (e[c] = k({}, e[c])); return e } function C(a) { null != a && this.set(a) } function D(a, b, c) { var d = this._calendar[a] || this._calendar.sameElse; return z(d) ? d.call(b, c) : d } function E(a) { var b = this._longDateFormat[a], c = this._longDateFormat[a.toUpperCase()]; return b || !c ? b : (this._longDateFormat[a] = c.replace(/MMMM|MM|DD|dddd/g, function (a) { return a.slice(1) }), this._longDateFormat[a]) } function F() { return this._invalidDate } function G(a) { return this._ordinal.replace("%d", a) } function H(a, b, c, d) { var e = this._relativeTime[c]; return z(e) ? e(a, b, c, d) : e.replace(/%d/i, a) } function I(a, b) { var c = this._relativeTime[a > 0 ? "future" : "past"]; return z(c) ? c(b) : c.replace(/%s/i, b) } function J(a, b) { var c = a.toLowerCase(); Ge[c] = Ge[c + "s"] = Ge[b] = a } function K(a) { return "string" == typeof a ? Ge[a] || Ge[a.toLowerCase()] : void 0 } function L(a) { var b, c, d = {}; for (c in a) j(a, c) && (b = K(c), b && (d[b] = a[c])); return d } function M(a, b) { He[a] = b } function N(a) { var b = []; for (var c in a) b.push({ unit: c, priority: He[c] }); return b.sort(function (a, b) { return a.priority - b.priority }), b } function O(b, c) { return function (d) { return null != d ? (Q(this, b, d), a.updateOffset(this, c), this) : P(this, b) } } function P(a, b) { return a.isValid() ? a._d["get" + (a._isUTC ? "UTC" : "") + b]() : NaN } function Q(a, b, c) { a.isValid() && a._d["set" + (a._isUTC ? "UTC" : "") + b](c) } function R(a) { return a = K(a), z(this[a]) ? this[a]() : this } function S(a, b) { if ("object" == typeof a) { a = L(a); for (var c = N(a), d = 0; d < c.length; d++)this[c[d].unit](a[c[d].unit]) } else if (a = K(a), z(this[a])) return this[a](b); return this } function T(a, b, c) { var d = "" + Math.abs(a), e = b - d.length, f = a >= 0; return (f ? c ? "+" : "" : "-") + Math.pow(10, Math.max(0, e)).toString().substr(1) + d } function U(a, b, c, d) { var e = d; "string" == typeof d && (e = function () { return this[d]() }), a && (Le[a] = e), b && (Le[b[0]] = function () { return T(e.apply(this, arguments), b[1], b[2]) }), c && (Le[c] = function () { return this.localeData().ordinal(e.apply(this, arguments), a) }) } function V(a) { return a.match(/\[[\s\S]/) ? a.replace(/^\[|\]$/g, "") : a.replace(/\\/g, "") } function W(a) { var b, c, d = a.match(Ie); for (b = 0, c = d.length; b < c; b++)Le[d[b]] ? d[b] = Le[d[b]] : d[b] = V(d[b]); return function (b) { var e, f = ""; for (e = 0; e < c; e++)f += z(d[e]) ? d[e].call(b, a) : d[e]; return f } } function X(a, b) { return a.isValid() ? (b = Y(b, a.localeData()), Ke[b] = Ke[b] || W(b), Ke[b](a)) : a.localeData().invalidDate() } function Y(a, b) { function c(a) { return b.longDateFormat(a) || a } var d = 5; for (Je.lastIndex = 0; d >= 0 && Je.test(a);)a = a.replace(Je, c), Je.lastIndex = 0, d -= 1; return a } function Z(a, b, c) { bf[a] = z(b) ? b : function (a, d) { return a && c ? c : b } } function $(a, b) { return j(bf, a) ? bf[a](b._strict, b._locale) : new RegExp(_(a)) } function _(a) { return aa(a.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (a, b, c, d, e) { return b || c || d || e })) } function aa(a) { return a.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&") } function ba(a, b) { var c, d = b; for ("string" == typeof a && (a = [a]), g(b) && (d = function (a, c) { c[b] = u(a) }), c = 0; c < a.length; c++)cf[a[c]] = d } function ca(a, b) { ba(a, function (a, c, d, e) { d._w = d._w || {}, b(a, d._w, d, e) }) } function da(a, b, c) { null != b && j(cf, a) && cf[a](b, c._a, c, a) } function ea(a, b) { return new Date(Date.UTC(a, b + 1, 0)).getUTCDate() } function fa(a, b) { return a ? c(this._months) ? this._months[a.month()] : this._months[(this._months.isFormat || of).test(b) ? "format" : "standalone"][a.month()] : c(this._months) ? this._months : this._months.standalone } function ga(a, b) { return a ? c(this._monthsShort) ? this._monthsShort[a.month()] : this._monthsShort[of.test(b) ? "format" : "standalone"][a.month()] : c(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone } function ha(a, b, c) { var d, e, f, g = a.toLocaleLowerCase(); if (!this._monthsParse) for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], d = 0; d < 12; ++d)f = l([2e3, d]), this._shortMonthsParse[d] = this.monthsShort(f, "").toLocaleLowerCase(), this._longMonthsParse[d] = this.months(f, "").toLocaleLowerCase(); return c ? "MMM" === b ? (e = nf.call(this._shortMonthsParse, g), e !== -1 ? e : null) : (e = nf.call(this._longMonthsParse, g), e !== -1 ? e : null) : "MMM" === b ? (e = nf.call(this._shortMonthsParse, g), e !== -1 ? e : (e = nf.call(this._longMonthsParse, g), e !== -1 ? e : null)) : (e = nf.call(this._longMonthsParse, g), e !== -1 ? e : (e = nf.call(this._shortMonthsParse, g), e !== -1 ? e : null)) } function ia(a, b, c) { var d, e, f; if (this._monthsParseExact) return ha.call(this, a, b, c); for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), d = 0; d < 12; d++) { if (e = l([2e3, d]), c && !this._longMonthsParse[d] && (this._longMonthsParse[d] = new RegExp("^" + this.months(e, "").replace(".", "") + "$", "i"), this._shortMonthsParse[d] = new RegExp("^" + this.monthsShort(e, "").replace(".", "") + "$", "i")), c || this._monthsParse[d] || (f = "^" + this.months(e, "") + "|^" + this.monthsShort(e, ""), this._monthsParse[d] = new RegExp(f.replace(".", ""), "i")), c && "MMMM" === b && this._longMonthsParse[d].test(a)) return d; if (c && "MMM" === b && this._shortMonthsParse[d].test(a)) return d; if (!c && this._monthsParse[d].test(a)) return d } } function ja(a, b) { var c; if (!a.isValid()) return a; if ("string" == typeof b) if (/^\d+$/.test(b)) b = u(b); else if (b = a.localeData().monthsParse(b), !g(b)) return a; return c = Math.min(a.date(), ea(a.year(), b)), a._d["set" + (a._isUTC ? "UTC" : "") + "Month"](b, c), a } function ka(b) { return null != b ? (ja(this, b), a.updateOffset(this, !0), this) : P(this, "Month") } function la() { return ea(this.year(), this.month()) } function ma(a) { return this._monthsParseExact ? (j(this, "_monthsRegex") || oa.call(this), a ? this._monthsShortStrictRegex : this._monthsShortRegex) : (j(this, "_monthsShortRegex") || (this._monthsShortRegex = rf), this._monthsShortStrictRegex && a ? this._monthsShortStrictRegex : this._monthsShortRegex) } function na(a) { return this._monthsParseExact ? (j(this, "_monthsRegex") || oa.call(this), a ? this._monthsStrictRegex : this._monthsRegex) : (j(this, "_monthsRegex") || (this._monthsRegex = sf), this._monthsStrictRegex && a ? this._monthsStrictRegex : this._monthsRegex) } function oa() { function a(a, b) { return b.length - a.length } var b, c, d = [], e = [], f = []; for (b = 0; b < 12; b++)c = l([2e3, b]), d.push(this.monthsShort(c, "")), e.push(this.months(c, "")), f.push(this.months(c, "")), f.push(this.monthsShort(c, "")); for (d.sort(a), e.sort(a), f.sort(a), b = 0; b < 12; b++)d[b] = aa(d[b]), e[b] = aa(e[b]); for (b = 0; b < 24; b++)f[b] = aa(f[b]); this._monthsRegex = new RegExp("^(" + f.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + e.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + d.join("|") + ")", "i") } function pa(a) { return qa(a) ? 366 : 365 } function qa(a) { return a % 4 === 0 && a % 100 !== 0 || a % 400 === 0 } function ra() { return qa(this.year()) } function sa(a, b, c, d, e, f, g) { var h = new Date(a, b, c, d, e, f, g); return a < 100 && a >= 0 && isFinite(h.getFullYear()) && h.setFullYear(a), h } function ta(a) { var b = new Date(Date.UTC.apply(null, arguments)); return a < 100 && a >= 0 && isFinite(b.getUTCFullYear()) && b.setUTCFullYear(a), b } function ua(a, b, c) { var d = 7 + b - c, e = (7 + ta(a, 0, d).getUTCDay() - b) % 7; return -e + d - 1 } function va(a, b, c, d, e) { var f, g, h = (7 + c - d) % 7, i = ua(a, d, e), j = 1 + 7 * (b - 1) + h + i; return j <= 0 ? (f = a - 1, g = pa(f) + j) : j > pa(a) ? (f = a + 1, g = j - pa(a)) : (f = a, g = j), { year: f, dayOfYear: g } } function wa(a, b, c) { var d, e, f = ua(a.year(), b, c), g = Math.floor((a.dayOfYear() - f - 1) / 7) + 1; return g < 1 ? (e = a.year() - 1, d = g + xa(e, b, c)) : g > xa(a.year(), b, c) ? (d = g - xa(a.year(), b, c), e = a.year() + 1) : (e = a.year(), d = g), { week: d, year: e } } function xa(a, b, c) { var d = ua(a, b, c), e = ua(a + 1, b, c); return (pa(a) - d + e) / 7 } function ya(a) { return wa(a, this._week.dow, this._week.doy).week } function za() { return this._week.dow } function Aa() { return this._week.doy } function Ba(a) { var b = this.localeData().week(this); return null == a ? b : this.add(7 * (a - b), "d") } function Ca(a) { var b = wa(this, 1, 4).week; return null == a ? b : this.add(7 * (a - b), "d") } function Da(a, b) { return "string" != typeof a ? a : isNaN(a) ? (a = b.weekdaysParse(a), "number" == typeof a ? a : null) : parseInt(a, 10) } function Ea(a, b) { return "string" == typeof a ? b.weekdaysParse(a) % 7 || 7 : isNaN(a) ? null : a } function Fa(a, b) { return a ? c(this._weekdays) ? this._weekdays[a.day()] : this._weekdays[this._weekdays.isFormat.test(b) ? "format" : "standalone"][a.day()] : c(this._weekdays) ? this._weekdays : this._weekdays.standalone } function Ga(a) { return a ? this._weekdaysShort[a.day()] : this._weekdaysShort } function Ha(a) { return a ? this._weekdaysMin[a.day()] : this._weekdaysMin } function Ia(a, b, c) { var d, e, f, g = a.toLocaleLowerCase(); if (!this._weekdaysParse) for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], d = 0; d < 7; ++d)f = l([2e3, 1]).day(d), this._minWeekdaysParse[d] = this.weekdaysMin(f, "").toLocaleLowerCase(), this._shortWeekdaysParse[d] = this.weekdaysShort(f, "").toLocaleLowerCase(), this._weekdaysParse[d] = this.weekdays(f, "").toLocaleLowerCase(); return c ? "dddd" === b ? (e = nf.call(this._weekdaysParse, g), e !== -1 ? e : null) : "ddd" === b ? (e = nf.call(this._shortWeekdaysParse, g), e !== -1 ? e : null) : (e = nf.call(this._minWeekdaysParse, g), e !== -1 ? e : null) : "dddd" === b ? (e = nf.call(this._weekdaysParse, g), e !== -1 ? e : (e = nf.call(this._shortWeekdaysParse, g), e !== -1 ? e : (e = nf.call(this._minWeekdaysParse, g), e !== -1 ? e : null))) : "ddd" === b ? (e = nf.call(this._shortWeekdaysParse, g), e !== -1 ? e : (e = nf.call(this._weekdaysParse, g), e !== -1 ? e : (e = nf.call(this._minWeekdaysParse, g), e !== -1 ? e : null))) : (e = nf.call(this._minWeekdaysParse, g), e !== -1 ? e : (e = nf.call(this._weekdaysParse, g), e !== -1 ? e : (e = nf.call(this._shortWeekdaysParse, g), e !== -1 ? e : null))) } function Ja(a, b, c) { var d, e, f; if (this._weekdaysParseExact) return Ia.call(this, a, b, c); for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), d = 0; d < 7; d++) { if (e = l([2e3, 1]).day(d), c && !this._fullWeekdaysParse[d] && (this._fullWeekdaysParse[d] = new RegExp("^" + this.weekdays(e, "").replace(".", ".?") + "$", "i"), this._shortWeekdaysParse[d] = new RegExp("^" + this.weekdaysShort(e, "").replace(".", ".?") + "$", "i"), this._minWeekdaysParse[d] = new RegExp("^" + this.weekdaysMin(e, "").replace(".", ".?") + "$", "i")), this._weekdaysParse[d] || (f = "^" + this.weekdays(e, "") + "|^" + this.weekdaysShort(e, "") + "|^" + this.weekdaysMin(e, ""), this._weekdaysParse[d] = new RegExp(f.replace(".", ""), "i")), c && "dddd" === b && this._fullWeekdaysParse[d].test(a)) return d; if (c && "ddd" === b && this._shortWeekdaysParse[d].test(a)) return d; if (c && "dd" === b && this._minWeekdaysParse[d].test(a)) return d; if (!c && this._weekdaysParse[d].test(a)) return d } } function Ka(a) { if (!this.isValid()) return null != a ? this : NaN; var b = this._isUTC ? this._d.getUTCDay() : this._d.getDay(); return null != a ? (a = Da(a, this.localeData()), this.add(a - b, "d")) : b } function La(a) { if (!this.isValid()) return null != a ? this : NaN; var b = (this.day() + 7 - this.localeData()._week.dow) % 7; return null == a ? b : this.add(a - b, "d") } function Ma(a) { if (!this.isValid()) return null != a ? this : NaN; if (null != a) { var b = Ea(a, this.localeData()); return this.day(this.day() % 7 ? b : b - 7) } return this.day() || 7 } function Na(a) { return this._weekdaysParseExact ? (j(this, "_weekdaysRegex") || Qa.call(this), a ? this._weekdaysStrictRegex : this._weekdaysRegex) : (j(this, "_weekdaysRegex") || (this._weekdaysRegex = yf), this._weekdaysStrictRegex && a ? this._weekdaysStrictRegex : this._weekdaysRegex) } function Oa(a) { return this._weekdaysParseExact ? (j(this, "_weekdaysRegex") || Qa.call(this), a ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (j(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = zf), this._weekdaysShortStrictRegex && a ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) } function Pa(a) { return this._weekdaysParseExact ? (j(this, "_weekdaysRegex") || Qa.call(this), a ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (j(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = Af), this._weekdaysMinStrictRegex && a ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) } function Qa() { function a(a, b) { return b.length - a.length } var b, c, d, e, f, g = [], h = [], i = [], j = []; for (b = 0; b < 7; b++)c = l([2e3, 1]).day(b), d = this.weekdaysMin(c, ""), e = this.weekdaysShort(c, ""), f = this.weekdays(c, ""), g.push(d), h.push(e), i.push(f), j.push(d), j.push(e), j.push(f); for (g.sort(a), h.sort(a), i.sort(a), j.sort(a), b = 0; b < 7; b++)h[b] = aa(h[b]), i[b] = aa(i[b]), j[b] = aa(j[b]); this._weekdaysRegex = new RegExp("^(" + j.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + i.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + h.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + g.join("|") + ")", "i") } function Ra() { return this.hours() % 12 || 12 } function Sa() { return this.hours() || 24 } function Ta(a, b) { U(a, 0, 0, function () { return this.localeData().meridiem(this.hours(), this.minutes(), b) }) } function Ua(a, b) { return b._meridiemParse } function Va(a) { return "p" === (a + "").toLowerCase().charAt(0) } function Wa(a, b, c) { return a > 11 ? c ? "pm" : "PM" : c ? "am" : "AM" } function Xa(a) { return a ? a.toLowerCase().replace("_", "-") : a } function Ya(a) { for (var b, c, d, e, f = 0; f < a.length;) { for (e = Xa(a[f]).split("-"), b = e.length, c = Xa(a[f + 1]), c = c ? c.split("-") : null; b > 0;) { if (d = Za(e.slice(0, b).join("-"))) return d; if (c && c.length >= b && v(e, c, !0) >= b - 1) break; b-- } f++ } return null } function Za(a) { var b = null; if (!Ff[a] && "undefined" != typeof module && module && module.exports) try { b = Bf._abbr, require("./locale/" + a), $a(b) } catch (a) { } return Ff[a] } function $a(a, b) { var c; return a && (c = f(b) ? bb(a) : _a(a, b), c && (Bf = c)), Bf._abbr } function _a(a, b) { if (null !== b) { var c = Ef; if (b.abbr = a, null != Ff[a]) y("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), c = Ff[a]._config; else if (null != b.parentLocale) { if (null == Ff[b.parentLocale]) return Gf[b.parentLocale] || (Gf[b.parentLocale] = []), Gf[b.parentLocale].push({ name: a, config: b }), null; c = Ff[b.parentLocale]._config } return Ff[a] = new C(B(c, b)), Gf[a] && Gf[a].forEach(function (a) { _a(a.name, a.config) }), $a(a), Ff[a] } return delete Ff[a], null } function ab(a, b) { if (null != b) { var c, d = Ef; null != Ff[a] && (d = Ff[a]._config), b = B(d, b), c = new C(b), c.parentLocale = Ff[a], Ff[a] = c, $a(a) } else null != Ff[a] && (null != Ff[a].parentLocale ? Ff[a] = Ff[a].parentLocale : null != Ff[a] && delete Ff[a]); return Ff[a] } function bb(a) { var b; if (a && a._locale && a._locale._abbr && (a = a._locale._abbr), !a) return Bf; if (!c(a)) { if (b = Za(a)) return b; a = [a] } return Ya(a) } function cb() { return ze(Ff) } function db(a) { var b, c = a._a; return c && n(a).overflow === -2 && (b = c[ef] < 0 || c[ef] > 11 ? ef : c[ff] < 1 || c[ff] > ea(c[df], c[ef]) ? ff : c[gf] < 0 || c[gf] > 24 || 24 === c[gf] && (0 !== c[hf] || 0 !== c[jf] || 0 !== c[kf]) ? gf : c[hf] < 0 || c[hf] > 59 ? hf : c[jf] < 0 || c[jf] > 59 ? jf : c[kf] < 0 || c[kf] > 999 ? kf : -1, n(a)._overflowDayOfYear && (b < df || b > ff) && (b = ff), n(a)._overflowWeeks && b === -1 && (b = lf), n(a)._overflowWeekday && b === -1 && (b = mf), n(a).overflow = b), a } function eb(a) { var b, c, d, e, f, g, h = a._i, i = Hf.exec(h) || If.exec(h); if (i) { for (n(a).iso = !0, b = 0, c = Kf.length; b < c; b++)if (Kf[b][1].exec(i[1])) { e = Kf[b][0], d = Kf[b][2] !== !1; break } if (null == e) return void (a._isValid = !1); if (i[3]) { for (b = 0, c = Lf.length; b < c; b++)if (Lf[b][1].exec(i[3])) { f = (i[2] || " ") + Lf[b][0]; break } if (null == f) return void (a._isValid = !1) } if (!d && null != f) return void (a._isValid = !1); if (i[4]) { if (!Jf.exec(i[4])) return void (a._isValid = !1); g = "Z" } a._f = e + (f || "") + (g || ""), lb(a) } else a._isValid = !1 } function fb(a) { var b, c, d, e, f, g, h, i, j = { " GMT": " +0000", " EDT": " -0400", " EST": " -0500", " CDT": " -0500", " CST": " -0600", " MDT": " -0600", " MST": " -0700", " PDT": " -0700", " PST": " -0800" }, k = "YXWVUTSRQPONZABCDEFGHIKLM"; if (b = a._i.replace(/\([^\)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s|\s$/g, ""), c = Nf.exec(b)) { if (d = c[1] ? "ddd" + (5 === c[1].length ? ", " : " ") : "", e = "D MMM " + (c[2].length > 10 ? "YYYY " : "YY "), f = "HH:mm" + (c[4] ? ":ss" : ""), c[1]) { var l = new Date(c[2]), m = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][l.getDay()]; if (c[1].substr(0, 3) !== m) return n(a).weekdayMismatch = !0, void (a._isValid = !1) } switch (c[5].length) { case 2: 0 === i ? h = " +0000" : (i = k.indexOf(c[5][1].toUpperCase()) - 12, h = (i < 0 ? " -" : " +") + ("" + i).replace(/^-?/, "0").match(/..$/)[0] + "00"); break; case 4: h = j[c[5]]; break; default: h = j[" GMT"] }c[5] = h, a._i = c.splice(1).join(""), g = " ZZ", a._f = d + e + f + g, lb(a), n(a).rfc2822 = !0 } else a._isValid = !1 } function gb(b) { var c = Mf.exec(b._i); return null !== c ? void (b._d = new Date(+c[1])) : (eb(b), void (b._isValid === !1 && (delete b._isValid, fb(b), b._isValid === !1 && (delete b._isValid, a.createFromInputFallback(b))))) } function hb(a, b, c) { return null != a ? a : null != b ? b : c } function ib(b) { var c = new Date(a.now()); return b._useUTC ? [c.getUTCFullYear(), c.getUTCMonth(), c.getUTCDate()] : [c.getFullYear(), c.getMonth(), c.getDate()] } function jb(a) { var b, c, d, e, f = []; if (!a._d) { for (d = ib(a), a._w && null == a._a[ff] && null == a._a[ef] && kb(a), null != a._dayOfYear && (e = hb(a._a[df], d[df]), (a._dayOfYear > pa(e) || 0 === a._dayOfYear) && (n(a)._overflowDayOfYear = !0), c = ta(e, 0, a._dayOfYear), a._a[ef] = c.getUTCMonth(), a._a[ff] = c.getUTCDate()), b = 0; b < 3 && null == a._a[b]; ++b)a._a[b] = f[b] = d[b]; for (; b < 7; b++)a._a[b] = f[b] = null == a._a[b] ? 2 === b ? 1 : 0 : a._a[b]; 24 === a._a[gf] && 0 === a._a[hf] && 0 === a._a[jf] && 0 === a._a[kf] && (a._nextDay = !0, a._a[gf] = 0), a._d = (a._useUTC ? ta : sa).apply(null, f), null != a._tzm && a._d.setUTCMinutes(a._d.getUTCMinutes() - a._tzm), a._nextDay && (a._a[gf] = 24) } } function kb(a) { var b, c, d, e, f, g, h, i; if (b = a._w, null != b.GG || null != b.W || null != b.E) f = 1, g = 4, c = hb(b.GG, a._a[df], wa(tb(), 1, 4).year), d = hb(b.W, 1), e = hb(b.E, 1), (e < 1 || e > 7) && (i = !0); else { f = a._locale._week.dow, g = a._locale._week.doy; var j = wa(tb(), f, g); c = hb(b.gg, a._a[df], j.year), d = hb(b.w, j.week), null != b.d ? (e = b.d, (e < 0 || e > 6) && (i = !0)) : null != b.e ? (e = b.e + f, (b.e < 0 || b.e > 6) && (i = !0)) : e = f } d < 1 || d > xa(c, f, g) ? n(a)._overflowWeeks = !0 : null != i ? n(a)._overflowWeekday = !0 : (h = va(c, d, e, f, g), a._a[df] = h.year, a._dayOfYear = h.dayOfYear) } function lb(b) { if (b._f === a.ISO_8601) return void eb(b); if (b._f === a.RFC_2822) return void fb(b); b._a = [], n(b).empty = !0; var c, d, e, f, g, h = "" + b._i, i = h.length, j = 0; for (e = Y(b._f, b._locale).match(Ie) || [], c = 0; c < e.length; c++)f = e[c], d = (h.match($(f, b)) || [])[0], d && (g = h.substr(0, h.indexOf(d)), g.length > 0 && n(b).unusedInput.push(g), h = h.slice(h.indexOf(d) + d.length), j += d.length), Le[f] ? (d ? n(b).empty = !1 : n(b).unusedTokens.push(f), da(f, d, b)) : b._strict && !d && n(b).unusedTokens.push(f); n(b).charsLeftOver = i - j, h.length > 0 && n(b).unusedInput.push(h), b._a[gf] <= 12 && n(b).bigHour === !0 && b._a[gf] > 0 && (n(b).bigHour = void 0), n(b).parsedDateParts = b._a.slice(0), n(b).meridiem = b._meridiem, b._a[gf] = mb(b._locale, b._a[gf], b._meridiem), jb(b), db(b) } function mb(a, b, c) { var d; return null == c ? b : null != a.meridiemHour ? a.meridiemHour(b, c) : null != a.isPM ? (d = a.isPM(c), d && b < 12 && (b += 12), d || 12 !== b || (b = 0), b) : b } function nb(a) { var b, c, d, e, f; if (0 === a._f.length) return n(a).invalidFormat = !0, void (a._d = new Date(NaN)); for (e = 0; e < a._f.length; e++)f = 0, b = q({}, a), null != a._useUTC && (b._useUTC = a._useUTC), b._f = a._f[e], lb(b), o(b) && (f += n(b).charsLeftOver, f += 10 * n(b).unusedTokens.length, n(b).score = f, (null == d || f < d) && (d = f, c = b)); k(a, c || b) } function ob(a) { if (!a._d) { var b = L(a._i); a._a = i([b.year, b.month, b.day || b.date, b.hour, b.minute, b.second, b.millisecond], function (a) { return a && parseInt(a, 10) }), jb(a) } } function pb(a) { var b = new r(db(qb(a))); return b._nextDay && (b.add(1, "d"), b._nextDay = void 0), b } function qb(a) { var b = a._i, d = a._f; return a._locale = a._locale || bb(a._l), null === b || void 0 === d && "" === b ? p({ nullInput: !0 }) : ("string" == typeof b && (a._i = b = a._locale.preparse(b)), s(b) ? new r(db(b)) : (h(b) ? a._d = b : c(d) ? nb(a) : d ? lb(a) : rb(a), o(a) || (a._d = null), a)) } function rb(b) { var e = b._i; f(e) ? b._d = new Date(a.now()) : h(e) ? b._d = new Date(e.valueOf()) : "string" == typeof e ? gb(b) : c(e) ? (b._a = i(e.slice(0), function (a) { return parseInt(a, 10) }), jb(b)) : d(e) ? ob(b) : g(e) ? b._d = new Date(e) : a.createFromInputFallback(b) } function sb(a, b, f, g, h) { var i = {}; return f !== !0 && f !== !1 || (g = f, f = void 0), (d(a) && e(a) || c(a) && 0 === a.length) && (a = void 0), i._isAMomentObject = !0, i._useUTC = i._isUTC = h, i._l = f, i._i = a, i._f = b, i._strict = g, pb(i) } function tb(a, b, c, d) { return sb(a, b, c, d, !1) } function ub(a, b) { var d, e; if (1 === b.length && c(b[0]) && (b = b[0]), !b.length) return tb(); for (d = b[0], e = 1; e < b.length; ++e)b[e].isValid() && !b[e][a](d) || (d = b[e]); return d } function vb() { var a = [].slice.call(arguments, 0); return ub("isBefore", a) } function wb() { var a = [].slice.call(arguments, 0); return ub("isAfter", a) } function xb(a) { for (var b in a) if (Rf.indexOf(b) === -1 || null != a[b] && isNaN(a[b])) return !1; for (var c = !1, d = 0; d < Rf.length; ++d)if (a[Rf[d]]) { if (c) return !1; parseFloat(a[Rf[d]]) !== u(a[Rf[d]]) && (c = !0) } return !0 } function yb() { return this._isValid } function zb() { return Sb(NaN) } function Ab(a) { var b = L(a), c = b.year || 0, d = b.quarter || 0, e = b.month || 0, f = b.week || 0, g = b.day || 0, h = b.hour || 0, i = b.minute || 0, j = b.second || 0, k = b.millisecond || 0; this._isValid = xb(b), this._milliseconds = +k + 1e3 * j + 6e4 * i + 1e3 * h * 60 * 60, this._days = +g + 7 * f, this._months = +e + 3 * d + 12 * c, this._data = {}, this._locale = bb(), this._bubble() } function Bb(a) { return a instanceof Ab } function Cb(a) { return a < 0 ? Math.round(-1 * a) * -1 : Math.round(a) } function Db(a, b) { U(a, 0, 0, function () { var a = this.utcOffset(), c = "+"; return a < 0 && (a = -a, c = "-"), c + T(~~(a / 60), 2) + b + T(~~a % 60, 2) }) } function Eb(a, b) { var c = (b || "").match(a); if (null === c) return null; var d = c[c.length - 1] || [], e = (d + "").match(Sf) || ["-", 0, 0], f = +(60 * e[1]) + u(e[2]); return 0 === f ? 0 : "+" === e[0] ? f : -f } function Fb(b, c) { var d, e; return c._isUTC ? (d = c.clone(), e = (s(b) || h(b) ? b.valueOf() : tb(b).valueOf()) - d.valueOf(), d._d.setTime(d._d.valueOf() + e), a.updateOffset(d, !1), d) : tb(b).local() } function Gb(a) { return 15 * -Math.round(a._d.getTimezoneOffset() / 15) } function Hb(b, c, d) { var e, f = this._offset || 0; if (!this.isValid()) return null != b ? this : NaN; if (null != b) { if ("string" == typeof b) { if (b = Eb($e, b), null === b) return this } else Math.abs(b) < 16 && !d && (b = 60 * b); return !this._isUTC && c && (e = Gb(this)), this._offset = b, this._isUTC = !0, null != e && this.add(e, "m"), f !== b && (!c || this._changeInProgress ? Xb(this, Sb(b - f, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, a.updateOffset(this, !0), this._changeInProgress = null)), this } return this._isUTC ? f : Gb(this) } function Ib(a, b) { return null != a ? ("string" != typeof a && (a = -a), this.utcOffset(a, b), this) : -this.utcOffset() } function Jb(a) { return this.utcOffset(0, a) } function Kb(a) { return this._isUTC && (this.utcOffset(0, a), this._isUTC = !1, a && this.subtract(Gb(this), "m")), this } function Lb() { if (null != this._tzm) this.utcOffset(this._tzm, !1, !0); else if ("string" == typeof this._i) { var a = Eb(Ze, this._i); null != a ? this.utcOffset(a) : this.utcOffset(0, !0) } return this } function Mb(a) { return !!this.isValid() && (a = a ? tb(a).utcOffset() : 0, (this.utcOffset() - a) % 60 === 0) } function Nb() { return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset() } function Ob() { if (!f(this._isDSTShifted)) return this._isDSTShifted; var a = {}; if (q(a, this), a = qb(a), a._a) { var b = a._isUTC ? l(a._a) : tb(a._a); this._isDSTShifted = this.isValid() && v(a._a, b.toArray()) > 0 } else this._isDSTShifted = !1; return this._isDSTShifted } function Pb() { return !!this.isValid() && !this._isUTC } function Qb() { return !!this.isValid() && this._isUTC } function Rb() { return !!this.isValid() && (this._isUTC && 0 === this._offset) } function Sb(a, b) { var c, d, e, f = a, h = null; return Bb(a) ? f = { ms: a._milliseconds, d: a._days, M: a._months } : g(a) ? (f = {}, b ? f[b] = a : f.milliseconds = a) : (h = Tf.exec(a)) ? (c = "-" === h[1] ? -1 : 1, f = { y: 0, d: u(h[ff]) * c, h: u(h[gf]) * c, m: u(h[hf]) * c, s: u(h[jf]) * c, ms: u(Cb(1e3 * h[kf])) * c }) : (h = Uf.exec(a)) ? (c = "-" === h[1] ? -1 : 1, f = { y: Tb(h[2], c), M: Tb(h[3], c), w: Tb(h[4], c), d: Tb(h[5], c), h: Tb(h[6], c), m: Tb(h[7], c), s: Tb(h[8], c) }) : null == f ? f = {} : "object" == typeof f && ("from" in f || "to" in f) && (e = Vb(tb(f.from), tb(f.to)), f = {}, f.ms = e.milliseconds, f.M = e.months), d = new Ab(f), Bb(a) && j(a, "_locale") && (d._locale = a._locale), d } function Tb(a, b) { var c = a && parseFloat(a.replace(",", ".")); return (isNaN(c) ? 0 : c) * b } function Ub(a, b) { var c = { milliseconds: 0, months: 0 }; return c.months = b.month() - a.month() + 12 * (b.year() - a.year()), a.clone().add(c.months, "M").isAfter(b) && --c.months, c.milliseconds = +b - +a.clone().add(c.months, "M"), c } function Vb(a, b) { var c; return a.isValid() && b.isValid() ? (b = Fb(b, a), a.isBefore(b) ? c = Ub(a, b) : (c = Ub(b, a), c.milliseconds = -c.milliseconds, c.months = -c.months), c) : { milliseconds: 0, months: 0 } } function Wb(a, b) { return function (c, d) { var e, f; return null === d || isNaN(+d) || (y(b, "moment()." + b + "(period, number) is deprecated. Please use moment()." + b + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), f = c, c = d, d = f), c = "string" == typeof c ? +c : c, e = Sb(c, d), Xb(this, e, a), this } } function Xb(b, c, d, e) { var f = c._milliseconds, g = Cb(c._days), h = Cb(c._months); b.isValid() && (e = null == e || e, f && b._d.setTime(b._d.valueOf() + f * d), g && Q(b, "Date", P(b, "Date") + g * d), h && ja(b, P(b, "Month") + h * d), e && a.updateOffset(b, g || h)) } function Yb(a, b) { var c = a.diff(b, "days", !0); return c < -6 ? "sameElse" : c < -1 ? "lastWeek" : c < 0 ? "lastDay" : c < 1 ? "sameDay" : c < 2 ? "nextDay" : c < 7 ? "nextWeek" : "sameElse" } function Zb(b, c) { var d = b || tb(), e = Fb(d, this).startOf("day"), f = a.calendarFormat(this, e) || "sameElse", g = c && (z(c[f]) ? c[f].call(this, d) : c[f]); return this.format(g || this.localeData().calendar(f, this, tb(d))) } function $b() { return new r(this) } function _b(a, b) { var c = s(a) ? a : tb(a); return !(!this.isValid() || !c.isValid()) && (b = K(f(b) ? "millisecond" : b), "millisecond" === b ? this.valueOf() > c.valueOf() : c.valueOf() < this.clone().startOf(b).valueOf()) } function ac(a, b) { var c = s(a) ? a : tb(a); return !(!this.isValid() || !c.isValid()) && (b = K(f(b) ? "millisecond" : b), "millisecond" === b ? this.valueOf() < c.valueOf() : this.clone().endOf(b).valueOf() < c.valueOf()) } function bc(a, b, c, d) { return d = d || "()", ("(" === d[0] ? this.isAfter(a, c) : !this.isBefore(a, c)) && (")" === d[1] ? this.isBefore(b, c) : !this.isAfter(b, c)) } function cc(a, b) { var c, d = s(a) ? a : tb(a); return !(!this.isValid() || !d.isValid()) && (b = K(b || "millisecond"), "millisecond" === b ? this.valueOf() === d.valueOf() : (c = d.valueOf(), this.clone().startOf(b).valueOf() <= c && c <= this.clone().endOf(b).valueOf())) } function dc(a, b) { return this.isSame(a, b) || this.isAfter(a, b) } function ec(a, b) { return this.isSame(a, b) || this.isBefore(a, b) } function fc(a, b, c) { var d, e, f, g; return this.isValid() ? (d = Fb(a, this), d.isValid() ? (e = 6e4 * (d.utcOffset() - this.utcOffset()), b = K(b), "year" === b || "month" === b || "quarter" === b ? (g = gc(this, d), "quarter" === b ? g /= 3 : "year" === b && (g /= 12)) : (f = this - d, g = "second" === b ? f / 1e3 : "minute" === b ? f / 6e4 : "hour" === b ? f / 36e5 : "day" === b ? (f - e) / 864e5 : "week" === b ? (f - e) / 6048e5 : f), c ? g : t(g)) : NaN) : NaN } function gc(a, b) { var c, d, e = 12 * (b.year() - a.year()) + (b.month() - a.month()), f = a.clone().add(e, "months"); return b - f < 0 ? (c = a.clone().add(e - 1, "months"), d = (b - f) / (f - c)) : (c = a.clone().add(e + 1, "months"), d = (b - f) / (c - f)), -(e + d) || 0 } function hc() { return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ") } function ic() { if (!this.isValid()) return null; var a = this.clone().utc(); return a.year() < 0 || a.year() > 9999 ? X(a, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]") : z(Date.prototype.toISOString) ? this.toDate().toISOString() : X(a, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]") } function jc() { if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)"; var a = "moment", b = ""; this.isLocal() || (a = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", b = "Z"); var c = "[" + a + '("]', d = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", e = "-MM-DD[T]HH:mm:ss.SSS", f = b + '[")]'; return this.format(c + d + e + f) } function kc(b) { b || (b = this.isUtc() ? a.defaultFormatUtc : a.defaultFormat); var c = X(this, b); return this.localeData().postformat(c) } function lc(a, b) { return this.isValid() && (s(a) && a.isValid() || tb(a).isValid()) ? Sb({ to: this, from: a }).locale(this.locale()).humanize(!b) : this.localeData().invalidDate() } function mc(a) { return this.from(tb(), a) } function nc(a, b) { return this.isValid() && (s(a) && a.isValid() || tb(a).isValid()) ? Sb({ from: this, to: a }).locale(this.locale()).humanize(!b) : this.localeData().invalidDate() } function oc(a) { return this.to(tb(), a) } function pc(a) { var b; return void 0 === a ? this._locale._abbr : (b = bb(a), null != b && (this._locale = b), this) } function qc() { return this._locale } function rc(a) { switch (a = K(a)) { case "year": this.month(0); case "quarter": case "month": this.date(1); case "week": case "isoWeek": case "day": case "date": this.hours(0); case "hour": this.minutes(0); case "minute": this.seconds(0); case "second": this.milliseconds(0) }return "week" === a && this.weekday(0), "isoWeek" === a && this.isoWeekday(1), "quarter" === a && this.month(3 * Math.floor(this.month() / 3)), this } function sc(a) { return a = K(a), void 0 === a || "millisecond" === a ? this : ("date" === a && (a = "day"), this.startOf(a).add(1, "isoWeek" === a ? "week" : a).subtract(1, "ms")) } function tc() { return this._d.valueOf() - 6e4 * (this._offset || 0) } function uc() { return Math.floor(this.valueOf() / 1e3) } function vc() { return new Date(this.valueOf()) } function wc() { var a = this; return [a.year(), a.month(), a.date(), a.hour(), a.minute(), a.second(), a.millisecond()] } function xc() { var a = this; return { years: a.year(), months: a.month(), date: a.date(), hours: a.hours(), minutes: a.minutes(), seconds: a.seconds(), milliseconds: a.milliseconds() } } function yc() { return this.isValid() ? this.toISOString() : null } function zc() { return o(this) } function Ac() {
        return k({}, n(this))
    } function Bc() { return n(this).overflow } function Cc() { return { input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict } } function Dc(a, b) { U(0, [a, a.length], 0, b) } function Ec(a) { return Ic.call(this, a, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy) } function Fc(a) { return Ic.call(this, a, this.isoWeek(), this.isoWeekday(), 1, 4) } function Gc() { return xa(this.year(), 1, 4) } function Hc() { var a = this.localeData()._week; return xa(this.year(), a.dow, a.doy) } function Ic(a, b, c, d, e) { var f; return null == a ? wa(this, d, e).year : (f = xa(a, d, e), b > f && (b = f), Jc.call(this, a, b, c, d, e)) } function Jc(a, b, c, d, e) { var f = va(a, b, c, d, e), g = ta(f.year, 0, f.dayOfYear); return this.year(g.getUTCFullYear()), this.month(g.getUTCMonth()), this.date(g.getUTCDate()), this } function Kc(a) { return null == a ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (a - 1) + this.month() % 3) } function Lc(a) { var b = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1; return null == a ? b : this.add(a - b, "d") } function Mc(a, b) { b[kf] = u(1e3 * ("0." + a)) } function Nc() { return this._isUTC ? "UTC" : "" } function Oc() { return this._isUTC ? "Coordinated Universal Time" : "" } function Pc(a) { return tb(1e3 * a) } function Qc() { return tb.apply(null, arguments).parseZone() } function Rc(a) { return a } function Sc(a, b, c, d) { var e = bb(), f = l().set(d, b); return e[c](f, a) } function Tc(a, b, c) { if (g(a) && (b = a, a = void 0), a = a || "", null != b) return Sc(a, b, c, "month"); var d, e = []; for (d = 0; d < 12; d++)e[d] = Sc(a, d, c, "month"); return e } function Uc(a, b, c, d) { "boolean" == typeof a ? (g(b) && (c = b, b = void 0), b = b || "") : (b = a, c = b, a = !1, g(b) && (c = b, b = void 0), b = b || ""); var e = bb(), f = a ? e._week.dow : 0; if (null != c) return Sc(b, (c + f) % 7, d, "day"); var h, i = []; for (h = 0; h < 7; h++)i[h] = Sc(b, (h + f) % 7, d, "day"); return i } function Vc(a, b) { return Tc(a, b, "months") } function Wc(a, b) { return Tc(a, b, "monthsShort") } function Xc(a, b, c) { return Uc(a, b, c, "weekdays") } function Yc(a, b, c) { return Uc(a, b, c, "weekdaysShort") } function Zc(a, b, c) { return Uc(a, b, c, "weekdaysMin") } function $c() { var a = this._data; return this._milliseconds = dg(this._milliseconds), this._days = dg(this._days), this._months = dg(this._months), a.milliseconds = dg(a.milliseconds), a.seconds = dg(a.seconds), a.minutes = dg(a.minutes), a.hours = dg(a.hours), a.months = dg(a.months), a.years = dg(a.years), this } function _c(a, b, c, d) { var e = Sb(b, c); return a._milliseconds += d * e._milliseconds, a._days += d * e._days, a._months += d * e._months, a._bubble() } function ad(a, b) { return _c(this, a, b, 1) } function bd(a, b) { return _c(this, a, b, -1) } function cd(a) { return a < 0 ? Math.floor(a) : Math.ceil(a) } function dd() { var a, b, c, d, e, f = this._milliseconds, g = this._days, h = this._months, i = this._data; return f >= 0 && g >= 0 && h >= 0 || f <= 0 && g <= 0 && h <= 0 || (f += 864e5 * cd(fd(h) + g), g = 0, h = 0), i.milliseconds = f % 1e3, a = t(f / 1e3), i.seconds = a % 60, b = t(a / 60), i.minutes = b % 60, c = t(b / 60), i.hours = c % 24, g += t(c / 24), e = t(ed(g)), h += e, g -= cd(fd(e)), d = t(h / 12), h %= 12, i.days = g, i.months = h, i.years = d, this } function ed(a) { return 4800 * a / 146097 } function fd(a) { return 146097 * a / 4800 } function gd(a) { if (!this.isValid()) return NaN; var b, c, d = this._milliseconds; if (a = K(a), "month" === a || "year" === a) return b = this._days + d / 864e5, c = this._months + ed(b), "month" === a ? c : c / 12; switch (b = this._days + Math.round(fd(this._months)), a) { case "week": return b / 7 + d / 6048e5; case "day": return b + d / 864e5; case "hour": return 24 * b + d / 36e5; case "minute": return 1440 * b + d / 6e4; case "second": return 86400 * b + d / 1e3; case "millisecond": return Math.floor(864e5 * b) + d; default: throw new Error("Unknown unit " + a) } } function hd() { return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * u(this._months / 12) : NaN } function id(a) { return function () { return this.as(a) } } function jd(a) { return a = K(a), this.isValid() ? this[a + "s"]() : NaN } function kd(a) { return function () { return this.isValid() ? this._data[a] : NaN } } function ld() { return t(this.days() / 7) } function md(a, b, c, d, e) { return e.relativeTime(b || 1, !!c, a, d) } function nd(a, b, c) { var d = Sb(a).abs(), e = tg(d.as("s")), f = tg(d.as("m")), g = tg(d.as("h")), h = tg(d.as("d")), i = tg(d.as("M")), j = tg(d.as("y")), k = e <= ug.ss && ["s", e] || e < ug.s && ["ss", e] || f <= 1 && ["m"] || f < ug.m && ["mm", f] || g <= 1 && ["h"] || g < ug.h && ["hh", g] || h <= 1 && ["d"] || h < ug.d && ["dd", h] || i <= 1 && ["M"] || i < ug.M && ["MM", i] || j <= 1 && ["y"] || ["yy", j]; return k[2] = b, k[3] = +a > 0, k[4] = c, md.apply(null, k) } function od(a) { return void 0 === a ? tg : "function" == typeof a && (tg = a, !0) } function pd(a, b) { return void 0 !== ug[a] && (void 0 === b ? ug[a] : (ug[a] = b, "s" === a && (ug.ss = b - 1), !0)) } function qd(a) { if (!this.isValid()) return this.localeData().invalidDate(); var b = this.localeData(), c = nd(this, !a, b); return a && (c = b.pastFuture(+this, c)), b.postformat(c) } function rd() { if (!this.isValid()) return this.localeData().invalidDate(); var a, b, c, d = vg(this._milliseconds) / 1e3, e = vg(this._days), f = vg(this._months); a = t(d / 60), b = t(a / 60), d %= 60, a %= 60, c = t(f / 12), f %= 12; var g = c, h = f, i = e, j = b, k = a, l = d, m = this.asSeconds(); return m ? (m < 0 ? "-" : "") + "P" + (g ? g + "Y" : "") + (h ? h + "M" : "") + (i ? i + "D" : "") + (j || k || l ? "T" : "") + (j ? j + "H" : "") + (k ? k + "M" : "") + (l ? l + "S" : "") : "P0D" }
    //! moment.js locale configuration
    //! locale : Belarusian [be]
    //! author : Dmitry Demidov : https://github.com/demidov91
    //! author: Praleska: http://praleska.pro/
    //! Author : Menelion Elensúle : https://github.com/Oire
    function sd(a, b) { var c = a.split("_"); return b % 10 === 1 && b % 100 !== 11 ? c[0] : b % 10 >= 2 && b % 10 <= 4 && (b % 100 < 10 || b % 100 >= 20) ? c[1] : c[2] } function td(a, b, c) { var d = { mm: b ? "хвіліна_хвіліны_хвілін" : "хвіліну_хвіліны_хвілін", hh: b ? "гадзіна_гадзіны_гадзін" : "гадзіну_гадзіны_гадзін", dd: "дзень_дні_дзён", MM: "месяц_месяцы_месяцаў", yy: "год_гады_гадоў" }; return "m" === c ? b ? "хвіліна" : "хвіліну" : "h" === c ? b ? "гадзіна" : "гадзіну" : a + " " + sd(d[c], +a) }
    //! moment.js locale configuration
    //! locale : Breton [br]
    //! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou
    function ud(a, b, c) { var d = { mm: "munutenn", MM: "miz", dd: "devezh" }; return a + " " + xd(d[c], a) } function vd(a) { switch (wd(a)) { case 1: case 3: case 4: case 5: case 9: return a + " bloaz"; default: return a + " vloaz" } } function wd(a) { return a > 9 ? wd(a % 10) : a } function xd(a, b) { return 2 === b ? yd(a) : a } function yd(a) { var b = { m: "v", b: "v", d: "z" }; return void 0 === b[a.charAt(0)] ? a : b[a.charAt(0)] + a.substring(1) }
    //! moment.js locale configuration
    //! locale : Bosnian [bs]
    //! author : Nedim Cholich : https://github.com/frontyard
    //! based on (hr) translation by Bojan Marković
    function zd(a, b, c) { var d = a + " "; switch (c) { case "m": return b ? "jedna minuta" : "jedne minute"; case "mm": return d += 1 === a ? "minuta" : 2 === a || 3 === a || 4 === a ? "minute" : "minuta"; case "h": return b ? "jedan sat" : "jednog sata"; case "hh": return d += 1 === a ? "sat" : 2 === a || 3 === a || 4 === a ? "sata" : "sati"; case "dd": return d += 1 === a ? "dan" : "dana"; case "MM": return d += 1 === a ? "mjesec" : 2 === a || 3 === a || 4 === a ? "mjeseca" : "mjeseci"; case "yy": return d += 1 === a ? "godina" : 2 === a || 3 === a || 4 === a ? "godine" : "godina" } } function Ad(a) { return a > 1 && a < 5 && 1 !== ~~(a / 10) } function Bd(a, b, c, d) { var e = a + " "; switch (c) { case "s": return b || d ? "pár sekund" : "pár sekundami"; case "m": return b ? "minuta" : d ? "minutu" : "minutou"; case "mm": return b || d ? e + (Ad(a) ? "minuty" : "minut") : e + "minutami"; break; case "h": return b ? "hodina" : d ? "hodinu" : "hodinou"; case "hh": return b || d ? e + (Ad(a) ? "hodiny" : "hodin") : e + "hodinami"; break; case "d": return b || d ? "den" : "dnem"; case "dd": return b || d ? e + (Ad(a) ? "dny" : "dní") : e + "dny"; break; case "M": return b || d ? "měsíc" : "měsícem"; case "MM": return b || d ? e + (Ad(a) ? "měsíce" : "měsíců") : e + "měsíci"; break; case "y": return b || d ? "rok" : "rokem"; case "yy": return b || d ? e + (Ad(a) ? "roky" : "let") : e + "lety" } }
    //! moment.js locale configuration
    //! locale : German (Austria) [de-at]
    //! author : lluchs : https://github.com/lluchs
    //! author: Menelion Elensúle: https://github.com/Oire
    //! author : Martin Groller : https://github.com/MadMG
    //! author : Mikolaj Dadela : https://github.com/mik01aj
    function Cd(a, b, c, d) { var e = { m: ["eine Minute", "einer Minute"], h: ["eine Stunde", "einer Stunde"], d: ["ein Tag", "einem Tag"], dd: [a + " Tage", a + " Tagen"], M: ["ein Monat", "einem Monat"], MM: [a + " Monate", a + " Monaten"], y: ["ein Jahr", "einem Jahr"], yy: [a + " Jahre", a + " Jahren"] }; return b ? e[c][0] : e[c][1] }
    //! moment.js locale configuration
    //! locale : German (Switzerland) [de-ch]
    //! author : sschueller : https://github.com/sschueller
    function Dd(a, b, c, d) { var e = { m: ["eine Minute", "einer Minute"], h: ["eine Stunde", "einer Stunde"], d: ["ein Tag", "einem Tag"], dd: [a + " Tage", a + " Tagen"], M: ["ein Monat", "einem Monat"], MM: [a + " Monate", a + " Monaten"], y: ["ein Jahr", "einem Jahr"], yy: [a + " Jahre", a + " Jahren"] }; return b ? e[c][0] : e[c][1] }
    //! moment.js locale configuration
    //! locale : German [de]
    //! author : lluchs : https://github.com/lluchs
    //! author: Menelion Elensúle: https://github.com/Oire
    //! author : Mikolaj Dadela : https://github.com/mik01aj
    function Ed(a, b, c, d) { var e = { m: ["eine Minute", "einer Minute"], h: ["eine Stunde", "einer Stunde"], d: ["ein Tag", "einem Tag"], dd: [a + " Tage", a + " Tagen"], M: ["ein Monat", "einem Monat"], MM: [a + " Monate", a + " Monaten"], y: ["ein Jahr", "einem Jahr"], yy: [a + " Jahre", a + " Jahren"] }; return b ? e[c][0] : e[c][1] }
    //! moment.js locale configuration
    //! locale : Estonian [et]
    //! author : Henry Kehlmann : https://github.com/madhenry
    //! improvements : Illimar Tambek : https://github.com/ragulka
    function Fd(a, b, c, d) { var e = { s: ["mõne sekundi", "mõni sekund", "paar sekundit"], m: ["ühe minuti", "üks minut"], mm: [a + " minuti", a + " minutit"], h: ["ühe tunni", "tund aega", "üks tund"], hh: [a + " tunni", a + " tundi"], d: ["ühe päeva", "üks päev"], M: ["kuu aja", "kuu aega", "üks kuu"], MM: [a + " kuu", a + " kuud"], y: ["ühe aasta", "aasta", "üks aasta"], yy: [a + " aasta", a + " aastat"] }; return b ? e[c][2] ? e[c][2] : e[c][1] : d ? e[c][0] : e[c][1] } function Gd(a, b, c, d) { var e = ""; switch (c) { case "s": return d ? "muutaman sekunnin" : "muutama sekunti"; case "m": return d ? "minuutin" : "minuutti"; case "mm": e = d ? "minuutin" : "minuuttia"; break; case "h": return d ? "tunnin" : "tunti"; case "hh": e = d ? "tunnin" : "tuntia"; break; case "d": return d ? "päivän" : "päivä"; case "dd": e = d ? "päivän" : "päivää"; break; case "M": return d ? "kuukauden" : "kuukausi"; case "MM": e = d ? "kuukauden" : "kuukautta"; break; case "y": return d ? "vuoden" : "vuosi"; case "yy": e = d ? "vuoden" : "vuotta" }return e = Hd(a, d) + " " + e } function Hd(a, b) { return a < 10 ? b ? $g[a] : Zg[a] : a }
    //! moment.js locale configuration
    //! locale : Konkani Latin script [gom-latn]
    //! author : The Discoverer : https://github.com/WikiDiscoverer
    function Id(a, b, c, d) { var e = { s: ["thodde secondanim", "thodde second"], m: ["eka mintan", "ek minute"], mm: [a + " mintanim", a + " mintam"], h: ["eka horan", "ek hor"], hh: [a + " horanim", a + " hor"], d: ["eka disan", "ek dis"], dd: [a + " disanim", a + " dis"], M: ["eka mhoinean", "ek mhoino"], MM: [a + " mhoineanim", a + " mhoine"], y: ["eka vorsan", "ek voros"], yy: [a + " vorsanim", a + " vorsam"] }; return b ? e[c][0] : e[c][1] }
    //! moment.js locale configuration
    //! locale : Croatian [hr]
    //! author : Bojan Marković : https://github.com/bmarkovic
    function Jd(a, b, c) { var d = a + " "; switch (c) { case "m": return b ? "jedna minuta" : "jedne minute"; case "mm": return d += 1 === a ? "minuta" : 2 === a || 3 === a || 4 === a ? "minute" : "minuta"; case "h": return b ? "jedan sat" : "jednog sata"; case "hh": return d += 1 === a ? "sat" : 2 === a || 3 === a || 4 === a ? "sata" : "sati"; case "dd": return d += 1 === a ? "dan" : "dana"; case "MM": return d += 1 === a ? "mjesec" : 2 === a || 3 === a || 4 === a ? "mjeseca" : "mjeseci"; case "yy": return d += 1 === a ? "godina" : 2 === a || 3 === a || 4 === a ? "godine" : "godina" } } function Kd(a, b, c, d) { var e = a; switch (c) { case "s": return d || b ? "néhány másodperc" : "néhány másodperce"; case "m": return "egy" + (d || b ? " perc" : " perce"); case "mm": return e + (d || b ? " perc" : " perce"); case "h": return "egy" + (d || b ? " óra" : " órája"); case "hh": return e + (d || b ? " óra" : " órája"); case "d": return "egy" + (d || b ? " nap" : " napja"); case "dd": return e + (d || b ? " nap" : " napja"); case "M": return "egy" + (d || b ? " hónap" : " hónapja"); case "MM": return e + (d || b ? " hónap" : " hónapja"); case "y": return "egy" + (d || b ? " év" : " éve"); case "yy": return e + (d || b ? " év" : " éve") }return "" } function Ld(a) { return (a ? "" : "[múlt] ") + "[" + ih[this.day()] + "] LT[-kor]" }
    //! moment.js locale configuration
    //! locale : Icelandic [is]
    //! author : Hinrik Örn Sigurðsson : https://github.com/hinrik
    function Md(a) { return a % 100 === 11 || a % 10 !== 1 } function Nd(a, b, c, d) { var e = a + " "; switch (c) { case "s": return b || d ? "nokkrar sekúndur" : "nokkrum sekúndum"; case "m": return b ? "mínúta" : "mínútu"; case "mm": return Md(a) ? e + (b || d ? "mínútur" : "mínútum") : b ? e + "mínúta" : e + "mínútu"; case "hh": return Md(a) ? e + (b || d ? "klukkustundir" : "klukkustundum") : e + "klukkustund"; case "d": return b ? "dagur" : d ? "dag" : "degi"; case "dd": return Md(a) ? b ? e + "dagar" : e + (d ? "daga" : "dögum") : b ? e + "dagur" : e + (d ? "dag" : "degi"); case "M": return b ? "mánuður" : d ? "mánuð" : "mánuði"; case "MM": return Md(a) ? b ? e + "mánuðir" : e + (d ? "mánuði" : "mánuðum") : b ? e + "mánuður" : e + (d ? "mánuð" : "mánuði"); case "y": return b || d ? "ár" : "ári"; case "yy": return Md(a) ? e + (b || d ? "ár" : "árum") : e + (b || d ? "ár" : "ári") } }
    //! moment.js locale configuration
    //! locale : Luxembourgish [lb]
    //! author : mweimerskirch : https://github.com/mweimerskirch
    //! author : David Raison : https://github.com/kwisatz
    function Od(a, b, c, d) { var e = { m: ["eng Minutt", "enger Minutt"], h: ["eng Stonn", "enger Stonn"], d: ["een Dag", "engem Dag"], M: ["ee Mount", "engem Mount"], y: ["ee Joer", "engem Joer"] }; return b ? e[c][0] : e[c][1] } function Pd(a) { var b = a.substr(0, a.indexOf(" ")); return Rd(b) ? "a " + a : "an " + a } function Qd(a) { var b = a.substr(0, a.indexOf(" ")); return Rd(b) ? "viru " + a : "virun " + a } function Rd(a) { if (a = parseInt(a, 10), isNaN(a)) return !1; if (a < 0) return !0; if (a < 10) return 4 <= a && a <= 7; if (a < 100) { var b = a % 10, c = a / 10; return Rd(0 === b ? c : b) } if (a < 1e4) { for (; a >= 10;)a /= 10; return Rd(a) } return a /= 1e3, Rd(a) } function Sd(a, b, c, d) { return b ? "kelios sekundės" : d ? "kelių sekundžių" : "kelias sekundes" } function Td(a, b, c, d) { return b ? Vd(c)[0] : d ? Vd(c)[1] : Vd(c)[2] } function Ud(a) { return a % 10 === 0 || a > 10 && a < 20 } function Vd(a) { return nh[a].split("_") } function Wd(a, b, c, d) { var e = a + " "; return 1 === a ? e + Td(a, b, c[0], d) : b ? e + (Ud(a) ? Vd(c)[1] : Vd(c)[0]) : d ? e + Vd(c)[1] : e + (Ud(a) ? Vd(c)[1] : Vd(c)[2]) } function Xd(a, b, c) { return c ? b % 10 === 1 && b % 100 !== 11 ? a[2] : a[3] : b % 10 === 1 && b % 100 !== 11 ? a[0] : a[1] } function Yd(a, b, c) { return a + " " + Xd(oh[c], a, b) } function Zd(a, b, c) { return Xd(oh[c], a, b) } function $d(a, b) { return b ? "dažas sekundes" : "dažām sekundēm" } function _d(a, b, c, d) { var e = ""; if (b) switch (c) { case "s": e = "काही सेकंद"; break; case "m": e = "एक मिनिट"; break; case "mm": e = "%d मिनिटे"; break; case "h": e = "एक तास"; break; case "hh": e = "%d तास"; break; case "d": e = "एक दिवस"; break; case "dd": e = "%d दिवस"; break; case "M": e = "एक महिना"; break; case "MM": e = "%d महिने"; break; case "y": e = "एक वर्ष"; break; case "yy": e = "%d वर्षे" } else switch (c) { case "s": e = "काही सेकंदां"; break; case "m": e = "एका मिनिटा"; break; case "mm": e = "%d मिनिटां"; break; case "h": e = "एका तासा"; break; case "hh": e = "%d तासां"; break; case "d": e = "एका दिवसा"; break; case "dd": e = "%d दिवसां"; break; case "M": e = "एका महिन्या"; break; case "MM": e = "%d महिन्यां"; break; case "y": e = "एका वर्षा"; break; case "yy": e = "%d वर्षां" }return e.replace(/%d/i, a) } function ae(a) { return a % 10 < 5 && a % 10 > 1 && ~~(a / 10) % 10 !== 1 } function be(a, b, c) { var d = a + " "; switch (c) { case "m": return b ? "minuta" : "minutę"; case "mm": return d + (ae(a) ? "minuty" : "minut"); case "h": return b ? "godzina" : "godzinę"; case "hh": return d + (ae(a) ? "godziny" : "godzin"); case "MM": return d + (ae(a) ? "miesiące" : "miesięcy"); case "yy": return d + (ae(a) ? "lata" : "lat") } }
    //! moment.js locale configuration
    //! locale : Romanian [ro]
    //! author : Vlad Gurdiga : https://github.com/gurdiga
    //! author : Valentin Agachi : https://github.com/avaly
    function ce(a, b, c) { var d = { mm: "minute", hh: "ore", dd: "zile", MM: "luni", yy: "ani" }, e = " "; return (a % 100 >= 20 || a >= 100 && a % 100 === 0) && (e = " de "), a + e + d[c] }
    //! moment.js locale configuration
    //! locale : Russian [ru]
    //! author : Viktorminator : https://github.com/Viktorminator
    //! Author : Menelion Elensúle : https://github.com/Oire
    //! author : Коренберг Марк : https://github.com/socketpair
    function de(a, b) { var c = a.split("_"); return b % 10 === 1 && b % 100 !== 11 ? c[0] : b % 10 >= 2 && b % 10 <= 4 && (b % 100 < 10 || b % 100 >= 20) ? c[1] : c[2] } function ee(a, b, c) { var d = { mm: b ? "минута_минуты_минут" : "минуту_минуты_минут", hh: "час_часа_часов", dd: "день_дня_дней", MM: "месяц_месяца_месяцев", yy: "год_года_лет" }; return "m" === c ? b ? "минута" : "минуту" : a + " " + de(d[c], +a) } function fe(a) { return a > 1 && a < 5 } function ge(a, b, c, d) { var e = a + " "; switch (c) { case "s": return b || d ? "pár sekúnd" : "pár sekundami"; case "m": return b ? "minúta" : d ? "minútu" : "minútou"; case "mm": return b || d ? e + (fe(a) ? "minúty" : "minút") : e + "minútami"; break; case "h": return b ? "hodina" : d ? "hodinu" : "hodinou"; case "hh": return b || d ? e + (fe(a) ? "hodiny" : "hodín") : e + "hodinami"; break; case "d": return b || d ? "deň" : "dňom"; case "dd": return b || d ? e + (fe(a) ? "dni" : "dní") : e + "dňami"; break; case "M": return b || d ? "mesiac" : "mesiacom"; case "MM": return b || d ? e + (fe(a) ? "mesiace" : "mesiacov") : e + "mesiacmi"; break; case "y": return b || d ? "rok" : "rokom"; case "yy": return b || d ? e + (fe(a) ? "roky" : "rokov") : e + "rokmi" } }
    //! moment.js locale configuration
    //! locale : Slovenian [sl]
    //! author : Robert Sedovšek : https://github.com/sedovsek
    function he(a, b, c, d) { var e = a + " "; switch (c) { case "s": return b || d ? "nekaj sekund" : "nekaj sekundami"; case "m": return b ? "ena minuta" : "eno minuto"; case "mm": return e += 1 === a ? b ? "minuta" : "minuto" : 2 === a ? b || d ? "minuti" : "minutama" : a < 5 ? b || d ? "minute" : "minutami" : b || d ? "minut" : "minutami"; case "h": return b ? "ena ura" : "eno uro"; case "hh": return e += 1 === a ? b ? "ura" : "uro" : 2 === a ? b || d ? "uri" : "urama" : a < 5 ? b || d ? "ure" : "urami" : b || d ? "ur" : "urami"; case "d": return b || d ? "en dan" : "enim dnem"; case "dd": return e += 1 === a ? b || d ? "dan" : "dnem" : 2 === a ? b || d ? "dni" : "dnevoma" : b || d ? "dni" : "dnevi"; case "M": return b || d ? "en mesec" : "enim mesecem"; case "MM": return e += 1 === a ? b || d ? "mesec" : "mesecem" : 2 === a ? b || d ? "meseca" : "mesecema" : a < 5 ? b || d ? "mesece" : "meseci" : b || d ? "mesecev" : "meseci"; case "y": return b || d ? "eno leto" : "enim letom"; case "yy": return e += 1 === a ? b || d ? "leto" : "letom" : 2 === a ? b || d ? "leti" : "letoma" : a < 5 ? b || d ? "leta" : "leti" : b || d ? "let" : "leti" } } function ie(a) { var b = a; return b = a.indexOf("jaj") !== -1 ? b.slice(0, -3) + "leS" : a.indexOf("jar") !== -1 ? b.slice(0, -3) + "waQ" : a.indexOf("DIS") !== -1 ? b.slice(0, -3) + "nem" : b + " pIq" } function je(a) { var b = a; return b = a.indexOf("jaj") !== -1 ? b.slice(0, -3) + "Hu’" : a.indexOf("jar") !== -1 ? b.slice(0, -3) + "wen" : a.indexOf("DIS") !== -1 ? b.slice(0, -3) + "ben" : b + " ret" } function ke(a, b, c, d) { var e = le(a); switch (c) { case "mm": return e + " tup"; case "hh": return e + " rep"; case "dd": return e + " jaj"; case "MM": return e + " jar"; case "yy": return e + " DIS" } } function le(a) { var b = Math.floor(a % 1e3 / 100), c = Math.floor(a % 100 / 10), d = a % 10, e = ""; return b > 0 && (e += Rh[b] + "vatlh"), c > 0 && (e += ("" !== e ? " " : "") + Rh[c] + "maH"), d > 0 && (e += ("" !== e ? " " : "") + Rh[d]), "" === e ? "pagh" : e } function me(a, b, c, d) { var e = { s: ["viensas secunds", "'iensas secunds"], m: ["'n míut", "'iens míut"], mm: [a + " míuts", "" + a + " míuts"], h: ["'n þora", "'iensa þora"], hh: [a + " þoras", "" + a + " þoras"], d: ["'n ziua", "'iensa ziua"], dd: [a + " ziuas", "" + a + " ziuas"], M: ["'n mes", "'iens mes"], MM: [a + " mesen", "" + a + " mesen"], y: ["'n ar", "'iens ar"], yy: [a + " ars", "" + a + " ars"] }; return d ? e[c][0] : b ? e[c][0] : e[c][1] }
    //! moment.js locale configuration
    //! locale : Ukrainian [uk]
    //! author : zemlanin : https://github.com/zemlanin
    //! Author : Menelion Elensúle : https://github.com/Oire
    function ne(a, b) { var c = a.split("_"); return b % 10 === 1 && b % 100 !== 11 ? c[0] : b % 10 >= 2 && b % 10 <= 4 && (b % 100 < 10 || b % 100 >= 20) ? c[1] : c[2] } function oe(a, b, c) { var d = { mm: b ? "хвилина_хвилини_хвилин" : "хвилину_хвилини_хвилин", hh: b ? "година_години_годин" : "годину_години_годин", dd: "день_дні_днів", MM: "місяць_місяці_місяців", yy: "рік_роки_років" }; return "m" === c ? b ? "хвилина" : "хвилину" : "h" === c ? b ? "година" : "годину" : a + " " + ne(d[c], +a) } function pe(a, b) { var c = { nominative: "неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота".split("_"), accusative: "неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу".split("_"), genitive: "неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи".split("_") }; if (!a) return c.nominative; var d = /(\[[ВвУу]\]) ?dddd/.test(b) ? "accusative" : /\[?(?:минулої|наступної)? ?\] ?dddd/.test(b) ? "genitive" : "nominative"; return c[d][a.day()] } function qe(a) { return function () { return a + "о" + (11 === this.hours() ? "б" : "") + "] LT" } } var re, se; se = Array.prototype.some ? Array.prototype.some : function (a) { for (var b = Object(this), c = b.length >>> 0, d = 0; d < c; d++)if (d in b && a.call(this, b[d], d, b)) return !0; return !1 }; var te = se, ue = a.momentProperties = [], ve = !1, we = {}; a.suppressDeprecationWarnings = !1, a.deprecationHandler = null; var xe; xe = Object.keys ? Object.keys : function (a) { var b, c = []; for (b in a) j(a, b) && c.push(b); return c }; var ye, ze = xe, Ae = { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, Be = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, Ce = "Invalid date", De = "%d", Ee = /\d{1,2}/, Fe = { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, Ge = {}, He = {}, Ie = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, Je = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, Ke = {}, Le = {}, Me = /\d/, Ne = /\d\d/, Oe = /\d{3}/, Pe = /\d{4}/, Qe = /[+-]?\d{6}/, Re = /\d\d?/, Se = /\d\d\d\d?/, Te = /\d\d\d\d\d\d?/, Ue = /\d{1,3}/, Ve = /\d{1,4}/, We = /[+-]?\d{1,6}/, Xe = /\d+/, Ye = /[+-]?\d+/, Ze = /Z|[+-]\d\d:?\d\d/gi, $e = /Z|[+-]\d\d(?::?\d\d)?/gi, _e = /[+-]?\d+(\.\d{1,3})?/, af = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, bf = {}, cf = {}, df = 0, ef = 1, ff = 2, gf = 3, hf = 4, jf = 5, kf = 6, lf = 7, mf = 8; ye = Array.prototype.indexOf ? Array.prototype.indexOf : function (a) { var b; for (b = 0; b < this.length; ++b)if (this[b] === a) return b; return -1 }; var nf = ye; U("M", ["MM", 2], "Mo", function () { return this.month() + 1 }), U("MMM", 0, 0, function (a) { return this.localeData().monthsShort(this, a) }), U("MMMM", 0, 0, function (a) { return this.localeData().months(this, a) }), J("month", "M"), M("month", 8), Z("M", Re), Z("MM", Re, Ne), Z("MMM", function (a, b) { return b.monthsShortRegex(a) }), Z("MMMM", function (a, b) { return b.monthsRegex(a) }), ba(["M", "MM"], function (a, b) { b[ef] = u(a) - 1 }), ba(["MMM", "MMMM"], function (a, b, c, d) { var e = c._locale.monthsParse(a, d, c._strict); null != e ? b[ef] = e : n(c).invalidMonth = a }); var of = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, pf = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), qf = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), rf = af, sf = af; U("Y", 0, 0, function () { var a = this.year(); return a <= 9999 ? "" + a : "+" + a }), U(0, ["YY", 2], 0, function () { return this.year() % 100 }), U(0, ["YYYY", 4], 0, "year"), U(0, ["YYYYY", 5], 0, "year"), U(0, ["YYYYYY", 6, !0], 0, "year"), J("year", "y"), M("year", 1), Z("Y", Ye), Z("YY", Re, Ne), Z("YYYY", Ve, Pe), Z("YYYYY", We, Qe), Z("YYYYYY", We, Qe), ba(["YYYYY", "YYYYYY"], df), ba("YYYY", function (b, c) { c[df] = 2 === b.length ? a.parseTwoDigitYear(b) : u(b) }), ba("YY", function (b, c) { c[df] = a.parseTwoDigitYear(b) }), ba("Y", function (a, b) { b[df] = parseInt(a, 10) }), a.parseTwoDigitYear = function (a) { return u(a) + (u(a) > 68 ? 1900 : 2e3) }; var tf = O("FullYear", !0); U("w", ["ww", 2], "wo", "week"), U("W", ["WW", 2], "Wo", "isoWeek"), J("week", "w"), J("isoWeek", "W"), M("week", 5), M("isoWeek", 5), Z("w", Re), Z("ww", Re, Ne), Z("W", Re), Z("WW", Re, Ne), ca(["w", "ww", "W", "WW"], function (a, b, c, d) { b[d.substr(0, 1)] = u(a) }); var uf = { dow: 0, doy: 6 }; U("d", 0, "do", "day"), U("dd", 0, 0, function (a) { return this.localeData().weekdaysMin(this, a) }), U("ddd", 0, 0, function (a) { return this.localeData().weekdaysShort(this, a) }), U("dddd", 0, 0, function (a) { return this.localeData().weekdays(this, a) }), U("e", 0, 0, "weekday"), U("E", 0, 0, "isoWeekday"), J("day", "d"), J("weekday", "e"), J("isoWeekday", "E"), M("day", 11), M("weekday", 11), M("isoWeekday", 11), Z("d", Re), Z("e", Re), Z("E", Re), Z("dd", function (a, b) { return b.weekdaysMinRegex(a) }), Z("ddd", function (a, b) { return b.weekdaysShortRegex(a) }), Z("dddd", function (a, b) { return b.weekdaysRegex(a) }), ca(["dd", "ddd", "dddd"], function (a, b, c, d) { var e = c._locale.weekdaysParse(a, d, c._strict); null != e ? b.d = e : n(c).invalidWeekday = a }), ca(["d", "e", "E"], function (a, b, c, d) { b[d] = u(a) }); var vf = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), wf = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), xf = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), yf = af, zf = af, Af = af; U("H", ["HH", 2], 0, "hour"), U("h", ["hh", 2], 0, Ra), U("k", ["kk", 2], 0, Sa), U("hmm", 0, 0, function () { return "" + Ra.apply(this) + T(this.minutes(), 2) }), U("hmmss", 0, 0, function () { return "" + Ra.apply(this) + T(this.minutes(), 2) + T(this.seconds(), 2) }), U("Hmm", 0, 0, function () { return "" + this.hours() + T(this.minutes(), 2) }), U("Hmmss", 0, 0, function () { return "" + this.hours() + T(this.minutes(), 2) + T(this.seconds(), 2) }), Ta("a", !0), Ta("A", !1), J("hour", "h"), M("hour", 13), Z("a", Ua), Z("A", Ua), Z("H", Re), Z("h", Re), Z("k", Re), Z("HH", Re, Ne), Z("hh", Re, Ne), Z("kk", Re, Ne), Z("hmm", Se), Z("hmmss", Te), Z("Hmm", Se), Z("Hmmss", Te), ba(["H", "HH"], gf), ba(["k", "kk"], function (a, b, c) { var d = u(a); b[gf] = 24 === d ? 0 : d }), ba(["a", "A"], function (a, b, c) { c._isPm = c._locale.isPM(a), c._meridiem = a }), ba(["h", "hh"], function (a, b, c) { b[gf] = u(a), n(c).bigHour = !0 }), ba("hmm", function (a, b, c) { var d = a.length - 2; b[gf] = u(a.substr(0, d)), b[hf] = u(a.substr(d)), n(c).bigHour = !0 }), ba("hmmss", function (a, b, c) { var d = a.length - 4, e = a.length - 2; b[gf] = u(a.substr(0, d)), b[hf] = u(a.substr(d, 2)), b[jf] = u(a.substr(e)), n(c).bigHour = !0 }), ba("Hmm", function (a, b, c) { var d = a.length - 2; b[gf] = u(a.substr(0, d)), b[hf] = u(a.substr(d)) }), ba("Hmmss", function (a, b, c) { var d = a.length - 4, e = a.length - 2; b[gf] = u(a.substr(0, d)), b[hf] = u(a.substr(d, 2)), b[jf] = u(a.substr(e)) }); var Bf, Cf = /[ap]\.?m?\.?/i, Df = O("Hours", !0), Ef = { calendar: Ae, longDateFormat: Be, invalidDate: Ce, ordinal: De, dayOfMonthOrdinalParse: Ee, relativeTime: Fe, months: pf, monthsShort: qf, week: uf, weekdays: vf, weekdaysMin: xf, weekdaysShort: wf, meridiemParse: Cf }, Ff = {}, Gf = {}, Hf = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, If = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, Jf = /Z|[+-]\d\d(?::?\d\d)?/, Kf = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, !1], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, !1], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, !1], ["YYYYDDD", /\d{7}/]], Lf = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]], Mf = /^\/?Date\((\-?\d+)/i, Nf = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/; a.createFromInputFallback = x("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function (a) { a._d = new Date(a._i + (a._useUTC ? " UTC" : "")) }), a.ISO_8601 = function () { }, a.RFC_2822 = function () { }; var Of = x("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function () { var a = tb.apply(null, arguments); return this.isValid() && a.isValid() ? a < this ? this : a : p() }), Pf = x("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function () { var a = tb.apply(null, arguments); return this.isValid() && a.isValid() ? a > this ? this : a : p() }), Qf = function () { return Date.now ? Date.now() : +new Date }, Rf = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"]; Db("Z", ":"), Db("ZZ", ""), Z("Z", $e), Z("ZZ", $e), ba(["Z", "ZZ"], function (a, b, c) { c._useUTC = !0, c._tzm = Eb($e, a) }); var Sf = /([\+\-]|\d\d)/gi; a.updateOffset = function () { }; var Tf = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/, Uf = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/; Sb.fn = Ab.prototype, Sb.invalid = zb; var Vf = Wb(1, "add"), Wf = Wb(-1, "subtract"); a.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", a.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]"; var Xf = x("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function (a) { return void 0 === a ? this.localeData() : this.locale(a) }); U(0, ["gg", 2], 0, function () { return this.weekYear() % 100 }), U(0, ["GG", 2], 0, function () { return this.isoWeekYear() % 100 }), Dc("gggg", "weekYear"), Dc("ggggg", "weekYear"), Dc("GGGG", "isoWeekYear"), Dc("GGGGG", "isoWeekYear"), J("weekYear", "gg"), J("isoWeekYear", "GG"), M("weekYear", 1), M("isoWeekYear", 1), Z("G", Ye), Z("g", Ye), Z("GG", Re, Ne), Z("gg", Re, Ne), Z("GGGG", Ve, Pe), Z("gggg", Ve, Pe), Z("GGGGG", We, Qe), Z("ggggg", We, Qe), ca(["gggg", "ggggg", "GGGG", "GGGGG"], function (a, b, c, d) { b[d.substr(0, 2)] = u(a) }), ca(["gg", "GG"], function (b, c, d, e) { c[e] = a.parseTwoDigitYear(b) }), U("Q", 0, "Qo", "quarter"), J("quarter", "Q"), M("quarter", 7), Z("Q", Me), ba("Q", function (a, b) { b[ef] = 3 * (u(a) - 1) }), U("D", ["DD", 2], "Do", "date"), J("date", "D"), M("date", 9), Z("D", Re), Z("DD", Re, Ne), Z("Do", function (a, b) { return a ? b._dayOfMonthOrdinalParse || b._ordinalParse : b._dayOfMonthOrdinalParseLenient }), ba(["D", "DD"], ff), ba("Do", function (a, b) { b[ff] = u(a.match(Re)[0], 10) }); var Yf = O("Date", !0); U("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), J("dayOfYear", "DDD"), M("dayOfYear", 4), Z("DDD", Ue), Z("DDDD", Oe), ba(["DDD", "DDDD"], function (a, b, c) { c._dayOfYear = u(a) }), U("m", ["mm", 2], 0, "minute"), J("minute", "m"), M("minute", 14), Z("m", Re), Z("mm", Re, Ne), ba(["m", "mm"], hf); var Zf = O("Minutes", !1); U("s", ["ss", 2], 0, "second"), J("second", "s"), M("second", 15), Z("s", Re), Z("ss", Re, Ne), ba(["s", "ss"], jf); var $f = O("Seconds", !1); U("S", 0, 0, function () { return ~~(this.millisecond() / 100) }), U(0, ["SS", 2], 0, function () { return ~~(this.millisecond() / 10) }), U(0, ["SSS", 3], 0, "millisecond"), U(0, ["SSSS", 4], 0, function () { return 10 * this.millisecond() }), U(0, ["SSSSS", 5], 0, function () { return 100 * this.millisecond() }), U(0, ["SSSSSS", 6], 0, function () { return 1e3 * this.millisecond() }), U(0, ["SSSSSSS", 7], 0, function () { return 1e4 * this.millisecond() }), U(0, ["SSSSSSSS", 8], 0, function () { return 1e5 * this.millisecond() }), U(0, ["SSSSSSSSS", 9], 0, function () { return 1e6 * this.millisecond() }), J("millisecond", "ms"), M("millisecond", 16), Z("S", Ue, Me), Z("SS", Ue, Ne), Z("SSS", Ue, Oe); var _f; for (_f = "SSSS"; _f.length <= 9; _f += "S")Z(_f, Xe); for (_f = "S"; _f.length <= 9; _f += "S")ba(_f, Mc); var ag = O("Milliseconds", !1); U("z", 0, 0, "zoneAbbr"), U("zz", 0, 0, "zoneName"); var bg = r.prototype; bg.add = Vf, bg.calendar = Zb, bg.clone = $b, bg.diff = fc, bg.endOf = sc, bg.format = kc, bg.from = lc, bg.fromNow = mc, bg.to = nc, bg.toNow = oc, bg.get = R, bg.invalidAt = Bc, bg.isAfter = _b, bg.isBefore = ac, bg.isBetween = bc, bg.isSame = cc, bg.isSameOrAfter = dc, bg.isSameOrBefore = ec, bg.isValid = zc, bg.lang = Xf, bg.locale = pc, bg.localeData = qc, bg.max = Pf, bg.min = Of, bg.parsingFlags = Ac, bg.set = S, bg.startOf = rc, bg.subtract = Wf, bg.toArray = wc, bg.toObject = xc, bg.toDate = vc, bg.toISOString = ic, bg.inspect = jc, bg.toJSON = yc, bg.toString = hc, bg.unix = uc, bg.valueOf = tc, bg.creationData = Cc, bg.year = tf, bg.isLeapYear = ra, bg.weekYear = Ec, bg.isoWeekYear = Fc, bg.quarter = bg.quarters = Kc, bg.month = ka, bg.daysInMonth = la, bg.week = bg.weeks = Ba, bg.isoWeek = bg.isoWeeks = Ca, bg.weeksInYear = Hc, bg.isoWeeksInYear = Gc, bg.date = Yf, bg.day = bg.days = Ka, bg.weekday = La, bg.isoWeekday = Ma, bg.dayOfYear = Lc, bg.hour = bg.hours = Df, bg.minute = bg.minutes = Zf, bg.second = bg.seconds = $f, bg.millisecond = bg.milliseconds = ag, bg.utcOffset = Hb, bg.utc = Jb, bg.local = Kb, bg.parseZone = Lb, bg.hasAlignedHourOffset = Mb, bg.isDST = Nb, bg.isLocal = Pb, bg.isUtcOffset = Qb, bg.isUtc = Rb, bg.isUTC = Rb, bg.zoneAbbr = Nc, bg.zoneName = Oc, bg.dates = x("dates accessor is deprecated. Use date instead.", Yf), bg.months = x("months accessor is deprecated. Use month instead", ka), bg.years = x("years accessor is deprecated. Use year instead", tf), bg.zone = x("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", Ib), bg.isDSTShifted = x("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", Ob); var cg = C.prototype; cg.calendar = D, cg.longDateFormat = E, cg.invalidDate = F, cg.ordinal = G, cg.preparse = Rc, cg.postformat = Rc, cg.relativeTime = H, cg.pastFuture = I, cg.set = A, cg.months = fa, cg.monthsShort = ga, cg.monthsParse = ia, cg.monthsRegex = na, cg.monthsShortRegex = ma, cg.week = ya, cg.firstDayOfYear = Aa, cg.firstDayOfWeek = za, cg.weekdays = Fa, cg.weekdaysMin = Ha, cg.weekdaysShort = Ga, cg.weekdaysParse = Ja, cg.weekdaysRegex = Na, cg.weekdaysShortRegex = Oa, cg.weekdaysMinRegex = Pa, cg.isPM = Va, cg.meridiem = Wa, $a("en", { dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: function (a) { var b = a % 10, c = 1 === u(a % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th"; return a + c } }), a.lang = x("moment.lang is deprecated. Use moment.locale instead.", $a), a.langData = x("moment.langData is deprecated. Use moment.localeData instead.", bb); var dg = Math.abs, eg = id("ms"), fg = id("s"), gg = id("m"), hg = id("h"), ig = id("d"), jg = id("w"), kg = id("M"), lg = id("y"), mg = kd("milliseconds"), ng = kd("seconds"), og = kd("minutes"), pg = kd("hours"), qg = kd("days"), rg = kd("months"), sg = kd("years"), tg = Math.round, ug = { ss: 44, s: 45, m: 45, h: 22, d: 26, M: 11 }, vg = Math.abs, wg = Ab.prototype; wg.isValid = yb, wg.abs = $c, wg.add = ad, wg.subtract = bd, wg.as = gd, wg.asMilliseconds = eg, wg.asSeconds = fg, wg.asMinutes = gg, wg.asHours = hg, wg.asDays = ig, wg.asWeeks = jg, wg.asMonths = kg, wg.asYears = lg, wg.valueOf = hd, wg._bubble = dd, wg.get = jd, wg.milliseconds = mg, wg.seconds = ng, wg.minutes = og, wg.hours = pg, wg.days = qg, wg.weeks = ld, wg.months = rg, wg.years = sg, wg.humanize = qd, wg.toISOString = rd, wg.toString = rd, wg.toJSON = rd, wg.locale = pc, wg.localeData = qc, wg.toIsoString = x("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", rd), wg.lang = Xf, U("X", 0, 0, "unix"), U("x", 0, 0, "valueOf"), Z("x", Ye), Z("X", _e), ba("X", function (a, b, c) { c._d = new Date(1e3 * parseFloat(a, 10)) }), ba("x", function (a, b, c) { c._d = new Date(u(a)) }),
        //! moment.js
        //! version : 2.18.1
        //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
        //! license : MIT
        //! momentjs.com
        a.version = "2.18.1", b(tb), a.fn = bg, a.min = vb, a.max = wb, a.now = Qf, a.utc = l, a.unix = Pc, a.months = Vc, a.isDate = h, a.locale = $a, a.invalid = p, a.duration = Sb, a.isMoment = s, a.weekdays = Xc, a.parseZone = Qc, a.localeData = bb, a.isDuration = Bb, a.monthsShort = Wc, a.weekdaysMin = Zc, a.defineLocale = _a, a.updateLocale = ab, a.locales = cb, a.weekdaysShort = Yc, a.normalizeUnits = K, a.relativeTimeRounding = od, a.relativeTimeThreshold = pd, a.calendarFormat = Yb, a.prototype = bg,
        //! moment.js locale configuration
        //! locale : Afrikaans [af]
        //! author : Werner Mollentze : https://github.com/wernerm
        a.defineLocale("af", { months: "Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember".split("_"), monthsShort: "Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des".split("_"), weekdays: "Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag".split("_"), weekdaysShort: "Son_Maa_Din_Woe_Don_Vry_Sat".split("_"), weekdaysMin: "So_Ma_Di_Wo_Do_Vr_Sa".split("_"), meridiemParse: /vm|nm/i, isPM: function (a) { return /^nm$/i.test(a) }, meridiem: function (a, b, c) { return a < 12 ? c ? "vm" : "VM" : c ? "nm" : "NM" }, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Vandag om] LT", nextDay: "[Môre om] LT", nextWeek: "dddd [om] LT", lastDay: "[Gister om] LT", lastWeek: "[Laas] dddd [om] LT", sameElse: "L" }, relativeTime: { future: "oor %s", past: "%s gelede", s: "'n paar sekondes", m: "'n minuut", mm: "%d minute", h: "'n uur", hh: "%d ure", d: "'n dag", dd: "%d dae", M: "'n maand", MM: "%d maande", y: "'n jaar", yy: "%d jaar" }, dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/, ordinal: function (a) { return a + (1 === a || 8 === a || a >= 20 ? "ste" : "de") }, week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Arabic (Algeria) [ar-dz]
        //! author : Noureddine LOUAHEDJ : https://github.com/noureddineme
        a.defineLocale("ar-dz", { months: "جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"), monthsShort: "جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"), weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "احد_اثنين_ثلاثاء_اربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "أح_إث_ثلا_أر_خم_جم_سب".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" }, relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" }, week: { dow: 0, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Arabic (Kuwait) [ar-kw]
        //! author : Nusret Parlak: https://github.com/nusretparlak
        a.defineLocale("ar-kw", { months: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"), monthsShort: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"), weekdays: "الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" }, relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" }, week: { dow: 0, doy: 12 } });
    //! moment.js locale configuration
    //! locale : Arabic (Lybia) [ar-ly]
    //! author : Ali Hmer: https://github.com/kikoanis
    var xg = { 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 0: "0" }, yg = function (a) { return 0 === a ? 0 : 1 === a ? 1 : 2 === a ? 2 : a % 100 >= 3 && a % 100 <= 10 ? 3 : a % 100 >= 11 ? 4 : 5 }, zg = { s: ["أقل من ثانية", "ثانية واحدة", ["ثانيتان", "ثانيتين"], "%d ثوان", "%d ثانية", "%d ثانية"], m: ["أقل من دقيقة", "دقيقة واحدة", ["دقيقتان", "دقيقتين"], "%d دقائق", "%d دقيقة", "%d دقيقة"], h: ["أقل من ساعة", "ساعة واحدة", ["ساعتان", "ساعتين"], "%d ساعات", "%d ساعة", "%d ساعة"], d: ["أقل من يوم", "يوم واحد", ["يومان", "يومين"], "%d أيام", "%d يومًا", "%d يوم"], M: ["أقل من شهر", "شهر واحد", ["شهران", "شهرين"], "%d أشهر", "%d شهرا", "%d شهر"], y: ["أقل من عام", "عام واحد", ["عامان", "عامين"], "%d أعوام", "%d عامًا", "%d عام"] }, Ag = function (a) { return function (b, c, d, e) { var f = yg(b), g = zg[a][yg(b)]; return 2 === f && (g = g[c ? 0 : 1]), g.replace(/%d/i, b) } }, Bg = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"]; a.defineLocale("ar-ly", { months: Bg, monthsShort: Bg, weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/‏M/‏YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /ص|م/, isPM: function (a) { return "م" === a }, meridiem: function (a, b, c) { return a < 12 ? "ص" : "م" }, calendar: { sameDay: "[اليوم عند الساعة] LT", nextDay: "[غدًا عند الساعة] LT", nextWeek: "dddd [عند الساعة] LT", lastDay: "[أمس عند الساعة] LT", lastWeek: "dddd [عند الساعة] LT", sameElse: "L" }, relativeTime: { future: "بعد %s", past: "منذ %s", s: Ag("s"), m: Ag("m"), mm: Ag("m"), h: Ag("h"), hh: Ag("h"), d: Ag("d"), dd: Ag("d"), M: Ag("M"), MM: Ag("M"), y: Ag("y"), yy: Ag("y") }, preparse: function (a) { return a.replace(/\u200f/g, "").replace(/،/g, ",") }, postformat: function (a) { return a.replace(/\d/g, function (a) { return xg[a] }).replace(/,/g, "،") }, week: { dow: 6, doy: 12 } }),
        //! moment.js locale configuration
        //! locale : Arabic (Morocco) [ar-ma]
        //! author : ElFadili Yassine : https://github.com/ElFadiliY
        //! author : Abdel Said : https://github.com/abdelsaid
        a.defineLocale("ar-ma", { months: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"), monthsShort: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"), weekdays: "الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" }, relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" }, week: { dow: 6, doy: 12 } });
    //! moment.js locale configuration
    //! locale : Arabic (Saudi Arabia) [ar-sa]
    //! author : Suhail Alkowaileet : https://github.com/xsoh
    var Cg = { 1: "١", 2: "٢", 3: "٣", 4: "٤", 5: "٥", 6: "٦", 7: "٧", 8: "٨", 9: "٩", 0: "٠" }, Dg = { "١": "1", "٢": "2", "٣": "3", "٤": "4", "٥": "5", "٦": "6", "٧": "7", "٨": "8", "٩": "9", "٠": "0" }; a.defineLocale("ar-sa", { months: "يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"), monthsShort: "يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"), weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /ص|م/, isPM: function (a) { return "م" === a }, meridiem: function (a, b, c) { return a < 12 ? "ص" : "م" }, calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" }, relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" }, preparse: function (a) { return a.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (a) { return Dg[a] }).replace(/،/g, ",") }, postformat: function (a) { return a.replace(/\d/g, function (a) { return Cg[a] }).replace(/,/g, "،") }, week: { dow: 0, doy: 6 } }),
        //! moment.js locale configuration
        //! locale  :  Arabic (Tunisia) [ar-tn]
        //! author : Nader Toukabri : https://github.com/naderio
        a.defineLocale("ar-tn", { months: "جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"), monthsShort: "جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"), weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" }, relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" }, week: { dow: 1, doy: 4 } });
    //! moment.js locale configuration
    //! locale : Arabic [ar]
    //! author : Abdel Said: https://github.com/abdelsaid
    //! author : Ahmed Elkhatib
    //! author : forabi https://github.com/forabi
    var Eg = { 1: "١", 2: "٢", 3: "٣", 4: "٤", 5: "٥", 6: "٦", 7: "٧", 8: "٨", 9: "٩", 0: "٠" }, Fg = { "١": "1", "٢": "2", "٣": "3", "٤": "4", "٥": "5", "٦": "6", "٧": "7", "٨": "8", "٩": "9", "٠": "0" }, Gg = function (a) { return 0 === a ? 0 : 1 === a ? 1 : 2 === a ? 2 : a % 100 >= 3 && a % 100 <= 10 ? 3 : a % 100 >= 11 ? 4 : 5 }, Hg = { s: ["أقل من ثانية", "ثانية واحدة", ["ثانيتان", "ثانيتين"], "%d ثوان", "%d ثانية", "%d ثانية"], m: ["أقل من دقيقة", "دقيقة واحدة", ["دقيقتان", "دقيقتين"], "%d دقائق", "%d دقيقة", "%d دقيقة"], h: ["أقل من ساعة", "ساعة واحدة", ["ساعتان", "ساعتين"], "%d ساعات", "%d ساعة", "%d ساعة"], d: ["أقل من يوم", "يوم واحد", ["يومان", "يومين"], "%d أيام", "%d يومًا", "%d يوم"], M: ["أقل من شهر", "شهر واحد", ["شهران", "شهرين"], "%d أشهر", "%d شهرا", "%d شهر"], y: ["أقل من عام", "عام واحد", ["عامان", "عامين"], "%d أعوام", "%d عامًا", "%d عام"] }, Ig = function (a) { return function (b, c, d, e) { var f = Gg(b), g = Hg[a][Gg(b)]; return 2 === f && (g = g[c ? 0 : 1]), g.replace(/%d/i, b) } }, Jg = ["كانون الثاني يناير", "شباط فبراير", "آذار مارس", "نيسان أبريل", "أيار مايو", "حزيران يونيو", "تموز يوليو", "آب أغسطس", "أيلول سبتمبر", "تشرين الأول أكتوبر", "تشرين الثاني نوفمبر", "كانون الأول ديسمبر"]; a.defineLocale("ar", { months: Jg, monthsShort: Jg, weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/‏M/‏YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /ص|م/, isPM: function (a) { return "م" === a }, meridiem: function (a, b, c) { return a < 12 ? "ص" : "م" }, calendar: { sameDay: "[اليوم عند الساعة] LT", nextDay: "[غدًا عند الساعة] LT", nextWeek: "dddd [عند الساعة] LT", lastDay: "[أمس عند الساعة] LT", lastWeek: "dddd [عند الساعة] LT", sameElse: "L" }, relativeTime: { future: "بعد %s", past: "منذ %s", s: Ig("s"), m: Ig("m"), mm: Ig("m"), h: Ig("h"), hh: Ig("h"), d: Ig("d"), dd: Ig("d"), M: Ig("M"), MM: Ig("M"), y: Ig("y"), yy: Ig("y") }, preparse: function (a) { return a.replace(/\u200f/g, "").replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (a) { return Fg[a] }).replace(/،/g, ",") }, postformat: function (a) { return a.replace(/\d/g, function (a) { return Eg[a] }).replace(/,/g, "،") }, week: { dow: 6, doy: 12 } });
    //! moment.js locale configuration
    //! locale : Azerbaijani [az]
    //! author : topchiyev : https://github.com/topchiyev
    var Kg = { 1: "-inci", 5: "-inci", 8: "-inci", 70: "-inci", 80: "-inci", 2: "-nci", 7: "-nci", 20: "-nci", 50: "-nci", 3: "-üncü", 4: "-üncü", 100: "-üncü", 6: "-ncı", 9: "-uncu", 10: "-uncu", 30: "-uncu", 60: "-ıncı", 90: "-ıncı" }; a.defineLocale("az", { months: "yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr".split("_"), monthsShort: "yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek".split("_"), weekdays: "Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə".split("_"), weekdaysShort: "Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən".split("_"), weekdaysMin: "Bz_BE_ÇA_Çə_CA_Cü_Şə".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[bugün saat] LT", nextDay: "[sabah saat] LT", nextWeek: "[gələn həftə] dddd [saat] LT", lastDay: "[dünən] LT", lastWeek: "[keçən həftə] dddd [saat] LT", sameElse: "L" }, relativeTime: { future: "%s sonra", past: "%s əvvəl", s: "birneçə saniyyə", m: "bir dəqiqə", mm: "%d dəqiqə", h: "bir saat", hh: "%d saat", d: "bir gün", dd: "%d gün", M: "bir ay", MM: "%d ay", y: "bir il", yy: "%d il" }, meridiemParse: /gecə|səhər|gündüz|axşam/, isPM: function (a) { return /^(gündüz|axşam)$/.test(a) }, meridiem: function (a, b, c) { return a < 4 ? "gecə" : a < 12 ? "səhər" : a < 17 ? "gündüz" : "axşam" }, dayOfMonthOrdinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/, ordinal: function (a) { if (0 === a) return a + "-ıncı"; var b = a % 10, c = a % 100 - b, d = a >= 100 ? 100 : null; return a + (Kg[b] || Kg[c] || Kg[d]) }, week: { dow: 1, doy: 7 } }), a.defineLocale("be", { months: { format: "студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня".split("_"), standalone: "студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань".split("_") }, monthsShort: "студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж".split("_"), weekdays: { format: "нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу".split("_"), standalone: "нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота".split("_"), isFormat: /\[ ?[Вв] ?(?:мінулую|наступную)? ?\] ?dddd/ }, weekdaysShort: "нд_пн_ат_ср_чц_пт_сб".split("_"), weekdaysMin: "нд_пн_ат_ср_чц_пт_сб".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY г.", LLL: "D MMMM YYYY г., HH:mm", LLLL: "dddd, D MMMM YYYY г., HH:mm" }, calendar: { sameDay: "[Сёння ў] LT", nextDay: "[Заўтра ў] LT", lastDay: "[Учора ў] LT", nextWeek: function () { return "[У] dddd [ў] LT" }, lastWeek: function () { switch (this.day()) { case 0: case 3: case 5: case 6: return "[У мінулую] dddd [ў] LT"; case 1: case 2: case 4: return "[У мінулы] dddd [ў] LT" } }, sameElse: "L" }, relativeTime: { future: "праз %s", past: "%s таму", s: "некалькі секунд", m: td, mm: td, h: td, hh: td, d: "дзень", dd: td, M: "месяц", MM: td, y: "год", yy: td }, meridiemParse: /ночы|раніцы|дня|вечара/, isPM: function (a) { return /^(дня|вечара)$/.test(a) }, meridiem: function (a, b, c) { return a < 4 ? "ночы" : a < 12 ? "раніцы" : a < 17 ? "дня" : "вечара" }, dayOfMonthOrdinalParse: /\d{1,2}-(і|ы|га)/, ordinal: function (a, b) { switch (b) { case "M": case "d": case "DDD": case "w": case "W": return a % 10 !== 2 && a % 10 !== 3 || a % 100 === 12 || a % 100 === 13 ? a + "-ы" : a + "-і"; case "D": return a + "-га"; default: return a } }, week: { dow: 1, doy: 7 } }),
        //! moment.js locale configuration
        //! locale : Bulgarian [bg]
        //! author : Krasen Borisov : https://github.com/kraz
        a.defineLocale("bg", { months: "януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември".split("_"), monthsShort: "янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек".split("_"), weekdays: "неделя_понеделник_вторник_сряда_четвъртък_петък_събота".split("_"), weekdaysShort: "нед_пон_вто_сря_чет_пет_съб".split("_"), weekdaysMin: "нд_пн_вт_ср_чт_пт_сб".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "D.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY H:mm", LLLL: "dddd, D MMMM YYYY H:mm" }, calendar: { sameDay: "[Днес в] LT", nextDay: "[Утре в] LT", nextWeek: "dddd [в] LT", lastDay: "[Вчера в] LT", lastWeek: function () { switch (this.day()) { case 0: case 3: case 6: return "[В изминалата] dddd [в] LT"; case 1: case 2: case 4: case 5: return "[В изминалия] dddd [в] LT" } }, sameElse: "L" }, relativeTime: { future: "след %s", past: "преди %s", s: "няколко секунди", m: "минута", mm: "%d минути", h: "час", hh: "%d часа", d: "ден", dd: "%d дни", M: "месец", MM: "%d месеца", y: "година", yy: "%d години" }, dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/, ordinal: function (a) { var b = a % 10, c = a % 100; return 0 === a ? a + "-ев" : 0 === c ? a + "-ен" : c > 10 && c < 20 ? a + "-ти" : 1 === b ? a + "-ви" : 2 === b ? a + "-ри" : 7 === b || 8 === b ? a + "-ми" : a + "-ти" }, week: { dow: 1, doy: 7 } });
    //! moment.js locale configuration
    //! locale : Bengali [bn]
    //! author : Kaushik Gandhi : https://github.com/kaushikgandhi
    var Lg = { 1: "১", 2: "২", 3: "৩", 4: "৪", 5: "৫", 6: "৬", 7: "৭", 8: "৮", 9: "৯", 0: "০" }, Mg = { "১": "1", "২": "2", "৩": "3", "৪": "4", "৫": "5", "৬": "6", "৭": "7", "৮": "8", "৯": "9", "০": "0" }; a.defineLocale("bn", { months: "জানুয়ারী_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর".split("_"), monthsShort: "জানু_ফেব_মার্চ_এপ্র_মে_জুন_জুল_আগ_সেপ্ট_অক্টো_নভে_ডিসে".split("_"), weekdays: "রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার".split("_"), weekdaysShort: "রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি".split("_"), weekdaysMin: "রবি_সোম_মঙ্গ_বুধ_বৃহঃ_শুক্র_শনি".split("_"), longDateFormat: { LT: "A h:mm সময়", LTS: "A h:mm:ss সময়", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm সময়", LLLL: "dddd, D MMMM YYYY, A h:mm সময়" }, calendar: { sameDay: "[আজ] LT", nextDay: "[আগামীকাল] LT", nextWeek: "dddd, LT", lastDay: "[গতকাল] LT", lastWeek: "[গত] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s পরে", past: "%s আগে", s: "কয়েক সেকেন্ড", m: "এক মিনিট", mm: "%d মিনিট", h: "এক ঘন্টা", hh: "%d ঘন্টা", d: "এক দিন", dd: "%d দিন", M: "এক মাস", MM: "%d মাস", y: "এক বছর", yy: "%d বছর" }, preparse: function (a) { return a.replace(/[১২৩৪৫৬৭৮৯০]/g, function (a) { return Mg[a] }) }, postformat: function (a) { return a.replace(/\d/g, function (a) { return Lg[a] }) }, meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/, meridiemHour: function (a, b) { return 12 === a && (a = 0), "রাত" === b && a >= 4 || "দুপুর" === b && a < 5 || "বিকাল" === b ? a + 12 : a }, meridiem: function (a, b, c) { return a < 4 ? "রাত" : a < 10 ? "সকাল" : a < 17 ? "দুপুর" : a < 20 ? "বিকাল" : "রাত" }, week: { dow: 0, doy: 6 } });
    //! moment.js locale configuration
    //! locale : Tibetan [bo]
    //! author : Thupten N. Chakrishar : https://github.com/vajradog
    var Ng = { 1: "༡", 2: "༢", 3: "༣", 4: "༤", 5: "༥", 6: "༦", 7: "༧", 8: "༨", 9: "༩", 0: "༠" }, Og = { "༡": "1", "༢": "2", "༣": "3", "༤": "4", "༥": "5", "༦": "6", "༧": "7", "༨": "8", "༩": "9", "༠": "0" }; a.defineLocale("bo", { months: "ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ".split("_"), monthsShort: "ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ".split("_"), weekdays: "གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་".split("_"), weekdaysShort: "ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་".split("_"), weekdaysMin: "ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་".split("_"), longDateFormat: { LT: "A h:mm", LTS: "A h:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm", LLLL: "dddd, D MMMM YYYY, A h:mm" }, calendar: { sameDay: "[དི་རིང] LT", nextDay: "[སང་ཉིན] LT", nextWeek: "[བདུན་ཕྲག་རྗེས་མ], LT", lastDay: "[ཁ་སང] LT", lastWeek: "[བདུན་ཕྲག་མཐའ་མ] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s ལ་", past: "%s སྔན་ལ", s: "ལམ་སང", m: "སྐར་མ་གཅིག", mm: "%d སྐར་མ", h: "ཆུ་ཚོད་གཅིག", hh: "%d ཆུ་ཚོད", d: "ཉིན་གཅིག", dd: "%d ཉིན་", M: "ཟླ་བ་གཅིག", MM: "%d ཟླ་བ", y: "ལོ་གཅིག", yy: "%d ལོ" }, preparse: function (a) { return a.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (a) { return Og[a] }) }, postformat: function (a) { return a.replace(/\d/g, function (a) { return Ng[a] }) }, meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/, meridiemHour: function (a, b) { return 12 === a && (a = 0), "མཚན་མོ" === b && a >= 4 || "ཉིན་གུང" === b && a < 5 || "དགོང་དག" === b ? a + 12 : a }, meridiem: function (a, b, c) { return a < 4 ? "མཚན་མོ" : a < 10 ? "ཞོགས་ཀས" : a < 17 ? "ཉིན་གུང" : a < 20 ? "དགོང་དག" : "མཚན་མོ" }, week: { dow: 0, doy: 6 } }), a.defineLocale("br", { months: "Genver_C'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split("_"), monthsShort: "Gen_C'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"), weekdays: "Sul_Lun_Meurzh_Merc'her_Yaou_Gwener_Sadorn".split("_"), weekdaysShort: "Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"), weekdaysMin: "Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "h[e]mm A", LTS: "h[e]mm:ss A", L: "DD/MM/YYYY", LL: "D [a viz] MMMM YYYY", LLL: "D [a viz] MMMM YYYY h[e]mm A", LLLL: "dddd, D [a viz] MMMM YYYY h[e]mm A" }, calendar: { sameDay: "[Hiziv da] LT", nextDay: "[Warc'hoazh da] LT", nextWeek: "dddd [da] LT", lastDay: "[Dec'h da] LT", lastWeek: "dddd [paset da] LT", sameElse: "L" }, relativeTime: { future: "a-benn %s", past: "%s 'zo", s: "un nebeud segondennoù", m: "ur vunutenn", mm: ud, h: "un eur", hh: "%d eur", d: "un devezh", dd: ud, M: "ur miz", MM: ud, y: "ur bloaz", yy: vd }, dayOfMonthOrdinalParse: /\d{1,2}(añ|vet)/, ordinal: function (a) { var b = 1 === a ? "añ" : "vet"; return a + b }, week: { dow: 1, doy: 4 } }), a.defineLocale("bs", { months: "januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar".split("_"), monthsShort: "jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"), weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"), weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" }, calendar: { sameDay: "[danas u] LT", nextDay: "[sutra u] LT", nextWeek: function () { switch (this.day()) { case 0: return "[u] [nedjelju] [u] LT"; case 3: return "[u] [srijedu] [u] LT"; case 6: return "[u] [subotu] [u] LT"; case 1: case 2: case 4: case 5: return "[u] dddd [u] LT" } }, lastDay: "[jučer u] LT", lastWeek: function () { switch (this.day()) { case 0: case 3: return "[prošlu] dddd [u] LT"; case 6: return "[prošle] [subote] [u] LT"; case 1: case 2: case 4: case 5: return "[prošli] dddd [u] LT" } }, sameElse: "L" }, relativeTime: { future: "za %s", past: "prije %s", s: "par sekundi", m: zd, mm: zd, h: zd, hh: zd, d: "dan", dd: zd, M: "mjesec", MM: zd, y: "godinu", yy: zd }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } }),
        //! moment.js locale configuration
        //! locale : Catalan [ca]
        //! author : Juan G. Hurtado : https://github.com/juanghurtado
        a.defineLocale("ca", { months: { standalone: "gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre".split("_"), format: "de gener_de febrer_de març_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split("_"), isFormat: /D[oD]?(\s)+MMMM/ }, monthsShort: "gen._febr._març_abr._maig_juny_jul._ag._set._oct._nov._des.".split("_"), monthsParseExact: !0, weekdays: "diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte".split("_"), weekdaysShort: "dg._dl._dt._dc._dj._dv._ds.".split("_"), weekdaysMin: "Dg_Dl_Dt_Dc_Dj_Dv_Ds".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "[el] D MMMM [de] YYYY", ll: "D MMM YYYY", LLL: "[el] D MMMM [de] YYYY [a les] H:mm", lll: "D MMM YYYY, H:mm", LLLL: "[el] dddd D MMMM [de] YYYY [a les] H:mm", llll: "ddd D MMM YYYY, H:mm" }, calendar: { sameDay: function () { return "[avui a " + (1 !== this.hours() ? "les" : "la") + "] LT" }, nextDay: function () { return "[demà a " + (1 !== this.hours() ? "les" : "la") + "] LT" }, nextWeek: function () { return "dddd [a " + (1 !== this.hours() ? "les" : "la") + "] LT" }, lastDay: function () { return "[ahir a " + (1 !== this.hours() ? "les" : "la") + "] LT" }, lastWeek: function () { return "[el] dddd [passat a " + (1 !== this.hours() ? "les" : "la") + "] LT" }, sameElse: "L" }, relativeTime: { future: "d'aquí %s", past: "fa %s", s: "uns segons", m: "un minut", mm: "%d minuts", h: "una hora", hh: "%d hores", d: "un dia", dd: "%d dies", M: "un mes", MM: "%d mesos", y: "un any", yy: "%d anys" }, dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/, ordinal: function (a, b) { var c = 1 === a ? "r" : 2 === a ? "n" : 3 === a ? "r" : 4 === a ? "t" : "è"; return "w" !== b && "W" !== b || (c = "a"), a + c }, week: { dow: 1, doy: 4 } });
    //! moment.js locale configuration
    //! locale : Czech [cs]
    //! author : petrbela : https://github.com/petrbela
    var Pg = "leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec".split("_"), Qg = "led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro".split("_"); a.defineLocale("cs", { months: Pg, monthsShort: Qg, monthsParse: function (a, b) { var c, d = []; for (c = 0; c < 12; c++)d[c] = new RegExp("^" + a[c] + "$|^" + b[c] + "$", "i"); return d }(Pg, Qg), shortMonthsParse: function (a) { var b, c = []; for (b = 0; b < 12; b++)c[b] = new RegExp("^" + a[b] + "$", "i"); return c }(Qg), longMonthsParse: function (a) { var b, c = []; for (b = 0; b < 12; b++)c[b] = new RegExp("^" + a[b] + "$", "i"); return c }(Pg), weekdays: "neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota".split("_"), weekdaysShort: "ne_po_út_st_čt_pá_so".split("_"), weekdaysMin: "ne_po_út_st_čt_pá_so".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd D. MMMM YYYY H:mm", l: "D. M. YYYY" }, calendar: { sameDay: "[dnes v] LT", nextDay: "[zítra v] LT", nextWeek: function () { switch (this.day()) { case 0: return "[v neděli v] LT"; case 1: case 2: return "[v] dddd [v] LT"; case 3: return "[ve středu v] LT"; case 4: return "[ve čtvrtek v] LT"; case 5: return "[v pátek v] LT"; case 6: return "[v sobotu v] LT" } }, lastDay: "[včera v] LT", lastWeek: function () { switch (this.day()) { case 0: return "[minulou neděli v] LT"; case 1: case 2: return "[minulé] dddd [v] LT"; case 3: return "[minulou středu v] LT"; case 4: case 5: return "[minulý] dddd [v] LT"; case 6: return "[minulou sobotu v] LT" } }, sameElse: "L" }, relativeTime: { future: "za %s", past: "před %s", s: Bd, m: Bd, mm: Bd, h: Bd, hh: Bd, d: Bd, dd: Bd, M: Bd, MM: Bd, y: Bd, yy: Bd }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Chuvash [cv]
        //! author : Anatoly Mironov : https://github.com/mirontoli
        a.defineLocale("cv", { months: "кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав".split("_"), monthsShort: "кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш".split("_"), weekdays: "вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун".split("_"), weekdaysShort: "выр_тун_ытл_юн_кӗҫ_эрн_шӑм".split("_"), weekdaysMin: "вр_тн_ыт_юн_кҫ_эр_шм".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD-MM-YYYY", LL: "YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]", LLL: "YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm", LLLL: "dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm" }, calendar: { sameDay: "[Паян] LT [сехетре]", nextDay: "[Ыран] LT [сехетре]", lastDay: "[Ӗнер] LT [сехетре]", nextWeek: "[Ҫитес] dddd LT [сехетре]", lastWeek: "[Иртнӗ] dddd LT [сехетре]", sameElse: "L" }, relativeTime: { future: function (a) { var b = /сехет$/i.exec(a) ? "рен" : /ҫул$/i.exec(a) ? "тан" : "ран"; return a + b }, past: "%s каялла", s: "пӗр-ик ҫеккунт", m: "пӗр минут", mm: "%d минут", h: "пӗр сехет", hh: "%d сехет", d: "пӗр кун", dd: "%d кун", M: "пӗр уйӑх", MM: "%d уйӑх", y: "пӗр ҫул", yy: "%d ҫул" }, dayOfMonthOrdinalParse: /\d{1,2}-мӗш/, ordinal: "%d-мӗш", week: { dow: 1, doy: 7 } }),
        //! moment.js locale configuration
        //! locale : Welsh [cy]
        //! author : Robert Allen : https://github.com/robgallen
        //! author : https://github.com/ryangreaves
        a.defineLocale("cy", { months: "Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split("_"), monthsShort: "Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split("_"), weekdays: "Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split("_"), weekdaysShort: "Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"), weekdaysMin: "Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Heddiw am] LT", nextDay: "[Yfory am] LT", nextWeek: "dddd [am] LT", lastDay: "[Ddoe am] LT", lastWeek: "dddd [diwethaf am] LT", sameElse: "L" }, relativeTime: { future: "mewn %s", past: "%s yn ôl", s: "ychydig eiliadau", m: "munud", mm: "%d munud", h: "awr", hh: "%d awr", d: "diwrnod", dd: "%d diwrnod", M: "mis", MM: "%d mis", y: "blwyddyn", yy: "%d flynedd" }, dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/, ordinal: function (a) { var b = a, c = "", d = ["", "af", "il", "ydd", "ydd", "ed", "ed", "ed", "fed", "fed", "fed", "eg", "fed", "eg", "eg", "fed", "eg", "eg", "fed", "eg", "fed"]; return b > 20 ? c = 40 === b || 50 === b || 60 === b || 80 === b || 100 === b ? "fed" : "ain" : b > 0 && (c = d[b]), a + c }, week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Danish [da]
        //! author : Ulrik Nielsen : https://github.com/mrbase
        a.defineLocale("da", { months: "januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"), monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"), weekdays: "søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag".split("_"), weekdaysShort: "søn_man_tir_ons_tor_fre_lør".split("_"), weekdaysMin: "sø_ma_ti_on_to_fr_lø".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd [d.] D. MMMM YYYY [kl.] HH:mm" }, calendar: { sameDay: "[i dag kl.] LT", nextDay: "[i morgen kl.] LT", nextWeek: "på dddd [kl.] LT", lastDay: "[i går kl.] LT", lastWeek: "[i] dddd[s kl.] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "%s siden", s: "få sekunder", m: "et minut", mm: "%d minutter", h: "en time", hh: "%d timer", d: "en dag", dd: "%d dage", M: "en måned", MM: "%d måneder", y: "et år", yy: "%d år" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } }), a.defineLocale("de-at", { months: "Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jän._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"), monthsParseExact: !0, weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"), weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"), weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd, D. MMMM YYYY HH:mm" }, calendar: { sameDay: "[heute um] LT [Uhr]", sameElse: "L", nextDay: "[morgen um] LT [Uhr]", nextWeek: "dddd [um] LT [Uhr]", lastDay: "[gestern um] LT [Uhr]", lastWeek: "[letzten] dddd [um] LT [Uhr]" }, relativeTime: { future: "in %s", past: "vor %s", s: "ein paar Sekunden", m: Cd, mm: "%d Minuten", h: Cd, hh: "%d Stunden", d: Cd, dd: Cd, M: Cd, MM: Cd, y: Cd, yy: Cd }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } }), a.defineLocale("de-ch", { months: "Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jan._Febr._März_April_Mai_Juni_Juli_Aug._Sept._Okt._Nov._Dez.".split("_"), monthsParseExact: !0, weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"), weekdaysShort: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH.mm", LLLL: "dddd, D. MMMM YYYY HH.mm" }, calendar: { sameDay: "[heute um] LT [Uhr]", sameElse: "L", nextDay: "[morgen um] LT [Uhr]", nextWeek: "dddd [um] LT [Uhr]", lastDay: "[gestern um] LT [Uhr]", lastWeek: "[letzten] dddd [um] LT [Uhr]" }, relativeTime: { future: "in %s", past: "vor %s", s: "ein paar Sekunden", m: Dd, mm: "%d Minuten", h: Dd, hh: "%d Stunden", d: Dd, dd: Dd, M: Dd, MM: Dd, y: Dd, yy: Dd }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } }), a.defineLocale("de", { months: "Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"), monthsParseExact: !0, weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"), weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"), weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd, D. MMMM YYYY HH:mm" }, calendar: { sameDay: "[heute um] LT [Uhr]", sameElse: "L", nextDay: "[morgen um] LT [Uhr]", nextWeek: "dddd [um] LT [Uhr]", lastDay: "[gestern um] LT [Uhr]", lastWeek: "[letzten] dddd [um] LT [Uhr]" }, relativeTime: { future: "in %s", past: "vor %s", s: "ein paar Sekunden", m: Ed, mm: "%d Minuten", h: Ed, hh: "%d Stunden", d: Ed, dd: Ed, M: Ed, MM: Ed, y: Ed, yy: Ed }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
    //! moment.js locale configuration
    //! locale : Maldivian [dv]
    //! author : Jawish Hameed : https://github.com/jawish
    var Rg = ["ޖެނުއަރީ", "ފެބްރުއަރީ", "މާރިޗު", "އޭޕްރީލު", "މޭ", "ޖޫން", "ޖުލައި", "އޯގަސްޓު", "ސެޕްޓެމްބަރު", "އޮކްޓޯބަރު", "ނޮވެމްބަރު", "ޑިސެމްބަރު"], Sg = ["އާދިއްތަ", "ހޯމަ", "އަންގާރަ", "ބުދަ", "ބުރާސްފަތި", "ހުކުރު", "ހޮނިހިރު"]; a.defineLocale("dv", { months: Rg, monthsShort: Rg, weekdays: Sg, weekdaysShort: Sg, weekdaysMin: "އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/M/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /މކ|މފ/, isPM: function (a) { return "މފ" === a }, meridiem: function (a, b, c) { return a < 12 ? "މކ" : "މފ" }, calendar: { sameDay: "[މިއަދު] LT", nextDay: "[މާދަމާ] LT", nextWeek: "dddd LT", lastDay: "[އިއްޔެ] LT", lastWeek: "[ފާއިތުވި] dddd LT", sameElse: "L" }, relativeTime: { future: "ތެރޭގައި %s", past: "ކުރިން %s", s: "ސިކުންތުކޮޅެއް", m: "މިނިޓެއް", mm: "މިނިޓު %d", h: "ގަޑިއިރެއް", hh: "ގަޑިއިރު %d", d: "ދުވަހެއް", dd: "ދުވަސް %d", M: "މަހެއް", MM: "މަސް %d", y: "އަހަރެއް", yy: "އަހަރު %d" }, preparse: function (a) { return a.replace(/،/g, ",") }, postformat: function (a) { return a.replace(/,/g, "،") }, week: { dow: 7, doy: 12 } }),
        //! moment.js locale configuration
        //! locale : Greek [el]
        //! author : Aggelos Karalias : https://github.com/mehiel
        a.defineLocale("el", { monthsNominativeEl: "Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος".split("_"), monthsGenitiveEl: "Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου".split("_"), months: function (a, b) { return a ? /D/.test(b.substring(0, b.indexOf("MMMM"))) ? this._monthsGenitiveEl[a.month()] : this._monthsNominativeEl[a.month()] : this._monthsNominativeEl }, monthsShort: "Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ".split("_"), weekdays: "Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο".split("_"), weekdaysShort: "Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ".split("_"), weekdaysMin: "Κυ_Δε_Τρ_Τε_Πε_Πα_Σα".split("_"), meridiem: function (a, b, c) { return a > 11 ? c ? "μμ" : "ΜΜ" : c ? "πμ" : "ΠΜ" }, isPM: function (a) { return "μ" === (a + "").toLowerCase()[0] }, meridiemParse: /[ΠΜ]\.?Μ?\.?/i, longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendarEl: { sameDay: "[Σήμερα {}] LT", nextDay: "[Αύριο {}] LT", nextWeek: "dddd [{}] LT", lastDay: "[Χθες {}] LT", lastWeek: function () { switch (this.day()) { case 6: return "[το προηγούμενο] dddd [{}] LT"; default: return "[την προηγούμενη] dddd [{}] LT" } }, sameElse: "L" }, calendar: function (a, b) { var c = this._calendarEl[a], d = b && b.hours(); return z(c) && (c = c.apply(b)), c.replace("{}", d % 12 === 1 ? "στη" : "στις") }, relativeTime: { future: "σε %s", past: "%s πριν", s: "λίγα δευτερόλεπτα", m: "ένα λεπτό", mm: "%d λεπτά", h: "μία ώρα", hh: "%d ώρες", d: "μία μέρα", dd: "%d μέρες", M: "ένας μήνας", MM: "%d μήνες", y: "ένας χρόνος", yy: "%d χρόνια" }, dayOfMonthOrdinalParse: /\d{1,2}η/, ordinal: "%dη", week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : English (Australia) [en-au]
        //! author : Jared Morse : https://github.com/jarcoal
        a.defineLocale("en-au", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function (a) { var b = a % 10, c = 1 === ~~(a % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th"; return a + c }, week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : English (Canada) [en-ca]
        //! author : Jonathan Abourbih : https://github.com/jonbca
        a.defineLocale("en-ca", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "YYYY-MM-DD", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function (a) { var b = a % 10, c = 1 === ~~(a % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th"; return a + c } }),
        //! moment.js locale configuration
        //! locale : English (United Kingdom) [en-gb]
        //! author : Chris Gedrim : https://github.com/chrisgedrim
        a.defineLocale("en-gb", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function (a) { var b = a % 10, c = 1 === ~~(a % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th"; return a + c }, week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : English (Ireland) [en-ie]
        //! author : Chris Cartlidge : https://github.com/chriscartlidge
        a.defineLocale("en-ie", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function (a) { var b = a % 10, c = 1 === ~~(a % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th"; return a + c }, week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : English (New Zealand) [en-nz]
        //! author : Luke McGregor : https://github.com/lukemcgregor
        a.defineLocale("en-nz", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function (a) { var b = a % 10, c = 1 === ~~(a % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th"; return a + c }, week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Esperanto [eo]
        //! author : Colin Dean : https://github.com/colindean
        //! author : Mia Nordentoft Imperatori : https://github.com/miestasmia
        //! comment : miestasmia corrected the translation by colindean
        a.defineLocale("eo", { months: "januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro".split("_"), monthsShort: "jan_feb_mar_apr_maj_jun_jul_aŭg_sep_okt_nov_dec".split("_"), weekdays: "dimanĉo_lundo_mardo_merkredo_ĵaŭdo_vendredo_sabato".split("_"), weekdaysShort: "dim_lun_mard_merk_ĵaŭ_ven_sab".split("_"), weekdaysMin: "di_lu_ma_me_ĵa_ve_sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "D[-a de] MMMM, YYYY", LLL: "D[-a de] MMMM, YYYY HH:mm", LLLL: "dddd, [la] D[-a de] MMMM, YYYY HH:mm" }, meridiemParse: /[ap]\.t\.m/i, isPM: function (a) { return "p" === a.charAt(0).toLowerCase() }, meridiem: function (a, b, c) { return a > 11 ? c ? "p.t.m." : "P.T.M." : c ? "a.t.m." : "A.T.M." }, calendar: { sameDay: "[Hodiaŭ je] LT", nextDay: "[Morgaŭ je] LT", nextWeek: "dddd [je] LT", lastDay: "[Hieraŭ je] LT", lastWeek: "[pasinta] dddd [je] LT", sameElse: "L" }, relativeTime: { future: "post %s", past: "antaŭ %s", s: "sekundoj", m: "minuto", mm: "%d minutoj", h: "horo", hh: "%d horoj", d: "tago", dd: "%d tagoj", M: "monato", MM: "%d monatoj", y: "jaro", yy: "%d jaroj" }, dayOfMonthOrdinalParse: /\d{1,2}a/, ordinal: "%da", week: { dow: 1, doy: 7 } });
    //! moment.js locale configuration
    //! locale : Spanish (Dominican Republic) [es-do]
    var Tg = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), Ug = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"); a.defineLocale("es-do", { months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"), monthsShort: function (a, b) { return a ? /-MMM-/.test(b) ? Ug[a.month()] : Tg[a.month()] : Tg }, monthsParseExact: !0, weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"), weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"), weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY h:mm A", LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A" }, calendar: { sameDay: function () { return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT" }, nextDay: function () { return "[mañana a la" + (1 !== this.hours() ? "s" : "") + "] LT" }, nextWeek: function () { return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT" }, lastDay: function () { return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT" }, lastWeek: function () { return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT" }, sameElse: "L" }, relativeTime: { future: "en %s", past: "hace %s", s: "unos segundos", m: "un minuto", mm: "%d minutos", h: "una hora", hh: "%d horas", d: "un día", dd: "%d días", M: "un mes", MM: "%d meses", y: "un año", yy: "%d años" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } });
    //! moment.js locale configuration
    //! locale : Spanish [es]
    //! author : Julio Napurí : https://github.com/julionc
    var Vg = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), Wg = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"); a.defineLocale("es", { months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"), monthsShort: function (a, b) { return a ? /-MMM-/.test(b) ? Wg[a.month()] : Vg[a.month()] : Vg }, monthsParseExact: !0, weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"), weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"), weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY H:mm", LLLL: "dddd, D [de] MMMM [de] YYYY H:mm" }, calendar: { sameDay: function () { return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT" }, nextDay: function () { return "[mañana a la" + (1 !== this.hours() ? "s" : "") + "] LT" }, nextWeek: function () { return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT" }, lastDay: function () { return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT" }, lastWeek: function () { return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT" }, sameElse: "L" }, relativeTime: { future: "en %s", past: "hace %s", s: "unos segundos", m: "un minuto", mm: "%d minutos", h: "una hora", hh: "%d horas", d: "un día", dd: "%d días", M: "un mes", MM: "%d meses", y: "un año", yy: "%d años" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } }), a.defineLocale("et", { months: "jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split("_"), monthsShort: "jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"), weekdays: "pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev".split("_"), weekdaysShort: "P_E_T_K_N_R_L".split("_"), weekdaysMin: "P_E_T_K_N_R_L".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" }, calendar: { sameDay: "[Täna,] LT", nextDay: "[Homme,] LT", nextWeek: "[Järgmine] dddd LT", lastDay: "[Eile,] LT", lastWeek: "[Eelmine] dddd LT", sameElse: "L" }, relativeTime: { future: "%s pärast", past: "%s tagasi", s: Fd, m: Fd, mm: Fd, h: Fd, hh: Fd, d: Fd, dd: "%d päeva", M: Fd, MM: Fd, y: Fd, yy: Fd }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Basque [eu]
        //! author : Eneko Illarramendi : https://github.com/eillarra
        a.defineLocale("eu", { months: "urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split("_"), monthsShort: "urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split("_"), monthsParseExact: !0, weekdays: "igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split("_"), weekdaysShort: "ig._al._ar._az._og._ol._lr.".split("_"), weekdaysMin: "ig_al_ar_az_og_ol_lr".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "YYYY[ko] MMMM[ren] D[a]", LLL: "YYYY[ko] MMMM[ren] D[a] HH:mm", LLLL: "dddd, YYYY[ko] MMMM[ren] D[a] HH:mm", l: "YYYY-M-D", ll: "YYYY[ko] MMM D[a]", lll: "YYYY[ko] MMM D[a] HH:mm", llll: "ddd, YYYY[ko] MMM D[a] HH:mm" }, calendar: { sameDay: "[gaur] LT[etan]", nextDay: "[bihar] LT[etan]", nextWeek: "dddd LT[etan]", lastDay: "[atzo] LT[etan]", lastWeek: "[aurreko] dddd LT[etan]", sameElse: "L" }, relativeTime: { future: "%s barru", past: "duela %s", s: "segundo batzuk", m: "minutu bat", mm: "%d minutu", h: "ordu bat", hh: "%d ordu", d: "egun bat", dd: "%d egun", M: "hilabete bat", MM: "%d hilabete", y: "urte bat", yy: "%d urte" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
    //! moment.js locale configuration
    //! locale : Persian [fa]
    //! author : Ebrahim Byagowi : https://github.com/ebraminio
    var Xg = { 1: "۱", 2: "۲", 3: "۳", 4: "۴", 5: "۵", 6: "۶", 7: "۷", 8: "۸", 9: "۹", 0: "۰" }, Yg = { "۱": "1", "۲": "2", "۳": "3", "۴": "4", "۵": "5", "۶": "6", "۷": "7", "۸": "8", "۹": "9", "۰": "0" }; a.defineLocale("fa", { months: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split("_"), monthsShort: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split("_"), weekdays: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split("_"), weekdaysShort: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split("_"), weekdaysMin: "ی_د_س_چ_پ_ج_ش".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, meridiemParse: /قبل از ظهر|بعد از ظهر/, isPM: function (a) { return /بعد از ظهر/.test(a) }, meridiem: function (a, b, c) { return a < 12 ? "قبل از ظهر" : "بعد از ظهر" }, calendar: { sameDay: "[امروز ساعت] LT", nextDay: "[فردا ساعت] LT", nextWeek: "dddd [ساعت] LT", lastDay: "[دیروز ساعت] LT", lastWeek: "dddd [پیش] [ساعت] LT", sameElse: "L" }, relativeTime: { future: "در %s", past: "%s پیش", s: "چند ثانیه", m: "یک دقیقه", mm: "%d دقیقه", h: "یک ساعت", hh: "%d ساعت", d: "یک روز", dd: "%d روز", M: "یک ماه", MM: "%d ماه", y: "یک سال", yy: "%d سال" }, preparse: function (a) { return a.replace(/[۰-۹]/g, function (a) { return Yg[a] }).replace(/،/g, ",") }, postformat: function (a) { return a.replace(/\d/g, function (a) { return Xg[a] }).replace(/,/g, "،") }, dayOfMonthOrdinalParse: /\d{1,2}م/, ordinal: "%dم", week: { dow: 6, doy: 12 } });
    //! moment.js locale configuration
    //! locale : Finnish [fi]
    //! author : Tarmo Aidantausta : https://github.com/bleadof
    var Zg = "nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän".split(" "), $g = ["nolla", "yhden", "kahden", "kolmen", "neljän", "viiden", "kuuden", Zg[7], Zg[8], Zg[9]]; a.defineLocale("fi", { months: "tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split("_"), monthsShort: "tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu".split("_"), weekdays: "sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split("_"), weekdaysShort: "su_ma_ti_ke_to_pe_la".split("_"), weekdaysMin: "su_ma_ti_ke_to_pe_la".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD.MM.YYYY", LL: "Do MMMM[ta] YYYY", LLL: "Do MMMM[ta] YYYY, [klo] HH.mm", LLLL: "dddd, Do MMMM[ta] YYYY, [klo] HH.mm", l: "D.M.YYYY", ll: "Do MMM YYYY", lll: "Do MMM YYYY, [klo] HH.mm", llll: "ddd, Do MMM YYYY, [klo] HH.mm" }, calendar: { sameDay: "[tänään] [klo] LT", nextDay: "[huomenna] [klo] LT", nextWeek: "dddd [klo] LT", lastDay: "[eilen] [klo] LT", lastWeek: "[viime] dddd[na] [klo] LT", sameElse: "L" }, relativeTime: { future: "%s päästä", past: "%s sitten", s: Gd, m: Gd, mm: Gd, h: Gd, hh: Gd, d: Gd, dd: Gd, M: Gd, MM: Gd, y: Gd, yy: Gd }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Faroese [fo]
        //! author : Ragnar Johannesen : https://github.com/ragnar123
        a.defineLocale("fo", { months: "januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember".split("_"), monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"), weekdays: "sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur".split("_"), weekdaysShort: "sun_mán_týs_mik_hós_frí_ley".split("_"), weekdaysMin: "su_má_tý_mi_hó_fr_le".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D. MMMM, YYYY HH:mm" }, calendar: { sameDay: "[Í dag kl.] LT", nextDay: "[Í morgin kl.] LT", nextWeek: "dddd [kl.] LT", lastDay: "[Í gjár kl.] LT", lastWeek: "[síðstu] dddd [kl] LT", sameElse: "L" }, relativeTime: { future: "um %s", past: "%s síðani", s: "fá sekund", m: "ein minutt", mm: "%d minuttir", h: "ein tími", hh: "%d tímar", d: "ein dagur", dd: "%d dagar", M: "ein mánaði", MM: "%d mánaðir", y: "eitt ár", yy: "%d ár" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : French (Canada) [fr-ca]
        //! author : Jonathan Abourbih : https://github.com/jonbca
        a.defineLocale("fr-ca", { months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"), monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"), monthsParseExact: !0, weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"), weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"), weekdaysMin: "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Aujourd’hui à] LT", nextDay: "[Demain à] LT", nextWeek: "dddd [à] LT", lastDay: "[Hier à] LT", lastWeek: "dddd [dernier à] LT", sameElse: "L" }, relativeTime: { future: "dans %s", past: "il y a %s", s: "quelques secondes", m: "une minute", mm: "%d minutes", h: "une heure", hh: "%d heures", d: "un jour", dd: "%d jours", M: "un mois", MM: "%d mois", y: "un an", yy: "%d ans" }, dayOfMonthOrdinalParse: /\d{1,2}(er|e)/, ordinal: function (a, b) { switch (b) { default: case "M": case "Q": case "D": case "DDD": case "d": return a + (1 === a ? "er" : "e"); case "w": case "W": return a + (1 === a ? "re" : "e") } } }),
        //! moment.js locale configuration
        //! locale : French (Switzerland) [fr-ch]
        //! author : Gaspard Bucher : https://github.com/gaspard
        a.defineLocale("fr-ch", { months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"), monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"), monthsParseExact: !0, weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"), weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"), weekdaysMin: "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Aujourd’hui à] LT", nextDay: "[Demain à] LT", nextWeek: "dddd [à] LT", lastDay: "[Hier à] LT", lastWeek: "dddd [dernier à] LT", sameElse: "L" }, relativeTime: { future: "dans %s", past: "il y a %s", s: "quelques secondes", m: "une minute", mm: "%d minutes", h: "une heure", hh: "%d heures", d: "un jour", dd: "%d jours", M: "un mois", MM: "%d mois", y: "un an", yy: "%d ans" }, dayOfMonthOrdinalParse: /\d{1,2}(er|e)/, ordinal: function (a, b) { switch (b) { default: case "M": case "Q": case "D": case "DDD": case "d": return a + (1 === a ? "er" : "e"); case "w": case "W": return a + (1 === a ? "re" : "e") } }, week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : French [fr]
        //! author : John Fischer : https://github.com/jfroffice
        a.defineLocale("fr", { months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"), monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"), monthsParseExact: !0, weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"), weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"), weekdaysMin: "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Aujourd’hui à] LT", nextDay: "[Demain à] LT", nextWeek: "dddd [à] LT", lastDay: "[Hier à] LT", lastWeek: "dddd [dernier à] LT", sameElse: "L" }, relativeTime: { future: "dans %s", past: "il y a %s", s: "quelques secondes", m: "une minute", mm: "%d minutes", h: "une heure", hh: "%d heures", d: "un jour", dd: "%d jours", M: "un mois", MM: "%d mois", y: "un an", yy: "%d ans" }, dayOfMonthOrdinalParse: /\d{1,2}(er|)/, ordinal: function (a, b) { switch (b) { case "D": return a + (1 === a ? "er" : ""); default: case "M": case "Q": case "DDD": case "d": return a + (1 === a ? "er" : "e"); case "w": case "W": return a + (1 === a ? "re" : "e") } }, week: { dow: 1, doy: 4 } });
    //! moment.js locale configuration
    //! locale : Frisian [fy]
    //! author : Robin van der Vliet : https://github.com/robin0van0der0v
    var _g = "jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.".split("_"), ah = "jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"); a.defineLocale("fy", { months: "jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber".split("_"), monthsShort: function (a, b) { return a ? /-MMM-/.test(b) ? ah[a.month()] : _g[a.month()] : _g }, monthsParseExact: !0, weekdays: "snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon".split("_"), weekdaysShort: "si._mo._ti._wo._to._fr._so.".split("_"), weekdaysMin: "Si_Mo_Ti_Wo_To_Fr_So".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[hjoed om] LT", nextDay: "[moarn om] LT", nextWeek: "dddd [om] LT", lastDay: "[juster om] LT", lastWeek: "[ôfrûne] dddd [om] LT", sameElse: "L" }, relativeTime: { future: "oer %s", past: "%s lyn", s: "in pear sekonden", m: "ien minút", mm: "%d minuten", h: "ien oere", hh: "%d oeren", d: "ien dei", dd: "%d dagen", M: "ien moanne", MM: "%d moannen", y: "ien jier", yy: "%d jierren" }, dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/, ordinal: function (a) { return a + (1 === a || 8 === a || a >= 20 ? "ste" : "de") }, week: { dow: 1, doy: 4 } });
    //! moment.js locale configuration
    //! locale : Scottish Gaelic [gd]
    //! author : Jon Ashdown : https://github.com/jonashdown
    var bh = ["Am Faoilleach", "An Gearran", "Am Màrt", "An Giblean", "An Cèitean", "An t-Ògmhios", "An t-Iuchar", "An Lùnastal", "An t-Sultain", "An Dàmhair", "An t-Samhain", "An Dùbhlachd"], ch = ["Faoi", "Gear", "Màrt", "Gibl", "Cèit", "Ògmh", "Iuch", "Lùn", "Sult", "Dàmh", "Samh", "Dùbh"], dh = ["Didòmhnaich", "Diluain", "Dimàirt", "Diciadain", "Diardaoin", "Dihaoine", "Disathairne"], eh = ["Did", "Dil", "Dim", "Dic", "Dia", "Dih", "Dis"], fh = ["Dò", "Lu", "Mà", "Ci", "Ar", "Ha", "Sa"]; a.defineLocale("gd", { months: bh, monthsShort: ch, monthsParseExact: !0, weekdays: dh, weekdaysShort: eh, weekdaysMin: fh, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[An-diugh aig] LT", nextDay: "[A-màireach aig] LT", nextWeek: "dddd [aig] LT", lastDay: "[An-dè aig] LT", lastWeek: "dddd [seo chaidh] [aig] LT", sameElse: "L" }, relativeTime: { future: "ann an %s", past: "bho chionn %s", s: "beagan diogan", m: "mionaid", mm: "%d mionaidean", h: "uair", hh: "%d uairean", d: "latha", dd: "%d latha", M: "mìos", MM: "%d mìosan", y: "bliadhna", yy: "%d bliadhna" }, dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/, ordinal: function (a) { var b = 1 === a ? "d" : a % 10 === 2 ? "na" : "mh"; return a + b }, week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Galician [gl]
        //! author : Juan G. Hurtado : https://github.com/juanghurtado
        a.defineLocale("gl", { months: "xaneiro_febreiro_marzo_abril_maio_xuño_xullo_agosto_setembro_outubro_novembro_decembro".split("_"), monthsShort: "xan._feb._mar._abr._mai._xuñ._xul._ago._set._out._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "domingo_luns_martes_mércores_xoves_venres_sábado".split("_"), weekdaysShort: "dom._lun._mar._mér._xov._ven._sáb.".split("_"), weekdaysMin: "do_lu_ma_mé_xo_ve_sá".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY H:mm", LLLL: "dddd, D [de] MMMM [de] YYYY H:mm" }, calendar: { sameDay: function () { return "[hoxe " + (1 !== this.hours() ? "ás" : "á") + "] LT" }, nextDay: function () { return "[mañá " + (1 !== this.hours() ? "ás" : "á") + "] LT" }, nextWeek: function () { return "dddd [" + (1 !== this.hours() ? "ás" : "a") + "] LT" }, lastDay: function () { return "[onte " + (1 !== this.hours() ? "á" : "a") + "] LT" }, lastWeek: function () { return "[o] dddd [pasado " + (1 !== this.hours() ? "ás" : "a") + "] LT" }, sameElse: "L" }, relativeTime: { future: function (a) { return 0 === a.indexOf("un") ? "n" + a : "en " + a }, past: "hai %s", s: "uns segundos", m: "un minuto", mm: "%d minutos", h: "unha hora", hh: "%d horas", d: "un día", dd: "%d días", M: "un mes", MM: "%d meses", y: "un ano", yy: "%d anos" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } }), a.defineLocale("gom-latn", { months: "Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr".split("_"), monthsShort: "Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.".split("_"), monthsParseExact: !0, weekdays: "Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son'var".split("_"), weekdaysShort: "Ait._Som._Mon._Bud._Bre._Suk._Son.".split("_"), weekdaysMin: "Ai_Sm_Mo_Bu_Br_Su_Sn".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "A h:mm [vazta]", LTS: "A h:mm:ss [vazta]", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY A h:mm [vazta]", LLLL: "dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]", llll: "ddd, D MMM YYYY, A h:mm [vazta]" }, calendar: { sameDay: "[Aiz] LT", nextDay: "[Faleam] LT", nextWeek: "[Ieta to] dddd[,] LT", lastDay: "[Kal] LT", lastWeek: "[Fatlo] dddd[,] LT", sameElse: "L" }, relativeTime: { future: "%s", past: "%s adim", s: Id, m: Id, mm: Id, h: Id, hh: Id, d: Id, dd: Id, M: Id, MM: Id, y: Id, yy: Id }, dayOfMonthOrdinalParse: /\d{1,2}(er)/, ordinal: function (a, b) { switch (b) { case "D": return a + "er"; default: case "M": case "Q": case "DDD": case "d": case "w": case "W": return a } }, week: { dow: 1, doy: 4 }, meridiemParse: /rati|sokalli|donparam|sanje/, meridiemHour: function (a, b) { return 12 === a && (a = 0), "rati" === b ? a < 4 ? a : a + 12 : "sokalli" === b ? a : "donparam" === b ? a > 12 ? a : a + 12 : "sanje" === b ? a + 12 : void 0 }, meridiem: function (a, b, c) { return a < 4 ? "rati" : a < 12 ? "sokalli" : a < 16 ? "donparam" : a < 20 ? "sanje" : "rati" } }),
        //! moment.js locale configuration
        //! locale : Hebrew [he]
        //! author : Tomer Cohen : https://github.com/tomer
        //! author : Moshe Simantov : https://github.com/DevelopmentIL
        //! author : Tal Ater : https://github.com/TalAter
        a.defineLocale("he", { months: "ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר".split("_"), monthsShort: "ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳".split("_"), weekdays: "ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת".split("_"), weekdaysShort: "א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳".split("_"), weekdaysMin: "א_ב_ג_ד_ה_ו_ש".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [ב]MMMM YYYY", LLL: "D [ב]MMMM YYYY HH:mm", LLLL: "dddd, D [ב]MMMM YYYY HH:mm", l: "D/M/YYYY", ll: "D MMM YYYY", lll: "D MMM YYYY HH:mm", llll: "ddd, D MMM YYYY HH:mm" }, calendar: { sameDay: "[היום ב־]LT", nextDay: "[מחר ב־]LT", nextWeek: "dddd [בשעה] LT", lastDay: "[אתמול ב־]LT", lastWeek: "[ביום] dddd [האחרון בשעה] LT", sameElse: "L" }, relativeTime: { future: "בעוד %s", past: "לפני %s", s: "מספר שניות", m: "דקה", mm: "%d דקות", h: "שעה", hh: function (a) { return 2 === a ? "שעתיים" : a + " שעות" }, d: "יום", dd: function (a) { return 2 === a ? "יומיים" : a + " ימים" }, M: "חודש", MM: function (a) { return 2 === a ? "חודשיים" : a + " חודשים" }, y: "שנה", yy: function (a) { return 2 === a ? "שנתיים" : a % 10 === 0 && 10 !== a ? a + " שנה" : a + " שנים" } }, meridiemParse: /אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i, isPM: function (a) { return /^(אחה"צ|אחרי הצהריים|בערב)$/.test(a) }, meridiem: function (a, b, c) { return a < 5 ? "לפנות בוקר" : a < 10 ? "בבוקר" : a < 12 ? c ? 'לפנה"צ' : "לפני הצהריים" : a < 18 ? c ? 'אחה"צ' : "אחרי הצהריים" : "בערב" } });
    //! moment.js locale configuration
    //! locale : Hindi [hi]
    //! author : Mayank Singhal : https://github.com/mayanksinghal
    var gh = { 1: "१", 2: "२", 3: "३", 4: "४", 5: "५", 6: "६", 7: "७", 8: "८", 9: "९", 0: "०" }, hh = { "१": "1", "२": "2", "३": "3", "४": "4", "५": "5", "६": "6", "७": "7", "८": "8", "९": "9", "०": "0" }; a.defineLocale("hi", { months: "जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर".split("_"), monthsShort: "जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.".split("_"), monthsParseExact: !0, weekdays: "रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार".split("_"), weekdaysShort: "रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि".split("_"), weekdaysMin: "र_सो_मं_बु_गु_शु_श".split("_"), longDateFormat: { LT: "A h:mm बजे", LTS: "A h:mm:ss बजे", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm बजे", LLLL: "dddd, D MMMM YYYY, A h:mm बजे" }, calendar: { sameDay: "[आज] LT", nextDay: "[कल] LT", nextWeek: "dddd, LT", lastDay: "[कल] LT", lastWeek: "[पिछले] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s में", past: "%s पहले", s: "कुछ ही क्षण", m: "एक मिनट", mm: "%d मिनट", h: "एक घंटा", hh: "%d घंटे", d: "एक दिन", dd: "%d दिन", M: "एक महीने", MM: "%d महीने", y: "एक वर्ष", yy: "%d वर्ष" }, preparse: function (a) { return a.replace(/[१२३४५६७८९०]/g, function (a) { return hh[a] }) }, postformat: function (a) { return a.replace(/\d/g, function (a) { return gh[a] }) }, meridiemParse: /रात|सुबह|दोपहर|शाम/, meridiemHour: function (a, b) { return 12 === a && (a = 0), "रात" === b ? a < 4 ? a : a + 12 : "सुबह" === b ? a : "दोपहर" === b ? a >= 10 ? a : a + 12 : "शाम" === b ? a + 12 : void 0 }, meridiem: function (a, b, c) { return a < 4 ? "रात" : a < 10 ? "सुबह" : a < 17 ? "दोपहर" : a < 20 ? "शाम" : "रात" }, week: { dow: 0, doy: 6 } }), a.defineLocale("hr", { months: { format: "siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca".split("_"), standalone: "siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split("_") }, monthsShort: "sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split("_"), monthsParseExact: !0, weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"), weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"), weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" }, calendar: { sameDay: "[danas u] LT", nextDay: "[sutra u] LT", nextWeek: function () { switch (this.day()) { case 0: return "[u] [nedjelju] [u] LT"; case 3: return "[u] [srijedu] [u] LT"; case 6: return "[u] [subotu] [u] LT"; case 1: case 2: case 4: case 5: return "[u] dddd [u] LT" } }, lastDay: "[jučer u] LT", lastWeek: function () { switch (this.day()) { case 0: case 3: return "[prošlu] dddd [u] LT"; case 6: return "[prošle] [subote] [u] LT"; case 1: case 2: case 4: case 5: return "[prošli] dddd [u] LT" } }, sameElse: "L" }, relativeTime: { future: "za %s", past: "prije %s", s: "par sekundi", m: Jd, mm: Jd, h: Jd, hh: Jd, d: "dan", dd: Jd, M: "mjesec", MM: Jd, y: "godinu", yy: Jd }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
    //! moment.js locale configuration
    //! locale : Hungarian [hu]
    //! author : Adam Brunner : https://github.com/adambrunner
    var ih = "vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton".split(" "); a.defineLocale("hu", { months: "január_február_március_április_május_június_július_augusztus_szeptember_október_november_december".split("_"), monthsShort: "jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec".split("_"), weekdays: "vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat".split("_"), weekdaysShort: "vas_hét_kedd_sze_csüt_pén_szo".split("_"), weekdaysMin: "v_h_k_sze_cs_p_szo".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "YYYY.MM.DD.", LL: "YYYY. MMMM D.", LLL: "YYYY. MMMM D. H:mm", LLLL: "YYYY. MMMM D., dddd H:mm" }, meridiemParse: /de|du/i, isPM: function (a) { return "u" === a.charAt(1).toLowerCase() }, meridiem: function (a, b, c) { return a < 12 ? c === !0 ? "de" : "DE" : c === !0 ? "du" : "DU" }, calendar: { sameDay: "[ma] LT[-kor]", nextDay: "[holnap] LT[-kor]", nextWeek: function () { return Ld.call(this, !0) }, lastDay: "[tegnap] LT[-kor]", lastWeek: function () { return Ld.call(this, !1) }, sameElse: "L" }, relativeTime: { future: "%s múlva", past: "%s", s: Kd, m: Kd, mm: Kd, h: Kd, hh: Kd, d: Kd, dd: Kd, M: Kd, MM: Kd, y: Kd, yy: Kd }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Armenian [hy-am]
        //! author : Armendarabyan : https://github.com/armendarabyan
        a.defineLocale("hy-am", { months: { format: "հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի".split("_"), standalone: "հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր".split("_") }, monthsShort: "հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ".split("_"), weekdays: "կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ".split("_"), weekdaysShort: "կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ".split("_"), weekdaysMin: "կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY թ.", LLL: "D MMMM YYYY թ., HH:mm", LLLL: "dddd, D MMMM YYYY թ., HH:mm" }, calendar: { sameDay: "[այսօր] LT", nextDay: "[վաղը] LT", lastDay: "[երեկ] LT", nextWeek: function () { return "dddd [օրը ժամը] LT" }, lastWeek: function () { return "[անցած] dddd [օրը ժամը] LT" }, sameElse: "L" }, relativeTime: { future: "%s հետո", past: "%s առաջ", s: "մի քանի վայրկյան", m: "րոպե", mm: "%d րոպե", h: "ժամ", hh: "%d ժամ", d: "օր", dd: "%d օր", M: "ամիս", MM: "%d ամիս", y: "տարի", yy: "%d տարի" }, meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/, isPM: function (a) { return /^(ցերեկվա|երեկոյան)$/.test(a) }, meridiem: function (a) { return a < 4 ? "գիշերվա" : a < 12 ? "առավոտվա" : a < 17 ? "ցերեկվա" : "երեկոյան" }, dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/, ordinal: function (a, b) { switch (b) { case "DDD": case "w": case "W": case "DDDo": return 1 === a ? a + "-ին" : a + "-րդ"; default: return a } }, week: { dow: 1, doy: 7 } }),
        //! moment.js locale configuration
        //! locale : Indonesian [id]
        //! author : Mohammad Satrio Utomo : https://github.com/tyok
        //! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan
        a.defineLocale("id", { months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"), monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des".split("_"), weekdays: "Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"), weekdaysShort: "Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"), weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" }, meridiemParse: /pagi|siang|sore|malam/, meridiemHour: function (a, b) { return 12 === a && (a = 0), "pagi" === b ? a : "siang" === b ? a >= 11 ? a : a + 12 : "sore" === b || "malam" === b ? a + 12 : void 0 }, meridiem: function (a, b, c) { return a < 11 ? "pagi" : a < 15 ? "siang" : a < 19 ? "sore" : "malam" }, calendar: { sameDay: "[Hari ini pukul] LT", nextDay: "[Besok pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kemarin pukul] LT", lastWeek: "dddd [lalu pukul] LT", sameElse: "L" }, relativeTime: { future: "dalam %s", past: "%s yang lalu", s: "beberapa detik", m: "semenit", mm: "%d menit", h: "sejam", hh: "%d jam", d: "sehari", dd: "%d hari", M: "sebulan", MM: "%d bulan", y: "setahun", yy: "%d tahun" }, week: { dow: 1, doy: 7 } }), a.defineLocale("is", { months: "janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember".split("_"), monthsShort: "jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des".split("_"), weekdays: "sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur".split("_"), weekdaysShort: "sun_mán_þri_mið_fim_fös_lau".split("_"), weekdaysMin: "Su_Má_Þr_Mi_Fi_Fö_La".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY [kl.] H:mm", LLLL: "dddd, D. MMMM YYYY [kl.] H:mm" }, calendar: { sameDay: "[í dag kl.] LT", nextDay: "[á morgun kl.] LT", nextWeek: "dddd [kl.] LT", lastDay: "[í gær kl.] LT", lastWeek: "[síðasta] dddd [kl.] LT", sameElse: "L" }, relativeTime: { future: "eftir %s", past: "fyrir %s síðan", s: Nd, m: Nd, mm: Nd, h: "klukkustund", hh: Nd, d: Nd, dd: Nd, M: Nd, MM: Nd, y: Nd, yy: Nd }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Italian [it]
        //! author : Lorenzo : https://github.com/aliem
        //! author: Mattia Larentis: https://github.com/nostalgiaz
        a.defineLocale("it", { months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"), monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"), weekdays: "domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato".split("_"), weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"), weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Oggi alle] LT", nextDay: "[Domani alle] LT", nextWeek: "dddd [alle] LT", lastDay: "[Ieri alle] LT", lastWeek: function () { switch (this.day()) { case 0: return "[la scorsa] dddd [alle] LT"; default: return "[lo scorso] dddd [alle] LT" } }, sameElse: "L" }, relativeTime: { future: function (a) { return (/^[0-9].+$/.test(a) ? "tra" : "in") + " " + a }, past: "%s fa", s: "alcuni secondi", m: "un minuto", mm: "%d minuti", h: "un'ora", hh: "%d ore", d: "un giorno", dd: "%d giorni", M: "un mese", MM: "%d mesi", y: "un anno", yy: "%d anni" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Japanese [ja]
        //! author : LI Long : https://github.com/baryon
        a.defineLocale("ja", { months: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), weekdays: "日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日".split("_"), weekdaysShort: "日_月_火_水_木_金_土".split("_"), weekdaysMin: "日_月_火_水_木_金_土".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYY年M月D日", LLL: "YYYY年M月D日 HH:mm", LLLL: "YYYY年M月D日 HH:mm dddd", l: "YYYY/MM/DD", ll: "YYYY年M月D日", lll: "YYYY年M月D日 HH:mm", llll: "YYYY年M月D日 HH:mm dddd" }, meridiemParse: /午前|午後/i, isPM: function (a) { return "午後" === a }, meridiem: function (a, b, c) { return a < 12 ? "午前" : "午後" }, calendar: { sameDay: "[今日] LT", nextDay: "[明日] LT", nextWeek: "[来週]dddd LT", lastDay: "[昨日] LT", lastWeek: "[前週]dddd LT", sameElse: "L" }, dayOfMonthOrdinalParse: /\d{1,2}日/, ordinal: function (a, b) { switch (b) { case "d": case "D": case "DDD": return a + "日"; default: return a } }, relativeTime: { future: "%s後", past: "%s前", s: "数秒", m: "1分", mm: "%d分", h: "1時間", hh: "%d時間", d: "1日", dd: "%d日", M: "1ヶ月", MM: "%dヶ月", y: "1年", yy: "%d年" } }),
        //! moment.js locale configuration
        //! locale : Javanese [jv]
        //! author : Rony Lantip : https://github.com/lantip
        //! reference: http://jv.wikipedia.org/wiki/Basa_Jawa
        a.defineLocale("jv", { months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember".split("_"), monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des".split("_"), weekdays: "Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu".split("_"), weekdaysShort: "Min_Sen_Sel_Reb_Kem_Jem_Sep".split("_"), weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sp".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" }, meridiemParse: /enjing|siyang|sonten|ndalu/, meridiemHour: function (a, b) { return 12 === a && (a = 0), "enjing" === b ? a : "siyang" === b ? a >= 11 ? a : a + 12 : "sonten" === b || "ndalu" === b ? a + 12 : void 0 }, meridiem: function (a, b, c) { return a < 11 ? "enjing" : a < 15 ? "siyang" : a < 19 ? "sonten" : "ndalu" }, calendar: { sameDay: "[Dinten puniko pukul] LT", nextDay: "[Mbenjang pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kala wingi pukul] LT", lastWeek: "dddd [kepengker pukul] LT", sameElse: "L" }, relativeTime: { future: "wonten ing %s", past: "%s ingkang kepengker", s: "sawetawis detik", m: "setunggal menit", mm: "%d menit", h: "setunggal jam", hh: "%d jam", d: "sedinten", dd: "%d dinten", M: "sewulan", MM: "%d wulan", y: "setaun", yy: "%d taun" }, week: { dow: 1, doy: 7 } }),
        //! moment.js locale configuration
        //! locale : Georgian [ka]
        //! author : Irakli Janiashvili : https://github.com/irakli-janiashvili
        a.defineLocale("ka", { months: { standalone: "იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი".split("_"), format: "იანვარს_თებერვალს_მარტს_აპრილის_მაისს_ივნისს_ივლისს_აგვისტს_სექტემბერს_ოქტომბერს_ნოემბერს_დეკემბერს".split("_") }, monthsShort: "იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ".split("_"), weekdays: { standalone: "კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი".split("_"), format: "კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს".split("_"), isFormat: /(წინა|შემდეგ)/ }, weekdaysShort: "კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ".split("_"), weekdaysMin: "კვ_ორ_სა_ოთ_ხუ_პა_შა".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[დღეს] LT[-ზე]", nextDay: "[ხვალ] LT[-ზე]", lastDay: "[გუშინ] LT[-ზე]", nextWeek: "[შემდეგ] dddd LT[-ზე]", lastWeek: "[წინა] dddd LT-ზე", sameElse: "L" }, relativeTime: { future: function (a) { return /(წამი|წუთი|საათი|წელი)/.test(a) ? a.replace(/ი$/, "ში") : a + "ში" }, past: function (a) { return /(წამი|წუთი|საათი|დღე|თვე)/.test(a) ? a.replace(/(ი|ე)$/, "ის უკან") : /წელი/.test(a) ? a.replace(/წელი$/, "წლის უკან") : void 0 }, s: "რამდენიმე წამი", m: "წუთი", mm: "%d წუთი", h: "საათი", hh: "%d საათი", d: "დღე", dd: "%d დღე", M: "თვე", MM: "%d თვე", y: "წელი", yy: "%d წელი" }, dayOfMonthOrdinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/, ordinal: function (a) { return 0 === a ? a : 1 === a ? a + "-ლი" : a < 20 || a <= 100 && a % 20 === 0 || a % 100 === 0 ? "მე-" + a : a + "-ე" }, week: { dow: 1, doy: 7 } });
    //! moment.js locale configuration
    //! locale : Kazakh [kk]
    //! authors : Nurlan Rakhimzhanov : https://github.com/nurlan
    var jh = { 0: "-ші", 1: "-ші", 2: "-ші", 3: "-ші", 4: "-ші", 5: "-ші", 6: "-шы", 7: "-ші", 8: "-ші", 9: "-шы", 10: "-шы", 20: "-шы", 30: "-шы", 40: "-шы", 50: "-ші", 60: "-шы", 70: "-ші", 80: "-ші", 90: "-шы", 100: "-ші" }; a.defineLocale("kk", { months: "қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан".split("_"), monthsShort: "қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел".split("_"), weekdays: "жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі".split("_"), weekdaysShort: "жек_дүй_сей_сәр_бей_жұм_сен".split("_"), weekdaysMin: "жк_дй_сй_ср_бй_жм_сн".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Бүгін сағат] LT", nextDay: "[Ертең сағат] LT", nextWeek: "dddd [сағат] LT", lastDay: "[Кеше сағат] LT", lastWeek: "[Өткен аптаның] dddd [сағат] LT", sameElse: "L" }, relativeTime: { future: "%s ішінде", past: "%s бұрын", s: "бірнеше секунд", m: "бір минут", mm: "%d минут", h: "бір сағат", hh: "%d сағат", d: "бір күн", dd: "%d күн", M: "бір ай", MM: "%d ай", y: "бір жыл", yy: "%d жыл" }, dayOfMonthOrdinalParse: /\d{1,2}-(ші|шы)/, ordinal: function (a) { var b = a % 10, c = a >= 100 ? 100 : null; return a + (jh[a] || jh[b] || jh[c]) }, week: { dow: 1, doy: 7 } }),
        //! moment.js locale configuration
        //! locale : Cambodian [km]
        //! author : Kruy Vanna : https://github.com/kruyvanna
        a.defineLocale("km", { months: "មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ".split("_"), monthsShort: "មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ".split("_"), weekdays: "អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍".split("_"), weekdaysShort: "អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍".split("_"), weekdaysMin: "អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[ថ្ងៃនេះ ម៉ោង] LT", nextDay: "[ស្អែក ម៉ោង] LT", nextWeek: "dddd [ម៉ោង] LT", lastDay: "[ម្សិលមិញ ម៉ោង] LT", lastWeek: "dddd [សប្តាហ៍មុន] [ម៉ោង] LT", sameElse: "L" }, relativeTime: { future: "%sទៀត", past: "%sមុន", s: "ប៉ុន្មានវិនាទី", m: "មួយនាទី", mm: "%d នាទី", h: "មួយម៉ោង", hh: "%d ម៉ោង", d: "មួយថ្ងៃ", dd: "%d ថ្ងៃ", M: "មួយខែ", MM: "%d ខែ", y: "មួយឆ្នាំ", yy: "%d ឆ្នាំ" }, week: { dow: 1, doy: 4 } });
    //! moment.js locale configuration
    //! locale : Kannada [kn]
    //! author : Rajeev Naik : https://github.com/rajeevnaikte
    var kh = { 1: "೧", 2: "೨", 3: "೩", 4: "೪", 5: "೫", 6: "೬", 7: "೭", 8: "೮", 9: "೯", 0: "೦" }, lh = { "೧": "1", "೨": "2", "೩": "3", "೪": "4", "೫": "5", "೬": "6", "೭": "7", "೮": "8", "೯": "9", "೦": "0" }; a.defineLocale("kn", { months: "ಜನವರಿ_ಫೆಬ್ರವರಿ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬರ್_ಅಕ್ಟೋಬರ್_ನವೆಂಬರ್_ಡಿಸೆಂಬರ್".split("_"), monthsShort: "ಜನ_ಫೆಬ್ರ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬ_ಅಕ್ಟೋಬ_ನವೆಂಬ_ಡಿಸೆಂಬ".split("_"), monthsParseExact: !0, weekdays: "ಭಾನುವಾರ_ಸೋಮವಾರ_ಮಂಗಳವಾರ_ಬುಧವಾರ_ಗುರುವಾರ_ಶುಕ್ರವಾರ_ಶನಿವಾರ".split("_"), weekdaysShort: "ಭಾನು_ಸೋಮ_ಮಂಗಳ_ಬುಧ_ಗುರು_ಶುಕ್ರ_ಶನಿ".split("_"), weekdaysMin: "ಭಾ_ಸೋ_ಮಂ_ಬು_ಗು_ಶು_ಶ".split("_"), longDateFormat: { LT: "A h:mm", LTS: "A h:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm", LLLL: "dddd, D MMMM YYYY, A h:mm" }, calendar: { sameDay: "[ಇಂದು] LT", nextDay: "[ನಾಳೆ] LT", nextWeek: "dddd, LT", lastDay: "[ನಿನ್ನೆ] LT", lastWeek: "[ಕೊನೆಯ] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s ನಂತರ", past: "%s ಹಿಂದೆ", s: "ಕೆಲವು ಕ್ಷಣಗಳು", m: "ಒಂದು ನಿಮಿಷ", mm: "%d ನಿಮಿಷ", h: "ಒಂದು ಗಂಟೆ", hh: "%d ಗಂಟೆ", d: "ಒಂದು ದಿನ", dd: "%d ದಿನ", M: "ಒಂದು ತಿಂಗಳು", MM: "%d ತಿಂಗಳು", y: "ಒಂದು ವರ್ಷ", yy: "%d ವರ್ಷ" }, preparse: function (a) { return a.replace(/[೧೨೩೪೫೬೭೮೯೦]/g, function (a) { return lh[a] }) }, postformat: function (a) { return a.replace(/\d/g, function (a) { return kh[a] }) }, meridiemParse: /ರಾತ್ರಿ|ಬೆಳಿಗ್ಗೆ|ಮಧ್ಯಾಹ್ನ|ಸಂಜೆ/, meridiemHour: function (a, b) { return 12 === a && (a = 0), "ರಾತ್ರಿ" === b ? a < 4 ? a : a + 12 : "ಬೆಳಿಗ್ಗೆ" === b ? a : "ಮಧ್ಯಾಹ್ನ" === b ? a >= 10 ? a : a + 12 : "ಸಂಜೆ" === b ? a + 12 : void 0 }, meridiem: function (a, b, c) { return a < 4 ? "ರಾತ್ರಿ" : a < 10 ? "ಬೆಳಿಗ್ಗೆ" : a < 17 ? "ಮಧ್ಯಾಹ್ನ" : a < 20 ? "ಸಂಜೆ" : "ರಾತ್ರಿ" }, dayOfMonthOrdinalParse: /\d{1,2}(ನೇ)/, ordinal: function (a) { return a + "ನೇ" }, week: { dow: 0, doy: 6 } }),
        //! moment.js locale configuration
        //! locale : Korean [ko]
        //! author : Kyungwook, Park : https://github.com/kyungw00k
        //! author : Jeeeyul Lee <jeeeyul@gmail.com>
        a.defineLocale("ko", { months: "1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월".split("_"), monthsShort: "1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월".split("_"), weekdays: "일요일_월요일_화요일_수요일_목요일_금요일_토요일".split("_"), weekdaysShort: "일_월_화_수_목_금_토".split("_"), weekdaysMin: "일_월_화_수_목_금_토".split("_"), longDateFormat: { LT: "A h:mm", LTS: "A h:mm:ss", L: "YYYY.MM.DD", LL: "YYYY년 MMMM D일", LLL: "YYYY년 MMMM D일 A h:mm", LLLL: "YYYY년 MMMM D일 dddd A h:mm", l: "YYYY.MM.DD", ll: "YYYY년 MMMM D일", lll: "YYYY년 MMMM D일 A h:mm", llll: "YYYY년 MMMM D일 dddd A h:mm" }, calendar: { sameDay: "오늘 LT", nextDay: "내일 LT", nextWeek: "dddd LT", lastDay: "어제 LT", lastWeek: "지난주 dddd LT", sameElse: "L" }, relativeTime: { future: "%s 후", past: "%s 전", s: "몇 초", ss: "%d초", m: "1분", mm: "%d분", h: "한 시간", hh: "%d시간", d: "하루", dd: "%d일", M: "한 달", MM: "%d달", y: "일 년", yy: "%d년" }, dayOfMonthOrdinalParse: /\d{1,2}일/, ordinal: "%d일", meridiemParse: /오전|오후/, isPM: function (a) { return "오후" === a }, meridiem: function (a, b, c) { return a < 12 ? "오전" : "오후" } });
    //! moment.js locale configuration
    //! locale : Kyrgyz [ky]
    //! author : Chyngyz Arystan uulu : https://github.com/chyngyz
    var mh = { 0: "-чү", 1: "-чи", 2: "-чи", 3: "-чү", 4: "-чү", 5: "-чи", 6: "-чы", 7: "-чи", 8: "-чи", 9: "-чу", 10: "-чу", 20: "-чы", 30: "-чу", 40: "-чы", 50: "-чү", 60: "-чы", 70: "-чи", 80: "-чи", 90: "-чу", 100: "-чү" }; a.defineLocale("ky", { months: "январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь".split("_"), monthsShort: "янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек".split("_"), weekdays: "Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби".split("_"), weekdaysShort: "Жек_Дүй_Шей_Шар_Бей_Жум_Ише".split("_"), weekdaysMin: "Жк_Дй_Шй_Шр_Бй_Жм_Иш".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Бүгүн саат] LT", nextDay: "[Эртең саат] LT", nextWeek: "dddd [саат] LT", lastDay: "[Кече саат] LT", lastWeek: "[Өткен аптанын] dddd [күнү] [саат] LT", sameElse: "L" }, relativeTime: { future: "%s ичинде", past: "%s мурун", s: "бирнече секунд", m: "бир мүнөт", mm: "%d мүнөт", h: "бир саат", hh: "%d саат", d: "бир күн", dd: "%d күн", M: "бир ай", MM: "%d ай", y: "бир жыл", yy: "%d жыл" }, dayOfMonthOrdinalParse: /\d{1,2}-(чи|чы|чү|чу)/, ordinal: function (a) { var b = a % 10, c = a >= 100 ? 100 : null; return a + (mh[a] || mh[b] || mh[c]) }, week: { dow: 1, doy: 7 } }), a.defineLocale("lb", { months: "Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"), monthsParseExact: !0, weekdays: "Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg".split("_"), weekdaysShort: "So._Mé._Dë._Më._Do._Fr._Sa.".split("_"), weekdaysMin: "So_Mé_Dë_Më_Do_Fr_Sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm [Auer]", LTS: "H:mm:ss [Auer]", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm [Auer]", LLLL: "dddd, D. MMMM YYYY H:mm [Auer]" }, calendar: { sameDay: "[Haut um] LT", sameElse: "L", nextDay: "[Muer um] LT", nextWeek: "dddd [um] LT", lastDay: "[Gëschter um] LT", lastWeek: function () { switch (this.day()) { case 2: case 4: return "[Leschten] dddd [um] LT"; default: return "[Leschte] dddd [um] LT" } } }, relativeTime: { future: Pd, past: Qd, s: "e puer Sekonnen", m: Od, mm: "%d Minutten", h: Od, hh: "%d Stonnen", d: Od, dd: "%d Deeg", M: Od, MM: "%d Méint", y: Od, yy: "%d Joer" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Lao [lo]
        //! author : Ryan Hart : https://github.com/ryanhart2
        a.defineLocale("lo", { months: "ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ".split("_"), monthsShort: "ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ".split("_"), weekdays: "ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ".split("_"), weekdaysShort: "ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ".split("_"), weekdaysMin: "ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "ວັນdddd D MMMM YYYY HH:mm" }, meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/, isPM: function (a) { return "ຕອນແລງ" === a }, meridiem: function (a, b, c) { return a < 12 ? "ຕອນເຊົ້າ" : "ຕອນແລງ" }, calendar: { sameDay: "[ມື້ນີ້ເວລາ] LT", nextDay: "[ມື້ອື່ນເວລາ] LT", nextWeek: "[ວັນ]dddd[ໜ້າເວລາ] LT", lastDay: "[ມື້ວານນີ້ເວລາ] LT", lastWeek: "[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT", sameElse: "L" }, relativeTime: { future: "ອີກ %s", past: "%sຜ່ານມາ", s: "ບໍ່ເທົ່າໃດວິນາທີ", m: "1 ນາທີ", mm: "%d ນາທີ", h: "1 ຊົ່ວໂມງ", hh: "%d ຊົ່ວໂມງ", d: "1 ມື້", dd: "%d ມື້", M: "1 ເດືອນ", MM: "%d ເດືອນ", y: "1 ປີ", yy: "%d ປີ" }, dayOfMonthOrdinalParse: /(ທີ່)\d{1,2}/, ordinal: function (a) { return "ທີ່" + a } });
    //! moment.js locale configuration
    //! locale : Lithuanian [lt]
    //! author : Mindaugas Mozūras : https://github.com/mmozuras
    var nh = { m: "minutė_minutės_minutę", mm: "minutės_minučių_minutes", h: "valanda_valandos_valandą", hh: "valandos_valandų_valandas", d: "diena_dienos_dieną", dd: "dienos_dienų_dienas", M: "mėnuo_mėnesio_mėnesį", MM: "mėnesiai_mėnesių_mėnesius", y: "metai_metų_metus", yy: "metai_metų_metus" }; a.defineLocale("lt", { months: { format: "sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio".split("_"), standalone: "sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis".split("_"), isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/ }, monthsShort: "sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"), weekdays: { format: "sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį".split("_"), standalone: "sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis".split("_"), isFormat: /dddd HH:mm/ }, weekdaysShort: "Sek_Pir_Ant_Tre_Ket_Pen_Šeš".split("_"), weekdaysMin: "S_P_A_T_K_Pn_Š".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "YYYY [m.] MMMM D [d.]", LLL: "YYYY [m.] MMMM D [d.], HH:mm [val.]", LLLL: "YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]", l: "YYYY-MM-DD", ll: "YYYY [m.] MMMM D [d.]", lll: "YYYY [m.] MMMM D [d.], HH:mm [val.]", llll: "YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]" }, calendar: { sameDay: "[Šiandien] LT", nextDay: "[Rytoj] LT", nextWeek: "dddd LT", lastDay: "[Vakar] LT", lastWeek: "[Praėjusį] dddd LT", sameElse: "L" }, relativeTime: { future: "po %s", past: "prieš %s", s: Sd, m: Td, mm: Wd, h: Td, hh: Wd, d: Td, dd: Wd, M: Td, MM: Wd, y: Td, yy: Wd }, dayOfMonthOrdinalParse: /\d{1,2}-oji/, ordinal: function (a) { return a + "-oji" }, week: { dow: 1, doy: 4 } });
    //! moment.js locale configuration
    //! locale : Latvian [lv]
    //! author : Kristaps Karlsons : https://github.com/skakri
    //! author : Jānis Elmeris : https://github.com/JanisE
    var oh = { m: "minūtes_minūtēm_minūte_minūtes".split("_"), mm: "minūtes_minūtēm_minūte_minūtes".split("_"), h: "stundas_stundām_stunda_stundas".split("_"), hh: "stundas_stundām_stunda_stundas".split("_"), d: "dienas_dienām_diena_dienas".split("_"), dd: "dienas_dienām_diena_dienas".split("_"), M: "mēneša_mēnešiem_mēnesis_mēneši".split("_"), MM: "mēneša_mēnešiem_mēnesis_mēneši".split("_"), y: "gada_gadiem_gads_gadi".split("_"), yy: "gada_gadiem_gads_gadi".split("_") }; a.defineLocale("lv", { months: "janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris".split("_"), monthsShort: "jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec".split("_"), weekdays: "svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena".split("_"), weekdaysShort: "Sv_P_O_T_C_Pk_S".split("_"), weekdaysMin: "Sv_P_O_T_C_Pk_S".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY.", LL: "YYYY. [gada] D. MMMM", LLL: "YYYY. [gada] D. MMMM, HH:mm", LLLL: "YYYY. [gada] D. MMMM, dddd, HH:mm" }, calendar: { sameDay: "[Šodien pulksten] LT", nextDay: "[Rīt pulksten] LT", nextWeek: "dddd [pulksten] LT", lastDay: "[Vakar pulksten] LT", lastWeek: "[Pagājušā] dddd [pulksten] LT", sameElse: "L" }, relativeTime: { future: "pēc %s", past: "pirms %s", s: $d, m: Zd, mm: Yd, h: Zd, hh: Yd, d: Zd, dd: Yd, M: Zd, MM: Yd, y: Zd, yy: Yd }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
    //! moment.js locale configuration
    //! locale : Montenegrin [me]
    //! author : Miodrag Nikač <miodrag@restartit.me> : https://github.com/miodragnikac
    var ph = { words: { m: ["jedan minut", "jednog minuta"], mm: ["minut", "minuta", "minuta"], h: ["jedan sat", "jednog sata"], hh: ["sat", "sata", "sati"], dd: ["dan", "dana", "dana"], MM: ["mjesec", "mjeseca", "mjeseci"], yy: ["godina", "godine", "godina"] }, correctGrammaticalCase: function (a, b) { return 1 === a ? b[0] : a >= 2 && a <= 4 ? b[1] : b[2] }, translate: function (a, b, c) { var d = ph.words[c]; return 1 === c.length ? b ? d[0] : d[1] : a + " " + ph.correctGrammaticalCase(a, d) } }; a.defineLocale("me", { months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"), monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"), weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"), weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" }, calendar: { sameDay: "[danas u] LT", nextDay: "[sjutra u] LT", nextWeek: function () { switch (this.day()) { case 0: return "[u] [nedjelju] [u] LT"; case 3: return "[u] [srijedu] [u] LT"; case 6: return "[u] [subotu] [u] LT"; case 1: case 2: case 4: case 5: return "[u] dddd [u] LT" } }, lastDay: "[juče u] LT", lastWeek: function () { var a = ["[prošle] [nedjelje] [u] LT", "[prošlog] [ponedjeljka] [u] LT", "[prošlog] [utorka] [u] LT", "[prošle] [srijede] [u] LT", "[prošlog] [četvrtka] [u] LT", "[prošlog] [petka] [u] LT", "[prošle] [subote] [u] LT"]; return a[this.day()] }, sameElse: "L" }, relativeTime: { future: "za %s", past: "prije %s", s: "nekoliko sekundi", m: ph.translate, mm: ph.translate, h: ph.translate, hh: ph.translate, d: "dan", dd: ph.translate, M: "mjesec", MM: ph.translate, y: "godinu", yy: ph.translate }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } }),
        //! moment.js locale configuration
        //! locale : Maori [mi]
        //! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal
        a.defineLocale("mi", { months: "Kohi-tāte_Hui-tanguru_Poutū-te-rangi_Paenga-whāwhā_Haratua_Pipiri_Hōngoingoi_Here-turi-kōkā_Mahuru_Whiringa-ā-nuku_Whiringa-ā-rangi_Hakihea".split("_"), monthsShort: "Kohi_Hui_Pou_Pae_Hara_Pipi_Hōngoi_Here_Mahu_Whi-nu_Whi-ra_Haki".split("_"), monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i, monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i, monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i, monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i, weekdays: "Rātapu_Mane_Tūrei_Wenerei_Tāite_Paraire_Hātarei".split("_"), weekdaysShort: "Ta_Ma_Tū_We_Tāi_Pa_Hā".split("_"), weekdaysMin: "Ta_Ma_Tū_We_Tāi_Pa_Hā".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [i] HH:mm", LLLL: "dddd, D MMMM YYYY [i] HH:mm" }, calendar: { sameDay: "[i teie mahana, i] LT", nextDay: "[apopo i] LT", nextWeek: "dddd [i] LT", lastDay: "[inanahi i] LT", lastWeek: "dddd [whakamutunga i] LT", sameElse: "L" }, relativeTime: { future: "i roto i %s", past: "%s i mua", s: "te hēkona ruarua", m: "he meneti", mm: "%d meneti", h: "te haora", hh: "%d haora", d: "he ra", dd: "%d ra", M: "he marama", MM: "%d marama", y: "he tau", yy: "%d tau" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Macedonian [mk]
        //! author : Borislav Mickov : https://github.com/B0k0
        a.defineLocale("mk", { months: "јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември".split("_"), monthsShort: "јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек".split("_"), weekdays: "недела_понеделник_вторник_среда_четврток_петок_сабота".split("_"), weekdaysShort: "нед_пон_вто_сре_чет_пет_саб".split("_"), weekdaysMin: "нe_пo_вт_ср_че_пе_сa".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "D.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY H:mm", LLLL: "dddd, D MMMM YYYY H:mm" }, calendar: { sameDay: "[Денес во] LT", nextDay: "[Утре во] LT", nextWeek: "[Во] dddd [во] LT", lastDay: "[Вчера во] LT", lastWeek: function () { switch (this.day()) { case 0: case 3: case 6: return "[Изминатата] dddd [во] LT"; case 1: case 2: case 4: case 5: return "[Изминатиот] dddd [во] LT" } }, sameElse: "L" }, relativeTime: { future: "после %s", past: "пред %s", s: "неколку секунди", m: "минута", mm: "%d минути", h: "час", hh: "%d часа", d: "ден", dd: "%d дена", M: "месец", MM: "%d месеци", y: "година", yy: "%d години" }, dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/, ordinal: function (a) { var b = a % 10, c = a % 100; return 0 === a ? a + "-ев" : 0 === c ? a + "-ен" : c > 10 && c < 20 ? a + "-ти" : 1 === b ? a + "-ви" : 2 === b ? a + "-ри" : 7 === b || 8 === b ? a + "-ми" : a + "-ти" }, week: { dow: 1, doy: 7 } }),
        //! moment.js locale configuration
        //! locale : Malayalam [ml]
        //! author : Floyd Pink : https://github.com/floydpink
        a.defineLocale("ml", { months: "ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ".split("_"), monthsShort: "ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.".split("_"), monthsParseExact: !0, weekdays: "ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച".split("_"), weekdaysShort: "ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി".split("_"), weekdaysMin: "ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ".split("_"), longDateFormat: { LT: "A h:mm -നു", LTS: "A h:mm:ss -നു", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm -നു", LLLL: "dddd, D MMMM YYYY, A h:mm -നു" }, calendar: { sameDay: "[ഇന്ന്] LT", nextDay: "[നാളെ] LT", nextWeek: "dddd, LT", lastDay: "[ഇന്നലെ] LT", lastWeek: "[കഴിഞ്ഞ] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s കഴിഞ്ഞ്", past: "%s മുൻപ്", s: "അൽപ നിമിഷങ്ങൾ", m: "ഒരു മിനിറ്റ്", mm: "%d മിനിറ്റ്", h: "ഒരു മണിക്കൂർ", hh: "%d മണിക്കൂർ", d: "ഒരു ദിവസം", dd: "%d ദിവസം", M: "ഒരു മാസം", MM: "%d മാസം", y: "ഒരു വർഷം", yy: "%d വർഷം" }, meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i, meridiemHour: function (a, b) { return 12 === a && (a = 0), "രാത്രി" === b && a >= 4 || "ഉച്ച കഴിഞ്ഞ്" === b || "വൈകുന്നേരം" === b ? a + 12 : a }, meridiem: function (a, b, c) { return a < 4 ? "രാത്രി" : a < 12 ? "രാവിലെ" : a < 17 ? "ഉച്ച കഴിഞ്ഞ്" : a < 20 ? "വൈകുന്നേരം" : "രാത്രി" } });
    //! moment.js locale configuration
    //! locale : Marathi [mr]
    //! author : Harshad Kale : https://github.com/kalehv
    //! author : Vivek Athalye : https://github.com/vnathalye
    var qh = { 1: "१", 2: "२", 3: "३", 4: "४", 5: "५", 6: "६", 7: "७", 8: "८", 9: "९", 0: "०" }, rh = { "१": "1", "२": "2", "३": "3", "४": "4", "५": "5", "६": "6", "७": "7", "८": "8", "९": "9", "०": "0" }; a.defineLocale("mr", { months: "जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर".split("_"), monthsShort: "जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.".split("_"), monthsParseExact: !0, weekdays: "रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार".split("_"), weekdaysShort: "रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि".split("_"), weekdaysMin: "र_सो_मं_बु_गु_शु_श".split("_"), longDateFormat: { LT: "A h:mm वाजता", LTS: "A h:mm:ss वाजता", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm वाजता", LLLL: "dddd, D MMMM YYYY, A h:mm वाजता" }, calendar: { sameDay: "[आज] LT", nextDay: "[उद्या] LT", nextWeek: "dddd, LT", lastDay: "[काल] LT", lastWeek: "[मागील] dddd, LT", sameElse: "L" }, relativeTime: { future: "%sमध्ये", past: "%sपूर्वी", s: _d, m: _d, mm: _d, h: _d, hh: _d, d: _d, dd: _d, M: _d, MM: _d, y: _d, yy: _d }, preparse: function (a) { return a.replace(/[१२३४५६७८९०]/g, function (a) { return rh[a] }) }, postformat: function (a) { return a.replace(/\d/g, function (a) { return qh[a] }) }, meridiemParse: /रात्री|सकाळी|दुपारी|सायंकाळी/, meridiemHour: function (a, b) { return 12 === a && (a = 0), "रात्री" === b ? a < 4 ? a : a + 12 : "सकाळी" === b ? a : "दुपारी" === b ? a >= 10 ? a : a + 12 : "सायंकाळी" === b ? a + 12 : void 0 }, meridiem: function (a, b, c) { return a < 4 ? "रात्री" : a < 10 ? "सकाळी" : a < 17 ? "दुपारी" : a < 20 ? "सायंकाळी" : "रात्री" }, week: { dow: 0, doy: 6 } }),
        //! moment.js locale configuration
        //! locale : Malay [ms-my]
        //! note : DEPRECATED, the correct one is [ms]
        //! author : Weldan Jamili : https://github.com/weldan
        a.defineLocale("ms-my", { months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"), monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"), weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"), weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"), weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" }, meridiemParse: /pagi|tengahari|petang|malam/, meridiemHour: function (a, b) { return 12 === a && (a = 0), "pagi" === b ? a : "tengahari" === b ? a >= 11 ? a : a + 12 : "petang" === b || "malam" === b ? a + 12 : void 0 }, meridiem: function (a, b, c) { return a < 11 ? "pagi" : a < 15 ? "tengahari" : a < 19 ? "petang" : "malam" }, calendar: { sameDay: "[Hari ini pukul] LT", nextDay: "[Esok pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kelmarin pukul] LT", lastWeek: "dddd [lepas pukul] LT", sameElse: "L" }, relativeTime: { future: "dalam %s", past: "%s yang lepas", s: "beberapa saat", m: "seminit", mm: "%d minit", h: "sejam", hh: "%d jam", d: "sehari", dd: "%d hari", M: "sebulan", MM: "%d bulan", y: "setahun", yy: "%d tahun" }, week: { dow: 1, doy: 7 } }),
        //! moment.js locale configuration
        //! locale : Malay [ms]
        //! author : Weldan Jamili : https://github.com/weldan
        a.defineLocale("ms", { months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"), monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"), weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"), weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"), weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" }, meridiemParse: /pagi|tengahari|petang|malam/, meridiemHour: function (a, b) { return 12 === a && (a = 0), "pagi" === b ? a : "tengahari" === b ? a >= 11 ? a : a + 12 : "petang" === b || "malam" === b ? a + 12 : void 0 }, meridiem: function (a, b, c) { return a < 11 ? "pagi" : a < 15 ? "tengahari" : a < 19 ? "petang" : "malam" }, calendar: { sameDay: "[Hari ini pukul] LT", nextDay: "[Esok pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kelmarin pukul] LT", lastWeek: "dddd [lepas pukul] LT", sameElse: "L" }, relativeTime: { future: "dalam %s", past: "%s yang lepas", s: "beberapa saat", m: "seminit", mm: "%d minit", h: "sejam", hh: "%d jam", d: "sehari", dd: "%d hari", M: "sebulan", MM: "%d bulan", y: "setahun", yy: "%d tahun" }, week: { dow: 1, doy: 7 } });
    //! moment.js locale configuration
    //! locale : Burmese [my]
    //! author : Squar team, mysquar.com
    //! author : David Rossellat : https://github.com/gholadr
    //! author : Tin Aung Lin : https://github.com/thanyawzinmin
    var sh = { 1: "၁", 2: "၂", 3: "၃", 4: "၄", 5: "၅", 6: "၆", 7: "၇", 8: "၈", 9: "၉", 0: "၀" }, th = { "၁": "1", "၂": "2", "၃": "3", "၄": "4", "၅": "5", "၆": "6", "၇": "7", "၈": "8", "၉": "9", "၀": "0" }; a.defineLocale("my", { months: "ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ".split("_"), monthsShort: "ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ".split("_"), weekdays: "တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ".split("_"), weekdaysShort: "နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ".split("_"), weekdaysMin: "နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[ယနေ.] LT [မှာ]", nextDay: "[မနက်ဖြန်] LT [မှာ]", nextWeek: "dddd LT [မှာ]", lastDay: "[မနေ.က] LT [မှာ]", lastWeek: "[ပြီးခဲ့သော] dddd LT [မှာ]", sameElse: "L" }, relativeTime: { future: "လာမည့် %s မှာ", past: "လွန်ခဲ့သော %s က", s: "စက္ကန်.အနည်းငယ်", m: "တစ်မိနစ်", mm: "%d မိနစ်", h: "တစ်နာရီ", hh: "%d နာရီ", d: "တစ်ရက်", dd: "%d ရက်", M: "တစ်လ", MM: "%d လ", y: "တစ်နှစ်", yy: "%d နှစ်" }, preparse: function (a) { return a.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (a) { return th[a] }) }, postformat: function (a) { return a.replace(/\d/g, function (a) { return sh[a] }) }, week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Norwegian Bokmål [nb]
        //! authors : Espen Hovlandsdal : https://github.com/rexxars
        //!           Sigurd Gartmann : https://github.com/sigurdga
        a.defineLocale("nb", { months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"), monthsShort: "jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.".split("_"), monthsParseExact: !0, weekdays: "søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag".split("_"), weekdaysShort: "sø._ma._ti._on._to._fr._lø.".split("_"), weekdaysMin: "sø_ma_ti_on_to_fr_lø".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY [kl.] HH:mm", LLLL: "dddd D. MMMM YYYY [kl.] HH:mm" }, calendar: { sameDay: "[i dag kl.] LT", nextDay: "[i morgen kl.] LT", nextWeek: "dddd [kl.] LT", lastDay: "[i går kl.] LT", lastWeek: "[forrige] dddd [kl.] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "%s siden", s: "noen sekunder", m: "ett minutt", mm: "%d minutter", h: "en time", hh: "%d timer", d: "en dag", dd: "%d dager", M: "en måned", MM: "%d måneder", y: "ett år", yy: "%d år" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
    //! moment.js locale configuration
    //! locale : Nepalese [ne]
    //! author : suvash : https://github.com/suvash
    var uh = { 1: "१", 2: "२", 3: "३", 4: "४", 5: "५", 6: "६", 7: "७", 8: "८", 9: "९", 0: "०" }, vh = { "१": "1", "२": "2", "३": "3", "४": "4", "५": "5", "६": "6", "७": "7", "८": "8", "९": "9", "०": "0" }; a.defineLocale("ne", { months: "जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर".split("_"), monthsShort: "जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.".split("_"), monthsParseExact: !0, weekdays: "आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार".split("_"), weekdaysShort: "आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.".split("_"), weekdaysMin: "आ._सो._मं._बु._बि._शु._श.".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "Aको h:mm बजे", LTS: "Aको h:mm:ss बजे", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, Aको h:mm बजे", LLLL: "dddd, D MMMM YYYY, Aको h:mm बजे" }, preparse: function (a) { return a.replace(/[१२३४५६७८९०]/g, function (a) { return vh[a] }) }, postformat: function (a) { return a.replace(/\d/g, function (a) { return uh[a] }) }, meridiemParse: /राति|बिहान|दिउँसो|साँझ/, meridiemHour: function (a, b) { return 12 === a && (a = 0), "राति" === b ? a < 4 ? a : a + 12 : "बिहान" === b ? a : "दिउँसो" === b ? a >= 10 ? a : a + 12 : "साँझ" === b ? a + 12 : void 0 }, meridiem: function (a, b, c) { return a < 3 ? "राति" : a < 12 ? "बिहान" : a < 16 ? "दिउँसो" : a < 20 ? "साँझ" : "राति" }, calendar: { sameDay: "[आज] LT", nextDay: "[भोलि] LT", nextWeek: "[आउँदो] dddd[,] LT", lastDay: "[हिजो] LT", lastWeek: "[गएको] dddd[,] LT", sameElse: "L" }, relativeTime: { future: "%sमा", past: "%s अगाडि", s: "केही क्षण", m: "एक मिनेट", mm: "%d मिनेट", h: "एक घण्टा", hh: "%d घण्टा", d: "एक दिन", dd: "%d दिन", M: "एक महिना", MM: "%d महिना", y: "एक बर्ष", yy: "%d बर्ष" }, week: { dow: 0, doy: 6 } });
    //! moment.js locale configuration
    //! locale : Dutch (Belgium) [nl-be]
    //! author : Joris Röling : https://github.com/jorisroling
    //! author : Jacob Middag : https://github.com/middagj
    var wh = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), xh = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), yh = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i], zh = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i; a.defineLocale("nl-be", { months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"), monthsShort: function (a, b) { return a ? /-MMM-/.test(b) ? xh[a.month()] : wh[a.month()] : wh }, monthsRegex: zh, monthsShortRegex: zh, monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i, monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i, monthsParse: yh, longMonthsParse: yh, shortMonthsParse: yh, weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"), weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"), weekdaysMin: "Zo_Ma_Di_Wo_Do_Vr_Za".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[vandaag om] LT", nextDay: "[morgen om] LT", nextWeek: "dddd [om] LT", lastDay: "[gisteren om] LT", lastWeek: "[afgelopen] dddd [om] LT", sameElse: "L" }, relativeTime: { future: "over %s", past: "%s geleden", s: "een paar seconden", m: "één minuut", mm: "%d minuten", h: "één uur", hh: "%d uur", d: "één dag", dd: "%d dagen", M: "één maand", MM: "%d maanden", y: "één jaar", yy: "%d jaar" }, dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/, ordinal: function (a) { return a + (1 === a || 8 === a || a >= 20 ? "ste" : "de") }, week: { dow: 1, doy: 4 } });
    //! moment.js locale configuration
    //! locale : Dutch [nl]
    //! author : Joris Röling : https://github.com/jorisroling
    //! author : Jacob Middag : https://github.com/middagj
    var Ah = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), Bh = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), Ch = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i], Dh = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i; a.defineLocale("nl", { months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"), monthsShort: function (a, b) { return a ? /-MMM-/.test(b) ? Bh[a.month()] : Ah[a.month()] : Ah }, monthsRegex: Dh, monthsShortRegex: Dh, monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i, monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i, monthsParse: Ch, longMonthsParse: Ch, shortMonthsParse: Ch, weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"), weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"), weekdaysMin: "Zo_Ma_Di_Wo_Do_Vr_Za".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[vandaag om] LT", nextDay: "[morgen om] LT", nextWeek: "dddd [om] LT", lastDay: "[gisteren om] LT", lastWeek: "[afgelopen] dddd [om] LT", sameElse: "L" }, relativeTime: { future: "over %s", past: "%s geleden", s: "een paar seconden", m: "één minuut", mm: "%d minuten", h: "één uur", hh: "%d uur", d: "één dag", dd: "%d dagen", M: "één maand", MM: "%d maanden", y: "één jaar", yy: "%d jaar" }, dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/, ordinal: function (a) { return a + (1 === a || 8 === a || a >= 20 ? "ste" : "de") }, week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Nynorsk [nn]
        //! author : https://github.com/mechuwind
        a.defineLocale("nn", { months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"), monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"), weekdays: "sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"), weekdaysShort: "sun_mån_tys_ons_tor_fre_lau".split("_"), weekdaysMin: "su_må_ty_on_to_fr_lø".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY [kl.] H:mm", LLLL: "dddd D. MMMM YYYY [kl.] HH:mm" }, calendar: { sameDay: "[I dag klokka] LT", nextDay: "[I morgon klokka] LT", nextWeek: "dddd [klokka] LT", lastDay: "[I går klokka] LT", lastWeek: "[Føregåande] dddd [klokka] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "%s sidan", s: "nokre sekund", m: "eit minutt", mm: "%d minutt", h: "ein time", hh: "%d timar", d: "ein dag", dd: "%d dagar", M: "ein månad", MM: "%d månader", y: "eit år", yy: "%d år" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
    //! moment.js locale configuration
    //! locale : Punjabi (India) [pa-in]
    //! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit
    var Eh = { 1: "੧", 2: "੨", 3: "੩", 4: "੪", 5: "੫", 6: "੬", 7: "੭", 8: "੮", 9: "੯", 0: "੦" }, Fh = { "੧": "1", "੨": "2", "੩": "3", "੪": "4", "੫": "5", "੬": "6", "੭": "7", "੮": "8", "੯": "9", "੦": "0" }; a.defineLocale("pa-in", { months: "ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ".split("_"), monthsShort: "ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ".split("_"), weekdays: "ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ".split("_"), weekdaysShort: "ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ".split("_"), weekdaysMin: "ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ".split("_"), longDateFormat: { LT: "A h:mm ਵਜੇ", LTS: "A h:mm:ss ਵਜੇ", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm ਵਜੇ", LLLL: "dddd, D MMMM YYYY, A h:mm ਵਜੇ" }, calendar: { sameDay: "[ਅਜ] LT", nextDay: "[ਕਲ] LT", nextWeek: "dddd, LT", lastDay: "[ਕਲ] LT", lastWeek: "[ਪਿਛਲੇ] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s ਵਿੱਚ", past: "%s ਪਿਛਲੇ", s: "ਕੁਝ ਸਕਿੰਟ", m: "ਇਕ ਮਿੰਟ", mm: "%d ਮਿੰਟ", h: "ਇੱਕ ਘੰਟਾ", hh: "%d ਘੰਟੇ", d: "ਇੱਕ ਦਿਨ", dd: "%d ਦਿਨ", M: "ਇੱਕ ਮਹੀਨਾ", MM: "%d ਮਹੀਨੇ", y: "ਇੱਕ ਸਾਲ", yy: "%d ਸਾਲ" }, preparse: function (a) { return a.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, function (a) { return Fh[a] }) }, postformat: function (a) { return a.replace(/\d/g, function (a) { return Eh[a] }) }, meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/, meridiemHour: function (a, b) { return 12 === a && (a = 0), "ਰਾਤ" === b ? a < 4 ? a : a + 12 : "ਸਵੇਰ" === b ? a : "ਦੁਪਹਿਰ" === b ? a >= 10 ? a : a + 12 : "ਸ਼ਾਮ" === b ? a + 12 : void 0 }, meridiem: function (a, b, c) { return a < 4 ? "ਰਾਤ" : a < 10 ? "ਸਵੇਰ" : a < 17 ? "ਦੁਪਹਿਰ" : a < 20 ? "ਸ਼ਾਮ" : "ਰਾਤ" }, week: { dow: 0, doy: 6 } });
    //! moment.js locale configuration
    //! locale : Polish [pl]
    //! author : Rafal Hirsz : https://github.com/evoL
    var Gh = "styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień".split("_"), Hh = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia".split("_"); a.defineLocale("pl", { months: function (a, b) { return a ? "" === b ? "(" + Hh[a.month()] + "|" + Gh[a.month()] + ")" : /D MMMM/.test(b) ? Hh[a.month()] : Gh[a.month()] : Gh }, monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru".split("_"), weekdays: "niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota".split("_"), weekdaysShort: "ndz_pon_wt_śr_czw_pt_sob".split("_"), weekdaysMin: "Nd_Pn_Wt_Śr_Cz_Pt_So".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Dziś o] LT", nextDay: "[Jutro o] LT", nextWeek: "[W] dddd [o] LT", lastDay: "[Wczoraj o] LT", lastWeek: function () { switch (this.day()) { case 0: return "[W zeszłą niedzielę o] LT"; case 3: return "[W zeszłą środę o] LT"; case 6: return "[W zeszłą sobotę o] LT"; default: return "[W zeszły] dddd [o] LT" } }, sameElse: "L" }, relativeTime: { future: "za %s", past: "%s temu", s: "kilka sekund", m: be, mm: be, h: be, hh: be, d: "1 dzień", dd: "%d dni", M: "miesiąc", MM: be, y: "rok", yy: be }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Portuguese (Brazil) [pt-br]
        //! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira
        a.defineLocale("pt-br", { months: "Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro".split("_"), monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"), weekdays: "Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado".split("_"), weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_Sáb".split("_"), weekdaysMin: "Do_2ª_3ª_4ª_5ª_6ª_Sá".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY [às] HH:mm", LLLL: "dddd, D [de] MMMM [de] YYYY [às] HH:mm" }, calendar: { sameDay: "[Hoje às] LT", nextDay: "[Amanhã às] LT", nextWeek: "dddd [às] LT", lastDay: "[Ontem às] LT", lastWeek: function () { return 0 === this.day() || 6 === this.day() ? "[Último] dddd [às] LT" : "[Última] dddd [às] LT" }, sameElse: "L" }, relativeTime: { future: "em %s", past: "%s atrás", s: "poucos segundos", m: "um minuto", mm: "%d minutos", h: "uma hora", hh: "%d horas", d: "um dia", dd: "%d dias", M: "um mês", MM: "%d meses", y: "um ano", yy: "%d anos" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº" }),
        //! moment.js locale configuration
        //! locale : Portuguese [pt]
        //! author : Jefferson : https://github.com/jalex79
        a.defineLocale("pt", { months: "Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro".split("_"), monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"), weekdays: "Domingo_Segunda-Feira_Terça-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sábado".split("_"), weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_Sáb".split("_"), weekdaysMin: "Do_2ª_3ª_4ª_5ª_6ª_Sá".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY HH:mm", LLLL: "dddd, D [de] MMMM [de] YYYY HH:mm" }, calendar: { sameDay: "[Hoje às] LT", nextDay: "[Amanhã às] LT", nextWeek: "dddd [às] LT", lastDay: "[Ontem às] LT", lastWeek: function () { return 0 === this.day() || 6 === this.day() ? "[Último] dddd [às] LT" : "[Última] dddd [às] LT" }, sameElse: "L" }, relativeTime: { future: "em %s", past: "há %s", s: "segundos", m: "um minuto", mm: "%d minutos", h: "uma hora", hh: "%d horas", d: "um dia", dd: "%d dias", M: "um mês", MM: "%d meses", y: "um ano", yy: "%d anos" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } }), a.defineLocale("ro", { months: "ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split("_"), monthsShort: "ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "duminică_luni_marți_miercuri_joi_vineri_sâmbătă".split("_"), weekdaysShort: "Dum_Lun_Mar_Mie_Joi_Vin_Sâm".split("_"), weekdaysMin: "Du_Lu_Ma_Mi_Jo_Vi_Sâ".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY H:mm", LLLL: "dddd, D MMMM YYYY H:mm" }, calendar: { sameDay: "[azi la] LT", nextDay: "[mâine la] LT", nextWeek: "dddd [la] LT", lastDay: "[ieri la] LT", lastWeek: "[fosta] dddd [la] LT", sameElse: "L" }, relativeTime: { future: "peste %s", past: "%s în urmă", s: "câteva secunde", m: "un minut", mm: ce, h: "o oră", hh: ce, d: "o zi", dd: ce, M: "o lună", MM: ce, y: "un an", yy: ce }, week: { dow: 1, doy: 7 } }); var Ih = [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[йя]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i]; a.defineLocale("ru", { months: { format: "января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря".split("_"), standalone: "январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь".split("_") }, monthsShort: { format: "янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.".split("_"), standalone: "янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.".split("_") }, weekdays: { standalone: "воскресенье_понедельник_вторник_среда_четверг_пятница_суббота".split("_"), format: "воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу".split("_"), isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?\] ?dddd/ }, weekdaysShort: "вс_пн_вт_ср_чт_пт_сб".split("_"), weekdaysMin: "вс_пн_вт_ср_чт_пт_сб".split("_"), monthsParse: Ih, longMonthsParse: Ih, shortMonthsParse: Ih, monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i, monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i, monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i, monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY г.", LLL: "D MMMM YYYY г., HH:mm", LLLL: "dddd, D MMMM YYYY г., HH:mm" }, calendar: { sameDay: "[Сегодня в] LT", nextDay: "[Завтра в] LT", lastDay: "[Вчера в] LT", nextWeek: function (a) { if (a.week() === this.week()) return 2 === this.day() ? "[Во] dddd [в] LT" : "[В] dddd [в] LT"; switch (this.day()) { case 0: return "[В следующее] dddd [в] LT"; case 1: case 2: case 4: return "[В следующий] dddd [в] LT"; case 3: case 5: case 6: return "[В следующую] dddd [в] LT" } }, lastWeek: function (a) { if (a.week() === this.week()) return 2 === this.day() ? "[Во] dddd [в] LT" : "[В] dddd [в] LT"; switch (this.day()) { case 0: return "[В прошлое] dddd [в] LT"; case 1: case 2: case 4: return "[В прошлый] dddd [в] LT"; case 3: case 5: case 6: return "[В прошлую] dddd [в] LT" } }, sameElse: "L" }, relativeTime: { future: "через %s", past: "%s назад", s: "несколько секунд", m: ee, mm: ee, h: "час", hh: ee, d: "день", dd: ee, M: "месяц", MM: ee, y: "год", yy: ee }, meridiemParse: /ночи|утра|дня|вечера/i, isPM: function (a) { return /^(дня|вечера)$/.test(a) }, meridiem: function (a, b, c) { return a < 4 ? "ночи" : a < 12 ? "утра" : a < 17 ? "дня" : "вечера" }, dayOfMonthOrdinalParse: /\d{1,2}-(й|го|я)/, ordinal: function (a, b) { switch (b) { case "M": case "d": case "DDD": return a + "-й"; case "D": return a + "-го"; case "w": case "W": return a + "-я"; default: return a } }, week: { dow: 1, doy: 7 } });
    //! moment.js locale configuration
    //! locale : Sindhi [sd]
    //! author : Narain Sagar : https://github.com/narainsagar
    var Jh = ["جنوري", "فيبروري", "مارچ", "اپريل", "مئي", "جون", "جولاءِ", "آگسٽ", "سيپٽمبر", "آڪٽوبر", "نومبر", "ڊسمبر"], Kh = ["آچر", "سومر", "اڱارو", "اربع", "خميس", "جمع", "ڇنڇر"]; a.defineLocale("sd", { months: Jh, monthsShort: Jh, weekdays: Kh, weekdaysShort: Kh, weekdaysMin: Kh, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd، D MMMM YYYY HH:mm" }, meridiemParse: /صبح|شام/, isPM: function (a) { return "شام" === a }, meridiem: function (a, b, c) { return a < 12 ? "صبح" : "شام" }, calendar: { sameDay: "[اڄ] LT", nextDay: "[سڀاڻي] LT", nextWeek: "dddd [اڳين هفتي تي] LT", lastDay: "[ڪالهه] LT", lastWeek: "[گزريل هفتي] dddd [تي] LT", sameElse: "L" }, relativeTime: { future: "%s پوء", past: "%s اڳ", s: "چند سيڪنڊ", m: "هڪ منٽ", mm: "%d منٽ", h: "هڪ ڪلاڪ", hh: "%d ڪلاڪ", d: "هڪ ڏينهن", dd: "%d ڏينهن", M: "هڪ مهينو", MM: "%d مهينا", y: "هڪ سال", yy: "%d سال" }, preparse: function (a) { return a.replace(/،/g, ",") }, postformat: function (a) { return a.replace(/,/g, "،") }, week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Northern Sami [se]
        //! authors : Bård Rolstad Henriksen : https://github.com/karamell
        a.defineLocale("se", { months: "ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu".split("_"), monthsShort: "ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov".split("_"), weekdays: "sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat".split("_"), weekdaysShort: "sotn_vuos_maŋ_gask_duor_bear_láv".split("_"), weekdaysMin: "s_v_m_g_d_b_L".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "MMMM D. [b.] YYYY", LLL: "MMMM D. [b.] YYYY [ti.] HH:mm", LLLL: "dddd, MMMM D. [b.] YYYY [ti.] HH:mm" }, calendar: { sameDay: "[otne ti] LT", nextDay: "[ihttin ti] LT", nextWeek: "dddd [ti] LT", lastDay: "[ikte ti] LT", lastWeek: "[ovddit] dddd [ti] LT", sameElse: "L" }, relativeTime: { future: "%s geažes", past: "maŋit %s", s: "moadde sekunddat", m: "okta minuhta", mm: "%d minuhtat", h: "okta diimmu", hh: "%d diimmut", d: "okta beaivi", dd: "%d beaivvit", M: "okta mánnu", MM: "%d mánut", y: "okta jahki", yy: "%d jagit" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Sinhalese [si]
        //! author : Sampath Sitinamaluwa : https://github.com/sampathsris
        a.defineLocale("si", { months: "ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්".split("_"), monthsShort: "ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ".split("_"), weekdays: "ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා".split("_"), weekdaysShort: "ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන".split("_"), weekdaysMin: "ඉ_ස_අ_බ_බ්‍ර_සි_සෙ".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "a h:mm", LTS: "a h:mm:ss", L: "YYYY/MM/DD", LL: "YYYY MMMM D", LLL: "YYYY MMMM D, a h:mm", LLLL: "YYYY MMMM D [වැනි] dddd, a h:mm:ss" }, calendar: { sameDay: "[අද] LT[ට]", nextDay: "[හෙට] LT[ට]", nextWeek: "dddd LT[ට]", lastDay: "[ඊයේ] LT[ට]", lastWeek: "[පසුගිය] dddd LT[ට]", sameElse: "L" }, relativeTime: { future: "%sකින්", past: "%sකට පෙර", s: "තත්පර කිහිපය", m: "මිනිත්තුව", mm: "මිනිත්තු %d", h: "පැය", hh: "පැය %d", d: "දිනය", dd: "දින %d", M: "මාසය", MM: "මාස %d", y: "වසර", yy: "වසර %d" }, dayOfMonthOrdinalParse: /\d{1,2} වැනි/, ordinal: function (a) { return a + " වැනි" }, meridiemParse: /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./, isPM: function (a) { return "ප.ව." === a || "පස් වරු" === a }, meridiem: function (a, b, c) { return a > 11 ? c ? "ප.ව." : "පස් වරු" : c ? "පෙ.ව." : "පෙර වරු" } });
    //! moment.js locale configuration
    //! locale : Slovak [sk]
    //! author : Martin Minka : https://github.com/k2s
    //! based on work of petrbela : https://github.com/petrbela
    var Lh = "január_február_marec_apríl_máj_jún_júl_august_september_október_november_december".split("_"), Mh = "jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec".split("_"); a.defineLocale("sk", { months: Lh, monthsShort: Mh, weekdays: "nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota".split("_"), weekdaysShort: "ne_po_ut_st_št_pi_so".split("_"), weekdaysMin: "ne_po_ut_st_št_pi_so".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd D. MMMM YYYY H:mm" }, calendar: { sameDay: "[dnes o] LT", nextDay: "[zajtra o] LT", nextWeek: function () { switch (this.day()) { case 0: return "[v nedeľu o] LT"; case 1: case 2: return "[v] dddd [o] LT"; case 3: return "[v stredu o] LT"; case 4: return "[vo štvrtok o] LT"; case 5: return "[v piatok o] LT"; case 6: return "[v sobotu o] LT" } }, lastDay: "[včera o] LT", lastWeek: function () { switch (this.day()) { case 0: return "[minulú nedeľu o] LT"; case 1: case 2: return "[minulý] dddd [o] LT"; case 3: return "[minulú stredu o] LT"; case 4: case 5: return "[minulý] dddd [o] LT"; case 6: return "[minulú sobotu o] LT" } }, sameElse: "L" }, relativeTime: { future: "za %s", past: "pred %s", s: ge, m: ge, mm: ge, h: ge, hh: ge, d: ge, dd: ge, M: ge, MM: ge, y: ge, yy: ge }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } }), a.defineLocale("sl", { months: "januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split("_"), monthsShort: "jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota".split("_"), weekdaysShort: "ned._pon._tor._sre._čet._pet._sob.".split("_"), weekdaysMin: "ne_po_to_sr_če_pe_so".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" }, calendar: { sameDay: "[danes ob] LT", nextDay: "[jutri ob] LT", nextWeek: function () { switch (this.day()) { case 0: return "[v] [nedeljo] [ob] LT"; case 3: return "[v] [sredo] [ob] LT"; case 6: return "[v] [soboto] [ob] LT"; case 1: case 2: case 4: case 5: return "[v] dddd [ob] LT" } }, lastDay: "[včeraj ob] LT", lastWeek: function () { switch (this.day()) { case 0: return "[prejšnjo] [nedeljo] [ob] LT"; case 3: return "[prejšnjo] [sredo] [ob] LT"; case 6: return "[prejšnjo] [soboto] [ob] LT"; case 1: case 2: case 4: case 5: return "[prejšnji] dddd [ob] LT" } }, sameElse: "L" }, relativeTime: { future: "čez %s", past: "pred %s", s: he, m: he, mm: he, h: he, hh: he, d: he, dd: he, M: he, MM: he, y: he, yy: he }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } }),
        //! moment.js locale configuration
        //! locale : Albanian [sq]
        //! author : Flakërim Ismani : https://github.com/flakerimi
        //! author : Menelion Elensúle : https://github.com/Oire
        //! author : Oerd Cukalla : https://github.com/oerd
        a.defineLocale("sq", { months: "Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor".split("_"), monthsShort: "Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj".split("_"), weekdays: "E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë".split("_"), weekdaysShort: "Die_Hën_Mar_Mër_Enj_Pre_Sht".split("_"), weekdaysMin: "D_H_Ma_Më_E_P_Sh".split("_"), weekdaysParseExact: !0, meridiemParse: /PD|MD/, isPM: function (a) { return "M" === a.charAt(0) }, meridiem: function (a, b, c) { return a < 12 ? "PD" : "MD" }, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Sot në] LT", nextDay: "[Nesër në] LT", nextWeek: "dddd [në] LT", lastDay: "[Dje në] LT", lastWeek: "dddd [e kaluar në] LT", sameElse: "L" }, relativeTime: { future: "në %s", past: "%s më parë", s: "disa sekonda", m: "një minutë", mm: "%d minuta", h: "një orë", hh: "%d orë", d: "një ditë", dd: "%d ditë", M: "një muaj", MM: "%d muaj", y: "një vit", yy: "%d vite" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
    //! moment.js locale configuration
    //! locale : Serbian Cyrillic [sr-cyrl]
    //! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j
    var Nh = { words: { m: ["један минут", "једне минуте"], mm: ["минут", "минуте", "минута"], h: ["један сат", "једног сата"], hh: ["сат", "сата", "сати"], dd: ["дан", "дана", "дана"], MM: ["месец", "месеца", "месеци"], yy: ["година", "године", "година"] }, correctGrammaticalCase: function (a, b) { return 1 === a ? b[0] : a >= 2 && a <= 4 ? b[1] : b[2] }, translate: function (a, b, c) { var d = Nh.words[c]; return 1 === c.length ? b ? d[0] : d[1] : a + " " + Nh.correctGrammaticalCase(a, d) } }; a.defineLocale("sr-cyrl", { months: "јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар".split("_"), monthsShort: "јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.".split("_"), monthsParseExact: !0, weekdays: "недеља_понедељак_уторак_среда_четвртак_петак_субота".split("_"), weekdaysShort: "нед._пон._уто._сре._чет._пет._суб.".split("_"), weekdaysMin: "не_по_ут_ср_че_пе_су".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" }, calendar: { sameDay: "[данас у] LT", nextDay: "[сутра у] LT", nextWeek: function () { switch (this.day()) { case 0: return "[у] [недељу] [у] LT"; case 3: return "[у] [среду] [у] LT"; case 6: return "[у] [суботу] [у] LT"; case 1: case 2: case 4: case 5: return "[у] dddd [у] LT" } }, lastDay: "[јуче у] LT", lastWeek: function () { var a = ["[прошле] [недеље] [у] LT", "[прошлог] [понедељка] [у] LT", "[прошлог] [уторка] [у] LT", "[прошле] [среде] [у] LT", "[прошлог] [четвртка] [у] LT", "[прошлог] [петка] [у] LT", "[прошле] [суботе] [у] LT"]; return a[this.day()] }, sameElse: "L" }, relativeTime: { future: "за %s", past: "пре %s", s: "неколико секунди", m: Nh.translate, mm: Nh.translate, h: Nh.translate, hh: Nh.translate, d: "дан", dd: Nh.translate, M: "месец", MM: Nh.translate, y: "годину", yy: Nh.translate }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
    //! moment.js locale configuration
    //! locale : Serbian [sr]
    //! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j
    var Oh = { words: { m: ["jedan minut", "jedne minute"], mm: ["minut", "minute", "minuta"], h: ["jedan sat", "jednog sata"], hh: ["sat", "sata", "sati"], dd: ["dan", "dana", "dana"], MM: ["mesec", "meseca", "meseci"], yy: ["godina", "godine", "godina"] }, correctGrammaticalCase: function (a, b) { return 1 === a ? b[0] : a >= 2 && a <= 4 ? b[1] : b[2] }, translate: function (a, b, c) { var d = Oh.words[c]; return 1 === c.length ? b ? d[0] : d[1] : a + " " + Oh.correctGrammaticalCase(a, d) } }; a.defineLocale("sr", { months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"), monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota".split("_"), weekdaysShort: "ned._pon._uto._sre._čet._pet._sub.".split("_"), weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" }, calendar: { sameDay: "[danas u] LT", nextDay: "[sutra u] LT", nextWeek: function () { switch (this.day()) { case 0: return "[u] [nedelju] [u] LT"; case 3: return "[u] [sredu] [u] LT"; case 6: return "[u] [subotu] [u] LT"; case 1: case 2: case 4: case 5: return "[u] dddd [u] LT" } }, lastDay: "[juče u] LT", lastWeek: function () { var a = ["[prošle] [nedelje] [u] LT", "[prošlog] [ponedeljka] [u] LT", "[prošlog] [utorka] [u] LT", "[prošle] [srede] [u] LT", "[prošlog] [četvrtka] [u] LT", "[prošlog] [petka] [u] LT", "[prošle] [subote] [u] LT"]; return a[this.day()] }, sameElse: "L" }, relativeTime: { future: "za %s", past: "pre %s", s: "nekoliko sekundi", m: Oh.translate, mm: Oh.translate, h: Oh.translate, hh: Oh.translate, d: "dan", dd: Oh.translate, M: "mesec", MM: Oh.translate, y: "godinu", yy: Oh.translate }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } }),
        //! moment.js locale configuration
        //! locale : siSwati [ss]
        //! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies
        a.defineLocale("ss", { months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split("_"), monthsShort: "Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo".split("_"), weekdays: "Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo".split("_"), weekdaysShort: "Lis_Umb_Lsb_Les_Lsi_Lsh_Umg".split("_"), weekdaysMin: "Li_Us_Lb_Lt_Ls_Lh_Ug".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[Namuhla nga] LT", nextDay: "[Kusasa nga] LT", nextWeek: "dddd [nga] LT", lastDay: "[Itolo nga] LT", lastWeek: "dddd [leliphelile] [nga] LT", sameElse: "L" }, relativeTime: { future: "nga %s", past: "wenteka nga %s", s: "emizuzwana lomcane", m: "umzuzu", mm: "%d emizuzu", h: "lihora", hh: "%d emahora", d: "lilanga", dd: "%d emalanga", M: "inyanga", MM: "%d tinyanga", y: "umnyaka", yy: "%d iminyaka" }, meridiemParse: /ekuseni|emini|entsambama|ebusuku/, meridiem: function (a, b, c) { return a < 11 ? "ekuseni" : a < 15 ? "emini" : a < 19 ? "entsambama" : "ebusuku" }, meridiemHour: function (a, b) { return 12 === a && (a = 0), "ekuseni" === b ? a : "emini" === b ? a >= 11 ? a : a + 12 : "entsambama" === b || "ebusuku" === b ? 0 === a ? 0 : a + 12 : void 0 }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: "%d", week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Swedish [sv]
        //! author : Jens Alm : https://github.com/ulmus
        a.defineLocale("sv", { months: "januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"), monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"), weekdays: "söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag".split("_"), weekdaysShort: "sön_mån_tis_ons_tor_fre_lör".split("_"), weekdaysMin: "sö_må_ti_on_to_fr_lö".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [kl.] HH:mm", LLLL: "dddd D MMMM YYYY [kl.] HH:mm", lll: "D MMM YYYY HH:mm", llll: "ddd D MMM YYYY HH:mm" }, calendar: { sameDay: "[Idag] LT", nextDay: "[Imorgon] LT", lastDay: "[Igår] LT", nextWeek: "[På] dddd LT", lastWeek: "[I] dddd[s] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "för %s sedan", s: "några sekunder", m: "en minut", mm: "%d minuter", h: "en timme", hh: "%d timmar", d: "en dag", dd: "%d dagar", M: "en månad", MM: "%d månader", y: "ett år", yy: "%d år" }, dayOfMonthOrdinalParse: /\d{1,2}(e|a)/, ordinal: function (a) { var b = a % 10, c = 1 === ~~(a % 100 / 10) ? "e" : 1 === b ? "a" : 2 === b ? "a" : "e"; return a + c }, week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Swahili [sw]
        //! author : Fahad Kassim : https://github.com/fadsel
        a.defineLocale("sw", { months: "Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba".split("_"), monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des".split("_"), weekdays: "Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi".split("_"), weekdaysShort: "Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos".split("_"), weekdaysMin: "J2_J3_J4_J5_Al_Ij_J1".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[leo saa] LT", nextDay: "[kesho saa] LT", nextWeek: "[wiki ijayo] dddd [saat] LT", lastDay: "[jana] LT", lastWeek: "[wiki iliyopita] dddd [saat] LT", sameElse: "L" }, relativeTime: { future: "%s baadaye", past: "tokea %s", s: "hivi punde", m: "dakika moja", mm: "dakika %d", h: "saa limoja", hh: "masaa %d", d: "siku moja", dd: "masiku %d", M: "mwezi mmoja", MM: "miezi %d", y: "mwaka mmoja", yy: "miaka %d" }, week: { dow: 1, doy: 7 } });
    //! moment.js locale configuration
    //! locale : Tamil [ta]
    //! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404
    var Ph = { 1: "௧", 2: "௨", 3: "௩", 4: "௪", 5: "௫", 6: "௬", 7: "௭", 8: "௮", 9: "௯", 0: "௦" }, Qh = { "௧": "1", "௨": "2", "௩": "3", "௪": "4", "௫": "5", "௬": "6", "௭": "7", "௮": "8", "௯": "9", "௦": "0" }; a.defineLocale("ta", { months: "ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்".split("_"), monthsShort: "ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்".split("_"), weekdays: "ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை".split("_"), weekdaysShort: "ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி".split("_"), weekdaysMin: "ஞா_தி_செ_பு_வி_வெ_ச".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, HH:mm", LLLL: "dddd, D MMMM YYYY, HH:mm" }, calendar: { sameDay: "[இன்று] LT", nextDay: "[நாளை] LT", nextWeek: "dddd, LT", lastDay: "[நேற்று] LT", lastWeek: "[கடந்த வாரம்] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s இல்", past: "%s முன்", s: "ஒரு சில விநாடிகள்", m: "ஒரு நிமிடம்", mm: "%d நிமிடங்கள்", h: "ஒரு மணி நேரம்", hh: "%d மணி நேரம்", d: "ஒரு நாள்", dd: "%d நாட்கள்", M: "ஒரு மாதம்", MM: "%d மாதங்கள்", y: "ஒரு வருடம்", yy: "%d ஆண்டுகள்" }, dayOfMonthOrdinalParse: /\d{1,2}வது/, ordinal: function (a) { return a + "வது" }, preparse: function (a) { return a.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function (a) { return Qh[a] }) }, postformat: function (a) { return a.replace(/\d/g, function (a) { return Ph[a] }) }, meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/, meridiem: function (a, b, c) { return a < 2 ? " யாமம்" : a < 6 ? " வைகறை" : a < 10 ? " காலை" : a < 14 ? " நண்பகல்" : a < 18 ? " எற்பாடு" : a < 22 ? " மாலை" : " யாமம்" }, meridiemHour: function (a, b) { return 12 === a && (a = 0), "யாமம்" === b ? a < 2 ? a : a + 12 : "வைகறை" === b || "காலை" === b ? a : "நண்பகல்" === b && a >= 10 ? a : a + 12 }, week: { dow: 0, doy: 6 } }),
        //! moment.js locale configuration
        //! locale : Telugu [te]
        //! author : Krishna Chaitanya Thota : https://github.com/kcthota
        a.defineLocale("te", { months: "జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జూలై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్".split("_"), monthsShort: "జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జూలై_ఆగ._సెప్._అక్టో._నవ._డిసె.".split("_"), monthsParseExact: !0, weekdays: "ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం".split("_"), weekdaysShort: "ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని".split("_"), weekdaysMin: "ఆ_సో_మం_బు_గు_శు_శ".split("_"), longDateFormat: { LT: "A h:mm", LTS: "A h:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm", LLLL: "dddd, D MMMM YYYY, A h:mm" }, calendar: { sameDay: "[నేడు] LT", nextDay: "[రేపు] LT", nextWeek: "dddd, LT", lastDay: "[నిన్న] LT", lastWeek: "[గత] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s లో", past: "%s క్రితం", s: "కొన్ని క్షణాలు", m: "ఒక నిమిషం", mm: "%d నిమిషాలు", h: "ఒక గంట", hh: "%d గంటలు", d: "ఒక రోజు", dd: "%d రోజులు", M: "ఒక నెల", MM: "%d నెలలు", y: "ఒక సంవత్సరం", yy: "%d సంవత్సరాలు" }, dayOfMonthOrdinalParse: /\d{1,2}వ/, ordinal: "%dవ", meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/, meridiemHour: function (a, b) { return 12 === a && (a = 0), "రాత్రి" === b ? a < 4 ? a : a + 12 : "ఉదయం" === b ? a : "మధ్యాహ్నం" === b ? a >= 10 ? a : a + 12 : "సాయంత్రం" === b ? a + 12 : void 0 }, meridiem: function (a, b, c) { return a < 4 ? "రాత్రి" : a < 10 ? "ఉదయం" : a < 17 ? "మధ్యాహ్నం" : a < 20 ? "సాయంత్రం" : "రాత్రి" }, week: { dow: 0, doy: 6 } }),
        //! moment.js locale configuration
        //! locale : Tetun Dili (East Timor) [tet]
        //! author : Joshua Brooks : https://github.com/joshbrooks
        //! author : Onorio De J. Afonso : https://github.com/marobo
        a.defineLocale("tet", { months: "Janeiru_Fevereiru_Marsu_Abril_Maiu_Juniu_Juliu_Augustu_Setembru_Outubru_Novembru_Dezembru".split("_"), monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Aug_Set_Out_Nov_Dez".split("_"), weekdays: "Domingu_Segunda_Tersa_Kuarta_Kinta_Sexta_Sabadu".split("_"), weekdaysShort: "Dom_Seg_Ters_Kua_Kint_Sext_Sab".split("_"), weekdaysMin: "Do_Seg_Te_Ku_Ki_Sex_Sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Ohin iha] LT", nextDay: "[Aban iha] LT", nextWeek: "dddd [iha] LT", lastDay: "[Horiseik iha] LT", lastWeek: "dddd [semana kotuk] [iha] LT", sameElse: "L" }, relativeTime: { future: "iha %s", past: "%s liuba", s: "minutu balun", m: "minutu ida", mm: "minutus %d", h: "horas ida", hh: "horas %d", d: "loron ida", dd: "loron %d", M: "fulan ida", MM: "fulan %d", y: "tinan ida", yy: "tinan %d" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function (a) { var b = a % 10, c = 1 === ~~(a % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th"; return a + c }, week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Thai [th]
        //! author : Kridsada Thanabulpong : https://github.com/sirn
        a.defineLocale("th", { months: "มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม".split("_"), monthsShort: "ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.".split("_"), monthsParseExact: !0, weekdays: "อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์".split("_"), weekdaysShort: "อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์".split("_"), weekdaysMin: "อา._จ._อ._พ._พฤ._ศ._ส.".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY เวลา H:mm", LLLL: "วันddddที่ D MMMM YYYY เวลา H:mm" }, meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/, isPM: function (a) { return "หลังเที่ยง" === a }, meridiem: function (a, b, c) { return a < 12 ? "ก่อนเที่ยง" : "หลังเที่ยง" }, calendar: { sameDay: "[วันนี้ เวลา] LT", nextDay: "[พรุ่งนี้ เวลา] LT", nextWeek: "dddd[หน้า เวลา] LT", lastDay: "[เมื่อวานนี้ เวลา] LT", lastWeek: "[วัน]dddd[ที่แล้ว เวลา] LT", sameElse: "L" }, relativeTime: { future: "อีก %s", past: "%sที่แล้ว", s: "ไม่กี่วินาที", m: "1 นาที", mm: "%d นาที", h: "1 ชั่วโมง", hh: "%d ชั่วโมง", d: "1 วัน", dd: "%d วัน", M: "1 เดือน", MM: "%d เดือน", y: "1 ปี", yy: "%d ปี" } }),
        //! moment.js locale configuration
        //! locale : Tagalog (Philippines) [tl-ph]
        //! author : Dan Hagman : https://github.com/hagmandan
        a.defineLocale("tl-ph", { months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"), monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"), weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"), weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"), weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "MM/D/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY HH:mm", LLLL: "dddd, MMMM DD, YYYY HH:mm" }, calendar: { sameDay: "LT [ngayong araw]", nextDay: "[Bukas ng] LT", nextWeek: "LT [sa susunod na] dddd", lastDay: "LT [kahapon]", lastWeek: "LT [noong nakaraang] dddd", sameElse: "L" }, relativeTime: { future: "sa loob ng %s", past: "%s ang nakalipas", s: "ilang segundo", m: "isang minuto", mm: "%d minuto", h: "isang oras", hh: "%d oras", d: "isang araw", dd: "%d araw", M: "isang buwan", MM: "%d buwan", y: "isang taon", yy: "%d taon" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: function (a) { return a }, week: { dow: 1, doy: 4 } });
    //! moment.js locale configuration
    //! locale : Klingon [tlh]
    //! author : Dominika Kruk : https://github.com/amaranthrose
    var Rh = "pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut".split("_"); a.defineLocale("tlh", { months: "tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’".split("_"), monthsShort: "jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’".split("_"), monthsParseExact: !0, weekdays: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"), weekdaysShort: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"), weekdaysMin: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[DaHjaj] LT", nextDay: "[wa’leS] LT", nextWeek: "LLL", lastDay: "[wa’Hu’] LT", lastWeek: "LLL", sameElse: "L" }, relativeTime: { future: ie, past: je, s: "puS lup", m: "wa’ tup", mm: ke, h: "wa’ rep", hh: ke, d: "wa’ jaj", dd: ke, M: "wa’ jar", MM: ke, y: "wa’ DIS", yy: ke }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
    //! moment.js locale configuration
    //! locale : Turkish [tr]
    //! authors : Erhan Gundogan : https://github.com/erhangundogan,
    //!           Burak Yiğit Kaya: https://github.com/BYK
    var Sh = { 1: "'inci", 5: "'inci", 8: "'inci", 70: "'inci", 80: "'inci", 2: "'nci", 7: "'nci", 20: "'nci", 50: "'nci", 3: "'üncü", 4: "'üncü", 100: "'üncü", 6: "'ncı", 9: "'uncu", 10: "'uncu", 30: "'uncu", 60: "'ıncı", 90: "'ıncı" }; a.defineLocale("tr", { months: "Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık".split("_"), monthsShort: "Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara".split("_"), weekdays: "Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi".split("_"), weekdaysShort: "Paz_Pts_Sal_Çar_Per_Cum_Cts".split("_"), weekdaysMin: "Pz_Pt_Sa_Ça_Pe_Cu_Ct".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[bugün saat] LT", nextDay: "[yarın saat] LT", nextWeek: "[haftaya] dddd [saat] LT", lastDay: "[dün] LT", lastWeek: "[geçen hafta] dddd [saat] LT", sameElse: "L" }, relativeTime: { future: "%s sonra", past: "%s önce", s: "birkaç saniye", m: "bir dakika", mm: "%d dakika", h: "bir saat", hh: "%d saat", d: "bir gün", dd: "%d gün", M: "bir ay", MM: "%d ay", y: "bir yıl", yy: "%d yıl" }, dayOfMonthOrdinalParse: /\d{1,2}'(inci|nci|üncü|ncı|uncu|ıncı)/, ordinal: function (a) { if (0 === a) return a + "'ıncı"; var b = a % 10, c = a % 100 - b, d = a >= 100 ? 100 : null; return a + (Sh[b] || Sh[c] || Sh[d]) }, week: { dow: 1, doy: 7 } }),
        //! moment.js locale configuration
        //! locale : Talossan [tzl]
        //! author : Robin van der Vliet : https://github.com/robin0van0der0v
        //! author : Iustì Canun
        a.defineLocale("tzl", { months: "Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar".split("_"), monthsShort: "Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec".split("_"), weekdays: "Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi".split("_"), weekdaysShort: "Súl_Lún_Mai_Már_Xhú_Vié_Sát".split("_"), weekdaysMin: "Sú_Lú_Ma_Má_Xh_Vi_Sá".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD.MM.YYYY", LL: "D. MMMM [dallas] YYYY", LLL: "D. MMMM [dallas] YYYY HH.mm", LLLL: "dddd, [li] D. MMMM [dallas] YYYY HH.mm" }, meridiemParse: /d\'o|d\'a/i, isPM: function (a) { return "d'o" === a.toLowerCase() }, meridiem: function (a, b, c) { return a > 11 ? c ? "d'o" : "D'O" : c ? "d'a" : "D'A" }, calendar: { sameDay: "[oxhi à] LT", nextDay: "[demà à] LT", nextWeek: "dddd [à] LT", lastDay: "[ieiri à] LT", lastWeek: "[sür el] dddd [lasteu à] LT", sameElse: "L" }, relativeTime: { future: "osprei %s", past: "ja%s", s: me, m: me, mm: me, h: me, hh: me, d: me, dd: me, M: me, MM: me, y: me, yy: me }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } }),
        //! moment.js locale configuration
        //! locale : Central Atlas Tamazight Latin [tzm-latn]
        //! author : Abdel Said : https://github.com/abdelsaid
        a.defineLocale("tzm-latn", { months: "innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir".split("_"), monthsShort: "innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir".split("_"), weekdays: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"), weekdaysShort: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"), weekdaysMin: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[asdkh g] LT", nextDay: "[aska g] LT", nextWeek: "dddd [g] LT", lastDay: "[assant g] LT", lastWeek: "dddd [g] LT", sameElse: "L" }, relativeTime: { future: "dadkh s yan %s", past: "yan %s", s: "imik", m: "minuḍ", mm: "%d minuḍ", h: "saɛa", hh: "%d tassaɛin", d: "ass", dd: "%d ossan", M: "ayowr", MM: "%d iyyirn", y: "asgas", yy: "%d isgasn" }, week: { dow: 6, doy: 12 } }),
        //! moment.js locale configuration
        //! locale : Central Atlas Tamazight [tzm]
        //! author : Abdel Said : https://github.com/abdelsaid
        a.defineLocale("tzm", { months: "ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ".split("_"), monthsShort: "ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ".split("_"), weekdays: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"), weekdaysShort: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"), weekdaysMin: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[ⴰⵙⴷⵅ ⴴ] LT", nextDay: "[ⴰⵙⴽⴰ ⴴ] LT", nextWeek: "dddd [ⴴ] LT", lastDay: "[ⴰⵚⴰⵏⵜ ⴴ] LT", lastWeek: "dddd [ⴴ] LT", sameElse: "L" }, relativeTime: { future: "ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s", past: "ⵢⴰⵏ %s", s: "ⵉⵎⵉⴽ", m: "ⵎⵉⵏⵓⴺ", mm: "%d ⵎⵉⵏⵓⴺ", h: "ⵙⴰⵄⴰ", hh: "%d ⵜⴰⵙⵙⴰⵄⵉⵏ", d: "ⴰⵙⵙ", dd: "%d oⵙⵙⴰⵏ", M: "ⴰⵢoⵓⵔ", MM: "%d ⵉⵢⵢⵉⵔⵏ", y: "ⴰⵙⴳⴰⵙ", yy: "%d ⵉⵙⴳⴰⵙⵏ" }, week: { dow: 6, doy: 12 } }), a.defineLocale("uk", { months: { format: "січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня".split("_"), standalone: "січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень".split("_") }, monthsShort: "січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд".split("_"), weekdays: pe, weekdaysShort: "нд_пн_вт_ср_чт_пт_сб".split("_"), weekdaysMin: "нд_пн_вт_ср_чт_пт_сб".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY р.", LLL: "D MMMM YYYY р., HH:mm", LLLL: "dddd, D MMMM YYYY р., HH:mm" }, calendar: { sameDay: qe("[Сьогодні "), nextDay: qe("[Завтра "), lastDay: qe("[Вчора "), nextWeek: qe("[У] dddd ["), lastWeek: function () { switch (this.day()) { case 0: case 3: case 5: case 6: return qe("[Минулої] dddd [").call(this); case 1: case 2: case 4: return qe("[Минулого] dddd [").call(this) } }, sameElse: "L" }, relativeTime: { future: "за %s", past: "%s тому", s: "декілька секунд", m: oe, mm: oe, h: "годину", hh: oe, d: "день", dd: oe, M: "місяць", MM: oe, y: "рік", yy: oe }, meridiemParse: /ночі|ранку|дня|вечора/, isPM: function (a) { return /^(дня|вечора)$/.test(a) }, meridiem: function (a, b, c) { return a < 4 ? "ночі" : a < 12 ? "ранку" : a < 17 ? "дня" : "вечора" }, dayOfMonthOrdinalParse: /\d{1,2}-(й|го)/, ordinal: function (a, b) { switch (b) { case "M": case "d": case "DDD": case "w": case "W": return a + "-й"; case "D": return a + "-го"; default: return a } }, week: { dow: 1, doy: 7 } });
    //! moment.js locale configuration
    //! locale : Urdu [ur]
    //! author : Sawood Alam : https://github.com/ibnesayeed
    //! author : Zack : https://github.com/ZackVision
    var Th = ["جنوری", "فروری", "مارچ", "اپریل", "مئی", "جون", "جولائی", "اگست", "ستمبر", "اکتوبر", "نومبر", "دسمبر"], Uh = ["اتوار", "پیر", "منگل", "بدھ", "جمعرات", "جمعہ", "ہفتہ"];
    //! moment.js locale configuration
    //! locale : Uzbek Latin [uz-latn]
    //! author : Rasulbek Mirzayev : github.com/Rasulbeeek
    //! moment.js locale configuration
    //! locale : Uzbek [uz]
    //! author : Sardor Muminov : https://github.com/muminoff
    //! moment.js locale configuration
    //! locale : Vietnamese [vi]
    //! author : Bang Nguyen : https://github.com/bangnk
    //! moment.js locale configuration
    //! locale : Pseudo [x-pseudo]
    //! author : Andrew Hood : https://github.com/andrewhood125
    //! moment.js locale configuration
    //! locale : Yoruba Nigeria [yo]
    //! author : Atolagbe Abisoye : https://github.com/andela-batolagbe
    //! moment.js locale configuration
    //! locale : Chinese (China) [zh-cn]
    //! author : suupic : https://github.com/suupic
    //! author : Zeno Zeng : https://github.com/zenozeng
    //! moment.js locale configuration
    //! locale : Chinese (Hong Kong) [zh-hk]
    //! author : Ben : https://github.com/ben-lin
    //! author : Chris Lam : https://github.com/hehachris
    //! author : Konstantin : https://github.com/skfd
    //! moment.js locale configuration
    //! locale : Chinese (Taiwan) [zh-tw]
    //! author : Ben : https://github.com/ben-lin
    //! author : Chris Lam : https://github.com/hehachris
    return a.defineLocale("ur", { months: Th, monthsShort: Th, weekdays: Uh, weekdaysShort: Uh, weekdaysMin: Uh, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd، D MMMM YYYY HH:mm" }, meridiemParse: /صبح|شام/, isPM: function (a) { return "شام" === a }, meridiem: function (a, b, c) { return a < 12 ? "صبح" : "شام" }, calendar: { sameDay: "[آج بوقت] LT", nextDay: "[کل بوقت] LT", nextWeek: "dddd [بوقت] LT", lastDay: "[گذشتہ روز بوقت] LT", lastWeek: "[گذشتہ] dddd [بوقت] LT", sameElse: "L" }, relativeTime: { future: "%s بعد", past: "%s قبل", s: "چند سیکنڈ", m: "ایک منٹ", mm: "%d منٹ", h: "ایک گھنٹہ", hh: "%d گھنٹے", d: "ایک دن", dd: "%d دن", M: "ایک ماہ", MM: "%d ماہ", y: "ایک سال", yy: "%d سال" }, preparse: function (a) { return a.replace(/،/g, ",") }, postformat: function (a) { return a.replace(/,/g, "،") }, week: { dow: 1, doy: 4 } }), a.defineLocale("uz-latn", { months: "Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr".split("_"), monthsShort: "Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek".split("_"), weekdays: "Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba".split("_"), weekdaysShort: "Yak_Dush_Sesh_Chor_Pay_Jum_Shan".split("_"), weekdaysMin: "Ya_Du_Se_Cho_Pa_Ju_Sha".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "D MMMM YYYY, dddd HH:mm" }, calendar: { sameDay: "[Bugun soat] LT [da]", nextDay: "[Ertaga] LT [da]", nextWeek: "dddd [kuni soat] LT [da]", lastDay: "[Kecha soat] LT [da]", lastWeek: "[O'tgan] dddd [kuni soat] LT [da]", sameElse: "L" }, relativeTime: { future: "Yaqin %s ichida", past: "Bir necha %s oldin", s: "soniya", m: "bir daqiqa", mm: "%d daqiqa", h: "bir soat", hh: "%d soat", d: "bir kun", dd: "%d kun", M: "bir oy", MM: "%d oy", y: "bir yil", yy: "%d yil" }, week: { dow: 1, doy: 7 } }), a.defineLocale("uz", { months: "январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр".split("_"), monthsShort: "янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек".split("_"), weekdays: "Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба".split("_"), weekdaysShort: "Якш_Душ_Сеш_Чор_Пай_Жум_Шан".split("_"), weekdaysMin: "Як_Ду_Се_Чо_Па_Жу_Ша".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "D MMMM YYYY, dddd HH:mm" }, calendar: { sameDay: "[Бугун соат] LT [да]", nextDay: "[Эртага] LT [да]", nextWeek: "dddd [куни соат] LT [да]", lastDay: "[Кеча соат] LT [да]", lastWeek: "[Утган] dddd [куни соат] LT [да]", sameElse: "L" }, relativeTime: { future: "Якин %s ичида", past: "Бир неча %s олдин", s: "фурсат", m: "бир дакика", mm: "%d дакика", h: "бир соат", hh: "%d соат", d: "бир кун", dd: "%d кун", M: "бир ой", MM: "%d ой", y: "бир йил", yy: "%d йил" }, week: { dow: 1, doy: 7 } }), a.defineLocale("vi", { months: "tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12".split("_"), monthsShort: "Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12".split("_"), monthsParseExact: !0, weekdays: "chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy".split("_"), weekdaysShort: "CN_T2_T3_T4_T5_T6_T7".split("_"), weekdaysMin: "CN_T2_T3_T4_T5_T6_T7".split("_"), weekdaysParseExact: !0, meridiemParse: /sa|ch/i, isPM: function (a) { return /^ch$/i.test(a) }, meridiem: function (a, b, c) { return a < 12 ? c ? "sa" : "SA" : c ? "ch" : "CH" }, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM [năm] YYYY", LLL: "D MMMM [năm] YYYY HH:mm", LLLL: "dddd, D MMMM [năm] YYYY HH:mm", l: "DD/M/YYYY", ll: "D MMM YYYY", lll: "D MMM YYYY HH:mm", llll: "ddd, D MMM YYYY HH:mm" }, calendar: { sameDay: "[Hôm nay lúc] LT", nextDay: "[Ngày mai lúc] LT", nextWeek: "dddd [tuần tới lúc] LT", lastDay: "[Hôm qua lúc] LT", lastWeek: "dddd [tuần rồi lúc] LT", sameElse: "L" }, relativeTime: { future: "%s tới", past: "%s trước", s: "vài giây", m: "một phút", mm: "%d phút", h: "một giờ", hh: "%d giờ", d: "một ngày", dd: "%d ngày", M: "một tháng", MM: "%d tháng", y: "một năm", yy: "%d năm" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: function (a) { return a }, week: { dow: 1, doy: 4 } }), a.defineLocale("x-pseudo", { months: "J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér".split("_"), monthsShort: "J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc".split("_"), monthsParseExact: !0, weekdays: "S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý".split("_"), weekdaysShort: "S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát".split("_"), weekdaysMin: "S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[T~ódá~ý át] LT", nextDay: "[T~ómó~rró~w át] LT", nextWeek: "dddd [át] LT", lastDay: "[Ý~ést~érdá~ý át] LT", lastWeek: "[L~ást] dddd [át] LT", sameElse: "L" }, relativeTime: { future: "í~ñ %s", past: "%s á~gó", s: "á ~féw ~sécó~ñds", m: "á ~míñ~úté", mm: "%d m~íñú~tés", h: "á~ñ hó~úr", hh: "%d h~óúrs", d: "á ~dáý", dd: "%d d~áýs", M: "á ~móñ~th", MM: "%d m~óñt~hs", y: "á ~ýéár", yy: "%d ý~éárs" }, dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: function (a) { var b = a % 10, c = 1 === ~~(a % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th"; return a + c }, week: { dow: 1, doy: 4 } }), a.defineLocale("yo", { months: "Sẹ́rẹ́_Èrèlè_Ẹrẹ̀nà_Ìgbé_Èbibi_Òkùdu_Agẹmo_Ògún_Owewe_Ọ̀wàrà_Bélú_Ọ̀pẹ̀̀".split("_"), monthsShort: "Sẹ́r_Èrl_Ẹrn_Ìgb_Èbi_Òkù_Agẹ_Ògú_Owe_Ọ̀wà_Bél_Ọ̀pẹ̀̀".split("_"), weekdays: "Àìkú_Ajé_Ìsẹ́gun_Ọjọ́rú_Ọjọ́bọ_Ẹtì_Àbámẹ́ta".split("_"), weekdaysShort: "Àìk_Ajé_Ìsẹ́_Ọjr_Ọjb_Ẹtì_Àbá".split("_"), weekdaysMin: "Àì_Aj_Ìs_Ọr_Ọb_Ẹt_Àb".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[Ònì ni] LT", nextDay: "[Ọ̀la ni] LT", nextWeek: "dddd [Ọsẹ̀ tón'bọ] [ni] LT", lastDay: "[Àna ni] LT", lastWeek: "dddd [Ọsẹ̀ tólọ́] [ni] LT", sameElse: "L" }, relativeTime: { future: "ní %s", past: "%s kọjá", s: "ìsẹjú aayá die", m: "ìsẹjú kan", mm: "ìsẹjú %d", h: "wákati kan", hh: "wákati %d", d: "ọjọ́ kan", dd: "ọjọ́ %d", M: "osù kan", MM: "osù %d", y: "ọdún kan", yy: "ọdún %d" }, dayOfMonthOrdinalParse: /ọjọ́\s\d{1,2}/, ordinal: "ọjọ́ %d", week: { dow: 1, doy: 4 } }), a.defineLocale("zh-cn", { months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"), monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"), weekdaysShort: "周日_周一_周二_周三_周四_周五_周六".split("_"), weekdaysMin: "日_一_二_三_四_五_六".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY年MMMD日", LL: "YYYY年MMMD日", LLL: "YYYY年MMMD日Ah点mm分", LLLL: "YYYY年MMMD日ddddAh点mm分", l: "YYYY年MMMD日", ll: "YYYY年MMMD日", lll: "YYYY年MMMD日 HH:mm", llll: "YYYY年MMMD日dddd HH:mm" }, meridiemParse: /凌晨|早上|上午|中午|下午|晚上/, meridiemHour: function (a, b) { return 12 === a && (a = 0), "凌晨" === b || "早上" === b || "上午" === b ? a : "下午" === b || "晚上" === b ? a + 12 : a >= 11 ? a : a + 12 }, meridiem: function (a, b, c) { var d = 100 * a + b; return d < 600 ? "凌晨" : d < 900 ? "早上" : d < 1130 ? "上午" : d < 1230 ? "中午" : d < 1800 ? "下午" : "晚上" }, calendar: { sameDay: "[今天]LT", nextDay: "[明天]LT", nextWeek: "[下]ddddLT", lastDay: "[昨天]LT", lastWeek: "[上]ddddLT", sameElse: "L" }, dayOfMonthOrdinalParse: /\d{1,2}(日|月|周)/, ordinal: function (a, b) { switch (b) { case "d": case "D": case "DDD": return a + "日"; case "M": return a + "月"; case "w": case "W": return a + "周"; default: return a } }, relativeTime: { future: "%s内", past: "%s前", s: "几秒", m: "1 分钟", mm: "%d 分钟", h: "1 小时", hh: "%d 小时", d: "1 天", dd: "%d 天", M: "1 个月", MM: "%d 个月", y: "1 年", yy: "%d 年" }, week: { dow: 1, doy: 4 } }), a.defineLocale("zh-hk", { months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"), monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"), weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"), weekdaysMin: "日_一_二_三_四_五_六".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY年MMMD日", LL: "YYYY年MMMD日", LLL: "YYYY年MMMD日 HH:mm", LLLL: "YYYY年MMMD日dddd HH:mm", l: "YYYY年MMMD日", ll: "YYYY年MMMD日", lll: "YYYY年MMMD日 HH:mm", llll: "YYYY年MMMD日dddd HH:mm" }, meridiemParse: /凌晨|早上|上午|中午|下午|晚上/, meridiemHour: function (a, b) { return 12 === a && (a = 0), "凌晨" === b || "早上" === b || "上午" === b ? a : "中午" === b ? a >= 11 ? a : a + 12 : "下午" === b || "晚上" === b ? a + 12 : void 0 }, meridiem: function (a, b, c) { var d = 100 * a + b; return d < 600 ? "凌晨" : d < 900 ? "早上" : d < 1130 ? "上午" : d < 1230 ? "中午" : d < 1800 ? "下午" : "晚上" }, calendar: { sameDay: "[今天]LT", nextDay: "[明天]LT", nextWeek: "[下]ddddLT", lastDay: "[昨天]LT", lastWeek: "[上]ddddLT", sameElse: "L" }, dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/, ordinal: function (a, b) { switch (b) { case "d": case "D": case "DDD": return a + "日"; case "M": return a + "月"; case "w": case "W": return a + "週"; default: return a } }, relativeTime: { future: "%s內", past: "%s前", s: "幾秒", m: "1 分鐘", mm: "%d 分鐘", h: "1 小時", hh: "%d 小時", d: "1 天", dd: "%d 天", M: "1 個月", MM: "%d 個月", y: "1 年", yy: "%d 年" } }), a.defineLocale("zh-tw", { months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"), monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"), weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"), weekdaysMin: "日_一_二_三_四_五_六".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY年MMMD日", LL: "YYYY年MMMD日", LLL: "YYYY年MMMD日 HH:mm", LLLL: "YYYY年MMMD日dddd HH:mm", l: "YYYY年MMMD日", ll: "YYYY年MMMD日", lll: "YYYY年MMMD日 HH:mm", llll: "YYYY年MMMD日dddd HH:mm" }, meridiemParse: /凌晨|早上|上午|中午|下午|晚上/, meridiemHour: function (a, b) { return 12 === a && (a = 0), "凌晨" === b || "早上" === b || "上午" === b ? a : "中午" === b ? a >= 11 ? a : a + 12 : "下午" === b || "晚上" === b ? a + 12 : void 0 }, meridiem: function (a, b, c) { var d = 100 * a + b; return d < 600 ? "凌晨" : d < 900 ? "早上" : d < 1130 ? "上午" : d < 1230 ? "中午" : d < 1800 ? "下午" : "晚上" }, calendar: { sameDay: "[今天]LT", nextDay: "[明天]LT", nextWeek: "[下]ddddLT", lastDay: "[昨天]LT", lastWeek: "[上]ddddLT", sameElse: "L" }, dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/, ordinal: function (a, b) { switch (b) { case "d": case "D": case "DDD": return a + "日"; case "M": return a + "月"; case "w": case "W": return a + "週"; default: return a } }, relativeTime: { future: "%s內", past: "%s前", s: "幾秒", m: "1 分鐘", mm: "%d 分鐘", h: "1 小時", hh: "%d 小時", d: "1 天", dd: "%d 天", M: "1 個月", MM: "%d 個月", y: "1 年", yy: "%d 年" } }), a.locale("en"), a
});
"format amd"; !function () { "use strict"; function a(a) { return angular.isUndefined(a) || null === a } function b() { try { return require("moment") } catch (a) { throw new Error("Please install moment via npm. Please reference to: https://github.com/urish/angular-moment") } } function c(c, d) { if ("undefined" == typeof d) { if ("function" != typeof require) throw new Error("Moment cannot be found by angular-moment! Please reference to: https://github.com/urish/angular-moment"); d = b() } return c.module("angularMoment", []).constant("angularMomentConfig", { preprocess: null, timezone: null, format: null, statefulFilters: !0 }).constant("moment", d).constant("amTimeAgoConfig", { withoutSuffix: !1, serverTime: null, titleFormat: null, fullDateThreshold: null, fullDateFormat: null, fullDateThresholdUnit: "day" }).directive("amTimeAgo", ["$window", "moment", "amMoment", "amTimeAgoConfig", function (b, d, e, f) { return function (g, h, i) { function j() { var a; if (p) a = p; else if (f.serverTime) { var b = (new Date).getTime(), c = b - w + f.serverTime; a = d(c) } else a = d(); return a } function k() { q && (b.clearTimeout(q), q = null) } function l(a) { var c = j().diff(a, v), d = t && c >= t; if (d ? h.text(a.format(u)) : h.text(a.from(j(), r)), s && z && h.attr("title", a.format(s)), !d) { var e = Math.abs(j().diff(a, "minute")), f = 3600; e < 1 ? f = 1 : e < 60 ? f = 30 : e < 180 && (f = 300), q = b.setTimeout(function () { l(a) }, 1e3 * f) } } function m(a) { y && h.attr("datetime", a) } function n() { if (k(), o) { var a = e.preprocessDate(o); l(a), m(a.toISOString()) } } var o, p, q = null, r = f.withoutSuffix, s = f.titleFormat, t = f.fullDateThreshold, u = f.fullDateFormat, v = f.fullDateThresholdUnit, w = (new Date).getTime(), x = i.amTimeAgo, y = "TIME" === h[0].nodeName.toUpperCase(), z = !h.attr("title"); g.$watch(x, function (b) { return a(b) || "" === b ? (k(), void (o && (h.text(""), m(""), o = null))) : (o = b, void n()) }), c.isDefined(i.amFrom) && g.$watch(i.amFrom, function (b) { p = a(b) || "" === b ? null : d(b), n() }), c.isDefined(i.amWithoutSuffix) && g.$watch(i.amWithoutSuffix, function (a) { "boolean" == typeof a ? (r = a, n()) : r = f.withoutSuffix }), i.$observe("amFullDateThreshold", function (a) { t = a, n() }), i.$observe("amFullDateFormat", function (a) { u = a, n() }), i.$observe("amFullDateThresholdUnit", function (a) { v = a, n() }), g.$on("$destroy", function () { k() }), g.$on("amMoment:localeChanged", function () { n() }) } }]).service("amMoment", ["moment", "$rootScope", "$log", "angularMomentConfig", function (a, b, d, e) { var f = null; this.changeLocale = function (d, e) { var f = a.locale(d, e); return c.isDefined(d) && b.$broadcast("amMoment:localeChanged"), f }, this.changeTimezone = function (c) { a.tz && a.tz.setDefault ? (a.tz.setDefault(c), b.$broadcast("amMoment:timezoneChanged")) : d.warn("angular-moment: changeTimezone() works only with moment-timezone.js v0.3.0 or greater."), e.timezone = c, f = c }, this.preprocessDate = function (b) { return f !== e.timezone && this.changeTimezone(e.timezone), e.preprocess ? e.preprocess(b) : a(!isNaN(parseFloat(b)) && isFinite(b) ? parseInt(b, 10) : b) } }]).filter("amParse", ["moment", function (a) { return function (b, c) { return a(b, c) } }]).filter("amFromUnix", ["moment", function (a) { return function (b) { return a.unix(b) } }]).filter("amUtc", ["moment", function (a) { return function (b) { return a.utc(b) } }]).filter("amUtcOffset", ["amMoment", function (a) { function b(b, c) { return a.preprocessDate(b).utcOffset(c) } return b }]).filter("amLocal", ["moment", function (a) { return function (b) { return a.isMoment(b) ? b.local() : null } }]).filter("amTimezone", ["amMoment", "angularMomentConfig", "$log", function (a, b, c) { function d(b, d) { var e = a.preprocessDate(b); return d ? e.tz ? e.tz(d) : (c.warn("angular-moment: named timezone specified but moment.tz() is undefined. Did you forget to include moment-timezone.js ?"), e) : e } return d }]).filter("amCalendar", ["moment", "amMoment", "angularMomentConfig", function (b, c, d) { function e(b, d, e) { if (a(b)) return ""; var f = c.preprocessDate(b); return f.isValid() ? f.calendar(d, e) : "" } return e.$stateful = d.statefulFilters, e }]).filter("amDifference", ["moment", "amMoment", "angularMomentConfig", function (b, c, d) { function e(d, e, f, g) { if (a(d)) return ""; var h = c.preprocessDate(d), i = a(e) ? b() : c.preprocessDate(e); return h.isValid() && i.isValid() ? h.diff(i, f, g) : "" } return e.$stateful = d.statefulFilters, e }]).filter("amDateFormat", ["moment", "amMoment", "angularMomentConfig", function (b, c, d) { function e(b, d) { if (a(b)) return ""; var e = c.preprocessDate(b); return e.isValid() ? e.format(d) : "" } return e.$stateful = d.statefulFilters, e }]).filter("amDurationFormat", ["moment", "angularMomentConfig", function (b, c) { function d(c, d, e) { return a(c) ? "" : b.duration(c, d).humanize(e) } return d.$stateful = c.statefulFilters, d }]).filter("amTimeAgo", ["moment", "amMoment", "angularMomentConfig", function (b, c, d) { function e(d, e, f) { var g, h; return a(d) ? "" : (d = c.preprocessDate(d), g = b(d), g.isValid() ? (h = b(f), !a(f) && h.isValid() ? g.from(h, e) : g.fromNow(e)) : "") } return e.$stateful = d.statefulFilters, e }]).filter("amSubtract", ["moment", "angularMomentConfig", function (b, c) { function d(c, d, e) { return a(c) ? "" : b(c).subtract(parseInt(d, 10), e) } return d.$stateful = c.statefulFilters, d }]).filter("amAdd", ["moment", "angularMomentConfig", function (b, c) { function d(c, d, e) { return a(c) ? "" : b(c).add(parseInt(d, 10), e) } return d.$stateful = c.statefulFilters, d }]).filter("amStartOf", ["moment", "angularMomentConfig", function (b, c) { function d(c, d) { return a(c) ? "" : b(c).startOf(d) } return d.$stateful = c.statefulFilters, d }]).filter("amEndOf", ["moment", "angularMomentConfig", function (b, c) { function d(c, d) { return a(c) ? "" : b(c).endOf(d) } return d.$stateful = c.statefulFilters, d }]), "angularMoment" } var d = window && window.process && window.process.type; "function" == typeof define && define.amd ? define(["angular", "moment"], c) : "undefined" != typeof module && module && module.exports && "function" == typeof require && !d ? module.exports = c(require("angular"), require("moment")) : c(angular, ("undefined" != typeof global ? global : window).moment) }();
//# sourceMappingURL=angular-moment.min.js.map
/**
* @version: 2.1.25
* @author: Dan Grossman http://www.dangrossman.info/
* @copyright: Copyright (c) 2012-2017 Dan Grossman. All rights reserved.
* @license: Licensed under the MIT license. See http://www.opensource.org/licenses/mit-license.php
* @website: https://www.daterangepicker.com/
*/
// Follow the UMD template https://github.com/umdjs/umd/blob/master/templates/returnExportsGlobal.js
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Make globaly available as well
        define(['moment', 'jquery'], function (moment, jquery) {
            return (root.daterangepicker = factory(moment, jquery));
        });
    } else if (typeof module === 'object' && module.exports) {
        // Node / Browserify
        //isomorphic issue
        var jQuery = (typeof window != 'undefined') ? window.jQuery : undefined;
        if (!jQuery) {
            jQuery = require('jquery');
            if (!jQuery.fn) jQuery.fn = {};
        }
        module.exports = factory(require('moment'), jQuery);
    } else {
        // Browser globals
        root.daterangepicker = factory(root.moment, root.jQuery);
    }
}(this, function (moment, $) {
    var DateRangePicker = function (element, options, cb) {

        //default settings for options
        this.parentEl = 'body';
        this.element = $(element);
        this.startDate = moment().startOf('day');
        this.endDate = moment().endOf('day');
        this.minDate = false;
        this.maxDate = false;
        this.dateLimit = false;
        this.autoApply = false;
        this.singleDatePicker = false;
        this.showDropdowns = false;
        this.showWeekNumbers = false;
        this.showISOWeekNumbers = false;
        this.showCustomRangeLabel = true;
        this.timePicker = false;
        this.timePicker24Hour = false;
        this.timePickerIncrement = 1;
        this.timePickerSeconds = false;
        this.linkedCalendars = true;
        this.autoUpdateInput = true;
        this.alwaysShowCalendars = false;
        this.ranges = {};

        this.opens = 'right';
        if (this.element.hasClass('pull-right'))
            this.opens = 'left';

        this.drops = 'down';
        if (this.element.hasClass('dropup'))
            this.drops = 'up';

        this.buttonClasses = 'btn btn-sm';
        this.applyClass = 'btn-success';
        this.cancelClass = 'btn-default';

        this.locale = {
            direction: 'ltr',
            format: moment.localeData().longDateFormat('L'),
            separator: ' - ',
            applyLabel: 'Apply',
            cancelLabel: 'Cancel',
            weekLabel: 'W',
            customRangeLabel: 'Custom Range',
            daysOfWeek: moment.weekdaysMin(),
            monthNames: moment.monthsShort(),
            firstDay: moment.localeData().firstDayOfWeek()
        };

        this.callback = function () { };

        //some state information
        this.isShowing = false;
        this.leftCalendar = {};
        this.rightCalendar = {};

        //custom options from user
        if (typeof options !== 'object' || options === null)
            options = {};

        //allow setting options with data attributes
        //data-api options will be overwritten with custom javascript options
        options = $.extend(this.element.data(), options);

        //html template for the picker UI
        if (typeof options.template !== 'string' && !(options.template instanceof $))
            options.template = '<div class="daterangepicker dropdown-menu">' +
                '<div class="calendar left">' +
                '<div class="daterangepicker_input">' +
                '<input class="input-mini form-control" type="text" name="daterangepicker_start" value="" />' +
                '<i class="fa fa-calendar"></i>' +
                '<div class="calendar-time">' +
                '<div></div>' +
                '<i class="fa fa-clock-o glyphicon glyphicon-time"></i>' +
                '</div>' +
                '</div>' +
                '<div class="calendar-table"></div>' +
                '</div>' +
                '<div class="calendar right">' +
                '<div class="daterangepicker_input">' +
                '<input class="input-mini form-control" type="text" name="daterangepicker_end" value="" />' +
                '<i class="fa fa-calendar"></i>' +
                '<div class="calendar-time">' +
                '<div></div>' +
                '<i class="fa fa-clock-o glyphicon glyphicon-time"></i>' +
                '</div>' +
                '</div>' +
                '<div class="calendar-table"></div>' +
                '</div>' +
                '<div class="ranges">' +
                '<div class="range_inputs">' +
                '<button class="applyBtn" disabled="disabled" type="button"></button> ' +
                '<button class="cancelBtn" type="button"></button>' +
                '</div>' +
                '</div>' +
                '</div>';

        this.parentEl = (options.parentEl && $(options.parentEl).length) ? $(options.parentEl) : $(this.parentEl);
        this.container = $(options.template).appendTo(this.parentEl);

        //
        // handle all the possible options overriding defaults
        //

        if (typeof options.locale === 'object') {

            if (typeof options.locale.direction === 'string')
                this.locale.direction = options.locale.direction;

            if (typeof options.locale.format === 'string')
                this.locale.format = options.locale.format;

            if (typeof options.locale.separator === 'string')
                this.locale.separator = options.locale.separator;

            if (typeof options.locale.daysOfWeek === 'object')
                this.locale.daysOfWeek = options.locale.daysOfWeek.slice();

            if (typeof options.locale.monthNames === 'object')
                this.locale.monthNames = options.locale.monthNames.slice();

            if (typeof options.locale.firstDay === 'number')
                this.locale.firstDay = options.locale.firstDay;

            if (typeof options.locale.applyLabel === 'string')
                this.locale.applyLabel = options.locale.applyLabel;

            if (typeof options.locale.cancelLabel === 'string')
                this.locale.cancelLabel = options.locale.cancelLabel;

            if (typeof options.locale.weekLabel === 'string')
                this.locale.weekLabel = options.locale.weekLabel;

            if (typeof options.locale.customRangeLabel === 'string') {
                //Support unicode chars in the custom range name.
                var elem = document.createElement('textarea');
                elem.innerHTML = options.locale.customRangeLabel;
                var rangeHtml = elem.value;
                this.locale.customRangeLabel = rangeHtml;
            }
        }
        this.container.addClass(this.locale.direction);

        if (typeof options.startDate === 'string')
            this.startDate = moment(options.startDate, this.locale.format);

        if (typeof options.endDate === 'string')
            this.endDate = moment(options.endDate, this.locale.format);

        if (typeof options.minDate === 'string')
            this.minDate = moment(options.minDate, this.locale.format);

        if (typeof options.maxDate === 'string')
            this.maxDate = moment(options.maxDate, this.locale.format);

        if (typeof options.startDate === 'object')
            this.startDate = moment(options.startDate);

        if (typeof options.endDate === 'object')
            this.endDate = moment(options.endDate);

        if (typeof options.minDate === 'object')
            this.minDate = moment(options.minDate);

        if (typeof options.maxDate === 'object')
            this.maxDate = moment(options.maxDate);

        // sanity check for bad options
        if (this.minDate && this.startDate.isBefore(this.minDate))
            this.startDate = this.minDate.clone();

        // sanity check for bad options
        if (this.maxDate && this.endDate.isAfter(this.maxDate))
            this.endDate = this.maxDate.clone();

        if (typeof options.applyClass === 'string')
            this.applyClass = options.applyClass;

        if (typeof options.cancelClass === 'string')
            this.cancelClass = options.cancelClass;

        if (typeof options.dateLimit === 'object')
            this.dateLimit = options.dateLimit;

        if (typeof options.opens === 'string')
            this.opens = options.opens;

        if (typeof options.drops === 'string')
            this.drops = options.drops;

        if (typeof options.showWeekNumbers === 'boolean')
            this.showWeekNumbers = options.showWeekNumbers;

        if (typeof options.showISOWeekNumbers === 'boolean')
            this.showISOWeekNumbers = options.showISOWeekNumbers;

        if (typeof options.buttonClasses === 'string')
            this.buttonClasses = options.buttonClasses;

        if (typeof options.buttonClasses === 'object')
            this.buttonClasses = options.buttonClasses.join(' ');

        if (typeof options.showDropdowns === 'boolean')
            this.showDropdowns = options.showDropdowns;

        if (typeof options.showCustomRangeLabel === 'boolean')
            this.showCustomRangeLabel = options.showCustomRangeLabel;

        if (typeof options.singleDatePicker === 'boolean') {
            this.singleDatePicker = options.singleDatePicker;
            if (this.singleDatePicker)
                this.endDate = this.startDate.clone();
        }

        if (typeof options.timePicker === 'boolean')
            this.timePicker = options.timePicker;

        if (typeof options.timePickerSeconds === 'boolean')
            this.timePickerSeconds = options.timePickerSeconds;

        if (typeof options.timePickerIncrement === 'number')
            this.timePickerIncrement = options.timePickerIncrement;

        if (typeof options.timePicker24Hour === 'boolean')
            this.timePicker24Hour = options.timePicker24Hour;

        if (typeof options.autoApply === 'boolean')
            this.autoApply = options.autoApply;

        if (typeof options.autoUpdateInput === 'boolean')
            this.autoUpdateInput = options.autoUpdateInput;

        if (typeof options.linkedCalendars === 'boolean')
            this.linkedCalendars = options.linkedCalendars;

        if (typeof options.isInvalidDate === 'function')
            this.isInvalidDate = options.isInvalidDate;

        if (typeof options.isCustomDate === 'function')
            this.isCustomDate = options.isCustomDate;

        if (typeof options.alwaysShowCalendars === 'boolean')
            this.alwaysShowCalendars = options.alwaysShowCalendars;

        // update day names order to firstDay
        if (this.locale.firstDay != 0) {
            var iterator = this.locale.firstDay;
            while (iterator > 0) {
                this.locale.daysOfWeek.push(this.locale.daysOfWeek.shift());
                iterator--;
            }
        }

        var start, end, range;

        //if no start/end dates set, check if an input element contains initial values
        if (typeof options.startDate === 'undefined' && typeof options.endDate === 'undefined') {
            if ($(this.element).is('input[type=text]')) {
                var val = $(this.element).val(),
                    split = val.split(this.locale.separator);

                start = end = null;

                if (split.length == 2) {
                    start = moment(split[0], this.locale.format);
                    end = moment(split[1], this.locale.format);
                } else if (this.singleDatePicker && val !== "") {
                    start = moment(val, this.locale.format);
                    end = moment(val, this.locale.format);
                }
                if (start !== null && end !== null) {
                    this.setStartDate(start);
                    this.setEndDate(end);
                }
            }
        }

        if (typeof options.ranges === 'object') {
            for (range in options.ranges) {

                if (typeof options.ranges[range][0] === 'string')
                    start = moment(options.ranges[range][0], this.locale.format);
                else
                    start = moment(options.ranges[range][0]);

                if (typeof options.ranges[range][1] === 'string')
                    end = moment(options.ranges[range][1], this.locale.format);
                else
                    end = moment(options.ranges[range][1]);

                // If the start or end date exceed those allowed by the minDate or dateLimit
                // options, shorten the range to the allowable period.
                if (this.minDate && start.isBefore(this.minDate))
                    start = this.minDate.clone();

                var maxDate = this.maxDate;
                if (this.dateLimit && maxDate && start.clone().add(this.dateLimit).isAfter(maxDate))
                    maxDate = start.clone().add(this.dateLimit);
                if (maxDate && end.isAfter(maxDate))
                    end = maxDate.clone();

                // If the end of the range is before the minimum or the start of the range is
                // after the maximum, don't display this range option at all.
                if ((this.minDate && end.isBefore(this.minDate, this.timepicker ? 'minute' : 'day'))
                    || (maxDate && start.isAfter(maxDate, this.timepicker ? 'minute' : 'day')))
                    continue;

                //Support unicode chars in the range names.
                var elem = document.createElement('textarea');
                elem.innerHTML = range;
                var rangeHtml = elem.value;

                this.ranges[rangeHtml] = [start, end];
            }

            var list = '<ul>';
            for (range in this.ranges) {
                list += '<li data-range-key="' + range + '">' + range + '</li>';
            }
            if (this.showCustomRangeLabel) {
                list += '<li data-range-key="' + this.locale.customRangeLabel + '">' + this.locale.customRangeLabel + '</li>';
            }
            list += '</ul>';
            this.container.find('.ranges').prepend(list);
        }

        if (typeof cb === 'function') {
            this.callback = cb;
        }

        if (!this.timePicker) {
            this.startDate = this.startDate.startOf('day');
            this.endDate = this.endDate.endOf('day');
            this.container.find('.calendar-time').hide();
        }

        //can't be used together for now
        if (this.timePicker && this.autoApply)
            this.autoApply = false;

        if (this.autoApply && typeof options.ranges !== 'object') {
            this.container.find('.ranges').hide();
        } else if (this.autoApply) {
            this.container.find('.applyBtn, .cancelBtn').addClass('hide');
        }

        if (this.singleDatePicker) {
            this.container.addClass('single');
            this.container.find('.calendar.left').addClass('single');
            this.container.find('.calendar.left').show();
            this.container.find('.calendar.right').hide();
            this.container.find('.daterangepicker_input input, .daterangepicker_input > i').hide();
            if (this.timePicker) {
                this.container.find('.ranges ul').hide();
            } else {
                this.container.find('.ranges').hide();
            }
        }

        if ((typeof options.ranges === 'undefined' && !this.singleDatePicker) || this.alwaysShowCalendars) {
            this.container.addClass('show-calendar');
        }

        this.container.addClass('opens' + this.opens);

        //swap the position of the predefined ranges if opens right
        if (typeof options.ranges !== 'undefined' && this.opens == 'right') {
            this.container.find('.ranges').prependTo(this.container.find('.calendar.left').parent());
        }

        //apply CSS classes and labels to buttons
        this.container.find('.applyBtn, .cancelBtn').addClass(this.buttonClasses);
        if (this.applyClass.length)
            this.container.find('.applyBtn').addClass(this.applyClass);
        if (this.cancelClass.length)
            this.container.find('.cancelBtn').addClass(this.cancelClass);
        this.container.find('.applyBtn').html(this.locale.applyLabel);
        this.container.find('.cancelBtn').html(this.locale.cancelLabel);

        //
        // event listeners
        //

        this.container.find('.calendar')
            .on('click.daterangepicker', '.prev', $.proxy(this.clickPrev, this))
            .on('click.daterangepicker', '.next', $.proxy(this.clickNext, this))
            .on('mousedown.daterangepicker', 'td.available', $.proxy(this.clickDate, this))
            .on('mouseenter.daterangepicker', 'td.available', $.proxy(this.hoverDate, this))
            .on('mouseleave.daterangepicker', 'td.available', $.proxy(this.updateFormInputs, this))
            .on('change.daterangepicker', 'select.yearselect', $.proxy(this.monthOrYearChanged, this))
            .on('change.daterangepicker', 'select.monthselect', $.proxy(this.monthOrYearChanged, this))
            .on('change.daterangepicker', 'select.hourselect,select.minuteselect,select.secondselect,select.ampmselect', $.proxy(this.timeChanged, this))
            .on('click.daterangepicker', '.daterangepicker_input input', $.proxy(this.showCalendars, this))
            .on('focus.daterangepicker', '.daterangepicker_input input', $.proxy(this.formInputsFocused, this))
            .on('blur.daterangepicker', '.daterangepicker_input input', $.proxy(this.formInputsBlurred, this))
            .on('change.daterangepicker', '.daterangepicker_input input', $.proxy(this.formInputsChanged, this));

        this.container.find('.ranges')
            .on('click.daterangepicker', 'button.applyBtn', $.proxy(this.clickApply, this))
            .on('click.daterangepicker', 'button.cancelBtn', $.proxy(this.clickCancel, this))
            .on('click.daterangepicker', 'li', $.proxy(this.clickRange, this))
            .on('mouseenter.daterangepicker', 'li', $.proxy(this.hoverRange, this))
            .on('mouseleave.daterangepicker', 'li', $.proxy(this.updateFormInputs, this));

        if (this.element.is('input') || this.element.is('button')) {
            this.element.on({
                'click.daterangepicker': $.proxy(this.show, this),
                'focus.daterangepicker': $.proxy(this.show, this),
                'keyup.daterangepicker': $.proxy(this.elementChanged, this),
                'keydown.daterangepicker': $.proxy(this.keydown, this)
            });
        } else {
            this.element.on('click.daterangepicker', $.proxy(this.toggle, this));
        }

        //
        // if attached to a text input, set the initial value
        //

        if (this.element.is('input') && !this.singleDatePicker && this.autoUpdateInput) {
            this.element.val(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format));
            this.element.trigger('change');
        } else if (this.element.is('input') && this.autoUpdateInput) {
            this.element.val(this.startDate.format(this.locale.format));
            this.element.trigger('change');
        }

    };

    DateRangePicker.prototype = {

        constructor: DateRangePicker,

        setStartDate: function (startDate) {
            if (typeof startDate === 'string')
                this.startDate = moment(startDate, this.locale.format);

            if (typeof startDate === 'object')
                this.startDate = moment(startDate);

            if (!this.timePicker)
                this.startDate = this.startDate.startOf('day');

            if (this.timePicker && this.timePickerIncrement)
                this.startDate.minute(Math.round(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);

            if (this.minDate && this.startDate.isBefore(this.minDate)) {
                this.startDate = this.minDate.clone();
                if (this.timePicker && this.timePickerIncrement)
                    this.startDate.minute(Math.round(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);
            }

            if (this.maxDate && this.startDate.isAfter(this.maxDate)) {
                this.startDate = this.maxDate.clone();
                if (this.timePicker && this.timePickerIncrement)
                    this.startDate.minute(Math.floor(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);
            }

            if (!this.isShowing)
                this.updateElement();

            this.updateMonthsInView();
        },

        setEndDate: function (endDate) {
            if (typeof endDate === 'string')
                this.endDate = moment(endDate, this.locale.format);

            if (typeof endDate === 'object')
                this.endDate = moment(endDate);

            if (!this.timePicker)
                this.endDate = this.endDate.endOf('day');

            if (this.timePicker && this.timePickerIncrement)
                this.endDate.minute(Math.round(this.endDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);

            if (this.endDate.isBefore(this.startDate))
                this.endDate = this.startDate.clone();

            if (this.maxDate && this.endDate.isAfter(this.maxDate))
                this.endDate = this.maxDate.clone();

            if (this.dateLimit && this.startDate.clone().add(this.dateLimit).isBefore(this.endDate))
                this.endDate = this.startDate.clone().add(this.dateLimit);

            this.previousRightTime = this.endDate.clone();

            if (!this.isShowing)
                this.updateElement();

            this.updateMonthsInView();
        },

        isInvalidDate: function () {
            return false;
        },

        isCustomDate: function () {
            return false;
        },

        updateView: function () {
            if (this.timePicker) {
                this.renderTimePicker('left');
                this.renderTimePicker('right');
                if (!this.endDate) {
                    this.container.find('.right .calendar-time select').attr('disabled', 'disabled').addClass('disabled');
                } else {
                    this.container.find('.right .calendar-time select').removeAttr('disabled').removeClass('disabled');
                }
            }
            if (this.endDate) {
                this.container.find('input[name="daterangepicker_end"]').removeClass('active');
                this.container.find('input[name="daterangepicker_start"]').addClass('active');
            } else {
                this.container.find('input[name="daterangepicker_end"]').addClass('active');
                this.container.find('input[name="daterangepicker_start"]').removeClass('active');
            }
            this.updateMonthsInView();
            this.updateCalendars();
            this.updateFormInputs();
        },

        updateMonthsInView: function () {
            if (this.endDate) {

                //if both dates are visible already, do nothing
                if (!this.singleDatePicker && this.leftCalendar.month && this.rightCalendar.month &&
                    (this.startDate.format('YYYY-MM') == this.leftCalendar.month.format('YYYY-MM') || this.startDate.format('YYYY-MM') == this.rightCalendar.month.format('YYYY-MM'))
                    &&
                    (this.endDate.format('YYYY-MM') == this.leftCalendar.month.format('YYYY-MM') || this.endDate.format('YYYY-MM') == this.rightCalendar.month.format('YYYY-MM'))
                ) {
                    return;
                }

                this.leftCalendar.month = this.startDate.clone().date(2);
                if (!this.linkedCalendars && (this.endDate.month() != this.startDate.month() || this.endDate.year() != this.startDate.year())) {
                    this.rightCalendar.month = this.endDate.clone().date(2);
                } else {
                    this.rightCalendar.month = this.startDate.clone().date(2).add(1, 'month');
                }

            } else {
                if (this.leftCalendar.month.format('YYYY-MM') != this.startDate.format('YYYY-MM') && this.rightCalendar.month.format('YYYY-MM') != this.startDate.format('YYYY-MM')) {
                    this.leftCalendar.month = this.startDate.clone().date(2);
                    this.rightCalendar.month = this.startDate.clone().date(2).add(1, 'month');
                }
            }
            if (this.maxDate && this.linkedCalendars && !this.singleDatePicker && this.rightCalendar.month > this.maxDate) {
                this.rightCalendar.month = this.maxDate.clone().date(2);
                this.leftCalendar.month = this.maxDate.clone().date(2).subtract(1, 'month');
            }
        },

        updateCalendars: function () {

            if (this.timePicker) {
                var hour, minute, second;
                if (this.endDate) {
                    hour = parseInt(this.container.find('.left .hourselect').val(), 10);
                    minute = parseInt(this.container.find('.left .minuteselect').val(), 10);
                    second = this.timePickerSeconds ? parseInt(this.container.find('.left .secondselect').val(), 10) : 0;
                    if (!this.timePicker24Hour) {
                        var ampm = this.container.find('.left .ampmselect').val();
                        if (ampm === 'PM' && hour < 12)
                            hour += 12;
                        if (ampm === 'AM' && hour === 12)
                            hour = 0;
                    }
                } else {
                    hour = parseInt(this.container.find('.right .hourselect').val(), 10);
                    minute = parseInt(this.container.find('.right .minuteselect').val(), 10);
                    second = this.timePickerSeconds ? parseInt(this.container.find('.right .secondselect').val(), 10) : 0;
                    if (!this.timePicker24Hour) {
                        var ampm = this.container.find('.right .ampmselect').val();
                        if (ampm === 'PM' && hour < 12)
                            hour += 12;
                        if (ampm === 'AM' && hour === 12)
                            hour = 0;
                    }
                }
                this.leftCalendar.month.hour(hour).minute(minute).second(second);
                this.rightCalendar.month.hour(hour).minute(minute).second(second);
            }

            this.renderCalendar('left');
            this.renderCalendar('right');

            //highlight any predefined range matching the current start and end dates
            this.container.find('.ranges li').removeClass('active');
            if (this.endDate == null) return;

            this.calculateChosenLabel();
        },

        renderCalendar: function (side) {

            //
            // Build the matrix of dates that will populate the calendar
            //

            var calendar = side == 'left' ? this.leftCalendar : this.rightCalendar;
            var month = calendar.month.month();
            var year = calendar.month.year();
            var hour = calendar.month.hour();
            var minute = calendar.month.minute();
            var second = calendar.month.second();
            var daysInMonth = moment([year, month]).daysInMonth();
            var firstDay = moment([year, month, 1]);
            var lastDay = moment([year, month, daysInMonth]);
            var lastMonth = moment(firstDay).subtract(1, 'month').month();
            var lastYear = moment(firstDay).subtract(1, 'month').year();
            var daysInLastMonth = moment([lastYear, lastMonth]).daysInMonth();
            var dayOfWeek = firstDay.day();

            //initialize a 6 rows x 7 columns array for the calendar
            var calendar = [];
            calendar.firstDay = firstDay;
            calendar.lastDay = lastDay;

            for (var i = 0; i < 6; i++) {
                calendar[i] = [];
            }

            //populate the calendar with date objects
            var startDay = daysInLastMonth - dayOfWeek + this.locale.firstDay + 1;
            if (startDay > daysInLastMonth)
                startDay -= 7;

            if (dayOfWeek == this.locale.firstDay)
                startDay = daysInLastMonth - 6;

            var curDate = moment([lastYear, lastMonth, startDay, 12, minute, second]);

            var col, row;
            for (var i = 0, col = 0, row = 0; i < 42; i++ , col++ , curDate = moment(curDate).add(24, 'hour')) {
                if (i > 0 && col % 7 === 0) {
                    col = 0;
                    row++;
                }
                calendar[row][col] = curDate.clone().hour(hour).minute(minute).second(second);
                curDate.hour(12);

                if (this.minDate && calendar[row][col].format('YYYY-MM-DD') == this.minDate.format('YYYY-MM-DD') && calendar[row][col].isBefore(this.minDate) && side == 'left') {
                    calendar[row][col] = this.minDate.clone();
                }

                if (this.maxDate && calendar[row][col].format('YYYY-MM-DD') == this.maxDate.format('YYYY-MM-DD') && calendar[row][col].isAfter(this.maxDate) && side == 'right') {
                    calendar[row][col] = this.maxDate.clone();
                }

            }

            //make the calendar object available to hoverDate/clickDate
            if (side == 'left') {
                this.leftCalendar.calendar = calendar;
            } else {
                this.rightCalendar.calendar = calendar;
            }

            //
            // Display the calendar
            //

            var minDate = side == 'left' ? this.minDate : this.startDate;
            var maxDate = this.maxDate;
            var selected = side == 'left' ? this.startDate : this.endDate;
            var arrow = this.locale.direction == 'ltr' ? { left: 'chevron-left', right: 'chevron-right' } : { left: 'chevron-right', right: 'chevron-left' };

            var html = '<table class="table-condensed">';
            html += '<thead>';
            html += '<tr>';

            // add empty cell for week number
            if (this.showWeekNumbers || this.showISOWeekNumbers)
                html += '<th></th>';

            if ((!minDate || minDate.isBefore(calendar.firstDay)) && (!this.linkedCalendars || side == 'left')) {
                html += '<th class="prev available"><i class="fa fa-' + arrow.left + ' glyphicon glyphicon-' + arrow.left + '"></i></th>';
            } else {
                html += '<th></th>';
            }

            var dateHtml = this.locale.monthNames[calendar[1][1].month()] + calendar[1][1].format(" YYYY");

            if (this.showDropdowns) {
                var currentMonth = calendar[1][1].month();
                var currentYear = calendar[1][1].year();
                var maxYear = (maxDate && maxDate.year()) || (currentYear + 5);
                var minYear = (minDate && minDate.year()) || (currentYear - 50);
                var inMinYear = currentYear == minYear;
                var inMaxYear = currentYear == maxYear;

                var monthHtml = '<select class="monthselect">';
                for (var m = 0; m < 12; m++) {
                    if ((!inMinYear || m >= minDate.month()) && (!inMaxYear || m <= maxDate.month())) {
                        monthHtml += "<option value='" + m + "'" +
                            (m === currentMonth ? " selected='selected'" : "") +
                            ">" + this.locale.monthNames[m] + "</option>";
                    } else {
                        monthHtml += "<option value='" + m + "'" +
                            (m === currentMonth ? " selected='selected'" : "") +
                            " disabled='disabled'>" + this.locale.monthNames[m] + "</option>";
                    }
                }
                monthHtml += "</select>";

                var yearHtml = '<select class="yearselect">';
                for (var y = minYear; y <= maxYear; y++) {
                    yearHtml += '<option value="' + y + '"' +
                        (y === currentYear ? ' selected="selected"' : '') +
                        '>' + y + '</option>';
                }
                yearHtml += '</select>';

                dateHtml = monthHtml + yearHtml;
            }

            html += '<th colspan="5" class="month">' + dateHtml + '</th>';
            if ((!maxDate || maxDate.isAfter(calendar.lastDay)) && (!this.linkedCalendars || side == 'right' || this.singleDatePicker)) {
                html += '<th class="next available"><i class="fa fa-' + arrow.right + ' glyphicon glyphicon-' + arrow.right + '"></i></th>';
            } else {
                html += '<th></th>';
            }

            html += '</tr>';
            html += '<tr>';

            // add week number label
            if (this.showWeekNumbers || this.showISOWeekNumbers)
                html += '<th class="week">' + this.locale.weekLabel + '</th>';

            $.each(this.locale.daysOfWeek, function (index, dayOfWeek) {
                html += '<th>' + dayOfWeek + '</th>';
            });

            html += '</tr>';
            html += '</thead>';
            html += '<tbody>';

            //adjust maxDate to reflect the dateLimit setting in order to
            //grey out end dates beyond the dateLimit
            if (this.endDate == null && this.dateLimit) {
                var maxLimit = this.startDate.clone().add(this.dateLimit).endOf('day');
                if (!maxDate || maxLimit.isBefore(maxDate)) {
                    maxDate = maxLimit;
                }
            }

            for (var row = 0; row < 6; row++) {
                html += '<tr>';

                // add week number
                if (this.showWeekNumbers)
                    html += '<td class="week">' + calendar[row][0].week() + '</td>';
                else if (this.showISOWeekNumbers)
                    html += '<td class="week">' + calendar[row][0].isoWeek() + '</td>';

                for (var col = 0; col < 7; col++) {

                    var classes = [];

                    //highlight today's date
                    if (calendar[row][col].isSame(new Date(), "day"))
                        classes.push('today');

                    //highlight weekends
                    if (calendar[row][col].isoWeekday() > 5)
                        classes.push('weekend');

                    //grey out the dates in other months displayed at beginning and end of this calendar
                    if (calendar[row][col].month() != calendar[1][1].month())
                        classes.push('off');

                    //don't allow selection of dates before the minimum date
                    if (this.minDate && calendar[row][col].isBefore(this.minDate, 'day'))
                        classes.push('off', 'disabled');

                    //don't allow selection of dates after the maximum date
                    if (maxDate && calendar[row][col].isAfter(maxDate, 'day'))
                        classes.push('off', 'disabled');

                    //don't allow selection of date if a custom function decides it's invalid
                    if (this.isInvalidDate(calendar[row][col]))
                        classes.push('off', 'disabled');

                    //highlight the currently selected start date
                    if (calendar[row][col].format('YYYY-MM-DD') == this.startDate.format('YYYY-MM-DD'))
                        classes.push('active', 'start-date');

                    //highlight the currently selected end date
                    if (this.endDate != null && calendar[row][col].format('YYYY-MM-DD') == this.endDate.format('YYYY-MM-DD'))
                        classes.push('active', 'end-date');

                    //highlight dates in-between the selected dates
                    if (this.endDate != null && calendar[row][col] > this.startDate && calendar[row][col] < this.endDate)
                        classes.push('in-range');

                    //apply custom classes for this date
                    var isCustom = this.isCustomDate(calendar[row][col]);
                    if (isCustom !== false) {
                        if (typeof isCustom === 'string')
                            classes.push(isCustom);
                        else
                            Array.prototype.push.apply(classes, isCustom);
                    }

                    var cname = '', disabled = false;
                    for (var i = 0; i < classes.length; i++) {
                        cname += classes[i] + ' ';
                        if (classes[i] == 'disabled')
                            disabled = true;
                    }
                    if (!disabled)
                        cname += 'available';

                    html += '<td class="' + cname.replace(/^\s+|\s+$/g, '') + '" data-title="' + 'r' + row + 'c' + col + '">' + calendar[row][col].date() + '</td>';

                }
                html += '</tr>';
            }

            html += '</tbody>';
            html += '</table>';

            this.container.find('.calendar.' + side + ' .calendar-table').html(html);

        },

        renderTimePicker: function (side) {

            // Don't bother updating the time picker if it's currently disabled
            // because an end date hasn't been clicked yet
            if (side == 'right' && !this.endDate) return;

            var html, selected, minDate, maxDate = this.maxDate;

            if (this.dateLimit && (!this.maxDate || this.startDate.clone().add(this.dateLimit).isAfter(this.maxDate)))
                maxDate = this.startDate.clone().add(this.dateLimit);

            if (side == 'left') {
                selected = this.startDate.clone();
                minDate = this.minDate;
            } else if (side == 'right') {
                selected = this.endDate.clone();
                minDate = this.startDate;

                //Preserve the time already selected
                var timeSelector = this.container.find('.calendar.right .calendar-time div');
                if (timeSelector.html() != '') {

                    selected.hour(timeSelector.find('.hourselect option:selected').val() || selected.hour());
                    selected.minute(timeSelector.find('.minuteselect option:selected').val() || selected.minute());
                    selected.second(timeSelector.find('.secondselect option:selected').val() || selected.second());

                    if (!this.timePicker24Hour) {
                        var ampm = timeSelector.find('.ampmselect option:selected').val();
                        if (ampm === 'PM' && selected.hour() < 12)
                            selected.hour(selected.hour() + 12);
                        if (ampm === 'AM' && selected.hour() === 12)
                            selected.hour(0);
                    }

                }

                if (selected.isBefore(this.startDate))
                    selected = this.startDate.clone();

                if (maxDate && selected.isAfter(maxDate))
                    selected = maxDate.clone();

            }

            //
            // hours
            //

            html = '<select class="hourselect">';

            var start = this.timePicker24Hour ? 0 : 1;
            var end = this.timePicker24Hour ? 23 : 12;

            for (var i = start; i <= end; i++) {
                var i_in_24 = i;
                if (!this.timePicker24Hour)
                    i_in_24 = selected.hour() >= 12 ? (i == 12 ? 12 : i + 12) : (i == 12 ? 0 : i);

                var time = selected.clone().hour(i_in_24);
                var disabled = false;
                if (minDate && time.minute(59).isBefore(minDate))
                    disabled = true;
                if (maxDate && time.minute(0).isAfter(maxDate))
                    disabled = true;

                if (i_in_24 == selected.hour() && !disabled) {
                    html += '<option value="' + i + '" selected="selected">' + i + '</option>';
                } else if (disabled) {
                    html += '<option value="' + i + '" disabled="disabled" class="disabled">' + i + '</option>';
                } else {
                    html += '<option value="' + i + '">' + i + '</option>';
                }
            }

            html += '</select> ';

            //
            // minutes
            //

            html += ': <select class="minuteselect">';

            for (var i = 0; i < 60; i += this.timePickerIncrement) {
                var padded = i < 10 ? '0' + i : i;
                var time = selected.clone().minute(i);

                var disabled = false;
                if (minDate && time.second(59).isBefore(minDate))
                    disabled = true;
                if (maxDate && time.second(0).isAfter(maxDate))
                    disabled = true;

                if (selected.minute() == i && !disabled) {
                    html += '<option value="' + i + '" selected="selected">' + padded + '</option>';
                } else if (disabled) {
                    html += '<option value="' + i + '" disabled="disabled" class="disabled">' + padded + '</option>';
                } else {
                    html += '<option value="' + i + '">' + padded + '</option>';
                }
            }

            html += '</select> ';

            //
            // seconds
            //

            if (this.timePickerSeconds) {
                html += ': <select class="secondselect">';

                for (var i = 0; i < 60; i++) {
                    var padded = i < 10 ? '0' + i : i;
                    var time = selected.clone().second(i);

                    var disabled = false;
                    if (minDate && time.isBefore(minDate))
                        disabled = true;
                    if (maxDate && time.isAfter(maxDate))
                        disabled = true;

                    if (selected.second() == i && !disabled) {
                        html += '<option value="' + i + '" selected="selected">' + padded + '</option>';
                    } else if (disabled) {
                        html += '<option value="' + i + '" disabled="disabled" class="disabled">' + padded + '</option>';
                    } else {
                        html += '<option value="' + i + '">' + padded + '</option>';
                    }
                }

                html += '</select> ';
            }

            //
            // AM/PM
            //

            if (!this.timePicker24Hour) {
                html += '<select class="ampmselect">';

                var am_html = '';
                var pm_html = '';

                if (minDate && selected.clone().hour(12).minute(0).second(0).isBefore(minDate))
                    am_html = ' disabled="disabled" class="disabled"';

                if (maxDate && selected.clone().hour(0).minute(0).second(0).isAfter(maxDate))
                    pm_html = ' disabled="disabled" class="disabled"';

                if (selected.hour() >= 12) {
                    html += '<option value="AM"' + am_html + '>AM</option><option value="PM" selected="selected"' + pm_html + '>PM</option>';
                } else {
                    html += '<option value="AM" selected="selected"' + am_html + '>AM</option><option value="PM"' + pm_html + '>PM</option>';
                }

                html += '</select>';
            }

            this.container.find('.calendar.' + side + ' .calendar-time div').html(html);

        },

        updateFormInputs: function () {

            //ignore mouse movements while an above-calendar text input has focus
            if (this.container.find('input[name=daterangepicker_start]').is(":focus") || this.container.find('input[name=daterangepicker_end]').is(":focus"))
                return;

            this.container.find('input[name=daterangepicker_start]').val(this.startDate.format(this.locale.format));
            if (this.endDate)
                this.container.find('input[name=daterangepicker_end]').val(this.endDate.format(this.locale.format));

            if (this.singleDatePicker || (this.endDate && (this.startDate.isBefore(this.endDate) || this.startDate.isSame(this.endDate)))) {
                this.container.find('button.applyBtn').removeAttr('disabled');
            } else {
                this.container.find('button.applyBtn').attr('disabled', 'disabled');
            }

        },

        move: function () {
            var parentOffset = { top: 0, left: 0 },
                containerTop;
            var parentRightEdge = $(window).width();
            if (!this.parentEl.is('body')) {
                parentOffset = {
                    top: this.parentEl.offset().top - this.parentEl.scrollTop(),
                    left: this.parentEl.offset().left - this.parentEl.scrollLeft()
                };
                parentRightEdge = this.parentEl[0].clientWidth + this.parentEl.offset().left;
            }

            if (this.drops == 'up')
                containerTop = this.element.offset().top - this.container.outerHeight() - parentOffset.top;
            else
                containerTop = this.element.offset().top + this.element.outerHeight() - parentOffset.top;
            this.container[this.drops == 'up' ? 'addClass' : 'removeClass']('dropup');

            if (this.opens == 'left') {
                this.container.css({
                    top: containerTop,
                    right: parentRightEdge - this.element.offset().left - this.element.outerWidth(),
                    left: 'auto'
                });
                if (this.container.offset().left < 0) {
                    this.container.css({
                        right: 'auto',
                        left: 9
                    });
                }
            } else if (this.opens == 'center') {
                this.container.css({
                    top: containerTop,
                    left: this.element.offset().left - parentOffset.left + this.element.outerWidth() / 2
                    - this.container.outerWidth() / 2,
                    right: 'auto'
                });
                if (this.container.offset().left < 0) {
                    this.container.css({
                        right: 'auto',
                        left: 9
                    });
                }
            } else {
                this.container.css({
                    top: containerTop,
                    left: this.element.offset().left - parentOffset.left,
                    right: 'auto'
                });
                if (this.container.offset().left + this.container.outerWidth() > $(window).width()) {
                    this.container.css({
                        left: 'auto',
                        right: 0
                    });
                }
            }
        },

        show: function (e) {
            if (this.isShowing) return;

            // Create a click proxy that is private to this instance of datepicker, for unbinding
            this._outsideClickProxy = $.proxy(function (e) { this.outsideClick(e); }, this);

            // Bind global datepicker mousedown for hiding and
            $(document)
                .on('mousedown.daterangepicker', this._outsideClickProxy)
                // also support mobile devices
                .on('touchend.daterangepicker', this._outsideClickProxy)
                // also explicitly play nice with Bootstrap dropdowns, which stopPropagation when clicking them
                .on('click.daterangepicker', '[data-toggle=dropdown]', this._outsideClickProxy)
                // and also close when focus changes to outside the picker (eg. tabbing between controls)
                .on('focusin.daterangepicker', this._outsideClickProxy);

            // Reposition the picker if the window is resized while it's open
            $(window).on('resize.daterangepicker', $.proxy(function (e) { this.move(e); }, this));

            this.oldStartDate = this.startDate.clone();
            this.oldEndDate = this.endDate.clone();
            this.previousRightTime = this.endDate.clone();

            this.updateView();
            this.container.show();
            this.move();
            this.element.trigger('show.daterangepicker', this);
            this.isShowing = true;
        },

        hide: function (e) {
            if (!this.isShowing) return;

            //incomplete date selection, revert to last values
            if (!this.endDate) {
                this.startDate = this.oldStartDate.clone();
                this.endDate = this.oldEndDate.clone();
            }

            //if a new date range was selected, invoke the user callback function
            if (!this.startDate.isSame(this.oldStartDate) || !this.endDate.isSame(this.oldEndDate))
                this.callback(this.startDate, this.endDate, this.chosenLabel);

            //if picker is attached to a text input, update it
            this.updateElement();

            $(document).off('.daterangepicker');
            $(window).off('.daterangepicker');
            this.container.hide();
            this.element.trigger('hide.daterangepicker', this);
            this.isShowing = false;
        },

        toggle: function (e) {
            if (this.isShowing) {
                this.hide();
            } else {
                this.show();
            }
        },

        outsideClick: function (e) {
            var target = $(e.target);
            // if the page is clicked anywhere except within the daterangerpicker/button
            // itself then call this.hide()
            if (
                // ie modal dialog fix
                e.type == "focusin" ||
                target.closest(this.element).length ||
                target.closest(this.container).length ||
                target.closest('.calendar-table').length
            ) return;
            this.hide();
            this.element.trigger('outsideClick.daterangepicker', this);
        },

        showCalendars: function () {
            this.container.addClass('show-calendar');
            this.move();
            this.element.trigger('showCalendar.daterangepicker', this);
        },

        hideCalendars: function () {
            this.container.removeClass('show-calendar');
            this.element.trigger('hideCalendar.daterangepicker', this);
        },

        hoverRange: function (e) {

            //ignore mouse movements while an above-calendar text input has focus
            if (this.container.find('input[name=daterangepicker_start]').is(":focus") || this.container.find('input[name=daterangepicker_end]').is(":focus"))
                return;

            var label = e.target.getAttribute('data-range-key');

            if (label == this.locale.customRangeLabel) {
                this.updateView();
            } else {
                var dates = this.ranges[label];
                this.container.find('input[name=daterangepicker_start]').val(dates[0].format(this.locale.format));
                this.container.find('input[name=daterangepicker_end]').val(dates[1].format(this.locale.format));
            }

        },

        clickRange: function (e) {
            var label = e.target.getAttribute('data-range-key');
            this.chosenLabel = label;
            if (label == this.locale.customRangeLabel) {
                this.showCalendars();
            } else {
                var dates = this.ranges[label];
                this.startDate = dates[0];
                this.endDate = dates[1];

                if (!this.timePicker) {
                    this.startDate.startOf('day');
                    this.endDate.endOf('day');
                }

                if (!this.alwaysShowCalendars)
                    this.hideCalendars();
                this.clickApply();
            }
        },

        clickPrev: function (e) {
            var cal = $(e.target).parents('.calendar');
            if (cal.hasClass('left')) {
                this.leftCalendar.month.subtract(1, 'month');
                if (this.linkedCalendars)
                    this.rightCalendar.month.subtract(1, 'month');
            } else {
                this.rightCalendar.month.subtract(1, 'month');
            }
            this.updateCalendars();
        },

        clickNext: function (e) {
            var cal = $(e.target).parents('.calendar');
            if (cal.hasClass('left')) {
                this.leftCalendar.month.add(1, 'month');
            } else {
                this.rightCalendar.month.add(1, 'month');
                if (this.linkedCalendars)
                    this.leftCalendar.month.add(1, 'month');
            }
            this.updateCalendars();
        },

        hoverDate: function (e) {

            //ignore mouse movements while an above-calendar text input has focus
            //if (this.container.find('input[name=daterangepicker_start]').is(":focus") || this.container.find('input[name=daterangepicker_end]').is(":focus"))
            //    return;

            //ignore dates that can't be selected
            if (!$(e.target).hasClass('available')) return;

            //have the text inputs above calendars reflect the date being hovered over
            var title = $(e.target).attr('data-title');
            var row = title.substr(1, 1);
            var col = title.substr(3, 1);
            var cal = $(e.target).parents('.calendar');
            var date = cal.hasClass('left') ? this.leftCalendar.calendar[row][col] : this.rightCalendar.calendar[row][col];

            if (this.endDate && !this.container.find('input[name=daterangepicker_start]').is(":focus")) {
                this.container.find('input[name=daterangepicker_start]').val(date.format(this.locale.format));
            } else if (!this.endDate && !this.container.find('input[name=daterangepicker_end]').is(":focus")) {
                this.container.find('input[name=daterangepicker_end]').val(date.format(this.locale.format));
            }

            //highlight the dates between the start date and the date being hovered as a potential end date
            var leftCalendar = this.leftCalendar;
            var rightCalendar = this.rightCalendar;
            var startDate = this.startDate;
            if (!this.endDate) {
                this.container.find('.calendar tbody td').each(function (index, el) {

                    //skip week numbers, only look at dates
                    if ($(el).hasClass('week')) return;

                    var title = $(el).attr('data-title');
                    var row = title.substr(1, 1);
                    var col = title.substr(3, 1);
                    var cal = $(el).parents('.calendar');
                    var dt = cal.hasClass('left') ? leftCalendar.calendar[row][col] : rightCalendar.calendar[row][col];

                    if ((dt.isAfter(startDate) && dt.isBefore(date)) || dt.isSame(date, 'day')) {
                        $(el).addClass('in-range');
                    } else {
                        $(el).removeClass('in-range');
                    }

                });
            }

        },

        clickDate: function (e) {

            if (!$(e.target).hasClass('available')) return;

            var title = $(e.target).attr('data-title');
            var row = title.substr(1, 1);
            var col = title.substr(3, 1);
            var cal = $(e.target).parents('.calendar');
            var date = cal.hasClass('left') ? this.leftCalendar.calendar[row][col] : this.rightCalendar.calendar[row][col];

            //
            // this function needs to do a few things:
            // * alternate between selecting a start and end date for the range,
            // * if the time picker is enabled, apply the hour/minute/second from the select boxes to the clicked date
            // * if autoapply is enabled, and an end date was chosen, apply the selection
            // * if single date picker mode, and time picker isn't enabled, apply the selection immediately
            // * if one of the inputs above the calendars was focused, cancel that manual input
            //

            if (this.endDate || date.isBefore(this.startDate, 'day')) { //picking start
                if (this.timePicker) {
                    var hour = parseInt(this.container.find('.left .hourselect').val(), 10);
                    if (!this.timePicker24Hour) {
                        var ampm = this.container.find('.left .ampmselect').val();
                        if (ampm === 'PM' && hour < 12)
                            hour += 12;
                        if (ampm === 'AM' && hour === 12)
                            hour = 0;
                    }
                    var minute = parseInt(this.container.find('.left .minuteselect').val(), 10);
                    var second = this.timePickerSeconds ? parseInt(this.container.find('.left .secondselect').val(), 10) : 0;
                    date = date.clone().hour(hour).minute(minute).second(second);
                }
                this.endDate = null;
                this.setStartDate(date.clone());
            } else if (!this.endDate && date.isBefore(this.startDate)) {
                //special case: clicking the same date for start/end,
                //but the time of the end date is before the start date
                this.setEndDate(this.startDate.clone());
            } else { // picking end
                if (this.timePicker) {
                    var hour = parseInt(this.container.find('.right .hourselect').val(), 10);
                    if (!this.timePicker24Hour) {
                        var ampm = this.container.find('.right .ampmselect').val();
                        if (ampm === 'PM' && hour < 12)
                            hour += 12;
                        if (ampm === 'AM' && hour === 12)
                            hour = 0;
                    }
                    var minute = parseInt(this.container.find('.right .minuteselect').val(), 10);
                    var second = this.timePickerSeconds ? parseInt(this.container.find('.right .secondselect').val(), 10) : 0;
                    date = date.clone().hour(hour).minute(minute).second(second);
                }
                this.setEndDate(date.clone());
                if (this.autoApply) {
                    this.calculateChosenLabel();
                    this.clickApply();
                }
            }

            if (this.singleDatePicker) {
                this.setEndDate(this.startDate);
                if (!this.timePicker)
                    this.clickApply();
            }

            this.updateView();

            //This is to cancel the blur event handler if the mouse was in one of the inputs
            e.stopPropagation();

        },

        calculateChosenLabel: function () {
            var customRange = true;
            var i = 0;
            for (var range in this.ranges) {
                if (this.timePicker) {
                    if (this.startDate.isSame(this.ranges[range][0]) && this.endDate.isSame(this.ranges[range][1])) {
                        customRange = false;
                        this.chosenLabel = this.container.find('.ranges li:eq(' + i + ')').addClass('active').html();
                        break;
                    }
                } else {
                    //ignore times when comparing dates if time picker is not enabled
                    if (this.startDate.format('YYYY-MM-DD') == this.ranges[range][0].format('YYYY-MM-DD') && this.endDate.format('YYYY-MM-DD') == this.ranges[range][1].format('YYYY-MM-DD')) {
                        customRange = false;
                        this.chosenLabel = this.container.find('.ranges li:eq(' + i + ')').addClass('active').html();
                        break;
                    }
                }
                i++;
            }
            if (customRange) {
                if (this.showCustomRangeLabel) {
                    this.chosenLabel = this.container.find('.ranges li:last').addClass('active').html();
                } else {
                    this.chosenLabel = null;
                }
                this.showCalendars();
            }
        },

        clickApply: function (e) {
            this.hide();
            this.element.trigger('apply.daterangepicker', this);
        },

        clickCancel: function (e) {
            this.startDate = this.oldStartDate;
            this.endDate = this.oldEndDate;
            this.hide();
            this.element.trigger('cancel.daterangepicker', this);
        },

        monthOrYearChanged: function (e) {
            var isLeft = $(e.target).closest('.calendar').hasClass('left'),
                leftOrRight = isLeft ? 'left' : 'right',
                cal = this.container.find('.calendar.' + leftOrRight);

            // Month must be Number for new moment versions
            var month = parseInt(cal.find('.monthselect').val(), 10);
            var year = cal.find('.yearselect').val();

            if (!isLeft) {
                if (year < this.startDate.year() || (year == this.startDate.year() && month < this.startDate.month())) {
                    month = this.startDate.month();
                    year = this.startDate.year();
                }
            }

            if (this.minDate) {
                if (year < this.minDate.year() || (year == this.minDate.year() && month < this.minDate.month())) {
                    month = this.minDate.month();
                    year = this.minDate.year();
                }
            }

            if (this.maxDate) {
                if (year > this.maxDate.year() || (year == this.maxDate.year() && month > this.maxDate.month())) {
                    month = this.maxDate.month();
                    year = this.maxDate.year();
                }
            }

            if (isLeft) {
                this.leftCalendar.month.month(month).year(year);
                if (this.linkedCalendars)
                    this.rightCalendar.month = this.leftCalendar.month.clone().add(1, 'month');
            } else {
                this.rightCalendar.month.month(month).year(year);
                if (this.linkedCalendars)
                    this.leftCalendar.month = this.rightCalendar.month.clone().subtract(1, 'month');
            }
            this.updateCalendars();
        },

        timeChanged: function (e) {

            var cal = $(e.target).closest('.calendar'),
                isLeft = cal.hasClass('left');

            var hour = parseInt(cal.find('.hourselect').val(), 10);
            var minute = parseInt(cal.find('.minuteselect').val(), 10);
            var second = this.timePickerSeconds ? parseInt(cal.find('.secondselect').val(), 10) : 0;

            if (!this.timePicker24Hour) {
                var ampm = cal.find('.ampmselect').val();
                if (ampm === 'PM' && hour < 12)
                    hour += 12;
                if (ampm === 'AM' && hour === 12)
                    hour = 0;
            }

            if (isLeft) {
                var start = this.startDate.clone();
                start.hour(hour);
                start.minute(minute);
                start.second(second);
                this.setStartDate(start);
                if (this.singleDatePicker) {
                    this.endDate = this.startDate.clone();
                } else if (this.endDate && this.endDate.format('YYYY-MM-DD') == start.format('YYYY-MM-DD') && this.endDate.isBefore(start)) {
                    this.setEndDate(start.clone());
                }
            } else if (this.endDate) {
                var end = this.endDate.clone();
                end.hour(hour);
                end.minute(minute);
                end.second(second);
                this.setEndDate(end);
            }

            //update the calendars so all clickable dates reflect the new time component
            this.updateCalendars();

            //update the form inputs above the calendars with the new time
            this.updateFormInputs();

            //re-render the time pickers because changing one selection can affect what's enabled in another
            this.renderTimePicker('left');
            this.renderTimePicker('right');

        },

        formInputsChanged: function (e) {
            var isRight = $(e.target).closest('.calendar').hasClass('right');
            var start = moment(this.container.find('input[name="daterangepicker_start"]').val(), this.locale.format);
            var end = moment(this.container.find('input[name="daterangepicker_end"]').val(), this.locale.format);

            if (start.isValid() && end.isValid()) {

                if (isRight && end.isBefore(start))
                    start = end.clone();

                this.setStartDate(start);
                this.setEndDate(end);

                if (isRight) {
                    this.container.find('input[name="daterangepicker_start"]').val(this.startDate.format(this.locale.format));
                } else {
                    this.container.find('input[name="daterangepicker_end"]').val(this.endDate.format(this.locale.format));
                }

            }

            this.updateView();
        },

        formInputsFocused: function (e) {

            // Highlight the focused input
            this.container.find('input[name="daterangepicker_start"], input[name="daterangepicker_end"]').removeClass('active');
            $(e.target).addClass('active');

            // Set the state such that if the user goes back to using a mouse, 
            // the calendars are aware we're selecting the end of the range, not
            // the start. This allows someone to edit the end of a date range without
            // re-selecting the beginning, by clicking on the end date input then
            // using the calendar.
            var isRight = $(e.target).closest('.calendar').hasClass('right');
            if (isRight) {
                this.endDate = null;
                this.setStartDate(this.startDate.clone());
                this.updateView();
            }

        },

        formInputsBlurred: function (e) {

            // this function has one purpose right now: if you tab from the first
            // text input to the second in the UI, the endDate is nulled so that
            // you can click another, but if you tab out without clicking anything
            // or changing the input value, the old endDate should be retained

            if (!this.endDate) {
                var val = this.container.find('input[name="daterangepicker_end"]').val();
                var end = moment(val, this.locale.format);
                if (end.isValid()) {
                    this.setEndDate(end);
                    this.updateView();
                }
            }

        },

        elementChanged: function () {
            if (!this.element.is('input')) return;
            if (!this.element.val().length) return;
            if (this.element.val().length < this.locale.format.length) return;

            var dateString = this.element.val().split(this.locale.separator),
                start = null,
                end = null;

            if (dateString.length === 2) {
                start = moment(dateString[0], this.locale.format);
                end = moment(dateString[1], this.locale.format);
            }

            if (this.singleDatePicker || start === null || end === null) {
                start = moment(this.element.val(), this.locale.format);
                end = start;
            }

            if (!start.isValid() || !end.isValid()) return;

            this.setStartDate(start);
            this.setEndDate(end);
            this.updateView();
        },

        keydown: function (e) {
            //hide on tab or enter
            if ((e.keyCode === 9) || (e.keyCode === 13)) {
                this.hide();
            }
        },

        updateElement: function () {
            if (this.element.is('input') && !this.singleDatePicker && this.autoUpdateInput) {
                this.element.val(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format));
                this.element.trigger('change');
            } else if (this.element.is('input') && this.autoUpdateInput) {
                this.element.val(this.startDate.format(this.locale.format));
                this.element.trigger('change');
            }
        },

        remove: function () {
            this.container.remove();
            this.element.off('.daterangepicker');
            this.element.removeData();
        }

    };

    $.fn.daterangepicker = function (options, callback) {
        this.each(function () {
            var el = $(this);
            if (el.data('daterangepicker'))
                el.data('daterangepicker').remove();
            el.data('daterangepicker', new DateRangePicker(el, options, callback));
        });
        return this;
    };

    return DateRangePicker;

}));

(function () { var a; a = angular.module("daterangepicker", []), a.constant("dateRangePickerConfig", { clearLabel: "Clear", locale: { separator: " - ", format: "YYYY-MM-DD" } }), a.directive("dateRangePicker", ["$compile", "$timeout", "$parse", "dateRangePickerConfig", function (a, b, c, d) { return { require: "ngModel", restrict: "A", scope: { min: "=", max: "=", model: "=ngModel", opts: "=options", clearable: "=" }, link: function (a, b, c, e) { var f, g, h, i, j, k, l, m, n, o, p, q, r, s; return i = function () { var a, b; return b = angular.extend.apply(angular, Array.prototype.slice.call(arguments).map(function (a) { return null != a ? a.locale : void 0 }).filter(function (a) { return !!a })), a = angular.extend.apply(angular, arguments), a.locale = b, a }, r = $(b), q = a.opts, s = i({}, d, q), j = null, f = function () { return j.setStartDate(), j.setEndDate() }, k = function (a) { return function (b) { return j && b ? a(moment(b)) : void 0 } }, m = k(function (a) { return j.endDate < a && j.setEndDate(a), s.startDate = a, j.setStartDate(a) }), l = k(function (a) { return j.startDate > a && j.setStartDate(a), s.endDate = a, j.setEndDate(a) }), n = function (a) { return function (b, c) { return b && c ? a(moment(b), moment(c)) : !0 } }, p = n(function (a, b) { return a.isBefore(b) || a.isSame(b, "day") }), o = n(function (a, b) { return a.isAfter(b) || a.isSame(b, "day") }), e.$formatters.push(function (a) { var b; return b = function (a) { return moment.isMoment(a) ? a.format(s.locale.format) : moment(a).format(s.locale.format) }, s.singleDatePicker && a ? b(a) : a.startDate ? [b(a.startDate), b(a.endDate)].join(s.locale.separator) : "" }), e.$render = function () { return e.$modelValue && e.$modelValue.startDate ? (m(e.$modelValue.startDate), l(e.$modelValue.endDate)) : f(), r.val(e.$viewValue) }, e.$parsers.push(function (a) { var b, c, d; return b = function (a) { return moment(a, s.locale.format) }, c = { startDate: null, endDate: null }, angular.isString(a) && a.length > 0 && (s.singleDatePicker ? c = b(a) : (d = a.split(s.locale.separator).map(b), c.startDate = d[0], c.endDate = d[1])), c }), e.$isEmpty = function (a) { return !(angular.isString(a) && a.length > 0) }, g = function () { var b, c; r.daterangepicker(angular.extend(s, { autoUpdateInput: !1 }), function (b, c) { return a.$apply(function () { return a.model = s.singleDatePicker ? b : { startDate: b, endDate: c } }) }), j = r.data("daterangepicker"), c = []; for (b in s.eventHandlers) c.push(r.on(b, function (b) { var c; return c = b.type + "." + b.namespace, a.$evalAsync(s.eventHandlers[c]) })); return c }, g(), a.$watch("model.startDate", function (a) { return m(a) }), a.$watch("model.endDate", function (a) { return l(a) }), h = function (b, d, f, h) { return c[b] ? (e.$validators[b] = function (a) { return a && d(s[h], a[f]) }, a.$watch(b, function (a) { return s[h] = a ? moment(a) : !1, g() })) : void 0 }, h("min", p, "startDate", "minDate"), h("max", o, "endDate", "maxDate"), c.options && a.$watch("opts", function (a) { return s = i(s, a), g() }, !0), c.clearable && a.$watch("clearable", function (b) { return b && (s = i(s, { locale: { cancelLabel: s.clearLabel } })), g(), b ? r.on("cancel.daterangepicker", function () { return a.$apply(function () { return a.model = s.singleDatePicker ? null : { startDate: null, endDate: null } }) }) : void 0 }), a.$on("$destroy", function () { return null != j ? j.remove() : void 0 }) } } }]) }).call(this);
//# sourceMappingURL=angular-daterangepicker.min.js.map
/*!
 * ui-select
 * http://github.com/angular-ui/ui-select
 * Version: 0.19.8 - 2017-04-18T05:43:43.673Z
 * License: MIT
 */
!function () {
    "use strict"; function e(e) { return angular.isUndefined(e) || null === e } var t = { TAB: 9, ENTER: 13, ESC: 27, SPACE: 32, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, SHIFT: 16, CTRL: 17, ALT: 18, PAGE_UP: 33, PAGE_DOWN: 34, HOME: 36, END: 35, BACKSPACE: 8, DELETE: 46, COMMAND: 91, MAP: { 91: "COMMAND", 8: "BACKSPACE", 9: "TAB", 13: "ENTER", 16: "SHIFT", 17: "CTRL", 18: "ALT", 19: "PAUSEBREAK", 20: "CAPSLOCK", 27: "ESC", 32: "SPACE", 33: "PAGE_UP", 34: "PAGE_DOWN", 35: "END", 36: "HOME", 37: "LEFT", 38: "UP", 39: "RIGHT", 40: "DOWN", 43: "+", 44: "PRINTSCREEN", 45: "INSERT", 46: "DELETE", 48: "0", 49: "1", 50: "2", 51: "3", 52: "4", 53: "5", 54: "6", 55: "7", 56: "8", 57: "9", 59: ";", 61: "=", 65: "A", 66: "B", 67: "C", 68: "D", 69: "E", 70: "F", 71: "G", 72: "H", 73: "I", 74: "J", 75: "K", 76: "L", 77: "M", 78: "N", 79: "O", 80: "P", 81: "Q", 82: "R", 83: "S", 84: "T", 85: "U", 86: "V", 87: "W", 88: "X", 89: "Y", 90: "Z", 96: "0", 97: "1", 98: "2", 99: "3", 100: "4", 101: "5", 102: "6", 103: "7", 104: "8", 105: "9", 106: "*", 107: "+", 109: "-", 110: ".", 111: "/", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NUMLOCK", 145: "SCROLLLOCK", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'" }, isControl: function (e) { var s = e.which; switch (s) { case t.COMMAND: case t.SHIFT: case t.CTRL: case t.ALT: return !0 }return !!(e.metaKey || e.ctrlKey || e.altKey) }, isFunctionKey: function (e) { return e = e.which ? e.which : e, e >= 112 && e <= 123 }, isVerticalMovement: function (e) { return ~[t.UP, t.DOWN].indexOf(e) }, isHorizontalMovement: function (e) { return ~[t.LEFT, t.RIGHT, t.BACKSPACE, t.DELETE].indexOf(e) }, toSeparator: function (e) { var s = { ENTER: "\n", TAB: "\t", SPACE: " " }[e]; return s ? s : t[e] ? void 0 : e } }; void 0 === angular.element.prototype.querySelectorAll && (angular.element.prototype.querySelectorAll = function (e) { return angular.element(this[0].querySelectorAll(e)) }), void 0 === angular.element.prototype.closest && (angular.element.prototype.closest = function (e) { for (var t = this[0], s = t.matches || t.webkitMatchesSelector || t.mozMatchesSelector || t.msMatchesSelector; t;) { if (s.bind(t)(e)) return t; t = t.parentElement } return !1 }); var s = 0, i = angular.module("ui.select", []).constant("uiSelectConfig", { theme: "bootstrap", searchEnabled: !0, sortable: !1, placeholder: "", refreshDelay: 1e3, closeOnSelect: !0, skipFocusser: !1, dropdownPosition: "auto", removeSelected: !0, resetSearchInput: !0, generateId: function () { return s++ }, appendToBody: !1, spinnerEnabled: !1, spinnerClass: "glyphicon glyphicon-refresh ui-select-spin", backspaceReset: !0 }).service("uiSelectMinErr", function () { var e = angular.$$minErr("ui.select"); return function () { var t = e.apply(this, arguments), s = t.message.replace(new RegExp("\nhttp://errors.angularjs.org/.*"), ""); return new Error(s) } }).directive("uisTranscludeAppend", function () { return { link: function (e, t, s, i, c) { c(e, function (e) { t.append(e) }) } } }).filter("highlight", function () { function e(e) { return ("" + e).replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1") } return function (t, s) { return s && t ? ("" + t).replace(new RegExp(e(s), "gi"), '<span class="ui-select-highlight">$&</span>') : t } }).factory("uisOffset", ["$document", "$window", function (e, t) { return function (s) { var i = s[0].getBoundingClientRect(); return { width: i.width || s.prop("offsetWidth"), height: i.height || s.prop("offsetHeight"), top: i.top + (t.pageYOffset || e[0].documentElement.scrollTop), left: i.left + (t.pageXOffset || e[0].documentElement.scrollLeft) } } }]); i.directive("uiSelectChoices", ["uiSelectConfig", "uisRepeatParser", "uiSelectMinErr", "$compile", "$window", function (e, t, s, i, c) { return { restrict: "EA", require: "^uiSelect", replace: !0, transclude: !0, templateUrl: function (t) { t.addClass("ui-select-choices"); var s = t.parent().attr("theme") || e.theme; return s + "/choices.tpl.html" }, compile: function (i, n) { if (!n.repeat) throw s("repeat", "Expected 'repeat' expression."); var l = n.groupBy, a = n.groupFilter; if (l) { var r = i.querySelectorAll(".ui-select-choices-group"); if (1 !== r.length) throw s("rows", "Expected 1 .ui-select-choices-group but got '{0}'.", r.length); r.attr("ng-repeat", t.getGroupNgRepeatExpression()) } var o = t.parse(n.repeat), u = i.querySelectorAll(".ui-select-choices-row"); if (1 !== u.length) throw s("rows", "Expected 1 .ui-select-choices-row but got '{0}'.", u.length); u.attr("ng-repeat", o.repeatExpression(l)).attr("ng-if", "$select.open"); var d = i.querySelectorAll(".ui-select-choices-row-inner"); if (1 !== d.length) throw s("rows", "Expected 1 .ui-select-choices-row-inner but got '{0}'.", d.length); d.attr("uis-transclude-append", ""); var p = c.document.addEventListener ? u : d; return p.attr("ng-click", "$select.select(" + o.itemName + ",$select.skipFocusser,$event)"), function (t, s, c, n) { n.parseRepeatAttr(c.repeat, l, a), n.disableChoiceExpression = c.uiDisableChoice, n.onHighlightCallback = c.onHighlight, n.minimumInputLength = parseInt(c.minimumInputLength) || 0, n.dropdownPosition = c.position ? c.position.toLowerCase() : e.dropdownPosition, t.$watch("$select.search", function (e) { e && !n.open && n.multiple && n.activate(!1, !0), n.activeIndex = n.tagging.isActivated ? -1 : 0, !c.minimumInputLength || n.search.length >= c.minimumInputLength ? n.refresh(c.refresh) : n.items = [] }), c.$observe("refreshDelay", function () { var s = t.$eval(c.refreshDelay); n.refreshDelay = void 0 !== s ? s : e.refreshDelay }), t.$watch("$select.open", function (e) { e ? (i.attr("role", "listbox"), n.refresh(c.refresh)) : s.removeAttr("role") }) } } } }]), i.controller("uiSelectCtrl", ["$scope", "$element", "$timeout", "$filter", "$$uisDebounce", "uisRepeatParser", "uiSelectMinErr", "uiSelectConfig", "$parse", "$injector", "$window", function (s, i, c, n, l, a, r, o, u, d, p) { function h(e, t, s) { if (e.findIndex) return e.findIndex(t, s); for (var i, c = Object(e), n = c.length >>> 0, l = 0; l < n; l++)if (i = c[l], t.call(s, i, l, c)) return l; return -1 } function g() { y.resetSearchInput && (y.search = x, y.selected && y.items.length && !y.multiple && (y.activeIndex = h(y.items, function (e) { return angular.equals(this, e) }, y.selected))) } function f(e, t) { var s, i, c = []; for (s = 0; s < t.length; s++)for (i = 0; i < e.length; i++)e[i].name == [t[s]] && c.push(e[i]); return c } function v(e, t) { var s = I.indexOf(e); t && s === -1 && I.push(e), !t && s > -1 && I.splice(s, 1) } function m(e) { return I.indexOf(e) > -1 } function $(e) { function t(e, t) { var s = i.indexOf(e); t && s === -1 && i.push(e), !t && s > -1 && i.splice(s, 1) } function s(e) { return i.indexOf(e) > -1 } if (e) { var i = []; y.isLocked = function (e, i) { var c = !1, n = y.selected[i]; return n && (e ? (c = !!e.$eval(y.lockChoiceExpression), t(n, c)) : c = s(n)), c } } } function b(e) { var s = !0; switch (e) { case t.DOWN: if (!y.open && y.multiple) y.activate(!1, !0); else if (y.activeIndex < y.items.length - 1) for (var i = ++y.activeIndex; m(y.items[i]) && i < y.items.length;)y.activeIndex = ++i; break; case t.UP: var c = 0 === y.search.length && y.tagging.isActivated ? -1 : 0; if (!y.open && y.multiple) y.activate(!1, !0); else if (y.activeIndex > c) for (var n = --y.activeIndex; m(y.items[n]) && n > c;)y.activeIndex = --n; break; case t.TAB: y.multiple && !y.open || y.select(y.items[y.activeIndex], !0); break; case t.ENTER: y.open && (y.tagging.isActivated || y.activeIndex >= 0) ? y.select(y.items[y.activeIndex], y.skipFocusser) : y.activate(!1, !0); break; case t.ESC: y.close(); break; default: s = !1 }return s } function w() { var e = i.querySelectorAll(".ui-select-choices-content"), t = e.querySelectorAll(".ui-select-choices-row"); if (t.length < 1) throw r("choices", "Expected multiple .ui-select-choices-row but got '{0}'.", t.length); if (!(y.activeIndex < 0)) { var s = t[y.activeIndex], c = s.offsetTop + s.clientHeight - e[0].scrollTop, n = e[0].offsetHeight; c > n ? e[0].scrollTop += c - n : c < s.clientHeight && (y.isGrouped && 0 === y.activeIndex ? e[0].scrollTop = 0 : e[0].scrollTop -= s.clientHeight - c) } } var y = this, x = ""; if (y.placeholder = o.placeholder, y.searchEnabled = o.searchEnabled, y.sortable = o.sortable, y.refreshDelay = o.refreshDelay, y.paste = o.paste, y.resetSearchInput = o.resetSearchInput, y.refreshing = !1, y.spinnerEnabled = o.spinnerEnabled, y.spinnerClass = o.spinnerClass, y.removeSelected = o.removeSelected, y.closeOnSelect = !0, y.skipFocusser = !1, y.search = x, y.activeIndex = 0, y.items = [], y.open = !1, y.focus = !1, y.disabled = !1, y.selected = void 0, y.dropdownPosition = "auto", y.focusser = void 0, y.multiple = void 0, y.disableChoiceExpression = void 0, y.tagging = { isActivated: !1, fct: void 0 }, y.taggingTokens = { isActivated: !1, tokens: void 0 }, y.lockChoiceExpression = void 0, y.clickTriggeredSelect = !1, y.$filter = n, y.$element = i, y.$animate = function () { try { return d.get("$animate") } catch (e) { return null } }(), y.searchInput = i.querySelectorAll("input.ui-select-search"), 1 !== y.searchInput.length) throw r("searchInput", "Expected 1 input.ui-select-search but got '{0}'.", y.searchInput.length); y.isEmpty = function () { return e(y.selected) || "" === y.selected || y.multiple && 0 === y.selected.length }, y.activate = function (e, t) { if (y.disabled || y.open) y.open && !y.searchEnabled && y.close(); else { t || g(), s.$broadcast("uis:activate"), y.open = !0, y.activeIndex = y.activeIndex >= y.items.length ? 0 : y.activeIndex, y.activeIndex === -1 && y.taggingLabel !== !1 && (y.activeIndex = 0); var n = i.querySelectorAll(".ui-select-choices-content"), l = i.querySelectorAll(".ui-select-search"); if (y.$animate && y.$animate.on && y.$animate.enabled(n[0])) { var a = function (t, s) { "start" === s && 0 === y.items.length ? (y.$animate.off("removeClass", l[0], a), c(function () { y.focusSearchInput(e) })) : "close" === s && (y.$animate.off("enter", n[0], a), c(function () { y.focusSearchInput(e) })) }; y.items.length > 0 ? y.$animate.on("enter", n[0], a) : y.$animate.on("removeClass", l[0], a) } else c(function () { y.focusSearchInput(e), !y.tagging.isActivated && y.items.length > 1 && w() }) } }, y.focusSearchInput = function (e) { y.search = e || y.search, y.searchInput[0].focus() }, y.findGroupByName = function (e) { return y.groups && y.groups.filter(function (t) { return t.name === e })[0] }, y.parseRepeatAttr = function (e, t, i) { function c(e) { var c = s.$eval(t); if (y.groups = [], angular.forEach(e, function (e) { var t = angular.isFunction(c) ? c(e) : e[c], s = y.findGroupByName(t); s ? s.items.push(e) : y.groups.push({ name: t, items: [e] }) }), i) { var n = s.$eval(i); angular.isFunction(n) ? y.groups = n(y.groups) : angular.isArray(n) && (y.groups = f(y.groups, n)) } y.items = [], y.groups.forEach(function (e) { y.items = y.items.concat(e.items) }) } function n(e) { y.items = e || [] } y.setItemsFn = t ? c : n, y.parserResult = a.parse(e), y.isGrouped = !!t, y.itemProperty = y.parserResult.itemName; var l = y.parserResult.source, o = function () { var e = l(s); s.$uisSource = Object.keys(e).map(function (t) { var s = {}; return s[y.parserResult.keyName] = t, s.value = e[t], s }) }; y.parserResult.keyName && (o(), y.parserResult.source = u("$uisSource" + y.parserResult.filters), s.$watch(l, function (e, t) { e !== t && o() }, !0)), y.refreshItems = function (e) { e = e || y.parserResult.source(s); var t = y.selected; if (y.isEmpty() || angular.isArray(t) && !t.length || !y.multiple || !y.removeSelected) y.setItemsFn(e); else if (void 0 !== e && null !== e) { var i = e.filter(function (e) { return angular.isArray(t) ? t.every(function (t) { return !angular.equals(e, t) }) : !angular.equals(e, t) }); y.setItemsFn(i) } "auto" !== y.dropdownPosition && "up" !== y.dropdownPosition || s.calculateDropdownPos(), s.$broadcast("uis:refresh") }, s.$watchCollection(y.parserResult.source, function (e) { if (void 0 === e || null === e) y.items = []; else { if (!angular.isArray(e)) throw r("items", "Expected an array but got '{0}'.", e); y.refreshItems(e), angular.isDefined(y.ngModel.$modelValue) && (y.ngModel.$modelValue = null) } }) }; var E; y.refresh = function (e) { void 0 !== e && (E && c.cancel(E), E = c(function () { if (s.$select.search.length >= s.$select.minimumInputLength) { var t = s.$eval(e); t && angular.isFunction(t.then) && !y.refreshing && (y.refreshing = !0, t["finally"](function () { y.refreshing = !1 })) } }, y.refreshDelay)) }, y.isActive = function (e) { if (!y.open) return !1; var t = y.items.indexOf(e[y.itemProperty]), s = t == y.activeIndex; return !(!s || t < 0) && (s && !angular.isUndefined(y.onHighlightCallback) && e.$eval(y.onHighlightCallback), s) }; var S = function (e) { return y.selected && angular.isArray(y.selected) && y.selected.filter(function (t) { return angular.equals(t, e) }).length > 0 }, I = []; y.isDisabled = function (e) { if (y.open) { var t = e[y.itemProperty], s = y.items.indexOf(t), i = !1; if (s >= 0 && (angular.isDefined(y.disableChoiceExpression) || y.multiple)) { if (t.isTag) return !1; y.multiple && (i = S(t)), !i && angular.isDefined(y.disableChoiceExpression) && (i = !!e.$eval(y.disableChoiceExpression)), v(t, i) } return i } }, y.select = function (t, i, c) { if (e(t) || !m(t)) { if (!y.items && !y.search && !y.tagging.isActivated) return; if (!t || !m(t)) { if (y.clickTriggeredSelect = !1, c && ("click" === c.type || "touchend" === c.type) && t && (y.clickTriggeredSelect = !0), y.tagging.isActivated && y.clickTriggeredSelect === !1) { if (y.taggingLabel === !1) if (y.activeIndex < 0) { if (void 0 === t && (t = void 0 !== y.tagging.fct ? y.tagging.fct(y.search) : y.search), !t || angular.equals(y.items[0], t)) return } else t = y.items[y.activeIndex]; else if (0 === y.activeIndex) { if (void 0 === t) return; if (void 0 !== y.tagging.fct && "string" == typeof t) { if (t = y.tagging.fct(t), !t) return } else "string" == typeof t && (t = t.replace(y.taggingLabel, "").trim()) } if (S(t)) return void y.close(i) } g(), s.$broadcast("uis:select", t), y.closeOnSelect && y.close(i) } } }, y.close = function (e) { y.open && (y.ngModel && y.ngModel.$setTouched && y.ngModel.$setTouched(), y.open = !1, g(), s.$broadcast("uis:close", e)) }, y.setFocus = function () { y.focus || y.focusInput[0].focus() }, y.clear = function (e) { y.select(null), e.stopPropagation(), c(function () { y.focusser[0].focus() }, 0, !1) }, y.toggle = function (e) { y.open ? (y.close(), e.preventDefault(), e.stopPropagation()) : y.activate() }, y.isLocked = function () { return !1 }, s.$watch(function () { return angular.isDefined(y.lockChoiceExpression) && "" !== y.lockChoiceExpression }, $); var C = null, k = !1; y.sizeSearchInput = function () { var e = y.searchInput[0], t = y.$element[0], i = function () { return t.clientWidth * !!e.offsetParent }, n = function (t) { if (0 === t) return !1; var s = t - e.offsetLeft; return s < 50 && (s = t), y.searchInput.css("width", s + "px"), !0 }; y.searchInput.css("width", "10px"), c(function () { null !== C || n(i()) || (C = s.$watch(function () { k || (k = !0, s.$$postDigest(function () { k = !1, n(i()) && (C(), C = null) })) }, angular.noop)) }) }, y.searchInput.on("keydown", function (e) { var i = e.which; ~[t.ENTER, t.ESC].indexOf(i) && (e.preventDefault(), e.stopPropagation()), s.$apply(function () { var s = !1; if ((y.items.length > 0 || y.tagging.isActivated) && (b(i) || y.searchEnabled || (e.preventDefault(), e.stopPropagation()), y.taggingTokens.isActivated)) { for (var n = 0; n < y.taggingTokens.tokens.length; n++)y.taggingTokens.tokens[n] === t.MAP[e.keyCode] && y.search.length > 0 && (s = !0); s && c(function () { y.searchInput.triggerHandler("tagged"); var s = y.search.replace(t.MAP[e.keyCode], "").trim(); y.tagging.fct && (s = y.tagging.fct(s)), s && y.select(s, !0) }) } }), t.isVerticalMovement(i) && y.items.length > 0 && w(), i !== t.ENTER && i !== t.ESC || (e.preventDefault(), e.stopPropagation()) }), y.searchInput.on("paste", function (e) { var s; if (s = window.clipboardData && window.clipboardData.getData ? window.clipboardData.getData("Text") : (e.originalEvent || e).clipboardData.getData("text/plain"), s = y.search + s, s && s.length > 0) if (y.taggingTokens.isActivated) { for (var i = [], c = 0; c < y.taggingTokens.tokens.length; c++) { var n = t.toSeparator(y.taggingTokens.tokens[c]) || y.taggingTokens.tokens[c]; if (s.indexOf(n) > -1) { i = s.split(n); break } } 0 === i.length && (i = [s]); var l = y.search; angular.forEach(i, function (e) { var t = y.tagging.fct ? y.tagging.fct(e) : e; t && y.select(t, !0) }), y.search = l || x, e.preventDefault(), e.stopPropagation() } else y.paste && (y.paste(s), y.search = x, e.preventDefault(), e.stopPropagation()) }), y.searchInput.on("tagged", function () { c(function () { g() }) }); var A = l(function () { y.sizeSearchInput() }, 50); angular.element(p).bind("resize", A), s.$on("$destroy", function () { y.searchInput.off("keyup keydown tagged blur paste"), angular.element(p).off("resize", A) }), s.$watch("$select.activeIndex", function (e) { e && i.find("input").attr("aria-activedescendant", "ui-select-choices-row-" + y.generatedId + "-" + e) }), s.$watch("$select.open", function (e) { e || i.find("input").removeAttr("aria-activedescendant") }) }]), i.directive("uiSelect", ["$document", "uiSelectConfig", "uiSelectMinErr", "uisOffset", "$compile", "$parse", "$timeout", function (e, t, s, i, c, n, l) { return { restrict: "EA", templateUrl: function (e, s) { var i = s.theme || t.theme; return i + (angular.isDefined(s.multiple) ? "/select-multiple.tpl.html" : "/select.tpl.html") }, replace: !0, transclude: !0, require: ["uiSelect", "^ngModel"], scope: !0, controller: "uiSelectCtrl", controllerAs: "$select", compile: function (c, a) { var r = /{(.*)}\s*{(.*)}/.exec(a.ngClass); if (r) { var o = "{" + r[1] + ", " + r[2] + "}"; a.ngClass = o, c.attr("ng-class", o) } return angular.isDefined(a.multiple) ? c.append("<ui-select-multiple/>").removeAttr("multiple") : c.append("<ui-select-single/>"), a.inputId && (c.querySelectorAll("input.ui-select-search")[0].id = a.inputId), function (c, a, r, o, u) { function d(e) { if (g.open) { var t = !1; if (t = window.jQuery ? window.jQuery.contains(a[0], e.target) : a[0].contains(e.target), !t && !g.clickTriggeredSelect) { var s; if (g.skipFocusser) s = !0; else { var i = ["input", "button", "textarea", "select"], n = angular.element(e.target).controller("uiSelect"); s = n && n !== g, s || (s = ~i.indexOf(e.target.tagName.toLowerCase())) } g.close(s), c.$digest() } g.clickTriggeredSelect = !1 } } function p() { var t = i(a); m = angular.element('<div class="ui-select-placeholder"></div>'), m[0].style.width = t.width + "px", m[0].style.height = t.height + "px", a.after(m), $ = a[0].style.width, e.find("body").append(a), a[0].style.position = "absolute", a[0].style.left = t.left + "px", a[0].style.top = t.top + "px", a[0].style.width = t.width + "px" } function h() { null !== m && (m.replaceWith(a), m = null, a[0].style.position = "", a[0].style.left = "", a[0].style.top = "", a[0].style.width = $, g.setFocus()) } var g = o[0], f = o[1]; g.generatedId = t.generateId(), g.baseTitle = r.title || "Select box", g.focusserTitle = g.baseTitle + " focus", g.focusserId = "focusser-" + g.generatedId, g.closeOnSelect = function () { return angular.isDefined(r.closeOnSelect) ? n(r.closeOnSelect)() : t.closeOnSelect }(), c.$watch("skipFocusser", function () { var e = c.$eval(r.skipFocusser); g.skipFocusser = void 0 !== e ? e : t.skipFocusser }), g.onSelectCallback = n(r.onSelect), g.onRemoveCallback = n(r.onRemove), g.ngModel = f, g.choiceGrouped = function (e) { return g.isGrouped && e && e.name }, r.tabindex && r.$observe("tabindex", function (e) { g.focusInput.attr("tabindex", e), a.removeAttr("tabindex") }), c.$watch(function () { return c.$eval(r.searchEnabled) }, function (e) { g.searchEnabled = void 0 !== e ? e : t.searchEnabled }), c.$watch("sortable", function () { var e = c.$eval(r.sortable); g.sortable = void 0 !== e ? e : t.sortable }), r.$observe("backspaceReset", function () { var e = c.$eval(r.backspaceReset); g.backspaceReset = void 0 === e || e }), r.$observe("limit", function () { g.limit = angular.isDefined(r.limit) ? parseInt(r.limit, 10) : void 0 }), c.$watch("removeSelected", function () { var e = c.$eval(r.removeSelected); g.removeSelected = void 0 !== e ? e : t.removeSelected }), r.$observe("disabled", function () { g.disabled = void 0 !== r.disabled && r.disabled }), r.$observe("resetSearchInput", function () { var e = c.$eval(r.resetSearchInput); g.resetSearchInput = void 0 === e || e }), r.$observe("paste", function () { g.paste = c.$eval(r.paste) }), r.$observe("tagging", function () { if (void 0 !== r.tagging) { var e = c.$eval(r.tagging); g.tagging = { isActivated: !0, fct: e !== !0 ? e : void 0 } } else g.tagging = { isActivated: !1, fct: void 0 } }), r.$observe("taggingLabel", function () { void 0 !== r.tagging && ("false" === r.taggingLabel ? g.taggingLabel = !1 : g.taggingLabel = void 0 !== r.taggingLabel ? r.taggingLabel : "(new)") }), r.$observe("taggingTokens", function () { if (void 0 !== r.tagging) { var e = void 0 !== r.taggingTokens ? r.taggingTokens.split("|") : [",", "ENTER"]; g.taggingTokens = { isActivated: !0, tokens: e } } }), r.$observe("spinnerEnabled", function () { var e = c.$eval(r.spinnerEnabled); g.spinnerEnabled = void 0 !== e ? e : t.spinnerEnabled }), r.$observe("spinnerClass", function () { var e = r.spinnerClass; g.spinnerClass = void 0 !== e ? r.spinnerClass : t.spinnerClass }), angular.isDefined(r.autofocus) && l(function () { g.setFocus() }), angular.isDefined(r.focusOn) && c.$on(r.focusOn, function () { l(function () { g.setFocus() }) }), e.on("click", d), c.$on("$destroy", function () { e.off("click", d) }), u(c, function (e) { var t = angular.element("<div>").append(e), i = t.querySelectorAll(".ui-select-match"); if (i.removeAttr("ui-select-match"), i.removeAttr("data-ui-select-match"), 1 !== i.length) throw s("transcluded", "Expected 1 .ui-select-match but got '{0}'.", i.length); a.querySelectorAll(".ui-select-match").replaceWith(i); var c = t.querySelectorAll(".ui-select-choices"); if (c.removeAttr("ui-select-choices"), c.removeAttr("data-ui-select-choices"), 1 !== c.length) throw s("transcluded", "Expected 1 .ui-select-choices but got '{0}'.", c.length); a.querySelectorAll(".ui-select-choices").replaceWith(c); var n = t.querySelectorAll(".ui-select-no-choice"); n.removeAttr("ui-select-no-choice"), n.removeAttr("data-ui-select-no-choice"), 1 == n.length && a.querySelectorAll(".ui-select-no-choice").replaceWith(n) }); var v = c.$eval(r.appendToBody); (void 0 !== v ? v : t.appendToBody) && (c.$watch("$select.open", function (e) { e ? p() : h() }), c.$on("$destroy", function () { h() })); var m = null, $ = "", b = null, w = "direction-up"; c.$watch("$select.open", function () { "auto" !== g.dropdownPosition && "up" !== g.dropdownPosition || c.calculateDropdownPos() }); var y = function (e, t) { e = e || i(a), t = t || i(b), b[0].style.position = "absolute", b[0].style.top = t.height * -1 + "px", a.addClass(w) }, x = function (e, t) { a.removeClass(w), e = e || i(a), t = t || i(b), b[0].style.position = "", b[0].style.top = "" }, E = function () { l(function () { if ("up" === g.dropdownPosition) y(); else { a.removeClass(w); var t = i(a), s = i(b), c = e[0].documentElement.scrollTop || e[0].body.scrollTop; t.top + t.height + s.height > c + e[0].documentElement.clientHeight ? y(t, s) : x(t, s) } b[0].style.opacity = 1 }) }, S = !1; c.calculateDropdownPos = function () { if (g.open) { if (b = angular.element(a).querySelectorAll(".ui-select-dropdown"), 0 === b.length) return; if ("" !== g.search || S || (b[0].style.opacity = 0, S = !0), !i(b).height && g.$animate && g.$animate.on && g.$animate.enabled(b)) { var e = !0; g.$animate.on("enter", b, function (t, s) { "close" === s && e && (E(), e = !1) }) } else E() } else { if (null === b || 0 === b.length) return; b[0].style.opacity = 0, b[0].style.position = "", b[0].style.top = "", a.removeClass(w) } } } } } }]), i.directive("uiSelectMatch", ["uiSelectConfig", function (e) { function t(e, t) { return e[0].hasAttribute(t) ? e.attr(t) : e[0].hasAttribute("data-" + t) ? e.attr("data-" + t) : e[0].hasAttribute("x-" + t) ? e.attr("x-" + t) : void 0 } return { restrict: "EA", require: "^uiSelect", replace: !0, transclude: !0, templateUrl: function (s) { s.addClass("ui-select-match"); var i = s.parent(), c = t(i, "theme") || e.theme, n = angular.isDefined(t(i, "multiple")); return c + (n ? "/match-multiple.tpl.html" : "/match.tpl.html") }, link: function (t, s, i, c) { function n(e) { c.allowClear = !!angular.isDefined(e) && ("" === e || "true" === e.toLowerCase()) } c.lockChoiceExpression = i.uiLockChoice, i.$observe("placeholder", function (t) { c.placeholder = void 0 !== t ? t : e.placeholder }), i.$observe("allowClear", n), n(i.allowClear), c.multiple && c.sizeSearchInput() } } }]), i.directive("uiSelectMultiple", ["uiSelectMinErr", "$timeout", function (s, i) { return { restrict: "EA", require: ["^uiSelect", "^ngModel"], controller: ["$scope", "$timeout", function (e, t) { var s, i = this, c = e.$select; angular.isUndefined(c.selected) && (c.selected = []), e.$evalAsync(function () { s = e.ngModel }), i.activeMatchIndex = -1, i.updateModel = function () { s.$setViewValue(Date.now()), i.refreshComponent() }, i.refreshComponent = function () { c.refreshItems && c.refreshItems(), c.sizeSearchInput && c.sizeSearchInput() }, i.removeChoice = function (s) { if (c.isLocked(null, s)) return !1; var n = c.selected[s], l = {}; return l[c.parserResult.itemName] = n, c.selected.splice(s, 1), i.activeMatchIndex = -1, c.sizeSearchInput(), t(function () { c.onRemoveCallback(e, { $item: n, $model: c.parserResult.modelMapper(e, l) }) }), i.updateModel(), !0 }, i.getPlaceholder = function () { if (!c.selected || !c.selected.length) return c.placeholder } }], controllerAs: "$selectMultiple", link: function (c, n, l, a) { function r(e) { return angular.isNumber(e.selectionStart) ? e.selectionStart : e.value.length } function o(e) { function s() { switch (e) { case t.LEFT: return ~g.activeMatchIndex ? u : l; case t.RIGHT: return ~g.activeMatchIndex && a !== l ? o : (p.activate(), !1); case t.BACKSPACE: return ~g.activeMatchIndex ? g.removeChoice(a) ? u : a : l; case t.DELETE: return !!~g.activeMatchIndex && (g.removeChoice(g.activeMatchIndex), a) } } var i = r(p.searchInput[0]), c = p.selected.length, n = 0, l = c - 1, a = g.activeMatchIndex, o = g.activeMatchIndex + 1, u = g.activeMatchIndex - 1, d = a; return !(i > 0 || p.search.length && e == t.RIGHT) && (p.close(), d = s(), p.selected.length && d !== !1 ? g.activeMatchIndex = Math.min(l, Math.max(n, d)) : g.activeMatchIndex = -1, !0) } function u(e) { if (void 0 === e || void 0 === p.search) return !1; var t = e.filter(function (e) { return void 0 !== p.search.toUpperCase() && void 0 !== e && e.toUpperCase() === p.search.toUpperCase() }).length > 0; return t } function d(e, t) { var s = -1; if (angular.isArray(e)) for (var i = angular.copy(e), c = 0; c < i.length; c++)if (void 0 === p.tagging.fct) i[c] + " " + p.taggingLabel === t && (s = c); else { var n = i[c]; angular.isObject(n) && (n.isTag = !0), angular.equals(n, t) && (s = c) } return s } var p = a[0], h = c.ngModel = a[1], g = c.$selectMultiple; p.multiple = !0, p.focusInput = p.searchInput, h.$isEmpty = function (e) { return !e || 0 === e.length }, h.$parsers.unshift(function () { for (var e, t = {}, s = [], i = p.selected.length - 1; i >= 0; i--)t = {}, t[p.parserResult.itemName] = p.selected[i], e = p.parserResult.modelMapper(c, t), s.unshift(e); return s }), h.$formatters.unshift(function (e) { var t, s = p.parserResult && p.parserResult.source(c, { $select: { search: "" } }), i = {}; if (!s) return e; var n = [], l = function (e, s) { if (e && e.length) { for (var l = e.length - 1; l >= 0; l--) { if (i[p.parserResult.itemName] = e[l], t = p.parserResult.modelMapper(c, i), p.parserResult.trackByExp) { var a = /(\w*)\./.exec(p.parserResult.trackByExp), r = /\.([^\s]+)/.exec(p.parserResult.trackByExp); if (a && a.length > 0 && a[1] == p.parserResult.itemName && r && r.length > 0 && t[r[1]] == s[r[1]]) return n.unshift(e[l]), !0 } if (angular.equals(t, s)) return n.unshift(e[l]), !0 } return !1 } }; if (!e) return n; for (var a = e.length - 1; a >= 0; a--)l(p.selected, e[a]) || l(s, e[a]) || n.unshift(e[a]); return n }), c.$watchCollection(function () { return h.$modelValue }, function (e, t) { t != e && (angular.isDefined(h.$modelValue) && (h.$modelValue = null), g.refreshComponent()) }), h.$render = function () { if (!angular.isArray(h.$viewValue)) { if (!e(h.$viewValue)) throw s("multiarr", "Expected model value to be array but got '{0}'", h.$viewValue); h.$viewValue = [] } p.selected = h.$viewValue, g.refreshComponent(), c.$evalAsync() }, c.$on("uis:select", function (e, t) { if (!(p.selected.length >= p.limit)) { p.selected.push(t); var s = {}; s[p.parserResult.itemName] = t, i(function () { p.onSelectCallback(c, { $item: t, $model: p.parserResult.modelMapper(c, s) }) }), g.updateModel() } }), c.$on("uis:activate", function () { g.activeMatchIndex = -1 }), c.$watch("$select.disabled", function (e, t) { t && !e && p.sizeSearchInput() }), p.searchInput.on("keydown", function (e) { var s = e.which; c.$apply(function () { var i = !1; t.isHorizontalMovement(s) && (i = o(s)), i && s != t.TAB && (e.preventDefault(), e.stopPropagation()) }) }), p.searchInput.on("keyup", function (e) { if (t.isVerticalMovement(e.which) || c.$evalAsync(function () { p.activeIndex = p.taggingLabel === !1 ? -1 : 0 }), p.tagging.isActivated && p.search.length > 0) { if (e.which === t.TAB || t.isControl(e) || t.isFunctionKey(e) || e.which === t.ESC || t.isVerticalMovement(e.which)) return; if (p.activeIndex = p.taggingLabel === !1 ? -1 : 0, p.taggingLabel === !1) return; var s, i, n, l, a = angular.copy(p.items), r = angular.copy(p.items), o = !1, h = -1; if (void 0 !== p.tagging.fct) { if (n = p.$filter("filter")(a, { isTag: !0 }), n.length > 0 && (l = n[0]), a.length > 0 && l && (o = !0, a = a.slice(1, a.length), r = r.slice(1, r.length)), s = p.tagging.fct(p.search), r.some(function (e) { return angular.equals(e, s) }) || p.selected.some(function (e) { return angular.equals(e, s) })) return void c.$evalAsync(function () { p.activeIndex = 0, p.items = a }); s && (s.isTag = !0) } else { if (n = p.$filter("filter")(a, function (e) { return e.match(p.taggingLabel) }), n.length > 0 && (l = n[0]), i = a[0], void 0 !== i && a.length > 0 && l && (o = !0, a = a.slice(1, a.length), r = r.slice(1, r.length)), s = p.search + " " + p.taggingLabel, d(p.selected, p.search) > -1) return; if (u(r.concat(p.selected))) return void (o && (a = r, c.$evalAsync(function () { p.activeIndex = 0, p.items = a }))); if (u(r)) return void (o && (p.items = r.slice(1, r.length))) } o && (h = d(p.selected, s)), h > -1 ? a = a.slice(h + 1, a.length - 1) : (a = [], s && a.push(s), a = a.concat(r)), c.$evalAsync(function () { if (p.activeIndex = 0, p.items = a, p.isGrouped) { var e = s ? a.slice(1) : a; p.setItemsFn(e), s && (p.items.unshift(s), p.groups.unshift({ name: "", items: [s], tagging: !0 })) } }) } }), p.searchInput.on("blur", function () { i(function () { g.activeMatchIndex = -1 }) }) } } }]), i.directive("uiSelectNoChoice", ["uiSelectConfig", function (e) { return { restrict: "EA", require: "^uiSelect", replace: !0, transclude: !0, templateUrl: function (t) { t.addClass("ui-select-no-choice"); var s = t.parent().attr("theme") || e.theme; return s + "/no-choice.tpl.html" } } }]), i.directive("uiSelectSingle", ["$timeout", "$compile", function (s, i) { return { restrict: "EA", require: ["^uiSelect", "^ngModel"], link: function (c, n, l, a) { var r = a[0], o = a[1]; o.$parsers.unshift(function (t) { if (e(t)) return t; var s, i = {}; return i[r.parserResult.itemName] = t, s = r.parserResult.modelMapper(c, i) }), o.$formatters.unshift(function (t) { if (e(t)) return t; var s, i = r.parserResult && r.parserResult.source(c, { $select: { search: "" } }), n = {}; if (i) { var l = function (e) { return n[r.parserResult.itemName] = e, s = r.parserResult.modelMapper(c, n), s === t }; if (r.selected && l(r.selected)) return r.selected; for (var a = i.length - 1; a >= 0; a--)if (l(i[a])) return i[a] } return t }), c.$watch("$select.selected", function (e) { o.$viewValue !== e && o.$setViewValue(e) }), o.$render = function () { r.selected = o.$viewValue }, c.$on("uis:select", function (t, i) { r.selected = i; var n = {}; n[r.parserResult.itemName] = i, s(function () { r.onSelectCallback(c, { $item: i, $model: e(i) ? i : r.parserResult.modelMapper(c, n) }) }) }), c.$on("uis:close", function (e, t) { s(function () { r.focusser.prop("disabled", !1), t || r.focusser[0].focus() }, 0, !1) }), c.$on("uis:activate", function () { u.prop("disabled", !0) }); var u = angular.element("<input ng-disabled='$select.disabled' class='ui-select-focusser ui-select-offscreen' type='text' id='{{ $select.focusserId }}' aria-label='{{ $select.focusserTitle }}' aria-haspopup='true' role='button' />"); i(u)(c), r.focusser = u, r.focusInput = u, n.parent().append(u), u.bind("focus", function () { c.$evalAsync(function () { r.focus = !0 }) }), u.bind("blur", function () { c.$evalAsync(function () { r.focus = !1 }) }), u.bind("keydown", function (e) { return e.which === t.BACKSPACE && r.backspaceReset !== !1 ? (e.preventDefault(), e.stopPropagation(), r.select(void 0), void c.$apply()) : void (e.which === t.TAB || t.isControl(e) || t.isFunctionKey(e) || e.which === t.ESC || (e.which != t.DOWN && e.which != t.UP && e.which != t.ENTER && e.which != t.SPACE || (e.preventDefault(), e.stopPropagation(), r.activate()), c.$digest())) }), u.bind("keyup input", function (e) { e.which === t.TAB || t.isControl(e) || t.isFunctionKey(e) || e.which === t.ESC || e.which == t.ENTER || e.which === t.BACKSPACE || (r.activate(u.val()), u.val(""), c.$digest()) }) } } }]), i.directive("uiSelectSort", ["$timeout", "uiSelectConfig", "uiSelectMinErr", function (e, t, s) { return { require: ["^^uiSelect", "^ngModel"], link: function (t, i, c, n) { if (null === t[c.uiSelectSort]) throw s("sort", "Expected a list to sort"); var l = n[0], a = n[1], r = angular.extend({ axis: "horizontal" }, t.$eval(c.uiSelectSortOptions)), o = r.axis, u = "dragging", d = "dropping", p = "dropping-before", h = "dropping-after"; t.$watch(function () { return l.sortable }, function (e) { e ? i.attr("draggable", !0) : i.removeAttr("draggable") }), i.on("dragstart", function (e) { i.addClass(u), (e.dataTransfer || e.originalEvent.dataTransfer).setData("text", t.$index.toString()) }), i.on("dragend", function () { v(u) }); var g, f = function (e, t) { this.splice(t, 0, this.splice(e, 1)[0]) }, v = function (e) { angular.forEach(l.$element.querySelectorAll("." + e), function (t) { angular.element(t).removeClass(e) }) }, m = function (e) { e.preventDefault(); var t = "vertical" === o ? e.offsetY || e.layerY || (e.originalEvent ? e.originalEvent.offsetY : 0) : e.offsetX || e.layerX || (e.originalEvent ? e.originalEvent.offsetX : 0); t < this["vertical" === o ? "offsetHeight" : "offsetWidth"] / 2 ? (v(h), i.addClass(p)) : (v(p), i.addClass(h)) }, $ = function (t) { t.preventDefault(); var s = parseInt((t.dataTransfer || t.originalEvent.dataTransfer).getData("text"), 10); e.cancel(g), g = e(function () { b(s) }, 20) }, b = function (e) { var s = t.$eval(c.uiSelectSort), n = s[e], l = null; l = i.hasClass(p) ? e < t.$index ? t.$index - 1 : t.$index : e < t.$index ? t.$index : t.$index + 1, f.apply(s, [e, l]), a.$setViewValue(Date.now()), t.$apply(function () { t.$emit("uiSelectSort:change", { array: s, item: n, from: e, to: l }) }), v(d), v(p), v(h), i.off("drop", $) }; i.on("dragenter", function () { i.hasClass(u) || (i.addClass(d), i.on("dragover", m), i.on("drop", $)) }), i.on("dragleave", function (e) { e.target == i && (v(d), v(p), v(h), i.off("dragover", m), i.off("drop", $)) }) } } }]), i.factory("$$uisDebounce", ["$timeout", function (e) { return function (t, s) { var i; return function () { var c = this, n = Array.prototype.slice.call(arguments); i && e.cancel(i), i = e(function () { t.apply(c, n) }, s) } } }]), i.directive("uisOpenClose", ["$parse", "$timeout", function (e, t) {
        return {
            restrict: "A", require: "uiSelect", link: function (s, i, c, n) {
                n.onOpenCloseCallback = e(c.uisOpenClose), s.$watch("$select.open", function (e, i) {
                    e !== i && t(function () {
                        n.onOpenCloseCallback(s, { isOpen: e });
                    })
                })
            }
        }
    }]), i.service("uisRepeatParser", ["uiSelectMinErr", "$parse", function (e, t) { var s = this; s.parse = function (s) { var i; if (i = s.match(/^\s*(?:([\s\S]+?)\s+as\s+)?(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(\s*[\s\S]+?)?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/), !i) throw e("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", s); var c = i[5], n = ""; if (i[3]) { c = i[5].replace(/(^\()|(\)$)/g, ""); var l = i[5].match(/^\s*(?:[\s\S]+?)(?:[^\|]|\|\|)+([\s\S]*)\s*$/); l && l[1].trim() && (n = l[1], c = c.replace(n, "")) } return { itemName: i[4] || i[2], keyName: i[3], source: t(c), filters: n, trackByExp: i[6], modelMapper: t(i[1] || i[4] || i[2]), repeatExpression: function (e) { var t = this.itemName + " in " + (e ? "$group.items" : "$select.items"); return this.trackByExp && (t += " track by " + this.trackByExp), t } } }, s.getGroupNgRepeatExpression = function () { return "$group in $select.groups track by $group.name" } }])
}(), angular.module("ui.select").run(["$templateCache", function (e) { e.put("bootstrap/choices.tpl.html", '<ul class="ui-select-choices ui-select-choices-content ui-select-dropdown dropdown-menu" ng-show="$select.open && $select.items.length > 0"><li class="ui-select-choices-group" id="ui-select-choices-{{ $select.generatedId }}"><div class="divider" ng-show="$select.isGrouped && $index > 0"></div><div ng-show="$select.isGrouped" class="ui-select-choices-group-label dropdown-header" ng-bind="$group.name"></div><div ng-attr-id="ui-select-choices-row-{{ $select.generatedId }}-{{$index}}" class="ui-select-choices-row" ng-class="{active: $select.isActive(this), disabled: $select.isDisabled(this)}" role="option"><span class="ui-select-choices-row-inner"></span></div></li></ul>'), e.put("bootstrap/match-multiple.tpl.html", '<span class="ui-select-match"><span ng-repeat="$item in $select.selected track by $index"><span class="ui-select-match-item btn btn-default btn-xs" tabindex="-1" type="button" ng-disabled="$select.disabled" ng-click="$selectMultiple.activeMatchIndex = $index;" ng-class="{\'btn-primary\':$selectMultiple.activeMatchIndex === $index, \'select-locked\':$select.isLocked(this, $index)}" ui-select-sort="$select.selected"><span class="close ui-select-match-close" ng-hide="$select.disabled" ng-click="$selectMultiple.removeChoice($index)">&nbsp;&times;</span> <span uis-transclude-append=""></span></span></span></span>'), e.put("bootstrap/match.tpl.html", '<div class="ui-select-match" ng-hide="$select.open && $select.searchEnabled" ng-disabled="$select.disabled" ng-class="{\'btn-default-focus\':$select.focus}"><span tabindex="-1" class="btn btn-default form-control ui-select-toggle" aria-label="{{ $select.baseTitle }} activate" ng-disabled="$select.disabled" ng-click="$select.activate()" style="outline: 0;"><span ng-show="$select.isEmpty()" class="ui-select-placeholder text-muted">{{$select.placeholder}}</span> <span ng-hide="$select.isEmpty()" class="ui-select-match-text pull-left" ng-class="{\'ui-select-allow-clear\': $select.allowClear && !$select.isEmpty()}" ng-transclude=""></span> <i class="caret pull-right" ng-click="$select.toggle($event)"></i> <a ng-show="$select.allowClear && !$select.isEmpty() && ($select.disabled !== true)" aria-label="{{ $select.baseTitle }} clear" style="margin-right: 10px" ng-click="$select.clear($event)" class="btn btn-xs btn-link pull-right"><i class="glyphicon glyphicon-remove" aria-hidden="true"></i></a></span></div>'), e.put("bootstrap/no-choice.tpl.html", '<ul class="ui-select-no-choice dropdown-menu" ng-show="$select.items.length == 0"><li ng-transclude=""></li></ul>'), e.put("bootstrap/select-multiple.tpl.html", '<div class="ui-select-container ui-select-multiple ui-select-bootstrap dropdown form-control" ng-class="{open: $select.open}"><div><div class="ui-select-match"></div><input type="search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" class="ui-select-search input-xs" placeholder="{{$selectMultiple.getPlaceholder()}}" ng-disabled="$select.disabled" ng-click="$select.activate()" ng-model="$select.search" role="combobox" aria-expanded="{{$select.open}}" aria-label="{{$select.baseTitle}}" ng-class="{\'spinner\': $select.refreshing}" ondrop="return false;"></div><div class="ui-select-choices"></div><div class="ui-select-no-choice"></div></div>'), e.put("bootstrap/select.tpl.html", '<div class="ui-select-container ui-select-bootstrap dropdown" ng-class="{open: $select.open}"><div class="ui-select-match"></div><span ng-show="$select.open && $select.refreshing && $select.spinnerEnabled" class="ui-select-refreshing {{$select.spinnerClass}}"></span> <input type="search" autocomplete="off" tabindex="-1" aria-expanded="true" aria-label="{{ $select.baseTitle }}" aria-owns="ui-select-choices-{{ $select.generatedId }}" class="form-control ui-select-search" ng-class="{ \'ui-select-search-hidden\' : !$select.searchEnabled }" placeholder="{{$select.placeholder}}" ng-model="$select.search" ng-show="$select.open"><div class="ui-select-choices"></div><div class="ui-select-no-choice"></div></div>'), e.put("select2/choices.tpl.html", '<ul tabindex="-1" class="ui-select-choices ui-select-choices-content select2-results"><li class="ui-select-choices-group" ng-class="{\'select2-result-with-children\': $select.choiceGrouped($group) }"><div ng-show="$select.choiceGrouped($group)" class="ui-select-choices-group-label select2-result-label" ng-bind="$group.name"></div><ul id="ui-select-choices-{{ $select.generatedId }}" ng-class="{\'select2-result-sub\': $select.choiceGrouped($group), \'select2-result-single\': !$select.choiceGrouped($group) }"><li role="option" ng-attr-id="ui-select-choices-row-{{ $select.generatedId }}-{{$index}}" class="ui-select-choices-row" ng-class="{\'select2-highlighted\': $select.isActive(this), \'select2-disabled\': $select.isDisabled(this)}"><div class="select2-result-label ui-select-choices-row-inner"></div></li></ul></li></ul>'), e.put("select2/match-multiple.tpl.html", '<span class="ui-select-match"><li class="ui-select-match-item select2-search-choice" ng-repeat="$item in $select.selected track by $index" ng-class="{\'select2-search-choice-focus\':$selectMultiple.activeMatchIndex === $index, \'select2-locked\':$select.isLocked(this, $index)}" ui-select-sort="$select.selected"><span uis-transclude-append=""></span> <a href="javascript:;" class="ui-select-match-close select2-search-choice-close" ng-click="$selectMultiple.removeChoice($index)" tabindex="-1"></a></li></span>'), e.put("select2/match.tpl.html", '<a class="select2-choice ui-select-match" ng-class="{\'select2-default\': $select.isEmpty()}" ng-click="$select.toggle($event)" aria-label="{{ $select.baseTitle }} select"><span ng-show="$select.isEmpty()" class="select2-chosen">{{$select.placeholder}}</span> <span ng-hide="$select.isEmpty()" class="select2-chosen" ng-transclude=""></span> <abbr ng-if="$select.allowClear && !$select.isEmpty()" class="select2-search-choice-close" ng-click="$select.clear($event)"></abbr> <span class="select2-arrow ui-select-toggle"><b></b></span></a>'), e.put("select2/no-choice.tpl.html", '<div class="ui-select-no-choice dropdown" ng-show="$select.items.length == 0"><div class="dropdown-content"><div data-selectable="" ng-transclude=""></div></div></div>'), e.put("select2/select-multiple.tpl.html", '<div class="ui-select-container ui-select-multiple select2 select2-container select2-container-multi" ng-class="{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled}"><ul class="select2-choices"><span class="ui-select-match"></span><li class="select2-search-field"><input type="search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" role="combobox" aria-expanded="true" aria-owns="ui-select-choices-{{ $select.generatedId }}" aria-label="{{ $select.baseTitle }}" aria-activedescendant="ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}" class="select2-input ui-select-search" placeholder="{{$selectMultiple.getPlaceholder()}}" ng-disabled="$select.disabled" ng-hide="$select.disabled" ng-model="$select.search" ng-click="$select.activate()" style="width: 34px;" ondrop="return false;"></li></ul><div class="ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active" ng-class="{\'select2-display-none\': !$select.open || $select.items.length === 0}"><div class="ui-select-choices"></div></div></div>'), e.put("select2/select.tpl.html", '<div class="ui-select-container select2 select2-container" ng-class="{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled, \'select2-container-active\': $select.focus, \'select2-allowclear\': $select.allowClear && !$select.isEmpty()}"><div class="ui-select-match"></div><div class="ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active" ng-class="{\'select2-display-none\': !$select.open}"><div class="search-container" ng-class="{\'ui-select-search-hidden\':!$select.searchEnabled, \'select2-search\':$select.searchEnabled}"><input type="search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" ng-class="{\'select2-active\': $select.refreshing}" role="combobox" aria-expanded="true" aria-owns="ui-select-choices-{{ $select.generatedId }}" aria-label="{{ $select.baseTitle }}" class="ui-select-search select2-input" ng-model="$select.search"></div><div class="ui-select-choices"></div><div class="ui-select-no-choice"></div></div></div>'), e.put("selectize/choices.tpl.html", '<div ng-show="$select.open" class="ui-select-choices ui-select-dropdown selectize-dropdown" ng-class="{\'single\': !$select.multiple, \'multi\': $select.multiple}"><div class="ui-select-choices-content selectize-dropdown-content"><div class="ui-select-choices-group optgroup"><div ng-show="$select.isGrouped" class="ui-select-choices-group-label optgroup-header" ng-bind="$group.name"></div><div role="option" class="ui-select-choices-row" ng-class="{active: $select.isActive(this), disabled: $select.isDisabled(this)}"><div class="option ui-select-choices-row-inner" data-selectable=""></div></div></div></div></div>'), e.put("selectize/match-multiple.tpl.html", '<div class="ui-select-match" data-value="" ng-repeat="$item in $select.selected track by $index" ng-click="$selectMultiple.activeMatchIndex = $index;" ng-class="{\'active\':$selectMultiple.activeMatchIndex === $index}" ui-select-sort="$select.selected"><span class="ui-select-match-item" ng-class="{\'select-locked\':$select.isLocked(this, $index)}"><span uis-transclude-append=""></span> <span class="remove ui-select-match-close" ng-hide="$select.disabled" ng-click="$selectMultiple.removeChoice($index)">&times;</span></span></div>'), e.put("selectize/match.tpl.html", '<div ng-hide="$select.searchEnabled && ($select.open || $select.isEmpty())" class="ui-select-match"><span ng-show="!$select.searchEnabled && ($select.isEmpty() || $select.open)" class="ui-select-placeholder text-muted">{{$select.placeholder}}</span> <span ng-hide="$select.isEmpty() || $select.open" ng-transclude=""></span></div>'), e.put("selectize/no-choice.tpl.html", '<div class="ui-select-no-choice selectize-dropdown" ng-show="$select.items.length == 0"><div class="selectize-dropdown-content"><div data-selectable="" ng-transclude=""></div></div></div>'), e.put("selectize/select-multiple.tpl.html", '<div class="ui-select-container selectize-control multi plugin-remove_button" ng-class="{\'open\': $select.open}"><div class="selectize-input" ng-class="{\'focus\': $select.open, \'disabled\': $select.disabled, \'selectize-focus\' : $select.focus}" ng-click="$select.open && !$select.searchEnabled ? $select.toggle($event) : $select.activate()"><div class="ui-select-match"></div><input type="search" autocomplete="off" tabindex="-1" class="ui-select-search" ng-class="{\'ui-select-search-hidden\':!$select.searchEnabled}" placeholder="{{$selectMultiple.getPlaceholder()}}" ng-model="$select.search" ng-disabled="$select.disabled" aria-expanded="{{$select.open}}" aria-label="{{ $select.baseTitle }}" ondrop="return false;"></div><div class="ui-select-choices"></div><div class="ui-select-no-choice"></div></div>'), e.put("selectize/select.tpl.html", '<div class="ui-select-container selectize-control single" ng-class="{\'open\': $select.open}"><div class="selectize-input" ng-class="{\'focus\': $select.open, \'disabled\': $select.disabled, \'selectize-focus\' : $select.focus}" ng-click="$select.open && !$select.searchEnabled ? $select.toggle($event) : $select.activate()"><div class="ui-select-match"></div><input type="search" autocomplete="off" tabindex="-1" class="ui-select-search ui-select-toggle" ng-class="{\'ui-select-search-hidden\':!$select.searchEnabled}" ng-click="$select.toggle($event)" placeholder="{{$select.placeholder}}" ng-model="$select.search" ng-hide="!$select.isEmpty() && !$select.open" ng-disabled="$select.disabled" aria-label="{{ $select.baseTitle }}"></div><div class="ui-select-choices"></div><div class="ui-select-no-choice"></div></div>') }]);
//# sourceMappingURL=select.min.js.map

/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 2.3.0
 *
 * Copyright 2016 Nick Downie
 * Released under the MIT license
 * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md
 */
!function (t) { if ("object" == typeof exports && "undefined" != typeof module) module.exports = t(); else if ("function" == typeof define && define.amd) define([], t); else { var e; e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, e.Chart = t() } }(function () {
    return function t(e, a, i) { function n(r, l) { if (!a[r]) { if (!e[r]) { var s = "function" == typeof require && require; if (!l && s) return s(r, !0); if (o) return o(r, !0); var d = new Error("Cannot find module '" + r + "'"); throw d.code = "MODULE_NOT_FOUND", d } var u = a[r] = { exports: {} }; e[r][0].call(u.exports, function (t) { var a = e[r][1][t]; return n(a ? a : t) }, u, u.exports, t, e, a, i) } return a[r].exports } for (var o = "function" == typeof require && require, r = 0; r < i.length; r++)n(i[r]); return n }({
        1: [function (t, e, a) { }, {}], 2: [function (t, e, a) { function i(t) { if (t) { var e = /^#([a-fA-F0-9]{3})$/, a = /^#([a-fA-F0-9]{6})$/, i = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/, n = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/, o = /(\w+)/, r = [0, 0, 0], l = 1, s = t.match(e); if (s) { s = s[1]; for (var d = 0; d < r.length; d++)r[d] = parseInt(s[d] + s[d], 16) } else if (s = t.match(a)) { s = s[1]; for (var d = 0; d < r.length; d++)r[d] = parseInt(s.slice(2 * d, 2 * d + 2), 16) } else if (s = t.match(i)) { for (var d = 0; d < r.length; d++)r[d] = parseInt(s[d + 1]); l = parseFloat(s[4]) } else if (s = t.match(n)) { for (var d = 0; d < r.length; d++)r[d] = Math.round(2.55 * parseFloat(s[d + 1])); l = parseFloat(s[4]) } else if (s = t.match(o)) { if ("transparent" == s[1]) return [0, 0, 0, 0]; if (r = y[s[1]], !r) return } for (var d = 0; d < r.length; d++)r[d] = v(r[d], 0, 255); return l = l || 0 == l ? v(l, 0, 1) : 1, r[3] = l, r } } function n(t) { if (t) { var e = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/, a = t.match(e); if (a) { var i = parseFloat(a[4]), n = v(parseInt(a[1]), 0, 360), o = v(parseFloat(a[2]), 0, 100), r = v(parseFloat(a[3]), 0, 100), l = v(isNaN(i) ? 1 : i, 0, 1); return [n, o, r, l] } } } function o(t) { if (t) { var e = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/, a = t.match(e); if (a) { var i = parseFloat(a[4]), n = v(parseInt(a[1]), 0, 360), o = v(parseFloat(a[2]), 0, 100), r = v(parseFloat(a[3]), 0, 100), l = v(isNaN(i) ? 1 : i, 0, 1); return [n, o, r, l] } } } function r(t) { var e = i(t); return e && e.slice(0, 3) } function l(t) { var e = n(t); return e && e.slice(0, 3) } function s(t) { var e = i(t); return e ? e[3] : (e = n(t)) ? e[3] : (e = o(t)) ? e[3] : void 0 } function d(t) { return "#" + x(t[0]) + x(t[1]) + x(t[2]) } function u(t, e) { return 1 > e || t[3] && t[3] < 1 ? c(t, e) : "rgb(" + t[0] + ", " + t[1] + ", " + t[2] + ")" } function c(t, e) { return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "rgba(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + e + ")" } function h(t, e) { if (1 > e || t[3] && t[3] < 1) return f(t, e); var a = Math.round(t[0] / 255 * 100), i = Math.round(t[1] / 255 * 100), n = Math.round(t[2] / 255 * 100); return "rgb(" + a + "%, " + i + "%, " + n + "%)" } function f(t, e) { var a = Math.round(t[0] / 255 * 100), i = Math.round(t[1] / 255 * 100), n = Math.round(t[2] / 255 * 100); return "rgba(" + a + "%, " + i + "%, " + n + "%, " + (e || t[3] || 1) + ")" } function g(t, e) { return 1 > e || t[3] && t[3] < 1 ? p(t, e) : "hsl(" + t[0] + ", " + t[1] + "%, " + t[2] + "%)" } function p(t, e) { return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "hsla(" + t[0] + ", " + t[1] + "%, " + t[2] + "%, " + e + ")" } function m(t, e) { return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "hwb(" + t[0] + ", " + t[1] + "%, " + t[2] + "%" + (void 0 !== e && 1 !== e ? ", " + e : "") + ")" } function b(t) { return k[t.slice(0, 3)] } function v(t, e, a) { return Math.min(Math.max(e, t), a) } function x(t) { var e = t.toString(16).toUpperCase(); return e.length < 2 ? "0" + e : e } var y = t(6); e.exports = { getRgba: i, getHsla: n, getRgb: r, getHsl: l, getHwb: o, getAlpha: s, hexString: d, rgbString: u, rgbaString: c, percentString: h, percentaString: f, hslString: g, hslaString: p, hwbString: m, keyword: b }; var k = {}; for (var S in y) k[y[S]] = S }, { 6: 6 }], 3: [function (t, e, a) { var i = t(5), n = t(2), o = function (t) { if (t instanceof o) return t; if (!(this instanceof o)) return new o(t); this.values = { rgb: [0, 0, 0], hsl: [0, 0, 0], hsv: [0, 0, 0], hwb: [0, 0, 0], cmyk: [0, 0, 0, 0], alpha: 1 }; var e; if ("string" == typeof t) if (e = n.getRgba(t)) this.setValues("rgb", e); else if (e = n.getHsla(t)) this.setValues("hsl", e); else { if (!(e = n.getHwb(t))) throw new Error('Unable to parse color from string "' + t + '"'); this.setValues("hwb", e) } else if ("object" == typeof t) if (e = t, void 0 !== e.r || void 0 !== e.red) this.setValues("rgb", e); else if (void 0 !== e.l || void 0 !== e.lightness) this.setValues("hsl", e); else if (void 0 !== e.v || void 0 !== e.value) this.setValues("hsv", e); else if (void 0 !== e.w || void 0 !== e.whiteness) this.setValues("hwb", e); else { if (void 0 === e.c && void 0 === e.cyan) throw new Error("Unable to parse color from object " + JSON.stringify(t)); this.setValues("cmyk", e) } }; o.prototype = { rgb: function () { return this.setSpace("rgb", arguments) }, hsl: function () { return this.setSpace("hsl", arguments) }, hsv: function () { return this.setSpace("hsv", arguments) }, hwb: function () { return this.setSpace("hwb", arguments) }, cmyk: function () { return this.setSpace("cmyk", arguments) }, rgbArray: function () { return this.values.rgb }, hslArray: function () { return this.values.hsl }, hsvArray: function () { return this.values.hsv }, hwbArray: function () { var t = this.values; return 1 !== t.alpha ? t.hwb.concat([t.alpha]) : t.hwb }, cmykArray: function () { return this.values.cmyk }, rgbaArray: function () { var t = this.values; return t.rgb.concat([t.alpha]) }, hslaArray: function () { var t = this.values; return t.hsl.concat([t.alpha]) }, alpha: function (t) { return void 0 === t ? this.values.alpha : (this.setValues("alpha", t), this) }, red: function (t) { return this.setChannel("rgb", 0, t) }, green: function (t) { return this.setChannel("rgb", 1, t) }, blue: function (t) { return this.setChannel("rgb", 2, t) }, hue: function (t) { return t && (t %= 360, t = 0 > t ? 360 + t : t), this.setChannel("hsl", 0, t) }, saturation: function (t) { return this.setChannel("hsl", 1, t) }, lightness: function (t) { return this.setChannel("hsl", 2, t) }, saturationv: function (t) { return this.setChannel("hsv", 1, t) }, whiteness: function (t) { return this.setChannel("hwb", 1, t) }, blackness: function (t) { return this.setChannel("hwb", 2, t) }, value: function (t) { return this.setChannel("hsv", 2, t) }, cyan: function (t) { return this.setChannel("cmyk", 0, t) }, magenta: function (t) { return this.setChannel("cmyk", 1, t) }, yellow: function (t) { return this.setChannel("cmyk", 2, t) }, black: function (t) { return this.setChannel("cmyk", 3, t) }, hexString: function () { return n.hexString(this.values.rgb) }, rgbString: function () { return n.rgbString(this.values.rgb, this.values.alpha) }, rgbaString: function () { return n.rgbaString(this.values.rgb, this.values.alpha) }, percentString: function () { return n.percentString(this.values.rgb, this.values.alpha) }, hslString: function () { return n.hslString(this.values.hsl, this.values.alpha) }, hslaString: function () { return n.hslaString(this.values.hsl, this.values.alpha) }, hwbString: function () { return n.hwbString(this.values.hwb, this.values.alpha) }, keyword: function () { return n.keyword(this.values.rgb, this.values.alpha) }, rgbNumber: function () { var t = this.values.rgb; return t[0] << 16 | t[1] << 8 | t[2] }, luminosity: function () { for (var t = this.values.rgb, e = [], a = 0; a < t.length; a++) { var i = t[a] / 255; e[a] = .03928 >= i ? i / 12.92 : Math.pow((i + .055) / 1.055, 2.4) } return .2126 * e[0] + .7152 * e[1] + .0722 * e[2] }, contrast: function (t) { var e = this.luminosity(), a = t.luminosity(); return e > a ? (e + .05) / (a + .05) : (a + .05) / (e + .05) }, level: function (t) { var e = this.contrast(t); return e >= 7.1 ? "AAA" : e >= 4.5 ? "AA" : "" }, dark: function () { var t = this.values.rgb, e = (299 * t[0] + 587 * t[1] + 114 * t[2]) / 1e3; return 128 > e }, light: function () { return !this.dark() }, negate: function () { for (var t = [], e = 0; 3 > e; e++)t[e] = 255 - this.values.rgb[e]; return this.setValues("rgb", t), this }, lighten: function (t) { var e = this.values.hsl; return e[2] += e[2] * t, this.setValues("hsl", e), this }, darken: function (t) { var e = this.values.hsl; return e[2] -= e[2] * t, this.setValues("hsl", e), this }, saturate: function (t) { var e = this.values.hsl; return e[1] += e[1] * t, this.setValues("hsl", e), this }, desaturate: function (t) { var e = this.values.hsl; return e[1] -= e[1] * t, this.setValues("hsl", e), this }, whiten: function (t) { var e = this.values.hwb; return e[1] += e[1] * t, this.setValues("hwb", e), this }, blacken: function (t) { var e = this.values.hwb; return e[2] += e[2] * t, this.setValues("hwb", e), this }, greyscale: function () { var t = this.values.rgb, e = .3 * t[0] + .59 * t[1] + .11 * t[2]; return this.setValues("rgb", [e, e, e]), this }, clearer: function (t) { var e = this.values.alpha; return this.setValues("alpha", e - e * t), this }, opaquer: function (t) { var e = this.values.alpha; return this.setValues("alpha", e + e * t), this }, rotate: function (t) { var e = this.values.hsl, a = (e[0] + t) % 360; return e[0] = 0 > a ? 360 + a : a, this.setValues("hsl", e), this }, mix: function (t, e) { var a = this, i = t, n = void 0 === e ? .5 : e, o = 2 * n - 1, r = a.alpha() - i.alpha(), l = ((o * r === -1 ? o : (o + r) / (1 + o * r)) + 1) / 2, s = 1 - l; return this.rgb(l * a.red() + s * i.red(), l * a.green() + s * i.green(), l * a.blue() + s * i.blue()).alpha(a.alpha() * n + i.alpha() * (1 - n)) }, toJSON: function () { return this.rgb() }, clone: function () { var t, e, a = new o, i = this.values, n = a.values; for (var r in i) i.hasOwnProperty(r) && (t = i[r], e = {}.toString.call(t), "[object Array]" === e ? n[r] = t.slice(0) : "[object Number]" === e ? n[r] = t : console.error("unexpected color value:", t)); return a } }, o.prototype.spaces = { rgb: ["red", "green", "blue"], hsl: ["hue", "saturation", "lightness"], hsv: ["hue", "saturation", "value"], hwb: ["hue", "whiteness", "blackness"], cmyk: ["cyan", "magenta", "yellow", "black"] }, o.prototype.maxes = { rgb: [255, 255, 255], hsl: [360, 100, 100], hsv: [360, 100, 100], hwb: [360, 100, 100], cmyk: [100, 100, 100, 100] }, o.prototype.getValues = function (t) { for (var e = this.values, a = {}, i = 0; i < t.length; i++)a[t.charAt(i)] = e[t][i]; return 1 !== e.alpha && (a.a = e.alpha), a }, o.prototype.setValues = function (t, e) { var a, n = this.values, o = this.spaces, r = this.maxes, l = 1; if ("alpha" === t) l = e; else if (e.length) n[t] = e.slice(0, t.length), l = e[t.length]; else if (void 0 !== e[t.charAt(0)]) { for (a = 0; a < t.length; a++)n[t][a] = e[t.charAt(a)]; l = e.a } else if (void 0 !== e[o[t][0]]) { var s = o[t]; for (a = 0; a < t.length; a++)n[t][a] = e[s[a]]; l = e.alpha } if (n.alpha = Math.max(0, Math.min(1, void 0 === l ? n.alpha : l)), "alpha" === t) return !1; var d; for (a = 0; a < t.length; a++)d = Math.max(0, Math.min(r[t][a], n[t][a])), n[t][a] = Math.round(d); for (var u in o) u !== t && (n[u] = i[t][u](n[t])); return !0 }, o.prototype.setSpace = function (t, e) { var a = e[0]; return void 0 === a ? this.getValues(t) : ("number" == typeof a && (a = Array.prototype.slice.call(e)), this.setValues(t, a), this) }, o.prototype.setChannel = function (t, e, a) { var i = this.values[t]; return void 0 === a ? i[e] : a === i[e] ? this : (i[e] = a, this.setValues(t, i), this) }, "undefined" != typeof window && (window.Color = o), e.exports = o }, { 2: 2, 5: 5 }], 4: [function (t, e, a) { function i(t) { var e, a, i, n = t[0] / 255, o = t[1] / 255, r = t[2] / 255, l = Math.min(n, o, r), s = Math.max(n, o, r), d = s - l; return s == l ? e = 0 : n == s ? e = (o - r) / d : o == s ? e = 2 + (r - n) / d : r == s && (e = 4 + (n - o) / d), e = Math.min(60 * e, 360), 0 > e && (e += 360), i = (l + s) / 2, a = s == l ? 0 : .5 >= i ? d / (s + l) : d / (2 - s - l), [e, 100 * a, 100 * i] } function n(t) { var e, a, i, n = t[0], o = t[1], r = t[2], l = Math.min(n, o, r), s = Math.max(n, o, r), d = s - l; return a = 0 == s ? 0 : d / s * 1e3 / 10, s == l ? e = 0 : n == s ? e = (o - r) / d : o == s ? e = 2 + (r - n) / d : r == s && (e = 4 + (n - o) / d), e = Math.min(60 * e, 360), 0 > e && (e += 360), i = s / 255 * 1e3 / 10, [e, a, i] } function o(t) { var e = t[0], a = t[1], n = t[2], o = i(t)[0], r = 1 / 255 * Math.min(e, Math.min(a, n)), n = 1 - 1 / 255 * Math.max(e, Math.max(a, n)); return [o, 100 * r, 100 * n] } function l(t) { var e, a, i, n, o = t[0] / 255, r = t[1] / 255, l = t[2] / 255; return n = Math.min(1 - o, 1 - r, 1 - l), e = (1 - o - n) / (1 - n) || 0, a = (1 - r - n) / (1 - n) || 0, i = (1 - l - n) / (1 - n) || 0, [100 * e, 100 * a, 100 * i, 100 * n] } function s(t) { return G[JSON.stringify(t)] } function d(t) { var e = t[0] / 255, a = t[1] / 255, i = t[2] / 255; e = e > .04045 ? Math.pow((e + .055) / 1.055, 2.4) : e / 12.92, a = a > .04045 ? Math.pow((a + .055) / 1.055, 2.4) : a / 12.92, i = i > .04045 ? Math.pow((i + .055) / 1.055, 2.4) : i / 12.92; var n = .4124 * e + .3576 * a + .1805 * i, o = .2126 * e + .7152 * a + .0722 * i, r = .0193 * e + .1192 * a + .9505 * i; return [100 * n, 100 * o, 100 * r] } function u(t) { var e, a, i, n = d(t), o = n[0], r = n[1], l = n[2]; return o /= 95.047, r /= 100, l /= 108.883, o = o > .008856 ? Math.pow(o, 1 / 3) : 7.787 * o + 16 / 116, r = r > .008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, l = l > .008856 ? Math.pow(l, 1 / 3) : 7.787 * l + 16 / 116, e = 116 * r - 16, a = 500 * (o - r), i = 200 * (r - l), [e, a, i] } function c(t) { return W(u(t)) } function h(t) { var e, a, i, n, o, r = t[0] / 360, l = t[1] / 100, s = t[2] / 100; if (0 == l) return o = 255 * s, [o, o, o]; a = .5 > s ? s * (1 + l) : s + l - s * l, e = 2 * s - a, n = [0, 0, 0]; for (var d = 0; 3 > d; d++)i = r + 1 / 3 * -(d - 1), 0 > i && i++ , i > 1 && i-- , o = 1 > 6 * i ? e + 6 * (a - e) * i : 1 > 2 * i ? a : 2 > 3 * i ? e + (a - e) * (2 / 3 - i) * 6 : e, n[d] = 255 * o; return n } function f(t) { var e, a, i = t[0], n = t[1] / 100, o = t[2] / 100; return 0 === o ? [0, 0, 0] : (o *= 2, n *= 1 >= o ? o : 2 - o, a = (o + n) / 2, e = 2 * n / (o + n), [i, 100 * e, 100 * a]) } function p(t) { return o(h(t)) } function m(t) { return l(h(t)) } function v(t) { return s(h(t)) } function x(t) { var e = t[0] / 60, a = t[1] / 100, i = t[2] / 100, n = Math.floor(e) % 6, o = e - Math.floor(e), r = 255 * i * (1 - a), l = 255 * i * (1 - a * o), s = 255 * i * (1 - a * (1 - o)), i = 255 * i; switch (n) { case 0: return [i, s, r]; case 1: return [l, i, r]; case 2: return [r, i, s]; case 3: return [r, l, i]; case 4: return [s, r, i]; case 5: return [i, r, l] } } function y(t) { var e, a, i = t[0], n = t[1] / 100, o = t[2] / 100; return a = (2 - n) * o, e = n * o, e /= 1 >= a ? a : 2 - a, e = e || 0, a /= 2, [i, 100 * e, 100 * a] } function k(t) { return o(x(t)) } function S(t) { return l(x(t)) } function w(t) { return s(x(t)) } function C(t) { var e, a, i, n, o = t[0] / 360, l = t[1] / 100, s = t[2] / 100, d = l + s; switch (d > 1 && (l /= d, s /= d), e = Math.floor(6 * o), a = 1 - s, i = 6 * o - e, 0 != (1 & e) && (i = 1 - i), n = l + i * (a - l), e) { default: case 6: case 0: r = a, g = n, b = l; break; case 1: r = n, g = a, b = l; break; case 2: r = l, g = a, b = n; break; case 3: r = l, g = n, b = a; break; case 4: r = n, g = l, b = a; break; case 5: r = a, g = l, b = n }return [255 * r, 255 * g, 255 * b] } function M(t) { return i(C(t)) } function D(t) { return n(C(t)) } function I(t) { return l(C(t)) } function A(t) { return s(C(t)) } function T(t) { var e, a, i, n = t[0] / 100, o = t[1] / 100, r = t[2] / 100, l = t[3] / 100; return e = 1 - Math.min(1, n * (1 - l) + l), a = 1 - Math.min(1, o * (1 - l) + l), i = 1 - Math.min(1, r * (1 - l) + l), [255 * e, 255 * a, 255 * i] } function P(t) { return i(T(t)) } function F(t) { return n(T(t)) } function R(t) { return o(T(t)) } function _(t) { return s(T(t)) } function V(t) { var e, a, i, n = t[0] / 100, o = t[1] / 100, r = t[2] / 100; return e = 3.2406 * n + -1.5372 * o + r * -.4986, a = n * -.9689 + 1.8758 * o + .0415 * r, i = .0557 * n + o * -.204 + 1.057 * r, e = e > .0031308 ? 1.055 * Math.pow(e, 1 / 2.4) - .055 : e = 12.92 * e, a = a > .0031308 ? 1.055 * Math.pow(a, 1 / 2.4) - .055 : a = 12.92 * a, i = i > .0031308 ? 1.055 * Math.pow(i, 1 / 2.4) - .055 : i = 12.92 * i, e = Math.min(Math.max(0, e), 1), a = Math.min(Math.max(0, a), 1), i = Math.min(Math.max(0, i), 1), [255 * e, 255 * a, 255 * i] } function L(t) { var e, a, i, n = t[0], o = t[1], r = t[2]; return n /= 95.047, o /= 100, r /= 108.883, n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, o = o > .008856 ? Math.pow(o, 1 / 3) : 7.787 * o + 16 / 116, r = r > .008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, e = 116 * o - 16, a = 500 * (n - o), i = 200 * (o - r), [e, a, i] } function O(t) { return W(L(t)) } function B(t) { var e, a, i, n, o = t[0], r = t[1], l = t[2]; return 8 >= o ? (a = 100 * o / 903.3, n = 7.787 * (a / 100) + 16 / 116) : (a = 100 * Math.pow((o + 16) / 116, 3), n = Math.pow(a / 100, 1 / 3)), e = .008856 >= e / 95.047 ? e = 95.047 * (r / 500 + n - 16 / 116) / 7.787 : 95.047 * Math.pow(r / 500 + n, 3), i = .008859 >= i / 108.883 ? i = 108.883 * (n - l / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(n - l / 200, 3), [e, a, i] } function W(t) { var e, a, i, n = t[0], o = t[1], r = t[2]; return e = Math.atan2(r, o), a = 360 * e / 2 / Math.PI, 0 > a && (a += 360), i = Math.sqrt(o * o + r * r), [n, i, a] } function z(t) { return V(B(t)) } function N(t) { var e, a, i, n = t[0], o = t[1], r = t[2]; return i = r / 360 * 2 * Math.PI, e = o * Math.cos(i), a = o * Math.sin(i), [n, e, a] } function H(t) { return B(N(t)) } function E(t) { return z(N(t)) } function U(t) { return Z[t] } function q(t) { return i(U(t)) } function j(t) { return n(U(t)) } function Y(t) { return o(U(t)) } function K(t) { return l(U(t)) } function X(t) { return u(U(t)) } function J(t) { return d(U(t)) } e.exports = { rgb2hsl: i, rgb2hsv: n, rgb2hwb: o, rgb2cmyk: l, rgb2keyword: s, rgb2xyz: d, rgb2lab: u, rgb2lch: c, hsl2rgb: h, hsl2hsv: f, hsl2hwb: p, hsl2cmyk: m, hsl2keyword: v, hsv2rgb: x, hsv2hsl: y, hsv2hwb: k, hsv2cmyk: S, hsv2keyword: w, hwb2rgb: C, hwb2hsl: M, hwb2hsv: D, hwb2cmyk: I, hwb2keyword: A, cmyk2rgb: T, cmyk2hsl: P, cmyk2hsv: F, cmyk2hwb: R, cmyk2keyword: _, keyword2rgb: U, keyword2hsl: q, keyword2hsv: j, keyword2hwb: Y, keyword2cmyk: K, keyword2lab: X, keyword2xyz: J, xyz2rgb: V, xyz2lab: L, xyz2lch: O, lab2xyz: B, lab2rgb: z, lab2lch: W, lch2lab: N, lch2xyz: H, lch2rgb: E }; var Z = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, G = {}; for (var Q in Z) G[JSON.stringify(Z[Q])] = Q }, {}], 5: [function (t, e, a) { var i = t(4), n = function () { return new d }; for (var o in i) { n[o + "Raw"] = function (t) { return function (e) { return "number" == typeof e && (e = Array.prototype.slice.call(arguments)), i[t](e) } }(o); var r = /(\w+)2(\w+)/.exec(o), l = r[1], s = r[2]; n[l] = n[l] || {}, n[l][s] = n[o] = function (t) { return function (e) { "number" == typeof e && (e = Array.prototype.slice.call(arguments)); var a = i[t](e); if ("string" == typeof a || void 0 === a) return a; for (var n = 0; n < a.length; n++)a[n] = Math.round(a[n]); return a } }(o) } var d = function () { this.convs = {} }; d.prototype.routeSpace = function (t, e) { var a = e[0]; return void 0 === a ? this.getValues(t) : ("number" == typeof a && (a = Array.prototype.slice.call(e)), this.setValues(t, a)) }, d.prototype.setValues = function (t, e) { return this.space = t, this.convs = {}, this.convs[t] = e, this }, d.prototype.getValues = function (t) { var e = this.convs[t]; if (!e) { var a = this.space, i = this.convs[a]; e = n[a][t](i), this.convs[t] = e } return e }, ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (t) { d.prototype[t] = function (e) { return this.routeSpace(t, arguments) } }), e.exports = n }, { 4: 4 }], 6: [function (t, e, a) { e.exports = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] } }, {}], 7: [function (t, e, a) { var i = t(27)(); t(26)(i), t(22)(i), t(25)(i), t(21)(i), t(23)(i), t(24)(i), t(28)(i), t(32)(i), t(30)(i), t(31)(i), t(33)(i), t(29)(i), t(34)(i), t(35)(i), t(36)(i), t(37)(i), t(38)(i), t(41)(i), t(39)(i), t(40)(i), t(42)(i), t(43)(i), t(44)(i), t(15)(i), t(16)(i), t(17)(i), t(18)(i), t(19)(i), t(20)(i), t(8)(i), t(9)(i), t(10)(i), t(11)(i), t(12)(i), t(13)(i), t(14)(i), window.Chart = e.exports = i }, { 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 30: 30, 31: 31, 32: 32, 33: 33, 34: 34, 35: 35, 36: 36, 37: 37, 38: 38, 39: 39, 40: 40, 41: 41, 42: 42, 43: 43, 44: 44, 8: 8, 9: 9 }], 8: [function (t, e, a) { "use strict"; e.exports = function (t) { t.Bar = function (e, a) { return a.type = "bar", new t(e, a) } } }, {}], 9: [function (t, e, a) { "use strict"; e.exports = function (t) { t.Bubble = function (e, a) { return a.type = "bubble", new t(e, a) } } }, {}], 10: [function (t, e, a) { "use strict"; e.exports = function (t) { t.Doughnut = function (e, a) { return a.type = "doughnut", new t(e, a) } } }, {}], 11: [function (t, e, a) { "use strict"; e.exports = function (t) { t.Line = function (e, a) { return a.type = "line", new t(e, a) } } }, {}], 12: [function (t, e, a) { "use strict"; e.exports = function (t) { t.PolarArea = function (e, a) { return a.type = "polarArea", new t(e, a) } } }, {}], 13: [function (t, e, a) { "use strict"; e.exports = function (t) { t.Radar = function (e, a) { return a.options = t.helpers.configMerge({ aspectRatio: 1 }, a.options), a.type = "radar", new t(e, a) } } }, {}], 14: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = { hover: { mode: "single" }, scales: { xAxes: [{ type: "linear", position: "bottom", id: "x-axis-1" }], yAxes: [{ type: "linear", position: "left", id: "y-axis-1" }] }, tooltips: { callbacks: { title: function () { return "" }, label: function (t) { return "(" + t.xLabel + ", " + t.yLabel + ")" } } } }; t.defaults.scatter = e, t.controllers.scatter = t.controllers.line, t.Scatter = function (e, a) { return a.type = "scatter", new t(e, a) } } }, {}], 15: [function (t, e, a) {
            "use strict"; e.exports = function (t) {
                var e = t.helpers; t.defaults.bar = { hover: { mode: "label" }, scales: { xAxes: [{ type: "category", categoryPercentage: .8, barPercentage: .9, gridLines: { offsetGridLines: !0 } }], yAxes: [{ type: "linear" }] } }, t.controllers.bar = t.DatasetController.extend({ dataElementType: t.elements.Rectangle, initialize: function (e, a) { t.DatasetController.prototype.initialize.call(this, e, a), this.getMeta().bar = !0 }, getBarCount: function () { var t = this, a = 0; return e.each(t.chart.data.datasets, function (e, i) { var n = t.chart.getDatasetMeta(i); n.bar && t.chart.isDatasetVisible(i) && ++a }, t), a }, update: function (t) { var a = this; e.each(a.getMeta().data, function (e, i) { a.updateElement(e, i, t) }, a) }, updateElement: function (t, a, i) { var n = this, o = n.getMeta(), r = n.getScaleForId(o.xAxisID), l = n.getScaleForId(o.yAxisID), s = l.getBasePixel(), d = n.chart.options.elements.rectangle, u = t.custom || {}, c = n.getDataset(); e.extend(t, { _xScale: r, _yScale: l, _datasetIndex: n.index, _index: a, _model: { x: n.calculateBarX(a, n.index), y: i ? s : n.calculateBarY(a, n.index), label: n.chart.data.labels[a], datasetLabel: c.label, base: i ? s : n.calculateBarBase(n.index, a), width: n.calculateBarWidth(a), backgroundColor: u.backgroundColor ? u.backgroundColor : e.getValueAtIndexOrDefault(c.backgroundColor, a, d.backgroundColor), borderSkipped: u.borderSkipped ? u.borderSkipped : d.borderSkipped, borderColor: u.borderColor ? u.borderColor : e.getValueAtIndexOrDefault(c.borderColor, a, d.borderColor), borderWidth: u.borderWidth ? u.borderWidth : e.getValueAtIndexOrDefault(c.borderWidth, a, d.borderWidth) } }), t.pivot() }, calculateBarBase: function (t, e) { var a = this, i = a.getMeta(), n = a.getScaleForId(i.yAxisID), o = 0; if (n.options.stacked) { for (var r = a.chart, l = r.data.datasets, s = Number(l[t].data[e]), d = 0; t > d; d++) { var u = l[d], c = r.getDatasetMeta(d); if (c.bar && c.yAxisID === n.id && r.isDatasetVisible(d)) { var h = Number(u.data[e]); o += 0 > s ? Math.min(h, 0) : Math.max(h, 0) } } return n.getPixelForValue(o) } return n.getBasePixel() }, getRuler: function (t) { var e, a = this, i = a.getMeta(), n = a.getScaleForId(i.xAxisID), o = a.getBarCount(); e = "category" === n.options.type ? n.getPixelForTick(t + 1) - n.getPixelForTick(t) : n.width / n.ticks.length; var r = e * n.options.categoryPercentage, l = (e - e * n.options.categoryPercentage) / 2, s = r / o; if (n.ticks.length !== a.chart.data.labels.length) { var d = n.ticks.length / a.chart.data.labels.length; s *= d } var u = s * n.options.barPercentage, c = s - s * n.options.barPercentage; return { datasetCount: o, tickWidth: e, categoryWidth: r, categorySpacing: l, fullBarWidth: s, barWidth: u, barSpacing: c } }, calculateBarWidth: function (t) { var e = this.getScaleForId(this.getMeta().xAxisID); if (e.options.barThickness) return e.options.barThickness; var a = this.getRuler(t); return e.options.stacked ? a.categoryWidth : a.barWidth }, getBarIndex: function (t) { var e, a, i = 0; for (a = 0; t > a; ++a)e = this.chart.getDatasetMeta(a), e.bar && this.chart.isDatasetVisible(a) && ++i; return i }, calculateBarX: function (t, e) { var a = this, i = a.getMeta(), n = a.getScaleForId(i.xAxisID), o = a.getBarIndex(e), r = a.getRuler(t), l = n.getPixelForValue(null, t, e, a.chart.isCombo); return l -= a.chart.isCombo ? r.tickWidth / 2 : 0, n.options.stacked ? l + r.categoryWidth / 2 + r.categorySpacing : l + r.barWidth / 2 + r.categorySpacing + r.barWidth * o + r.barSpacing / 2 + r.barSpacing * o }, calculateBarY: function (t, e) { var a = this, i = a.getMeta(), n = a.getScaleForId(i.yAxisID), o = Number(a.getDataset().data[t]); if (n.options.stacked) { for (var r = 0, l = 0, s = 0; e > s; s++) { var d = a.chart.data.datasets[s], u = a.chart.getDatasetMeta(s); if (u.bar && u.yAxisID === n.id && a.chart.isDatasetVisible(s)) { var c = Number(d.data[t]); 0 > c ? l += c || 0 : r += c || 0 } } return 0 > o ? n.getPixelForValue(l + o) : n.getPixelForValue(r + o) } return n.getPixelForValue(o) }, draw: function (t) { var a = this, i = t || 1; e.each(a.getMeta().data, function (t, e) { var n = a.getDataset().data[e]; null === n || void 0 === n || isNaN(n) || t.transition(i).draw() }, a) }, setHoverStyle: function (t) { var a = this.chart.data.datasets[t._datasetIndex], i = t._index, n = t.custom || {}, o = t._model; o.backgroundColor = n.hoverBackgroundColor ? n.hoverBackgroundColor : e.getValueAtIndexOrDefault(a.hoverBackgroundColor, i, e.getHoverColor(o.backgroundColor)), o.borderColor = n.hoverBorderColor ? n.hoverBorderColor : e.getValueAtIndexOrDefault(a.hoverBorderColor, i, e.getHoverColor(o.borderColor)), o.borderWidth = n.hoverBorderWidth ? n.hoverBorderWidth : e.getValueAtIndexOrDefault(a.hoverBorderWidth, i, o.borderWidth) }, removeHoverStyle: function (t) { var a = this.chart.data.datasets[t._datasetIndex], i = t._index, n = t.custom || {}, o = t._model, r = this.chart.options.elements.rectangle; o.backgroundColor = n.backgroundColor ? n.backgroundColor : e.getValueAtIndexOrDefault(a.backgroundColor, i, r.backgroundColor), o.borderColor = n.borderColor ? n.borderColor : e.getValueAtIndexOrDefault(a.borderColor, i, r.borderColor), o.borderWidth = n.borderWidth ? n.borderWidth : e.getValueAtIndexOrDefault(a.borderWidth, i, r.borderWidth) } }), t.defaults.horizontalBar = { hover: { mode: "label" }, scales: { xAxes: [{ type: "linear", position: "bottom" }], yAxes: [{ position: "left", type: "category", categoryPercentage: .8, barPercentage: .9, gridLines: { offsetGridLines: !0 } }] }, elements: { rectangle: { borderSkipped: "left" } }, tooltips: { callbacks: { title: function (t, e) { var a = ""; return t.length > 0 && (t[0].yLabel ? a = t[0].yLabel : e.labels.length > 0 && t[0].index < e.labels.length && (a = e.labels[t[0].index])), a }, label: function (t, e) { var a = e.datasets[t.datasetIndex].label || ""; return a + ": " + t.xLabel } } } }, t.controllers.horizontalBar = t.controllers.bar.extend({
                    updateElement: function (t, a, i) { var n = this, o = n.getMeta(), r = n.getScaleForId(o.xAxisID), l = n.getScaleForId(o.yAxisID), s = r.getBasePixel(), d = t.custom || {}, u = n.getDataset(), c = n.chart.options.elements.rectangle; e.extend(t, { _xScale: r, _yScale: l, _datasetIndex: n.index, _index: a, _model: { x: i ? s : n.calculateBarX(a, n.index), y: n.calculateBarY(a, n.index), label: n.chart.data.labels[a], datasetLabel: u.label, base: i ? s : n.calculateBarBase(n.index, a), height: n.calculateBarHeight(a), backgroundColor: d.backgroundColor ? d.backgroundColor : e.getValueAtIndexOrDefault(u.backgroundColor, a, c.backgroundColor), borderSkipped: d.borderSkipped ? d.borderSkipped : c.borderSkipped, borderColor: d.borderColor ? d.borderColor : e.getValueAtIndexOrDefault(u.borderColor, a, c.borderColor), borderWidth: d.borderWidth ? d.borderWidth : e.getValueAtIndexOrDefault(u.borderWidth, a, c.borderWidth) }, draw: function () { function t(t) { return s[(u + t) % 4] } var e = this._chart.ctx, a = this._view, i = a.height / 2, n = a.y - i, o = a.y + i, r = a.base - (a.base - a.x), l = a.borderWidth / 2; a.borderWidth && (n += l, o -= l, r += l), e.beginPath(), e.fillStyle = a.backgroundColor, e.strokeStyle = a.borderColor, e.lineWidth = a.borderWidth; var s = [[a.base, o], [a.base, n], [r, n], [r, o]], d = ["bottom", "left", "top", "right"], u = d.indexOf(a.borderSkipped, 0); -1 === u && (u = 0), e.moveTo.apply(e, t(0)); for (var c = 1; 4 > c; c++)e.lineTo.apply(e, t(c)); e.fill(), a.borderWidth && e.stroke() }, inRange: function (t, e) { var a = this._view, i = !1; return a && (i = a.x < a.base ? e >= a.y - a.height / 2 && e <= a.y + a.height / 2 && t >= a.x && t <= a.base : e >= a.y - a.height / 2 && e <= a.y + a.height / 2 && t >= a.base && t <= a.x), i } }), t.pivot() }, calculateBarBase: function (t, e) {
                        var a = this, i = a.getMeta(), n = a.getScaleForId(i.xAxisID), o = 0;
                        if (n.options.stacked) { for (var r = a.chart, l = r.data.datasets, s = Number(l[t].data[e]), d = 0; t > d; d++) { var u = l[d], c = r.getDatasetMeta(d); if (c.bar && c.xAxisID === n.id && r.isDatasetVisible(d)) { var h = Number(u.data[e]); o += 0 > s ? Math.min(h, 0) : Math.max(h, 0) } } return n.getPixelForValue(o) } return n.getBasePixel()
                    }, getRuler: function (t) { var e, a = this, i = a.getMeta(), n = a.getScaleForId(i.yAxisID), o = a.getBarCount(); e = "category" === n.options.type ? n.getPixelForTick(t + 1) - n.getPixelForTick(t) : n.width / n.ticks.length; var r = e * n.options.categoryPercentage, l = (e - e * n.options.categoryPercentage) / 2, s = r / o; if (n.ticks.length !== a.chart.data.labels.length) { var d = n.ticks.length / a.chart.data.labels.length; s *= d } var u = s * n.options.barPercentage, c = s - s * n.options.barPercentage; return { datasetCount: o, tickHeight: e, categoryHeight: r, categorySpacing: l, fullBarHeight: s, barHeight: u, barSpacing: c } }, calculateBarHeight: function (t) { var e = this, a = e.getScaleForId(e.getMeta().yAxisID); if (a.options.barThickness) return a.options.barThickness; var i = e.getRuler(t); return a.options.stacked ? i.categoryHeight : i.barHeight }, calculateBarX: function (t, e) { var a = this, i = a.getMeta(), n = a.getScaleForId(i.xAxisID), o = Number(a.getDataset().data[t]); if (n.options.stacked) { for (var r = 0, l = 0, s = 0; e > s; s++) { var d = a.chart.data.datasets[s], u = a.chart.getDatasetMeta(s); if (u.bar && u.xAxisID === n.id && a.chart.isDatasetVisible(s)) { var c = Number(d.data[t]); 0 > c ? l += c || 0 : r += c || 0 } } return 0 > o ? n.getPixelForValue(l + o) : n.getPixelForValue(r + o) } return n.getPixelForValue(o) }, calculateBarY: function (t, e) { var a = this, i = a.getMeta(), n = a.getScaleForId(i.yAxisID), o = a.getBarIndex(e), r = a.getRuler(t), l = n.getPixelForValue(null, t, e, a.chart.isCombo); return l -= a.chart.isCombo ? r.tickHeight / 2 : 0, n.options.stacked ? l + r.categoryHeight / 2 + r.categorySpacing : l + r.barHeight / 2 + r.categorySpacing + r.barHeight * o + r.barSpacing / 2 + r.barSpacing * o }
                })
            }
        }, {}], 16: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.helpers; t.defaults.bubble = { hover: { mode: "single" }, scales: { xAxes: [{ type: "linear", position: "bottom", id: "x-axis-0" }], yAxes: [{ type: "linear", position: "left", id: "y-axis-0" }] }, tooltips: { callbacks: { title: function () { return "" }, label: function (t, e) { var a = e.datasets[t.datasetIndex].label || "", i = e.datasets[t.datasetIndex].data[t.index]; return a + ": (" + i.x + ", " + i.y + ", " + i.r + ")" } } } }, t.controllers.bubble = t.DatasetController.extend({ dataElementType: t.elements.Point, update: function (t) { var a = this, i = a.getMeta(), n = i.data; e.each(n, function (e, i) { a.updateElement(e, i, t) }) }, updateElement: function (a, i, n) { var o = this, r = o.getMeta(), l = o.getScaleForId(r.xAxisID), s = o.getScaleForId(r.yAxisID), d = a.custom || {}, u = o.getDataset(), c = u.data[i], h = o.chart.options.elements.point, f = o.index; e.extend(a, { _xScale: l, _yScale: s, _datasetIndex: f, _index: i, _model: { x: n ? l.getPixelForDecimal(.5) : l.getPixelForValue("object" == typeof c ? c : NaN, i, f, o.chart.isCombo), y: n ? s.getBasePixel() : s.getPixelForValue(c, i, f), radius: n ? 0 : d.radius ? d.radius : o.getRadius(c), hitRadius: d.hitRadius ? d.hitRadius : e.getValueAtIndexOrDefault(u.hitRadius, i, h.hitRadius) } }), t.DatasetController.prototype.removeHoverStyle.call(o, a, h); var g = a._model; g.skip = d.skip ? d.skip : isNaN(g.x) || isNaN(g.y), a.pivot() }, getRadius: function (t) { return t.r || this.chart.options.elements.point.radius }, setHoverStyle: function (a) { var i = this; t.DatasetController.prototype.setHoverStyle.call(i, a); var n = i.chart.data.datasets[a._datasetIndex], o = a._index, r = a.custom || {}, l = a._model; l.radius = r.hoverRadius ? r.hoverRadius : e.getValueAtIndexOrDefault(n.hoverRadius, o, i.chart.options.elements.point.hoverRadius) + i.getRadius(n.data[o]) }, removeHoverStyle: function (e) { var a = this; t.DatasetController.prototype.removeHoverStyle.call(a, e, a.chart.options.elements.point); var i = a.chart.data.datasets[e._datasetIndex].data[e._index], n = e.custom || {}, o = e._model; o.radius = n.radius ? n.radius : a.getRadius(i) } }) } }, {}], 17: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.helpers, a = t.defaults; a.doughnut = { animation: { animateRotate: !0, animateScale: !1 }, aspectRatio: 1, hover: { mode: "single" }, legendCallback: function (t) { var e = []; e.push('<ul class="' + t.id + '-legend">'); var a = t.data, i = a.datasets, n = a.labels; if (i.length) for (var o = 0; o < i[0].data.length; ++o)e.push('<li><span style="background-color:' + i[0].backgroundColor[o] + '"></span>'), n[o] && e.push(n[o]), e.push("</li>"); return e.push("</ul>"), e.join("") }, legend: { labels: { generateLabels: function (t) { var a = t.data; return a.labels.length && a.datasets.length ? a.labels.map(function (i, n) { var o = t.getDatasetMeta(0), r = a.datasets[0], l = o.data[n], s = l && l.custom || {}, d = e.getValueAtIndexOrDefault, u = t.options.elements.arc, c = s.backgroundColor ? s.backgroundColor : d(r.backgroundColor, n, u.backgroundColor), h = s.borderColor ? s.borderColor : d(r.borderColor, n, u.borderColor), f = s.borderWidth ? s.borderWidth : d(r.borderWidth, n, u.borderWidth); return { text: i, fillStyle: c, strokeStyle: h, lineWidth: f, hidden: isNaN(r.data[n]) || o.data[n].hidden, index: n } }) : [] } }, onClick: function (t, e) { var a, i, n, o = e.index, r = this.chart; for (a = 0, i = (r.data.datasets || []).length; i > a; ++a)n = r.getDatasetMeta(a), n.data[o] && (n.data[o].hidden = !n.data[o].hidden); r.update() } }, cutoutPercentage: 50, rotation: Math.PI * -.5, circumference: 2 * Math.PI, tooltips: { callbacks: { title: function () { return "" }, label: function (t, e) { return e.labels[t.index] + ": " + e.datasets[t.datasetIndex].data[t.index] } } } }, a.pie = e.clone(a.doughnut), e.extend(a.pie, { cutoutPercentage: 0 }), t.controllers.doughnut = t.controllers.pie = t.DatasetController.extend({ dataElementType: t.elements.Arc, linkScales: e.noop, getRingIndex: function (t) { for (var e = 0, a = 0; t > a; ++a)this.chart.isDatasetVisible(a) && ++e; return e }, update: function (t) { var a = this, i = a.chart, n = i.chartArea, o = i.options, r = o.elements.arc, l = n.right - n.left - r.borderWidth, s = n.bottom - n.top - r.borderWidth, d = Math.min(l, s), u = { x: 0, y: 0 }, c = a.getMeta(), h = o.cutoutPercentage, f = o.circumference; if (f < 2 * Math.PI) { var g = o.rotation % (2 * Math.PI); g += 2 * Math.PI * (g >= Math.PI ? -1 : g < -Math.PI ? 1 : 0); var p = g + f, m = { x: Math.cos(g), y: Math.sin(g) }, b = { x: Math.cos(p), y: Math.sin(p) }, v = 0 >= g && p >= 0 || g <= 2 * Math.PI && 2 * Math.PI <= p, x = g <= .5 * Math.PI && .5 * Math.PI <= p || g <= 2.5 * Math.PI && 2.5 * Math.PI <= p, y = g <= -Math.PI && -Math.PI <= p || g <= Math.PI && Math.PI <= p, k = g <= .5 * -Math.PI && .5 * -Math.PI <= p || g <= 1.5 * Math.PI && 1.5 * Math.PI <= p, S = h / 100, w = { x: y ? -1 : Math.min(m.x * (m.x < 0 ? 1 : S), b.x * (b.x < 0 ? 1 : S)), y: k ? -1 : Math.min(m.y * (m.y < 0 ? 1 : S), b.y * (b.y < 0 ? 1 : S)) }, C = { x: v ? 1 : Math.max(m.x * (m.x > 0 ? 1 : S), b.x * (b.x > 0 ? 1 : S)), y: x ? 1 : Math.max(m.y * (m.y > 0 ? 1 : S), b.y * (b.y > 0 ? 1 : S)) }, M = { width: .5 * (C.x - w.x), height: .5 * (C.y - w.y) }; d = Math.min(l / M.width, s / M.height), u = { x: (C.x + w.x) * -.5, y: (C.y + w.y) * -.5 } } i.borderWidth = a.getMaxBorderWidth(c.data), i.outerRadius = Math.max((d - i.borderWidth) / 2, 0), i.innerRadius = Math.max(h ? i.outerRadius / 100 * h : 1, 0), i.radiusLength = (i.outerRadius - i.innerRadius) / i.getVisibleDatasetCount(), i.offsetX = u.x * i.outerRadius, i.offsetY = u.y * i.outerRadius, c.total = a.calculateTotal(), a.outerRadius = i.outerRadius - i.radiusLength * a.getRingIndex(a.index), a.innerRadius = a.outerRadius - i.radiusLength, e.each(c.data, function (e, i) { a.updateElement(e, i, t) }) }, updateElement: function (t, a, i) { var n = this, o = n.chart, r = o.chartArea, l = o.options, s = l.animation, d = (r.left + r.right) / 2, u = (r.top + r.bottom) / 2, c = l.rotation, h = l.rotation, f = n.getDataset(), g = i && s.animateRotate ? 0 : t.hidden ? 0 : n.calculateCircumference(f.data[a]) * (l.circumference / (2 * Math.PI)), p = i && s.animateScale ? 0 : n.innerRadius, m = i && s.animateScale ? 0 : n.outerRadius, b = e.getValueAtIndexOrDefault; e.extend(t, { _datasetIndex: n.index, _index: a, _model: { x: d + o.offsetX, y: u + o.offsetY, startAngle: c, endAngle: h, circumference: g, outerRadius: m, innerRadius: p, label: b(f.label, a, o.data.labels[a]) } }); var v = t._model; this.removeHoverStyle(t), i && s.animateRotate || (0 === a ? v.startAngle = l.rotation : v.startAngle = n.getMeta().data[a - 1]._model.endAngle, v.endAngle = v.startAngle + v.circumference), t.pivot() }, removeHoverStyle: function (e) { t.DatasetController.prototype.removeHoverStyle.call(this, e, this.chart.options.elements.arc) }, calculateTotal: function () { var t, a = this.getDataset(), i = this.getMeta(), n = 0; return e.each(i.data, function (e, i) { t = a.data[i], isNaN(t) || e.hidden || (n += Math.abs(t)) }), n }, calculateCircumference: function (t) { var e = this.getMeta().total; return e > 0 && !isNaN(t) ? 2 * Math.PI * (t / e) : 0 }, getMaxBorderWidth: function (t) { for (var e, a, i = 0, n = this.index, o = t.length, r = 0; o > r; r++)e = t[r]._model ? t[r]._model.borderWidth : 0, a = t[r]._chart ? t[r]._chart.config.data.datasets[n].hoverBorderWidth : 0, i = e > i ? e : i, i = a > i ? a : i; return i } }) } }, {}], 18: [function (t, e, a) { "use strict"; e.exports = function (t) { function e(t, e) { return a.getValueOrDefault(t.showLine, e.showLines) } var a = t.helpers; t.defaults.line = { showLines: !0, spanGaps: !1, hover: { mode: "label" }, scales: { xAxes: [{ type: "category", id: "x-axis-0" }], yAxes: [{ type: "linear", id: "y-axis-0" }] } }, t.controllers.line = t.DatasetController.extend({ datasetElementType: t.elements.Line, dataElementType: t.elements.Point, addElementAndReset: function (a) { var i = this, n = i.chart.options, o = i.getMeta(); t.DatasetController.prototype.addElementAndReset.call(i, a), e(i.getDataset(), n) && 0 !== o.dataset._model.tension && i.updateBezierControlPoints() }, update: function (t) { var i, n, o, r = this, l = r.getMeta(), s = l.dataset, d = l.data || [], u = r.chart.options, c = u.elements.line, h = r.getScaleForId(l.yAxisID), f = r.getDataset(), g = e(f, u); for (g && (o = s.custom || {}, void 0 !== f.tension && void 0 === f.lineTension && (f.lineTension = f.tension), s._scale = h, s._datasetIndex = r.index, s._children = d, s._model = { spanGaps: f.spanGaps ? f.spanGaps : u.spanGaps, tension: o.tension ? o.tension : a.getValueOrDefault(f.lineTension, c.tension), backgroundColor: o.backgroundColor ? o.backgroundColor : f.backgroundColor || c.backgroundColor, borderWidth: o.borderWidth ? o.borderWidth : f.borderWidth || c.borderWidth, borderColor: o.borderColor ? o.borderColor : f.borderColor || c.borderColor, borderCapStyle: o.borderCapStyle ? o.borderCapStyle : f.borderCapStyle || c.borderCapStyle, borderDash: o.borderDash ? o.borderDash : f.borderDash || c.borderDash, borderDashOffset: o.borderDashOffset ? o.borderDashOffset : f.borderDashOffset || c.borderDashOffset, borderJoinStyle: o.borderJoinStyle ? o.borderJoinStyle : f.borderJoinStyle || c.borderJoinStyle, fill: o.fill ? o.fill : void 0 !== f.fill ? f.fill : c.fill, steppedLine: o.steppedLine ? o.steppedLine : a.getValueOrDefault(f.steppedLine, c.stepped), cubicInterpolationMode: o.cubicInterpolationMode ? o.cubicInterpolationMode : a.getValueOrDefault(f.cubicInterpolationMode, c.cubicInterpolationMode), scaleTop: h.top, scaleBottom: h.bottom, scaleZero: h.getBasePixel() }, s.pivot()), i = 0, n = d.length; n > i; ++i)r.updateElement(d[i], i, t); for (g && 0 !== s._model.tension && r.updateBezierControlPoints(), i = 0, n = d.length; n > i; ++i)d[i].pivot() }, getPointBackgroundColor: function (t, e) { var i = this.chart.options.elements.point.backgroundColor, n = this.getDataset(), o = t.custom || {}; return o.backgroundColor ? i = o.backgroundColor : n.pointBackgroundColor ? i = a.getValueAtIndexOrDefault(n.pointBackgroundColor, e, i) : n.backgroundColor && (i = n.backgroundColor), i }, getPointBorderColor: function (t, e) { var i = this.chart.options.elements.point.borderColor, n = this.getDataset(), o = t.custom || {}; return o.borderColor ? i = o.borderColor : n.pointBorderColor ? i = a.getValueAtIndexOrDefault(n.pointBorderColor, e, i) : n.borderColor && (i = n.borderColor), i }, getPointBorderWidth: function (t, e) { var i = this.chart.options.elements.point.borderWidth, n = this.getDataset(), o = t.custom || {}; return o.borderWidth ? i = o.borderWidth : n.pointBorderWidth ? i = a.getValueAtIndexOrDefault(n.pointBorderWidth, e, i) : n.borderWidth && (i = n.borderWidth), i }, updateElement: function (t, e, i) { var n, o, r = this, l = r.getMeta(), s = t.custom || {}, d = r.getDataset(), u = r.index, c = d.data[e], h = r.getScaleForId(l.yAxisID), f = r.getScaleForId(l.xAxisID), g = r.chart.options.elements.point, p = r.chart.data.labels || [], m = 1 === p.length || 1 === d.data.length || r.chart.isCombo; void 0 !== d.radius && void 0 === d.pointRadius && (d.pointRadius = d.radius), void 0 !== d.hitRadius && void 0 === d.pointHitRadius && (d.pointHitRadius = d.hitRadius), n = f.getPixelForValue("object" == typeof c ? c : NaN, e, u, m), o = i ? h.getBasePixel() : r.calculatePointY(c, e, u), t._xScale = f, t._yScale = h, t._datasetIndex = u, t._index = e, t._model = { x: n, y: o, skip: s.skip || isNaN(n) || isNaN(o), radius: s.radius || a.getValueAtIndexOrDefault(d.pointRadius, e, g.radius), pointStyle: s.pointStyle || a.getValueAtIndexOrDefault(d.pointStyle, e, g.pointStyle), backgroundColor: r.getPointBackgroundColor(t, e), borderColor: r.getPointBorderColor(t, e), borderWidth: r.getPointBorderWidth(t, e), tension: l.dataset._model ? l.dataset._model.tension : 0, steppedLine: l.dataset._model ? l.dataset._model.steppedLine : !1, hitRadius: s.hitRadius || a.getValueAtIndexOrDefault(d.pointHitRadius, e, g.hitRadius) } }, calculatePointY: function (t, e, a) { var i, n, o, r = this, l = r.chart, s = r.getMeta(), d = r.getScaleForId(s.yAxisID), u = 0, c = 0; if (d.options.stacked) { for (i = 0; a > i; i++)if (n = l.data.datasets[i], o = l.getDatasetMeta(i), "line" === o.type && o.yAxisID === d.id && l.isDatasetVisible(i)) { var h = Number(d.getRightValue(n.data[e])); 0 > h ? c += h || 0 : u += h || 0 } var f = Number(d.getRightValue(t)); return 0 > f ? d.getPixelForValue(c + f) : d.getPixelForValue(u + f) } return d.getPixelForValue(t) }, updateBezierControlPoints: function () { function t(t, e, a) { return Math.max(Math.min(t, a), e) } var e, i, n, o, r, l = this, s = l.getMeta(), d = l.chart.chartArea, u = s.data || []; if (s.dataset._model.spanGaps && (u = u.filter(function (t) { return !t._model.skip })), "monotone" === s.dataset._model.cubicInterpolationMode) a.splineCurveMonotone(u); else for (e = 0, i = u.length; i > e; ++e)n = u[e], o = n._model, r = a.splineCurve(a.previousItem(u, e)._model, o, a.nextItem(u, e)._model, s.dataset._model.tension), o.controlPointPreviousX = r.previous.x, o.controlPointPreviousY = r.previous.y, o.controlPointNextX = r.next.x, o.controlPointNextY = r.next.y; if (l.chart.options.elements.line.capBezierPoints) for (e = 0, i = u.length; i > e; ++e)o = u[e]._model, o.controlPointPreviousX = t(o.controlPointPreviousX, d.left, d.right), o.controlPointPreviousY = t(o.controlPointPreviousY, d.top, d.bottom), o.controlPointNextX = t(o.controlPointNextX, d.left, d.right), o.controlPointNextY = t(o.controlPointNextY, d.top, d.bottom) }, draw: function (t) { var a, i, n = this, o = n.getMeta(), r = o.data || [], l = t || 1; for (a = 0, i = r.length; i > a; ++a)r[a].transition(l); for (e(n.getDataset(), n.chart.options) && o.dataset.transition(l).draw(), a = 0, i = r.length; i > a; ++a)r[a].draw() }, setHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t._index, n = t.custom || {}, o = t._model; o.radius = n.hoverRadius || a.getValueAtIndexOrDefault(e.pointHoverRadius, i, this.chart.options.elements.point.hoverRadius), o.backgroundColor = n.hoverBackgroundColor || a.getValueAtIndexOrDefault(e.pointHoverBackgroundColor, i, a.getHoverColor(o.backgroundColor)), o.borderColor = n.hoverBorderColor || a.getValueAtIndexOrDefault(e.pointHoverBorderColor, i, a.getHoverColor(o.borderColor)), o.borderWidth = n.hoverBorderWidth || a.getValueAtIndexOrDefault(e.pointHoverBorderWidth, i, o.borderWidth) }, removeHoverStyle: function (t) { var e = this, i = e.chart.data.datasets[t._datasetIndex], n = t._index, o = t.custom || {}, r = t._model; void 0 !== i.radius && void 0 === i.pointRadius && (i.pointRadius = i.radius), r.radius = o.radius || a.getValueAtIndexOrDefault(i.pointRadius, n, e.chart.options.elements.point.radius), r.backgroundColor = e.getPointBackgroundColor(t, n), r.borderColor = e.getPointBorderColor(t, n), r.borderWidth = e.getPointBorderWidth(t, n) } }) } }, {}], 19: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.helpers; t.defaults.polarArea = { scale: { type: "radialLinear", lineArc: !0, ticks: { beginAtZero: !0 } }, animation: { animateRotate: !0, animateScale: !0 }, startAngle: -.5 * Math.PI, aspectRatio: 1, legendCallback: function (t) { var e = []; e.push('<ul class="' + t.id + '-legend">'); var a = t.data, i = a.datasets, n = a.labels; if (i.length) for (var o = 0; o < i[0].data.length; ++o)e.push('<li><span style="background-color:' + i[0].backgroundColor[o] + '">'), n[o] && e.push(n[o]), e.push("</span></li>"); return e.push("</ul>"), e.join("") }, legend: { labels: { generateLabels: function (t) { var a = t.data; return a.labels.length && a.datasets.length ? a.labels.map(function (i, n) { var o = t.getDatasetMeta(0), r = a.datasets[0], l = o.data[n], s = l.custom || {}, d = e.getValueAtIndexOrDefault, u = t.options.elements.arc, c = s.backgroundColor ? s.backgroundColor : d(r.backgroundColor, n, u.backgroundColor), h = s.borderColor ? s.borderColor : d(r.borderColor, n, u.borderColor), f = s.borderWidth ? s.borderWidth : d(r.borderWidth, n, u.borderWidth); return { text: i, fillStyle: c, strokeStyle: h, lineWidth: f, hidden: isNaN(r.data[n]) || o.data[n].hidden, index: n } }) : [] } }, onClick: function (t, e) { var a, i, n, o = e.index, r = this.chart; for (a = 0, i = (r.data.datasets || []).length; i > a; ++a)n = r.getDatasetMeta(a), n.data[o].hidden = !n.data[o].hidden; r.update() } }, tooltips: { callbacks: { title: function () { return "" }, label: function (t, e) { return e.labels[t.index] + ": " + t.yLabel } } } }, t.controllers.polarArea = t.DatasetController.extend({ dataElementType: t.elements.Arc, linkScales: e.noop, update: function (t) { var a = this, i = a.chart, n = i.chartArea, o = a.getMeta(), r = i.options, l = r.elements.arc, s = Math.min(n.right - n.left, n.bottom - n.top); i.outerRadius = Math.max((s - l.borderWidth / 2) / 2, 0), i.innerRadius = Math.max(r.cutoutPercentage ? i.outerRadius / 100 * r.cutoutPercentage : 1, 0), i.radiusLength = (i.outerRadius - i.innerRadius) / i.getVisibleDatasetCount(), a.outerRadius = i.outerRadius - i.radiusLength * a.index, a.innerRadius = a.outerRadius - i.radiusLength, o.count = a.countVisibleElements(), e.each(o.data, function (e, i) { a.updateElement(e, i, t) }) }, updateElement: function (t, a, i) { for (var n = this, o = n.chart, r = n.getDataset(), l = o.options, s = l.animation, d = o.scale, u = e.getValueAtIndexOrDefault, c = o.data.labels, h = n.calculateCircumference(r.data[a]), f = d.xCenter, g = d.yCenter, p = 0, m = n.getMeta(), b = 0; a > b; ++b)isNaN(r.data[b]) || m.data[b].hidden || ++p; var v = l.startAngle, x = t.hidden ? 0 : d.getDistanceFromCenterForValue(r.data[a]), y = v + h * p, k = y + (t.hidden ? 0 : h), S = s.animateScale ? 0 : d.getDistanceFromCenterForValue(r.data[a]); e.extend(t, { _datasetIndex: n.index, _index: a, _scale: d, _model: { x: f, y: g, innerRadius: 0, outerRadius: i ? S : x, startAngle: i && s.animateRotate ? v : y, endAngle: i && s.animateRotate ? v : k, label: u(c, a, c[a]) } }), n.removeHoverStyle(t), t.pivot() }, removeHoverStyle: function (e) { t.DatasetController.prototype.removeHoverStyle.call(this, e, this.chart.options.elements.arc) }, countVisibleElements: function () { var t = this.getDataset(), a = this.getMeta(), i = 0; return e.each(a.data, function (e, a) { isNaN(t.data[a]) || e.hidden || i++ }), i }, calculateCircumference: function (t) { var e = this.getMeta().count; return e > 0 && !isNaN(t) ? 2 * Math.PI / e : 0 } }) } }, {}], 20: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.helpers; t.defaults.radar = { scale: { type: "radialLinear" }, elements: { line: { tension: 0 } } }, t.controllers.radar = t.DatasetController.extend({ datasetElementType: t.elements.Line, dataElementType: t.elements.Point, linkScales: e.noop, addElementAndReset: function (e) { t.DatasetController.prototype.addElementAndReset.call(this, e), this.updateBezierControlPoints() }, update: function (t) { var a = this, i = a.getMeta(), n = i.dataset, o = i.data, r = n.custom || {}, l = a.getDataset(), s = a.chart.options.elements.line, d = a.chart.scale; void 0 !== l.tension && void 0 === l.lineTension && (l.lineTension = l.tension), e.extend(i.dataset, { _datasetIndex: a.index, _children: o, _loop: !0, _model: { tension: r.tension ? r.tension : e.getValueOrDefault(l.lineTension, s.tension), backgroundColor: r.backgroundColor ? r.backgroundColor : l.backgroundColor || s.backgroundColor, borderWidth: r.borderWidth ? r.borderWidth : l.borderWidth || s.borderWidth, borderColor: r.borderColor ? r.borderColor : l.borderColor || s.borderColor, fill: r.fill ? r.fill : void 0 !== l.fill ? l.fill : s.fill, borderCapStyle: r.borderCapStyle ? r.borderCapStyle : l.borderCapStyle || s.borderCapStyle, borderDash: r.borderDash ? r.borderDash : l.borderDash || s.borderDash, borderDashOffset: r.borderDashOffset ? r.borderDashOffset : l.borderDashOffset || s.borderDashOffset, borderJoinStyle: r.borderJoinStyle ? r.borderJoinStyle : l.borderJoinStyle || s.borderJoinStyle, scaleTop: d.top, scaleBottom: d.bottom, scaleZero: d.getBasePosition() } }), i.dataset.pivot(), e.each(o, function (e, i) { a.updateElement(e, i, t) }, a), a.updateBezierControlPoints() }, updateElement: function (t, a, i) { var n = this, o = t.custom || {}, r = n.getDataset(), l = n.chart.scale, s = n.chart.options.elements.point, d = l.getPointPositionForValue(a, r.data[a]); e.extend(t, { _datasetIndex: n.index, _index: a, _scale: l, _model: { x: i ? l.xCenter : d.x, y: i ? l.yCenter : d.y, tension: o.tension ? o.tension : e.getValueOrDefault(r.tension, n.chart.options.elements.line.tension), radius: o.radius ? o.radius : e.getValueAtIndexOrDefault(r.pointRadius, a, s.radius), backgroundColor: o.backgroundColor ? o.backgroundColor : e.getValueAtIndexOrDefault(r.pointBackgroundColor, a, s.backgroundColor), borderColor: o.borderColor ? o.borderColor : e.getValueAtIndexOrDefault(r.pointBorderColor, a, s.borderColor), borderWidth: o.borderWidth ? o.borderWidth : e.getValueAtIndexOrDefault(r.pointBorderWidth, a, s.borderWidth), pointStyle: o.pointStyle ? o.pointStyle : e.getValueAtIndexOrDefault(r.pointStyle, a, s.pointStyle), hitRadius: o.hitRadius ? o.hitRadius : e.getValueAtIndexOrDefault(r.hitRadius, a, s.hitRadius) } }), t._model.skip = o.skip ? o.skip : isNaN(t._model.x) || isNaN(t._model.y) }, updateBezierControlPoints: function () { var t = this.chart.chartArea, a = this.getMeta(); e.each(a.data, function (i, n) { var o = i._model, r = e.splineCurve(e.previousItem(a.data, n, !0)._model, o, e.nextItem(a.data, n, !0)._model, o.tension); o.controlPointPreviousX = Math.max(Math.min(r.previous.x, t.right), t.left), o.controlPointPreviousY = Math.max(Math.min(r.previous.y, t.bottom), t.top), o.controlPointNextX = Math.max(Math.min(r.next.x, t.right), t.left), o.controlPointNextY = Math.max(Math.min(r.next.y, t.bottom), t.top), i.pivot() }) }, draw: function (t) { var a = this.getMeta(), i = t || 1; e.each(a.data, function (t) { t.transition(i) }), a.dataset.transition(i).draw(), e.each(a.data, function (t) { t.draw() }) }, setHoverStyle: function (t) { var a = this.chart.data.datasets[t._datasetIndex], i = t.custom || {}, n = t._index, o = t._model; o.radius = i.hoverRadius ? i.hoverRadius : e.getValueAtIndexOrDefault(a.pointHoverRadius, n, this.chart.options.elements.point.hoverRadius), o.backgroundColor = i.hoverBackgroundColor ? i.hoverBackgroundColor : e.getValueAtIndexOrDefault(a.pointHoverBackgroundColor, n, e.getHoverColor(o.backgroundColor)), o.borderColor = i.hoverBorderColor ? i.hoverBorderColor : e.getValueAtIndexOrDefault(a.pointHoverBorderColor, n, e.getHoverColor(o.borderColor)), o.borderWidth = i.hoverBorderWidth ? i.hoverBorderWidth : e.getValueAtIndexOrDefault(a.pointHoverBorderWidth, n, o.borderWidth) }, removeHoverStyle: function (t) { var a = this.chart.data.datasets[t._datasetIndex], i = t.custom || {}, n = t._index, o = t._model, r = this.chart.options.elements.point; o.radius = i.radius ? i.radius : e.getValueAtIndexOrDefault(a.radius, n, r.radius), o.backgroundColor = i.backgroundColor ? i.backgroundColor : e.getValueAtIndexOrDefault(a.pointBackgroundColor, n, r.backgroundColor), o.borderColor = i.borderColor ? i.borderColor : e.getValueAtIndexOrDefault(a.pointBorderColor, n, r.borderColor), o.borderWidth = i.borderWidth ? i.borderWidth : e.getValueAtIndexOrDefault(a.pointBorderWidth, n, r.borderWidth) } }) } }, {}], 21: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.helpers; t.defaults.global.animation = { duration: 1e3, easing: "easeOutQuart", onProgress: e.noop, onComplete: e.noop }, t.Animation = t.Element.extend({ currentStep: null, numSteps: 60, easing: "", render: null, onAnimationProgress: null, onAnimationComplete: null }), t.animationService = { frameDuration: 17, animations: [], dropFrames: 0, request: null, addAnimation: function (t, e, a, i) { var n = this; i || (t.animating = !0); for (var o = 0; o < n.animations.length; ++o)if (n.animations[o].chartInstance === t) return void (n.animations[o].animationObject = e); n.animations.push({ chartInstance: t, animationObject: e }), 1 === n.animations.length && n.requestAnimationFrame() }, cancelAnimation: function (t) { var a = e.findIndex(this.animations, function (e) { return e.chartInstance === t }); -1 !== a && (this.animations.splice(a, 1), t.animating = !1) }, requestAnimationFrame: function () { var t = this; null === t.request && (t.request = e.requestAnimFrame.call(window, function () { t.request = null, t.startDigest() })) }, startDigest: function () { var t = this, e = Date.now(), a = 0; t.dropFrames > 1 && (a = Math.floor(t.dropFrames), t.dropFrames = t.dropFrames % 1); for (var i = 0; i < t.animations.length;)null === t.animations[i].animationObject.currentStep && (t.animations[i].animationObject.currentStep = 0), t.animations[i].animationObject.currentStep += 1 + a, t.animations[i].animationObject.currentStep > t.animations[i].animationObject.numSteps && (t.animations[i].animationObject.currentStep = t.animations[i].animationObject.numSteps), t.animations[i].animationObject.render(t.animations[i].chartInstance, t.animations[i].animationObject), t.animations[i].animationObject.onAnimationProgress && t.animations[i].animationObject.onAnimationProgress.call && t.animations[i].animationObject.onAnimationProgress.call(t.animations[i].chartInstance, t.animations[i]), t.animations[i].animationObject.currentStep === t.animations[i].animationObject.numSteps ? (t.animations[i].animationObject.onAnimationComplete && t.animations[i].animationObject.onAnimationComplete.call && t.animations[i].animationObject.onAnimationComplete.call(t.animations[i].chartInstance, t.animations[i]), t.animations[i].chartInstance.animating = !1, t.animations.splice(i, 1)) : ++i; var n = Date.now(), o = (n - e) / t.frameDuration; t.dropFrames += o, t.animations.length > 0 && t.requestAnimationFrame() } } } }, {}], 22: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.canvasHelpers = {}; e.drawPoint = function (t, e, a, i, n) { var o, r, l, s, d, u; if ("object" == typeof e && (o = e.toString(), "[object HTMLImageElement]" === o || "[object HTMLCanvasElement]" === o)) return void t.drawImage(e, i - e.width / 2, n - e.height / 2); if (!(isNaN(a) || 0 >= a)) { switch (e) { default: t.beginPath(), t.arc(i, n, a, 0, 2 * Math.PI), t.closePath(), t.fill(); break; case "triangle": t.beginPath(), r = 3 * a / Math.sqrt(3), d = r * Math.sqrt(3) / 2, t.moveTo(i - r / 2, n + d / 3), t.lineTo(i + r / 2, n + d / 3), t.lineTo(i, n - 2 * d / 3), t.closePath(), t.fill(); break; case "rect": u = 1 / Math.SQRT2 * a, t.beginPath(), t.fillRect(i - u, n - u, 2 * u, 2 * u), t.strokeRect(i - u, n - u, 2 * u, 2 * u); break; case "rectRot": u = 1 / Math.SQRT2 * a, t.beginPath(), t.moveTo(i - u, n), t.lineTo(i, n + u), t.lineTo(i + u, n), t.lineTo(i, n - u), t.closePath(), t.fill(); break; case "cross": t.beginPath(), t.moveTo(i, n + a), t.lineTo(i, n - a), t.moveTo(i - a, n), t.lineTo(i + a, n), t.closePath(); break; case "crossRot": t.beginPath(), l = Math.cos(Math.PI / 4) * a, s = Math.sin(Math.PI / 4) * a, t.moveTo(i - l, n - s), t.lineTo(i + l, n + s), t.moveTo(i - l, n + s), t.lineTo(i + l, n - s), t.closePath(); break; case "star": t.beginPath(), t.moveTo(i, n + a), t.lineTo(i, n - a), t.moveTo(i - a, n), t.lineTo(i + a, n), l = Math.cos(Math.PI / 4) * a, s = Math.sin(Math.PI / 4) * a, t.moveTo(i - l, n - s), t.lineTo(i + l, n + s), t.moveTo(i - l, n + s), t.lineTo(i + l, n - s), t.closePath(); break; case "line": t.beginPath(), t.moveTo(i - a, n), t.lineTo(i + a, n), t.closePath(); break; case "dash": t.beginPath(), t.moveTo(i, n), t.lineTo(i + a, n), t.closePath() }t.stroke() } } } }, {}], 23: [function (t, e, a) {
            "use strict"; e.exports = function (t) {
                var e = t.helpers; t.types = {}, t.instances = {}, t.controllers = {}, t.Controller = function (a) { return this.chart = a, this.config = a.config, this.options = this.config.options = e.configMerge(t.defaults.global, t.defaults[this.config.type], this.config.options || {}), this.id = e.uid(), Object.defineProperty(this, "data", { get: function () { return this.config.data } }), t.instances[this.id] = this, this.options.responsive && this.resize(!0), this.initialize(), this }, e.extend(t.Controller.prototype, {
                    initialize: function () { var e = this; return t.plugins.notify("beforeInit", [e]), e.bindEvents(), e.ensureScalesHaveIDs(), e.buildOrUpdateControllers(), e.buildScales(), e.updateLayout(), e.resetElements(), e.initToolTip(), e.update(), t.plugins.notify("afterInit", [e]), e }, clear: function () { return e.clear(this.chart), this }, stop: function () { return t.animationService.cancelAnimation(this), this }, resize: function (a) { var i = this, n = i.chart, o = n.canvas, r = e.getMaximumWidth(o), l = n.aspectRatio, s = i.options.maintainAspectRatio && isNaN(l) === !1 && isFinite(l) && 0 !== l ? r / l : e.getMaximumHeight(o), d = n.width !== r || n.height !== s; if (!d) return i; o.width = n.width = r, o.height = n.height = s, e.retinaScale(n); var u = { width: r, height: s }; return t.plugins.notify("resize", [i, u]), i.options.onResize && i.options.onResize(i, u), a || (i.stop(), i.update(i.options.responsiveAnimationDuration)), i }, ensureScalesHaveIDs: function () { var t = this.options, a = t.scales || {}, i = t.scale; e.each(a.xAxes, function (t, e) { t.id = t.id || "x-axis-" + e }), e.each(a.yAxes, function (t, e) { t.id = t.id || "y-axis-" + e }), i && (i.id = i.id || "scale") }, buildScales: function () { var a = this, i = a.options, n = a.scales = {}, o = []; i.scales && (o = o.concat((i.scales.xAxes || []).map(function (t) { return { options: t, dtype: "category" } }), (i.scales.yAxes || []).map(function (t) { return { options: t, dtype: "linear" } }))), i.scale && o.push({ options: i.scale, dtype: "radialLinear", isDefault: !0 }), e.each(o, function (i) { var o = i.options, r = e.getValueOrDefault(o.type, i.dtype), l = t.scaleService.getScaleConstructor(r); if (l) { var s = new l({ id: o.id, options: o, ctx: a.chart.ctx, chart: a }); n[s.id] = s, i.isDefault && (a.scale = s) } }), t.scaleService.addScalesToLayout(this) }, updateLayout: function () { t.layoutService.update(this, this.chart.width, this.chart.height) }, buildOrUpdateControllers: function () { var a = this, i = [], n = []; if (e.each(a.data.datasets, function (e, o) { var r = a.getDatasetMeta(o); r.type || (r.type = e.type || a.config.type), i.push(r.type), r.controller ? r.controller.updateIndex(o) : (r.controller = new t.controllers[r.type](a, o), n.push(r.controller)) }, a), i.length > 1) for (var o = 1; o < i.length; o++)if (i[o] !== i[o - 1]) { a.isCombo = !0; break } return n }, resetElements: function () { var t = this; e.each(t.data.datasets, function (e, a) { t.getDatasetMeta(a).controller.reset() }, t) }, update: function (a, i) { var n = this; t.plugins.notify("beforeUpdate", [n]), n.tooltip._data = n.data; var o = n.buildOrUpdateControllers(); e.each(n.data.datasets, function (t, e) { n.getDatasetMeta(e).controller.buildOrUpdateElements() }, n), t.layoutService.update(n, n.chart.width, n.chart.height), t.plugins.notify("afterScaleUpdate", [n]), e.each(o, function (t) { t.reset() }), n.updateDatasets(), t.plugins.notify("afterUpdate", [n]), n.render(a, i) }, updateDatasets: function () { var e, a, i = this; if (t.plugins.notify("beforeDatasetsUpdate", [i])) { for (e = 0, a = i.data.datasets.length; a > e; ++e)i.getDatasetMeta(e).controller.update(); t.plugins.notify("afterDatasetsUpdate", [i]) } }, render: function (a, i) { var n = this; t.plugins.notify("beforeRender", [n]); var o = n.options.animation; if (o && ("undefined" != typeof a && 0 !== a || "undefined" == typeof a && 0 !== o.duration)) { var r = new t.Animation; r.numSteps = (a || o.duration) / 16.66, r.easing = o.easing, r.render = function (t, a) { var i = e.easingEffects[a.easing], n = a.currentStep / a.numSteps, o = i(n); t.draw(o, n, a.currentStep) }, r.onAnimationProgress = o.onProgress, r.onAnimationComplete = o.onComplete, t.animationService.addAnimation(n, r, a, i) } else n.draw(), o && o.onComplete && o.onComplete.call && o.onComplete.call(n); return n }, draw: function (a) { var i = this, n = a || 1; i.clear(), t.plugins.notify("beforeDraw", [i, n]), e.each(i.boxes, function (t) { t.draw(i.chartArea) }, i), i.scale && i.scale.draw(), t.plugins.notify("beforeDatasetsDraw", [i, n]), e.each(i.data.datasets, function (t, e) { i.isDatasetVisible(e) && i.getDatasetMeta(e).controller.draw(a) }, i, !0), t.plugins.notify("afterDatasetsDraw", [i, n]), i.tooltip.transition(n).draw(), t.plugins.notify("afterDraw", [i, n]) }, getElementAtEvent: function (t) { var a = this, i = e.getRelativePosition(t, a.chart), n = []; return e.each(a.data.datasets, function (t, o) { if (a.isDatasetVisible(o)) { var r = a.getDatasetMeta(o); e.each(r.data, function (t) { return t.inRange(i.x, i.y) ? (n.push(t), n) : void 0 }) } }), n.slice(0, 1) }, getElementsAtEvent: function (t) { var a = this, i = e.getRelativePosition(t, a.chart), n = [], o = function () { if (a.data.datasets) for (var t = 0; t < a.data.datasets.length; t++) { var e = a.getDatasetMeta(t); if (a.isDatasetVisible(t)) for (var n = 0; n < e.data.length; n++)if (e.data[n].inRange(i.x, i.y)) return e.data[n] } }.call(a); return o ? (e.each(a.data.datasets, function (t, e) { if (a.isDatasetVisible(e)) { var i = a.getDatasetMeta(e), r = i.data[o._index]; r && !r._view.skip && n.push(r) } }, a), n) : n }, getElementsAtXAxis: function (t) { var a = this, i = e.getRelativePosition(t, a.chart), n = [], o = function () { if (a.data.datasets) for (var t = 0; t < a.data.datasets.length; t++) { var e = a.getDatasetMeta(t); if (a.isDatasetVisible(t)) for (var n = 0; n < e.data.length; n++)if (e.data[n].inLabelRange(i.x, i.y)) return e.data[n] } }.call(a); return o ? (e.each(a.data.datasets, function (t, i) { if (a.isDatasetVisible(i)) { var r = a.getDatasetMeta(i), l = e.findIndex(r.data, function (t) { return o._model.x === t._model.x }); -1 === l || r.data[l]._view.skip || n.push(r.data[l]) } }, a), n) : n }, getElementsAtEventForMode: function (t, e) { var a = this; switch (e) { case "single": return a.getElementAtEvent(t); case "label": return a.getElementsAtEvent(t); case "dataset": return a.getDatasetAtEvent(t); case "x-axis": return a.getElementsAtXAxis(t); default: return t } }, getDatasetAtEvent: function (t) {
                        var e = this.getElementAtEvent(t);
                        return e.length > 0 && (e = this.getDatasetMeta(e[0]._datasetIndex).data), e
                    }, getDatasetMeta: function (t) { var e = this, a = e.data.datasets[t]; a._meta || (a._meta = {}); var i = a._meta[e.id]; return i || (i = a._meta[e.id] = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null }), i }, getVisibleDatasetCount: function () { for (var t = 0, e = 0, a = this.data.datasets.length; a > e; ++e)this.isDatasetVisible(e) && t++; return t }, isDatasetVisible: function (t) { var e = this.getDatasetMeta(t); return "boolean" == typeof e.hidden ? !e.hidden : !this.data.datasets[t].hidden }, generateLegend: function () { return this.options.legendCallback(this) }, destroy: function () { var a = this; a.stop(), a.clear(), e.unbindEvents(a, a.events), e.removeResizeListener(a.chart.canvas.parentNode); var i = a.chart.canvas; i.width = a.chart.width, i.height = a.chart.height, void 0 !== a.chart.originalDevicePixelRatio && a.chart.ctx.scale(1 / a.chart.originalDevicePixelRatio, 1 / a.chart.originalDevicePixelRatio), i.style.width = a.chart.originalCanvasStyleWidth, i.style.height = a.chart.originalCanvasStyleHeight, t.plugins.notify("destroy", [a]), delete t.instances[a.id] }, toBase64Image: function () { return this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments) }, initToolTip: function () { var e = this; e.tooltip = new t.Tooltip({ _chart: e.chart, _chartInstance: e, _data: e.data, _options: e.options.tooltips }, e) }, bindEvents: function () { var t = this; e.bindEvents(t, t.options.events, function (e) { t.eventHandler(e) }) }, updateHoverStyle: function (t, e, a) { var i, n, o, r = a ? "setHoverStyle" : "removeHoverStyle"; switch (e) { case "single": t = [t[0]]; break; case "label": case "dataset": case "x-axis": break; default: return }for (n = 0, o = t.length; o > n; ++n)i = t[n], i && this.getDatasetMeta(i._datasetIndex).controller[r](i) }, eventHandler: function (t) { var a = this, i = a.tooltip, n = a.options || {}, o = n.hover, r = n.tooltips; return a.lastActive = a.lastActive || [], a.lastTooltipActive = a.lastTooltipActive || [], "mouseout" === t.type ? (a.active = [], a.tooltipActive = []) : (a.active = a.getElementsAtEventForMode(t, o.mode), a.tooltipActive = a.getElementsAtEventForMode(t, r.mode)), o.onHover && o.onHover.call(a, a.active), a.legend && a.legend.handleEvent && a.legend.handleEvent(t), ("mouseup" === t.type || "click" === t.type) && n.onClick && n.onClick.call(a, t, a.active), a.lastActive.length && a.updateHoverStyle(a.lastActive, o.mode, !1), a.active.length && o.mode && a.updateHoverStyle(a.active, o.mode, !0), (r.enabled || r.custom) && (i.initialize(), i._active = a.tooltipActive, i.update(!0)), i.pivot(), a.animating || e.arrayEquals(a.active, a.lastActive) && e.arrayEquals(a.tooltipActive, a.lastTooltipActive) || (a.stop(), (r.enabled || r.custom) && i.update(!0), a.render(o.animationDuration, !0)), a.lastActive = a.active, a.lastTooltipActive = a.tooltipActive, a }
                })
            }
        }, {}], 24: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.helpers, a = e.noop; t.DatasetController = function (t, e) { this.initialize(t, e) }, e.extend(t.DatasetController.prototype, { datasetElementType: null, dataElementType: null, initialize: function (t, e) { var a = this; a.chart = t, a.index = e, a.linkScales(), a.addElements() }, updateIndex: function (t) { this.index = t }, linkScales: function () { var t = this, e = t.getMeta(), a = t.getDataset(); null === e.xAxisID && (e.xAxisID = a.xAxisID || t.chart.options.scales.xAxes[0].id), null === e.yAxisID && (e.yAxisID = a.yAxisID || t.chart.options.scales.yAxes[0].id) }, getDataset: function () { return this.chart.data.datasets[this.index] }, getMeta: function () { return this.chart.getDatasetMeta(this.index) }, getScaleForId: function (t) { return this.chart.scales[t] }, reset: function () { this.update(!0) }, createMetaDataset: function () { var t = this, e = t.datasetElementType; return e && new e({ _chart: t.chart.chart, _datasetIndex: t.index }) }, createMetaData: function (t) { var e = this, a = e.dataElementType; return a && new a({ _chart: e.chart.chart, _datasetIndex: e.index, _index: t }) }, addElements: function () { var t, e, a = this, i = a.getMeta(), n = a.getDataset().data || [], o = i.data; for (t = 0, e = n.length; e > t; ++t)o[t] = o[t] || a.createMetaData(i, t); i.dataset = i.dataset || a.createMetaDataset() }, addElementAndReset: function (t) { var e = this, a = e.createMetaData(t); e.getMeta().data.splice(t, 0, a), e.updateElement(a, t, !0) }, buildOrUpdateElements: function () { var t = this.getMeta(), e = t.data, a = this.getDataset().data.length, i = e.length; if (i > a) e.splice(a, i - a); else if (a > i) for (var n = i; a > n; ++n)this.addElementAndReset(n) }, update: a, draw: function (t) { var a = t || 1; e.each(this.getMeta().data, function (t) { t.transition(a).draw() }) }, removeHoverStyle: function (t, a) { var i = this.chart.data.datasets[t._datasetIndex], n = t._index, o = t.custom || {}, r = e.getValueAtIndexOrDefault, l = t._model; l.backgroundColor = o.backgroundColor ? o.backgroundColor : r(i.backgroundColor, n, a.backgroundColor), l.borderColor = o.borderColor ? o.borderColor : r(i.borderColor, n, a.borderColor), l.borderWidth = o.borderWidth ? o.borderWidth : r(i.borderWidth, n, a.borderWidth) }, setHoverStyle: function (t) { var a = this.chart.data.datasets[t._datasetIndex], i = t._index, n = t.custom || {}, o = e.getValueAtIndexOrDefault, r = e.getHoverColor, l = t._model; l.backgroundColor = n.hoverBackgroundColor ? n.hoverBackgroundColor : o(a.hoverBackgroundColor, i, r(l.backgroundColor)), l.borderColor = n.hoverBorderColor ? n.hoverBorderColor : o(a.hoverBorderColor, i, r(l.borderColor)), l.borderWidth = n.hoverBorderWidth ? n.hoverBorderWidth : o(a.hoverBorderWidth, i, l.borderWidth) } }), t.DatasetController.extend = e.inherits } }, {}], 25: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.helpers; t.elements = {}, t.Element = function (t) { e.extend(this, t), this.initialize.apply(this, arguments) }, e.extend(t.Element.prototype, { initialize: function () { this.hidden = !1 }, pivot: function () { var t = this; return t._view || (t._view = e.clone(t._model)), t._start = e.clone(t._view), t }, transition: function (t) { var a = this; return a._view || (a._view = e.clone(a._model)), 1 === t ? (a._view = a._model, a._start = null, a) : (a._start || a.pivot(), e.each(a._model, function (i, n) { if ("_" === n[0]); else if (a._view.hasOwnProperty(n)) if (i === a._view[n]); else if ("string" == typeof i) try { var o = e.color(a._model[n]).mix(e.color(a._start[n]), t); a._view[n] = o.rgbString() } catch (r) { a._view[n] = i } else if ("number" == typeof i) { var l = void 0 !== a._start[n] && isNaN(a._start[n]) === !1 ? a._start[n] : 0; a._view[n] = (a._model[n] - l) * t + l } else a._view[n] = i; else "number" != typeof i || isNaN(a._view[n]) ? a._view[n] = i : a._view[n] = i * t }, a), a) }, tooltipPosition: function () { return { x: this._model.x, y: this._model.y } }, hasValue: function () { return e.isNumber(this._model.x) && e.isNumber(this._model.y) } }), t.Element.extend = e.inherits } }, {}], 26: [function (t, e, a) { "use strict"; var i = t(3); e.exports = function (t) { function e(t, e, a) { var i; return "string" == typeof t ? (i = parseInt(t, 10), -1 !== t.indexOf("%") && (i = i / 100 * e.parentNode[a])) : i = t, i } function a(t) { return void 0 !== t && null !== t && "none" !== t } function n(t, i, n) { var o = document.defaultView, r = t.parentNode, l = o.getComputedStyle(t)[i], s = o.getComputedStyle(r)[i], d = a(l), u = a(s), c = Number.POSITIVE_INFINITY; return d || u ? Math.min(d ? e(l, t, n) : c, u ? e(s, r, n) : c) : "none" } var o = t.helpers = {}; o.each = function (t, e, a, i) { var n, r; if (o.isArray(t)) if (r = t.length, i) for (n = r - 1; n >= 0; n--)e.call(a, t[n], n); else for (n = 0; r > n; n++)e.call(a, t[n], n); else if ("object" == typeof t) { var l = Object.keys(t); for (r = l.length, n = 0; r > n; n++)e.call(a, t[l[n]], l[n]) } }, o.clone = function (t) { var e = {}; return o.each(t, function (t, a) { o.isArray(t) ? e[a] = t.slice(0) : "object" == typeof t && null !== t ? e[a] = o.clone(t) : e[a] = t }), e }, o.extend = function (t) { for (var e = function (e, a) { t[a] = e }, a = 1, i = arguments.length; i > a; a++)o.each(arguments[a], e); return t }, o.configMerge = function (e) { var a = o.clone(e); return o.each(Array.prototype.slice.call(arguments, 1), function (e) { o.each(e, function (e, i) { if ("scales" === i) a[i] = o.scaleMerge(a.hasOwnProperty(i) ? a[i] : {}, e); else if ("scale" === i) a[i] = o.configMerge(a.hasOwnProperty(i) ? a[i] : {}, t.scaleService.getScaleDefaults(e.type), e); else if (a.hasOwnProperty(i) && o.isArray(a[i]) && o.isArray(e)) { var n = a[i]; o.each(e, function (t, e) { e < n.length ? "object" == typeof n[e] && null !== n[e] && "object" == typeof t && null !== t ? n[e] = o.configMerge(n[e], t) : n[e] = t : n.push(t) }) } else a.hasOwnProperty(i) && "object" == typeof a[i] && null !== a[i] && "object" == typeof e ? a[i] = o.configMerge(a[i], e) : a[i] = e }) }), a }, o.scaleMerge = function (e, a) { var i = o.clone(e); return o.each(a, function (e, a) { "xAxes" === a || "yAxes" === a ? i.hasOwnProperty(a) ? o.each(e, function (e, n) { var r = o.getValueOrDefault(e.type, "xAxes" === a ? "category" : "linear"), l = t.scaleService.getScaleDefaults(r); n >= i[a].length || !i[a][n].type ? i[a].push(o.configMerge(l, e)) : e.type && e.type !== i[a][n].type ? i[a][n] = o.configMerge(i[a][n], l, e) : i[a][n] = o.configMerge(i[a][n], e) }) : (i[a] = [], o.each(e, function (e) { var n = o.getValueOrDefault(e.type, "xAxes" === a ? "category" : "linear"); i[a].push(o.configMerge(t.scaleService.getScaleDefaults(n), e)) })) : i.hasOwnProperty(a) && "object" == typeof i[a] && null !== i[a] && "object" == typeof e ? i[a] = o.configMerge(i[a], e) : i[a] = e }), i }, o.getValueAtIndexOrDefault = function (t, e, a) { return void 0 === t || null === t ? a : o.isArray(t) ? e < t.length ? t[e] : a : t }, o.getValueOrDefault = function (t, e) { return void 0 === t ? e : t }, o.indexOf = Array.prototype.indexOf ? function (t, e) { return t.indexOf(e) } : function (t, e) { for (var a = 0, i = t.length; i > a; ++a)if (t[a] === e) return a; return -1 }, o.where = function (t, e) { if (o.isArray(t) && Array.prototype.filter) return t.filter(e); var a = []; return o.each(t, function (t) { e(t) && a.push(t) }), a }, o.findIndex = Array.prototype.findIndex ? function (t, e, a) { return t.findIndex(e, a) } : function (t, e, a) { a = void 0 === a ? t : a; for (var i = 0, n = t.length; n > i; ++i)if (e.call(a, t[i], i, t)) return i; return -1 }, o.findNextWhere = function (t, e, a) { (void 0 === a || null === a) && (a = -1); for (var i = a + 1; i < t.length; i++) { var n = t[i]; if (e(n)) return n } }, o.findPreviousWhere = function (t, e, a) { (void 0 === a || null === a) && (a = t.length); for (var i = a - 1; i >= 0; i--) { var n = t[i]; if (e(n)) return n } }, o.inherits = function (t) { var e = this, a = t && t.hasOwnProperty("constructor") ? t.constructor : function () { return e.apply(this, arguments) }, i = function () { this.constructor = a }; return i.prototype = e.prototype, a.prototype = new i, a.extend = o.inherits, t && o.extend(a.prototype, t), a.__super__ = e.prototype, a }, o.noop = function () { }, o.uid = function () { var t = 0; return function () { return t++ } }(), o.isNumber = function (t) { return !isNaN(parseFloat(t)) && isFinite(t) }, o.almostEquals = function (t, e, a) { return Math.abs(t - e) < a }, o.max = function (t) { return t.reduce(function (t, e) { return isNaN(e) ? t : Math.max(t, e) }, Number.NEGATIVE_INFINITY) }, o.min = function (t) { return t.reduce(function (t, e) { return isNaN(e) ? t : Math.min(t, e) }, Number.POSITIVE_INFINITY) }, o.sign = Math.sign ? function (t) { return Math.sign(t) } : function (t) { return t = +t, 0 === t || isNaN(t) ? t : t > 0 ? 1 : -1 }, o.log10 = Math.log10 ? function (t) { return Math.log10(t) } : function (t) { return Math.log(t) / Math.LN10 }, o.toRadians = function (t) { return t * (Math.PI / 180) }, o.toDegrees = function (t) { return t * (180 / Math.PI) }, o.getAngleFromPoint = function (t, e) { var a = e.x - t.x, i = e.y - t.y, n = Math.sqrt(a * a + i * i), o = Math.atan2(i, a); return o < -.5 * Math.PI && (o += 2 * Math.PI), { angle: o, distance: n } }, o.aliasPixel = function (t) { return t % 2 === 0 ? 0 : .5 }, o.splineCurve = function (t, e, a, i) { var n = t.skip ? e : t, o = e, r = a.skip ? e : a, l = Math.sqrt(Math.pow(o.x - n.x, 2) + Math.pow(o.y - n.y, 2)), s = Math.sqrt(Math.pow(r.x - o.x, 2) + Math.pow(r.y - o.y, 2)), d = l / (l + s), u = s / (l + s); d = isNaN(d) ? 0 : d, u = isNaN(u) ? 0 : u; var c = i * d, h = i * u; return { previous: { x: o.x - c * (r.x - n.x), y: o.y - c * (r.y - n.y) }, next: { x: o.x + h * (r.x - n.x), y: o.y + h * (r.y - n.y) } } }, o.EPSILON = Number.EPSILON || 1e-14, o.splineCurveMonotone = function (t) { var e, a, i, n, r = (t || []).map(function (t) { return { model: t._model, deltaK: 0, mK: 0 } }), l = r.length; for (e = 0; l > e; ++e)i = r[e], i.model.skip || (a = e > 0 ? r[e - 1] : null, n = l - 1 > e ? r[e + 1] : null, n && !n.model.skip && (i.deltaK = (n.model.y - i.model.y) / (n.model.x - i.model.x)), !a || a.model.skip ? i.mK = i.deltaK : !n || n.model.skip ? i.mK = a.deltaK : this.sign(a.deltaK) !== this.sign(i.deltaK) ? i.mK = 0 : i.mK = (a.deltaK + i.deltaK) / 2); var s, d, u, c; for (e = 0; l - 1 > e; ++e)i = r[e], n = r[e + 1], i.model.skip || n.model.skip || (o.almostEquals(i.deltaK, 0, this.EPSILON) ? i.mK = n.mK = 0 : (s = i.mK / i.deltaK, d = n.mK / i.deltaK, c = Math.pow(s, 2) + Math.pow(d, 2), 9 >= c || (u = 3 / Math.sqrt(c), i.mK = s * u * i.deltaK, n.mK = d * u * i.deltaK))); var h; for (e = 0; l > e; ++e)i = r[e], i.model.skip || (a = e > 0 ? r[e - 1] : null, n = l - 1 > e ? r[e + 1] : null, a && !a.model.skip && (h = (i.model.x - a.model.x) / 3, i.model.controlPointPreviousX = i.model.x - h, i.model.controlPointPreviousY = i.model.y - h * i.mK), n && !n.model.skip && (h = (n.model.x - i.model.x) / 3, i.model.controlPointNextX = i.model.x + h, i.model.controlPointNextY = i.model.y + h * i.mK)) }, o.nextItem = function (t, e, a) { return a ? e >= t.length - 1 ? t[0] : t[e + 1] : e >= t.length - 1 ? t[t.length - 1] : t[e + 1] }, o.previousItem = function (t, e, a) { return a ? 0 >= e ? t[t.length - 1] : t[e - 1] : 0 >= e ? t[0] : t[e - 1] }, o.niceNum = function (t, e) { var a, i = Math.floor(o.log10(t)), n = t / Math.pow(10, i); return a = e ? 1.5 > n ? 1 : 3 > n ? 2 : 7 > n ? 5 : 10 : 1 >= n ? 1 : 2 >= n ? 2 : 5 >= n ? 5 : 10, a * Math.pow(10, i) }; var r = o.easingEffects = { linear: function (t) { return t }, easeInQuad: function (t) { return t * t }, easeOutQuad: function (t) { return -1 * t * (t - 2) }, easeInOutQuad: function (t) { return (t /= .5) < 1 ? .5 * t * t : -0.5 * (--t * (t - 2) - 1) }, easeInCubic: function (t) { return t * t * t }, easeOutCubic: function (t) { return 1 * ((t = t / 1 - 1) * t * t + 1) }, easeInOutCubic: function (t) { return (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2) }, easeInQuart: function (t) { return t * t * t * t }, easeOutQuart: function (t) { return -1 * ((t = t / 1 - 1) * t * t * t - 1) }, easeInOutQuart: function (t) { return (t /= .5) < 1 ? .5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2) }, easeInQuint: function (t) { return 1 * (t /= 1) * t * t * t * t }, easeOutQuint: function (t) { return 1 * ((t = t / 1 - 1) * t * t * t * t + 1) }, easeInOutQuint: function (t) { return (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2) }, easeInSine: function (t) { return -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1 }, easeOutSine: function (t) { return 1 * Math.sin(t / 1 * (Math.PI / 2)) }, easeInOutSine: function (t) { return -0.5 * (Math.cos(Math.PI * t / 1) - 1) }, easeInExpo: function (t) { return 0 === t ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1)) }, easeOutExpo: function (t) { return 1 === t ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1) }, easeInOutExpo: function (t) { return 0 === t ? 0 : 1 === t ? 1 : (t /= .5) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (-Math.pow(2, -10 * --t) + 2) }, easeInCirc: function (t) { return t >= 1 ? t : -1 * (Math.sqrt(1 - (t /= 1) * t) - 1) }, easeOutCirc: function (t) { return 1 * Math.sqrt(1 - (t = t / 1 - 1) * t) }, easeInOutCirc: function (t) { return (t /= .5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1) }, easeInElastic: function (t) { var e = 1.70158, a = 0, i = 1; return 0 === t ? 0 : 1 === (t /= 1) ? 1 : (a || (a = .3), i < Math.abs(1) ? (i = 1, e = a / 4) : e = a / (2 * Math.PI) * Math.asin(1 / i), -(i * Math.pow(2, 10 * (t -= 1)) * Math.sin((1 * t - e) * (2 * Math.PI) / a))) }, easeOutElastic: function (t) { var e = 1.70158, a = 0, i = 1; return 0 === t ? 0 : 1 === (t /= 1) ? 1 : (a || (a = .3), i < Math.abs(1) ? (i = 1, e = a / 4) : e = a / (2 * Math.PI) * Math.asin(1 / i), i * Math.pow(2, -10 * t) * Math.sin((1 * t - e) * (2 * Math.PI) / a) + 1) }, easeInOutElastic: function (t) { var e = 1.70158, a = 0, i = 1; return 0 === t ? 0 : 2 === (t /= .5) ? 1 : (a || (a = 1 * (.3 * 1.5)), i < Math.abs(1) ? (i = 1, e = a / 4) : e = a / (2 * Math.PI) * Math.asin(1 / i), 1 > t ? -.5 * (i * Math.pow(2, 10 * (t -= 1)) * Math.sin((1 * t - e) * (2 * Math.PI) / a)) : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((1 * t - e) * (2 * Math.PI) / a) * .5 + 1) }, easeInBack: function (t) { var e = 1.70158; return 1 * (t /= 1) * t * ((e + 1) * t - e) }, easeOutBack: function (t) { var e = 1.70158; return 1 * ((t = t / 1 - 1) * t * ((e + 1) * t + e) + 1) }, easeInOutBack: function (t) { var e = 1.70158; return (t /= .5) < 1 ? .5 * (t * t * (((e *= 1.525) + 1) * t - e)) : .5 * ((t -= 2) * t * (((e *= 1.525) + 1) * t + e) + 2) }, easeInBounce: function (t) { return 1 - r.easeOutBounce(1 - t) }, easeOutBounce: function (t) { return (t /= 1) < 1 / 2.75 ? 1 * (7.5625 * t * t) : 2 / 2.75 > t ? 1 * (7.5625 * (t -= 1.5 / 2.75) * t + .75) : 2.5 / 2.75 > t ? 1 * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) }, easeInOutBounce: function (t) { return .5 > t ? .5 * r.easeInBounce(2 * t) : .5 * r.easeOutBounce(2 * t - 1) + .5 } }; o.requestAnimFrame = function () { return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) { return window.setTimeout(t, 1e3 / 60) } }(), o.cancelAnimFrame = function () { return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function (t) { return window.clearTimeout(t, 1e3 / 60) } }(), o.getRelativePosition = function (t, e) { var a, i, n = t.originalEvent || t, r = t.currentTarget || t.srcElement, l = r.getBoundingClientRect(), s = n.touches; s && s.length > 0 ? (a = s[0].clientX, i = s[0].clientY) : (a = n.clientX, i = n.clientY); var d = parseFloat(o.getStyle(r, "padding-left")), u = parseFloat(o.getStyle(r, "padding-top")), c = parseFloat(o.getStyle(r, "padding-right")), h = parseFloat(o.getStyle(r, "padding-bottom")), f = l.right - l.left - d - c, g = l.bottom - l.top - u - h; return a = Math.round((a - l.left - d) / f * r.width / e.currentDevicePixelRatio), i = Math.round((i - l.top - u) / g * r.height / e.currentDevicePixelRatio), { x: a, y: i } }, o.addEvent = function (t, e, a) { t.addEventListener ? t.addEventListener(e, a) : t.attachEvent ? t.attachEvent("on" + e, a) : t["on" + e] = a }, o.removeEvent = function (t, e, a) { t.removeEventListener ? t.removeEventListener(e, a, !1) : t.detachEvent ? t.detachEvent("on" + e, a) : t["on" + e] = o.noop }, o.bindEvents = function (t, e, a) { var i = t.events = t.events || {}; o.each(e, function (e) { i[e] = function () { a.apply(t, arguments) }, o.addEvent(t.chart.canvas, e, i[e]) }) }, o.unbindEvents = function (t, e) { var a = t.chart.canvas; o.each(e, function (t, e) { o.removeEvent(a, e, t) }) }, o.getConstraintWidth = function (t) { return n(t, "max-width", "clientWidth") }, o.getConstraintHeight = function (t) { return n(t, "max-height", "clientHeight") }, o.getMaximumWidth = function (t) { var e = t.parentNode, a = parseInt(o.getStyle(e, "padding-left"), 10), i = parseInt(o.getStyle(e, "padding-right"), 10), n = e.clientWidth - a - i, r = o.getConstraintWidth(t); return isNaN(r) ? n : Math.min(n, r) }, o.getMaximumHeight = function (t) { var e = t.parentNode, a = parseInt(o.getStyle(e, "padding-top"), 10), i = parseInt(o.getStyle(e, "padding-bottom"), 10), n = e.clientHeight - a - i, r = o.getConstraintHeight(t); return isNaN(r) ? n : Math.min(n, r) }, o.getStyle = function (t, e) { return t.currentStyle ? t.currentStyle[e] : document.defaultView.getComputedStyle(t, null).getPropertyValue(e) }, o.retinaScale = function (t) { var e = t.ctx, a = t.canvas, i = a.width, n = a.height, o = t.currentDevicePixelRatio = window.devicePixelRatio || 1; 1 !== o && (a.height = n * o, a.width = i * o, e.scale(o, o), t.originalDevicePixelRatio = t.originalDevicePixelRatio || o), a.style.width = i + "px", a.style.height = n + "px" }, o.clear = function (t) { t.ctx.clearRect(0, 0, t.width, t.height) }, o.fontString = function (t, e, a) { return e + " " + t + "px " + a }, o.longestText = function (t, e, a, i) { i = i || {}; var n = i.data = i.data || {}, r = i.garbageCollect = i.garbageCollect || []; i.font !== e && (n = i.data = {}, r = i.garbageCollect = [], i.font = e), t.font = e; var l = 0; o.each(a, function (e) { void 0 !== e && null !== e && o.isArray(e) !== !0 ? l = o.measureText(t, n, r, l, e) : o.isArray(e) && o.each(e, function (e) { void 0 === e || null === e || o.isArray(e) || (l = o.measureText(t, n, r, l, e)) }) }); var s = r.length / 2; if (s > a.length) { for (var d = 0; s > d; d++)delete n[r[d]]; r.splice(0, s) } return l }, o.measureText = function (t, e, a, i, n) { var o = e[n]; return o || (o = e[n] = t.measureText(n).width, a.push(n)), o > i && (i = o), i }, o.numberOfLabelLines = function (t) { var e = 1; return o.each(t, function (t) { o.isArray(t) && t.length > e && (e = t.length) }), e }, o.drawRoundedRectangle = function (t, e, a, i, n, o) { t.beginPath(), t.moveTo(e + o, a), t.lineTo(e + i - o, a), t.quadraticCurveTo(e + i, a, e + i, a + o), t.lineTo(e + i, a + n - o), t.quadraticCurveTo(e + i, a + n, e + i - o, a + n), t.lineTo(e + o, a + n), t.quadraticCurveTo(e, a + n, e, a + n - o), t.lineTo(e, a + o), t.quadraticCurveTo(e, a, e + o, a), t.closePath() }, o.color = function (e) { return i ? i(e instanceof CanvasGradient ? t.defaults.global.defaultColor : e) : (console.error("Color.js not found!"), e) }, o.addResizeListener = function (t, e) { var a = document.createElement("iframe"), i = "chartjs-hidden-iframe"; a.classlist ? a.classlist.add(i) : a.setAttribute("class", i), a.tabIndex = -1; var n = a.style; n.width = "100%", n.display = "block", n.border = 0, n.height = 0, n.margin = 0, n.position = "absolute", n.left = 0, n.right = 0, n.top = 0, n.bottom = 0, t.insertBefore(a, t.firstChild), (a.contentWindow || a).onresize = function () { return e ? e() : void 0 } }, o.removeResizeListener = function (t) { var e = t.querySelector(".chartjs-hidden-iframe"); e && e.parentNode.removeChild(e) }, o.isArray = Array.isArray ? function (t) { return Array.isArray(t) } : function (t) { return "[object Array]" === Object.prototype.toString.call(t) }, o.arrayEquals = function (t, e) { var a, i, n, r; if (!t || !e || t.length !== e.length) return !1; for (a = 0, i = t.length; i > a; ++a)if (n = t[a], r = e[a], n instanceof Array && r instanceof Array) { if (!o.arrayEquals(n, r)) return !1 } else if (n !== r) return !1; return !0 }, o.callCallback = function (t, e, a) { t && "function" == typeof t.call && t.apply(a, e) }, o.getHoverColor = function (t) { return t instanceof CanvasPattern ? t : o.color(t).saturate(.5).darken(.1).rgbString() } } }, { 3: 3 }], 27: [function (t, e, a) { "use strict"; e.exports = function () { var t = function (e, a) { var i = this, n = t.helpers; return i.config = a || { data: { datasets: [] } }, e.length && e[0].getContext && (e = e[0]), e.getContext && (e = e.getContext("2d")), i.ctx = e, i.canvas = e.canvas, e.canvas.style.display = e.canvas.style.display || "block", i.width = e.canvas.width || parseInt(n.getStyle(e.canvas, "width"), 10) || n.getMaximumWidth(e.canvas), i.height = e.canvas.height || parseInt(n.getStyle(e.canvas, "height"), 10) || n.getMaximumHeight(e.canvas), i.aspectRatio = i.width / i.height, (isNaN(i.aspectRatio) || isFinite(i.aspectRatio) === !1) && (i.aspectRatio = void 0 !== a.aspectRatio ? a.aspectRatio : 2), i.originalCanvasStyleWidth = e.canvas.style.width, i.originalCanvasStyleHeight = e.canvas.style.height, n.retinaScale(i), i.controller = new t.Controller(i), n.addResizeListener(e.canvas.parentNode, function () { i.controller && i.controller.config.options.responsive && i.controller.resize() }), i.controller ? i.controller : i }; return t.defaults = { global: { responsive: !0, responsiveAnimationDuration: 0, maintainAspectRatio: !0, events: ["mousemove", "mouseout", "click", "touchstart", "touchmove"], hover: { onHover: null, mode: "single", animationDuration: 400 }, onClick: null, defaultColor: "rgba(0,0,0,0.1)", defaultFontColor: "#666", defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", defaultFontSize: 12, defaultFontStyle: "normal", showLines: !0, elements: {}, legendCallback: function (t) { var e = []; e.push('<ul class="' + t.id + '-legend">'); for (var a = 0; a < t.data.datasets.length; a++)e.push('<li><span style="background-color:' + t.data.datasets[a].backgroundColor + '"></span>'), t.data.datasets[a].label && e.push(t.data.datasets[a].label), e.push("</li>"); return e.push("</ul>"), e.join("") } } }, t.Chart = t, t } }, {}], 28: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.helpers; t.layoutService = { defaults: {}, addBox: function (t, e) { t.boxes || (t.boxes = []), t.boxes.push(e) }, removeBox: function (t, e) { t.boxes && t.boxes.splice(t.boxes.indexOf(e), 1) }, update: function (t, a, i) { function n(t) { var e, a = t.isHorizontal(); a ? (e = t.update(t.options.fullWidth ? p : k, y), S -= e.height) : (e = t.update(x, v), k -= e.width), w.push({ horizontal: a, minSize: e, box: t }) } function o(t) { var a = e.findNextWhere(w, function (e) { return e.box === t }); if (a) if (t.isHorizontal()) { var i = { left: C, right: M, top: 0, bottom: 0 }; t.update(t.options.fullWidth ? p : k, m / 2, i) } else t.update(a.minSize.width, S) } function r(t) { var a = e.findNextWhere(w, function (e) { return e.box === t }), i = { left: 0, right: 0, top: D, bottom: I }; a && t.update(a.minSize.width, S, i) } function l(t) { t.isHorizontal() ? (t.left = t.options.fullWidth ? s : C, t.right = t.options.fullWidth ? a - s : C + k, t.top = F, t.bottom = F + t.height, F = t.bottom) : (t.left = P, t.right = P + t.width, t.top = D, t.bottom = D + S, P = t.right) } if (t) { var s = 0, d = 0, u = e.where(t.boxes, function (t) { return "left" === t.options.position }), c = e.where(t.boxes, function (t) { return "right" === t.options.position }), h = e.where(t.boxes, function (t) { return "top" === t.options.position }), f = e.where(t.boxes, function (t) { return "bottom" === t.options.position }), g = e.where(t.boxes, function (t) { return "chartArea" === t.options.position }); h.sort(function (t, e) { return (e.options.fullWidth ? 1 : 0) - (t.options.fullWidth ? 1 : 0) }), f.sort(function (t, e) { return (t.options.fullWidth ? 1 : 0) - (e.options.fullWidth ? 1 : 0) }); var p = a - 2 * s, m = i - 2 * d, b = p / 2, v = m / 2, x = (a - b) / (u.length + c.length), y = (i - v) / (h.length + f.length), k = p, S = m, w = []; e.each(u.concat(c, h, f), n); var C = s, M = s, D = d, I = d; e.each(u.concat(c), o), e.each(u, function (t) { C += t.width }), e.each(c, function (t) { M += t.width }), e.each(h.concat(f), o), e.each(h, function (t) { D += t.height }), e.each(f, function (t) { I += t.height }), e.each(u.concat(c), r), C = s, M = s, D = d, I = d, e.each(u, function (t) { C += t.width }), e.each(c, function (t) { M += t.width }), e.each(h, function (t) { D += t.height }), e.each(f, function (t) { I += t.height }); var A = i - D - I, T = a - C - M; (T !== k || A !== S) && (e.each(u, function (t) { t.height = A }), e.each(c, function (t) { t.height = A }), e.each(h, function (t) { t.options.fullWidth || (t.width = T) }), e.each(f, function (t) { t.options.fullWidth || (t.width = T) }), S = A, k = T); var P = s, F = d; e.each(u.concat(h), l), P += k, F += S, e.each(c, l), e.each(f, l), t.chartArea = { left: C, top: D, right: C + k, bottom: D + S }, e.each(g, function (e) { e.left = t.chartArea.left, e.top = t.chartArea.top, e.right = t.chartArea.right, e.bottom = t.chartArea.bottom, e.update(k, S) }) } } } } }, {}], 29: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.helpers, a = e.noop; t.defaults.global.legend = { display: !0, position: "top", fullWidth: !0, reverse: !1, onClick: function (t, e) { var a = e.datasetIndex, i = this.chart, n = i.getDatasetMeta(a); n.hidden = null === n.hidden ? !i.data.datasets[a].hidden : null, i.update() }, onHover: null, labels: { boxWidth: 40, padding: 10, generateLabels: function (t) { var a = t.data; return e.isArray(a.datasets) ? a.datasets.map(function (a, i) { return { text: a.label, fillStyle: e.isArray(a.backgroundColor) ? a.backgroundColor[0] : a.backgroundColor, hidden: !t.isDatasetVisible(i), lineCap: a.borderCapStyle, lineDash: a.borderDash, lineDashOffset: a.borderDashOffset, lineJoin: a.borderJoinStyle, lineWidth: a.borderWidth, strokeStyle: a.borderColor, pointStyle: a.pointStyle, datasetIndex: i } }, this) : [] } } }, t.Legend = t.Element.extend({ initialize: function (t) { e.extend(this, t), this.legendHitBoxes = [], this.doughnutMode = !1 }, beforeUpdate: a, update: function (t, e, a) { var i = this; return i.beforeUpdate(), i.maxWidth = t, i.maxHeight = e, i.margins = a, i.beforeSetDimensions(), i.setDimensions(), i.afterSetDimensions(), i.beforeBuildLabels(), i.buildLabels(), i.afterBuildLabels(), i.beforeFit(), i.fit(), i.afterFit(), i.afterUpdate(), i.minSize }, afterUpdate: a, beforeSetDimensions: a, setDimensions: function () { var t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = { width: 0, height: 0 } }, afterSetDimensions: a, beforeBuildLabels: a, buildLabels: function () { var t = this; t.legendItems = t.options.labels.generateLabels.call(t, t.chart), t.options.reverse && t.legendItems.reverse() }, afterBuildLabels: a, beforeFit: a, fit: function () { var a = this, i = a.options, n = i.labels, o = i.display, r = a.ctx, l = t.defaults.global, s = e.getValueOrDefault, d = s(n.fontSize, l.defaultFontSize), u = s(n.fontStyle, l.defaultFontStyle), c = s(n.fontFamily, l.defaultFontFamily), h = e.fontString(d, u, c), f = a.legendHitBoxes = [], g = a.minSize, p = a.isHorizontal(); if (p ? (g.width = a.maxWidth, g.height = o ? 10 : 0) : (g.width = o ? 10 : 0, g.height = a.maxHeight), o) if (r.font = h, p) { var m = a.lineWidths = [0], b = a.legendItems.length ? d + n.padding : 0; r.textAlign = "left", r.textBaseline = "top", e.each(a.legendItems, function (t, e) { var i = n.usePointStyle ? d * Math.sqrt(2) : n.boxWidth, o = i + d / 2 + r.measureText(t.text).width; m[m.length - 1] + o + n.padding >= a.width && (b += d + n.padding, m[m.length] = a.left), f[e] = { left: 0, top: 0, width: o, height: d }, m[m.length - 1] += o + n.padding }), g.height += b } else { var v = n.padding, x = a.columnWidths = [], y = n.padding, k = 0, S = 0, w = d + v; e.each(a.legendItems, function (t, e) { var a = n.usePointStyle ? 2 * n.boxWidth : n.boxWidth, i = a + d / 2 + r.measureText(t.text).width; S + w > g.height && (y += k + n.padding, x.push(k), k = 0, S = 0), k = Math.max(k, i), S += w, f[e] = { left: 0, top: 0, width: i, height: d } }), y += k, x.push(k), g.width += y } a.width = g.width, a.height = g.height }, afterFit: a, isHorizontal: function () { return "top" === this.options.position || "bottom" === this.options.position }, draw: function () { var a = this, i = a.options, n = i.labels, o = t.defaults.global, r = o.elements.line, l = a.width, s = a.lineWidths; if (i.display) { var d, u = a.ctx, c = e.getValueOrDefault, h = c(n.fontColor, o.defaultFontColor), f = c(n.fontSize, o.defaultFontSize), g = c(n.fontStyle, o.defaultFontStyle), p = c(n.fontFamily, o.defaultFontFamily), m = e.fontString(f, g, p); u.textAlign = "left", u.textBaseline = "top", u.lineWidth = .5, u.strokeStyle = h, u.fillStyle = h, u.font = m; var b = n.boxWidth, v = a.legendHitBoxes, x = function (e, a, n) { if (!(isNaN(b) || 0 >= b)) { u.save(), u.fillStyle = c(n.fillStyle, o.defaultColor), u.lineCap = c(n.lineCap, r.borderCapStyle), u.lineDashOffset = c(n.lineDashOffset, r.borderDashOffset), u.lineJoin = c(n.lineJoin, r.borderJoinStyle), u.lineWidth = c(n.lineWidth, r.borderWidth), u.strokeStyle = c(n.strokeStyle, o.defaultColor); var l = 0 === c(n.lineWidth, r.borderWidth); if (u.setLineDash && u.setLineDash(c(n.lineDash, r.borderDash)), i.labels && i.labels.usePointStyle) { var s = f * Math.SQRT2 / 2, d = s / Math.SQRT2, h = e + d, g = a + d; t.canvasHelpers.drawPoint(u, n.pointStyle, s, h, g) } else l || u.strokeRect(e, a, b, f), u.fillRect(e, a, b, f); u.restore() } }, y = function (t, e, a, i) { u.fillText(a.text, b + f / 2 + t, e), a.hidden && (u.beginPath(), u.lineWidth = 2, u.moveTo(b + f / 2 + t, e + f / 2), u.lineTo(b + f / 2 + t + i, e + f / 2), u.stroke()) }, k = a.isHorizontal(); d = k ? { x: a.left + (l - s[0]) / 2, y: a.top + n.padding, line: 0 } : { x: a.left + n.padding, y: a.top + n.padding, line: 0 }; var S = f + n.padding; e.each(a.legendItems, function (t, e) { var i = u.measureText(t.text).width, o = n.usePointStyle ? f + f / 2 + i : b + f / 2 + i, r = d.x, c = d.y; k ? r + o >= l && (c = d.y += S, d.line++ , r = d.x = a.left + (l - s[d.line]) / 2) : c + S > a.bottom && (r = d.x = r + a.columnWidths[d.line] + n.padding, c = d.y = a.top, d.line++), x(r, c, t), v[e].left = r, v[e].top = c, y(r, c, t, i), k ? d.x += o + n.padding : d.y += S }) } }, handleEvent: function (t) { var a = this, i = a.options, n = "mouseup" === t.type ? "click" : t.type; if ("mousemove" === n) { if (!i.onHover) return } else { if ("click" !== n) return; if (!i.onClick) return } var o = e.getRelativePosition(t, a.chart.chart), r = o.x, l = o.y; if (r >= a.left && r <= a.right && l >= a.top && l <= a.bottom) for (var s = a.legendHitBoxes, d = 0; d < s.length; ++d) { var u = s[d]; if (r >= u.left && r <= u.left + u.width && l >= u.top && l <= u.top + u.height) { if ("click" === n) { i.onClick.call(a, t, a.legendItems[d]); break } if ("mousemove" === n) { i.onHover.call(a, t, a.legendItems[d]); break } } } } }), t.plugins.register({ beforeInit: function (e) { var a = e.options, i = a.legend; i && (e.legend = new t.Legend({ ctx: e.chart.ctx, options: i, chart: e }), t.layoutService.addBox(e, e.legend)) } }) } }, {}], 30: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.helpers.noop; t.plugins = { _plugins: [], register: function (t) { var e = this._plugins;[].concat(t).forEach(function (t) { -1 === e.indexOf(t) && e.push(t) }) }, unregister: function (t) { var e = this._plugins;[].concat(t).forEach(function (t) { var a = e.indexOf(t); -1 !== a && e.splice(a, 1) }) }, clear: function () { this._plugins = [] }, count: function () { return this._plugins.length }, getAll: function () { return this._plugins }, notify: function (t, e) { var a, i, n = this._plugins, o = n.length; for (a = 0; o > a; ++a)if (i = n[a], "function" == typeof i[t] && i[t].apply(i, e || []) === !1) return !1; return !0 } }, t.PluginBase = t.Element.extend({ beforeInit: e, afterInit: e, beforeUpdate: e, afterUpdate: e, beforeDraw: e, afterDraw: e, destroy: e }), t.pluginService = t.plugins } }, {}], 31: [function (t, e, a) {
            "use strict"; e.exports = function (t) {
                var e = t.helpers; t.defaults.scale = { display: !0, position: "left", gridLines: { display: !0, color: "rgba(0, 0, 0, 0.1)", lineWidth: 1, drawBorder: !0, drawOnChartArea: !0, drawTicks: !0, tickMarkLength: 10, zeroLineWidth: 1, zeroLineColor: "rgba(0,0,0,0.25)", offsetGridLines: !1, borderDash: [], borderDashOffset: 0 }, scaleLabel: { labelString: "", display: !1 }, ticks: { beginAtZero: !1, minRotation: 0, maxRotation: 50, mirror: !1, padding: 10, reverse: !1, display: !0, autoSkip: !0, autoSkipPadding: 0, labelOffset: 0, callback: function (t) { return e.isArray(t) ? t : "" + t } } }, t.Scale = t.Element.extend({
                    beforeUpdate: function () { e.callCallback(this.options.beforeUpdate, [this]) }, update: function (t, a, i) { var n = this; return n.beforeUpdate(), n.maxWidth = t, n.maxHeight = a, n.margins = e.extend({ left: 0, right: 0, top: 0, bottom: 0 }, i), n.beforeSetDimensions(), n.setDimensions(), n.afterSetDimensions(), n.beforeDataLimits(), n.determineDataLimits(), n.afterDataLimits(), n.beforeBuildTicks(), n.buildTicks(), n.afterBuildTicks(), n.beforeTickToLabelConversion(), n.convertTicksToLabels(), n.afterTickToLabelConversion(), n.beforeCalculateTickRotation(), n.calculateTickRotation(), n.afterCalculateTickRotation(), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate(), n.minSize }, afterUpdate: function () { e.callCallback(this.options.afterUpdate, [this]) }, beforeSetDimensions: function () { e.callCallback(this.options.beforeSetDimensions, [this]) }, setDimensions: function () { var t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0 }, afterSetDimensions: function () { e.callCallback(this.options.afterSetDimensions, [this]) }, beforeDataLimits: function () { e.callCallback(this.options.beforeDataLimits, [this]) }, determineDataLimits: e.noop, afterDataLimits: function () {
                        e.callCallback(this.options.afterDataLimits, [this]);
                    }, beforeBuildTicks: function () { e.callCallback(this.options.beforeBuildTicks, [this]) }, buildTicks: e.noop, afterBuildTicks: function () { e.callCallback(this.options.afterBuildTicks, [this]) }, beforeTickToLabelConversion: function () { e.callCallback(this.options.beforeTickToLabelConversion, [this]) }, convertTicksToLabels: function () { var t = this; t.ticks = t.ticks.map(function (e, a, i) { return t.options.ticks.userCallback ? t.options.ticks.userCallback(e, a, i) : t.options.ticks.callback(e, a, i) }, t) }, afterTickToLabelConversion: function () { e.callCallback(this.options.afterTickToLabelConversion, [this]) }, beforeCalculateTickRotation: function () { e.callCallback(this.options.beforeCalculateTickRotation, [this]) }, calculateTickRotation: function () { var a = this, i = a.ctx, n = t.defaults.global, o = a.options.ticks, r = e.getValueOrDefault(o.fontSize, n.defaultFontSize), l = e.getValueOrDefault(o.fontStyle, n.defaultFontStyle), s = e.getValueOrDefault(o.fontFamily, n.defaultFontFamily), d = e.fontString(r, l, s); i.font = d; var u, c = i.measureText(a.ticks[0]).width, h = i.measureText(a.ticks[a.ticks.length - 1]).width; if (a.labelRotation = o.minRotation || 0, a.paddingRight = 0, a.paddingLeft = 0, a.options.display && a.isHorizontal()) { a.paddingRight = h / 2 + 3, a.paddingLeft = c / 2 + 3, a.longestTextCache || (a.longestTextCache = {}); for (var f, g, p = e.longestText(i, d, a.ticks, a.longestTextCache), m = p, b = a.getPixelForTick(1) - a.getPixelForTick(0) - 6; m > b && a.labelRotation < o.maxRotation;) { if (f = Math.cos(e.toRadians(a.labelRotation)), g = Math.sin(e.toRadians(a.labelRotation)), u = f * c, u + r / 2 > a.yLabelWidth && (a.paddingLeft = u + r / 2), a.paddingRight = r / 2, g * p > a.maxHeight) { a.labelRotation--; break } a.labelRotation++ , m = f * p } } a.margins && (a.paddingLeft = Math.max(a.paddingLeft - a.margins.left, 0), a.paddingRight = Math.max(a.paddingRight - a.margins.right, 0)) }, afterCalculateTickRotation: function () { e.callCallback(this.options.afterCalculateTickRotation, [this]) }, beforeFit: function () { e.callCallback(this.options.beforeFit, [this]) }, fit: function () { var a = this, i = a.minSize = { width: 0, height: 0 }, n = a.options, o = t.defaults.global, r = n.ticks, l = n.scaleLabel, s = n.gridLines, d = n.display, u = a.isHorizontal(), c = e.getValueOrDefault(r.fontSize, o.defaultFontSize), h = e.getValueOrDefault(r.fontStyle, o.defaultFontStyle), f = e.getValueOrDefault(r.fontFamily, o.defaultFontFamily), g = e.fontString(c, h, f), p = e.getValueOrDefault(l.fontSize, o.defaultFontSize), m = n.gridLines.tickMarkLength; if (u ? i.width = a.isFullWidth() ? a.maxWidth - a.margins.left - a.margins.right : a.maxWidth : i.width = d && s.drawTicks ? m : 0, u ? i.height = d && s.drawTicks ? m : 0 : i.height = a.maxHeight, l.display && d && (u ? i.height += 1.5 * p : i.width += 1.5 * p), r.display && d) { a.longestTextCache || (a.longestTextCache = {}); var b = e.longestText(a.ctx, g, a.ticks, a.longestTextCache), v = e.numberOfLabelLines(a.ticks), x = .5 * c; if (u) { a.longestLabelWidth = b; var y = Math.sin(e.toRadians(a.labelRotation)) * a.longestLabelWidth + c * v + x * v; i.height = Math.min(a.maxHeight, i.height + y), a.ctx.font = g; var k = a.ctx.measureText(a.ticks[0]).width, S = a.ctx.measureText(a.ticks[a.ticks.length - 1]).width, w = Math.cos(e.toRadians(a.labelRotation)), C = Math.sin(e.toRadians(a.labelRotation)); a.paddingLeft = 0 !== a.labelRotation ? w * k + 3 : k / 2 + 3, a.paddingRight = 0 !== a.labelRotation ? C * (c / 2) + 3 : S / 2 + 3 } else { var M = a.maxWidth - i.width, D = r.mirror; D ? b = 0 : b += a.options.ticks.padding, M > b ? i.width += b : i.width = a.maxWidth, a.paddingTop = c / 2, a.paddingBottom = c / 2 } } a.margins && (a.paddingLeft = Math.max(a.paddingLeft - a.margins.left, 0), a.paddingTop = Math.max(a.paddingTop - a.margins.top, 0), a.paddingRight = Math.max(a.paddingRight - a.margins.right, 0), a.paddingBottom = Math.max(a.paddingBottom - a.margins.bottom, 0)), a.width = i.width, a.height = i.height }, afterFit: function () { e.callCallback(this.options.afterFit, [this]) }, isHorizontal: function () { return "top" === this.options.position || "bottom" === this.options.position }, isFullWidth: function () { return this.options.fullWidth }, getRightValue: function (t) { return null === t || "undefined" == typeof t ? NaN : "number" == typeof t && isNaN(t) ? NaN : "object" == typeof t ? t instanceof Date || t.isValid ? t : this.getRightValue(this.isHorizontal() ? t.x : t.y) : t }, getLabelForIndex: e.noop, getPixelForValue: e.noop, getValueForPixel: e.noop, getPixelForTick: function (t, e) { var a = this; if (a.isHorizontal()) { var i = a.width - (a.paddingLeft + a.paddingRight), n = i / Math.max(a.ticks.length - (a.options.gridLines.offsetGridLines ? 0 : 1), 1), o = n * t + a.paddingLeft; e && (o += n / 2); var r = a.left + Math.round(o); return r += a.isFullWidth() ? a.margins.left : 0 } var l = a.height - (a.paddingTop + a.paddingBottom); return a.top + t * (l / (a.ticks.length - 1)) }, getPixelForDecimal: function (t) { var e = this; if (e.isHorizontal()) { var a = e.width - (e.paddingLeft + e.paddingRight), i = a * t + e.paddingLeft, n = e.left + Math.round(i); return n += e.isFullWidth() ? e.margins.left : 0 } return e.top + t * e.height }, getBasePixel: function () { var t = this, e = t.min, a = t.max; return t.getPixelForValue(t.beginAtZero ? 0 : 0 > e && 0 > a ? a : e > 0 && a > 0 ? e : 0) }, draw: function (a) { var i = this, n = i.options; if (n.display) { var o, r, l = i.ctx, s = t.defaults.global, d = n.ticks, u = n.gridLines, c = n.scaleLabel, h = 0 !== i.labelRotation, f = d.autoSkip, g = i.isHorizontal(); d.maxTicksLimit && (r = d.maxTicksLimit); var p = e.getValueOrDefault(d.fontColor, s.defaultFontColor), m = e.getValueOrDefault(d.fontSize, s.defaultFontSize), b = e.getValueOrDefault(d.fontStyle, s.defaultFontStyle), v = e.getValueOrDefault(d.fontFamily, s.defaultFontFamily), x = e.fontString(m, b, v), y = u.tickMarkLength, k = e.getValueOrDefault(u.borderDash, s.borderDash), S = e.getValueOrDefault(u.borderDashOffset, s.borderDashOffset), w = e.getValueOrDefault(c.fontColor, s.defaultFontColor), C = e.getValueOrDefault(c.fontSize, s.defaultFontSize), M = e.getValueOrDefault(c.fontStyle, s.defaultFontStyle), D = e.getValueOrDefault(c.fontFamily, s.defaultFontFamily), I = e.fontString(C, M, D), A = e.toRadians(i.labelRotation), T = Math.cos(A), P = i.longestLabelWidth * T; l.fillStyle = p; var F = []; if (g) { if (o = !1, h && (P /= 2), (P + d.autoSkipPadding) * i.ticks.length > i.width - (i.paddingLeft + i.paddingRight) && (o = 1 + Math.floor((P + d.autoSkipPadding) * i.ticks.length / (i.width - (i.paddingLeft + i.paddingRight)))), r && i.ticks.length > r) for (; !o || i.ticks.length / (o || 1) > r;)o || (o = 1), o += 1; f || (o = !1) } var R = "right" === n.position ? i.left : i.right - y, _ = "right" === n.position ? i.left + y : i.right, V = "bottom" === n.position ? i.top : i.bottom - y, L = "bottom" === n.position ? i.top + y : i.bottom; if (e.each(i.ticks, function (t, r) { if (void 0 !== t && null !== t) { var l = i.ticks.length === r + 1, s = o > 1 && r % o > 0 || r % o === 0 && r + o >= i.ticks.length; if ((!s || l) && void 0 !== t && null !== t) { var c, f; r === ("undefined" != typeof i.zeroLineIndex ? i.zeroLineIndex : 0) ? (c = u.zeroLineWidth, f = u.zeroLineColor) : (c = e.getValueAtIndexOrDefault(u.lineWidth, r), f = e.getValueAtIndexOrDefault(u.color, r)); var p, m, b, v, x, w, C, M, D, I, T = "middle", P = "middle"; if (g) { h || (P = "top" === n.position ? "bottom" : "top"), T = h ? "right" : "center"; var O = i.getPixelForTick(r) + e.aliasPixel(c); D = i.getPixelForTick(r, u.offsetGridLines) + d.labelOffset, I = h ? i.top + 12 : "top" === n.position ? i.bottom - y : i.top + y, p = b = x = C = O, m = V, v = L, w = a.top, M = a.bottom } else { "left" === n.position ? d.mirror ? (D = i.right + d.padding, T = "left") : (D = i.right - d.padding, T = "right") : d.mirror ? (D = i.left - d.padding, T = "right") : (D = i.left + d.padding, T = "left"); var B = i.getPixelForTick(r); B += e.aliasPixel(c), I = i.getPixelForTick(r, u.offsetGridLines), p = R, b = _, x = a.left, C = a.right, m = v = w = M = B } F.push({ tx1: p, ty1: m, tx2: b, ty2: v, x1: x, y1: w, x2: C, y2: M, labelX: D, labelY: I, glWidth: c, glColor: f, glBorderDash: k, glBorderDashOffset: S, rotation: -1 * A, label: t, textBaseline: P, textAlign: T }) } } }), e.each(F, function (t) { if (u.display && (l.save(), l.lineWidth = t.glWidth, l.strokeStyle = t.glColor, l.setLineDash && (l.setLineDash(t.glBorderDash), l.lineDashOffset = t.glBorderDashOffset), l.beginPath(), u.drawTicks && (l.moveTo(t.tx1, t.ty1), l.lineTo(t.tx2, t.ty2)), u.drawOnChartArea && (l.moveTo(t.x1, t.y1), l.lineTo(t.x2, t.y2)), l.stroke(), l.restore()), d.display) { l.save(), l.translate(t.labelX, t.labelY), l.rotate(t.rotation), l.font = x, l.textBaseline = t.textBaseline, l.textAlign = t.textAlign; var a = t.label; if (e.isArray(a)) for (var i = 0, n = -(a.length - 1) * m * .75; i < a.length; ++i)l.fillText("" + a[i], 0, n), n += 1.5 * m; else l.fillText(a, 0, 0); l.restore() } }), c.display) { var O, B, W = 0; if (g) O = i.left + (i.right - i.left) / 2, B = "bottom" === n.position ? i.bottom - C / 2 : i.top + C / 2; else { var z = "left" === n.position; O = z ? i.left + C / 2 : i.right - C / 2, B = i.top + (i.bottom - i.top) / 2, W = z ? -.5 * Math.PI : .5 * Math.PI } l.save(), l.translate(O, B), l.rotate(W), l.textAlign = "center", l.textBaseline = "middle", l.fillStyle = w, l.font = I, l.fillText(c.labelString, 0, 0), l.restore() } if (u.drawBorder) { l.lineWidth = e.getValueAtIndexOrDefault(u.lineWidth, 0), l.strokeStyle = e.getValueAtIndexOrDefault(u.color, 0); var N = i.left, H = i.right, E = i.top, U = i.bottom, q = e.aliasPixel(l.lineWidth); g ? (E = U = "top" === n.position ? i.bottom : i.top, E += q, U += q) : (N = H = "left" === n.position ? i.right : i.left, N += q, H += q), l.beginPath(), l.moveTo(N, E), l.lineTo(H, U), l.stroke() } } }
                })
            }
        }, {}], 32: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.helpers; t.scaleService = { constructors: {}, defaults: {}, registerScaleType: function (t, a, i) { this.constructors[t] = a, this.defaults[t] = e.clone(i) }, getScaleConstructor: function (t) { return this.constructors.hasOwnProperty(t) ? this.constructors[t] : void 0 }, getScaleDefaults: function (a) { return this.defaults.hasOwnProperty(a) ? e.scaleMerge(t.defaults.scale, this.defaults[a]) : {} }, updateScaleDefaults: function (t, a) { var i = this.defaults; i.hasOwnProperty(t) && (i[t] = e.extend(i[t], a)) }, addScalesToLayout: function (a) { e.each(a.scales, function (e) { t.layoutService.addBox(a, e) }) } } } }, {}], 33: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.helpers; t.defaults.global.title = { display: !1, position: "top", fullWidth: !0, fontStyle: "bold", padding: 10, text: "" }; var a = e.noop; t.Title = t.Element.extend({ initialize: function (a) { var i = this; e.extend(i, a), i.options = e.configMerge(t.defaults.global.title, a.options), i.legendHitBoxes = [] }, beforeUpdate: function () { var a = this.chart.options; a && a.title && (this.options = e.configMerge(t.defaults.global.title, a.title)) }, update: function (t, e, a) { var i = this; return i.beforeUpdate(), i.maxWidth = t, i.maxHeight = e, i.margins = a, i.beforeSetDimensions(), i.setDimensions(), i.afterSetDimensions(), i.beforeBuildLabels(), i.buildLabels(), i.afterBuildLabels(), i.beforeFit(), i.fit(), i.afterFit(), i.afterUpdate(), i.minSize }, afterUpdate: a, beforeSetDimensions: a, setDimensions: function () { var t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = { width: 0, height: 0 } }, afterSetDimensions: a, beforeBuildLabels: a, buildLabels: a, afterBuildLabels: a, beforeFit: a, fit: function () { var a = this, i = e.getValueOrDefault, n = a.options, o = t.defaults.global, r = n.display, l = i(n.fontSize, o.defaultFontSize), s = a.minSize; a.isHorizontal() ? (s.width = a.maxWidth, s.height = r ? l + 2 * n.padding : 0) : (s.width = r ? l + 2 * n.padding : 0, s.height = a.maxHeight), a.width = s.width, a.height = s.height }, afterFit: a, isHorizontal: function () { var t = this.options.position; return "top" === t || "bottom" === t }, draw: function () { var a = this, i = a.ctx, n = e.getValueOrDefault, o = a.options, r = t.defaults.global; if (o.display) { var l, s, d = n(o.fontSize, r.defaultFontSize), u = n(o.fontStyle, r.defaultFontStyle), c = n(o.fontFamily, r.defaultFontFamily), h = e.fontString(d, u, c), f = 0, g = a.top, p = a.left, m = a.bottom, b = a.right; i.fillStyle = n(o.fontColor, r.defaultFontColor), i.font = h, a.isHorizontal() ? (l = p + (b - p) / 2, s = g + (m - g) / 2) : (l = "left" === o.position ? p + d / 2 : b - d / 2, s = g + (m - g) / 2, f = Math.PI * ("left" === o.position ? -.5 : .5)), i.save(), i.translate(l, s), i.rotate(f), i.textAlign = "center", i.textBaseline = "middle", i.fillText(o.text, 0, 0), i.restore() } } }), t.plugins.register({ beforeInit: function (e) { var a = e.options, i = a.title; i && (e.titleBlock = new t.Title({ ctx: e.chart.ctx, options: i, chart: e }), t.layoutService.addBox(e, e.titleBlock)) } }) } }, {}], 34: [function (t, e, a) { "use strict"; e.exports = function (t) { function e(t, e) { return e && (n.isArray(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t } function a(t) { if (!t.length) return !1; var e, a, i = [], n = []; for (e = 0, a = t.length; a > e; ++e) { var o = t[e]; if (o && o.hasValue()) { var r = o.tooltipPosition(); i.push(r.x), n.push(r.y) } } var l = 0, s = 0; for (e = 0; e < i.length; ++e)i[e] && (l += i[e], s += n[e]); return { x: Math.round(l / i.length), y: Math.round(s / i.length) } } function i(t) { var e = t._xScale, a = t._yScale || t._scale, i = t._index, n = t._datasetIndex; return { xLabel: e ? e.getLabelForIndex(i, n) : "", yLabel: a ? a.getLabelForIndex(i, n) : "", index: i, datasetIndex: n } } var n = t.helpers; t.defaults.global.tooltips = { enabled: !0, custom: null, mode: "single", backgroundColor: "rgba(0,0,0,0.8)", titleFontStyle: "bold", titleSpacing: 2, titleMarginBottom: 6, titleFontColor: "#fff", titleAlign: "left", bodySpacing: 2, bodyFontColor: "#fff", bodyAlign: "left", footerFontStyle: "bold", footerSpacing: 2, footerMarginTop: 6, footerFontColor: "#fff", footerAlign: "left", yPadding: 6, xPadding: 6, yAlign: "center", xAlign: "center", caretSize: 5, cornerRadius: 6, multiKeyBackground: "#fff", callbacks: { beforeTitle: n.noop, title: function (t, e) { var a = "", i = e.labels, n = i ? i.length : 0; if (t.length > 0) { var o = t[0]; o.xLabel ? a = o.xLabel : n > 0 && o.index < n && (a = i[o.index]) } return a }, afterTitle: n.noop, beforeBody: n.noop, beforeLabel: n.noop, label: function (t, e) { var a = e.datasets[t.datasetIndex].label || ""; return a + ": " + t.yLabel }, labelColor: function (t, e) { var a = e.getDatasetMeta(t.datasetIndex), i = a.data[t.index], n = i._view; return { borderColor: n.borderColor, backgroundColor: n.backgroundColor } }, afterLabel: n.noop, afterBody: n.noop, beforeFooter: n.noop, footer: n.noop, afterFooter: n.noop } }, t.Tooltip = t.Element.extend({ initialize: function () { var e = this, a = t.defaults.global, i = e._options, o = n.getValueOrDefault; n.extend(e, { _model: { xPadding: i.xPadding, yPadding: i.yPadding, xAlign: i.xAlign, yAlign: i.yAlign, bodyFontColor: i.bodyFontColor, _bodyFontFamily: o(i.bodyFontFamily, a.defaultFontFamily), _bodyFontStyle: o(i.bodyFontStyle, a.defaultFontStyle), _bodyAlign: i.bodyAlign, bodyFontSize: o(i.bodyFontSize, a.defaultFontSize), bodySpacing: i.bodySpacing, titleFontColor: i.titleFontColor, _titleFontFamily: o(i.titleFontFamily, a.defaultFontFamily), _titleFontStyle: o(i.titleFontStyle, a.defaultFontStyle), titleFontSize: o(i.titleFontSize, a.defaultFontSize), _titleAlign: i.titleAlign, titleSpacing: i.titleSpacing, titleMarginBottom: i.titleMarginBottom, footerFontColor: i.footerFontColor, _footerFontFamily: o(i.footerFontFamily, a.defaultFontFamily), _footerFontStyle: o(i.footerFontStyle, a.defaultFontStyle), footerFontSize: o(i.footerFontSize, a.defaultFontSize), _footerAlign: i.footerAlign, footerSpacing: i.footerSpacing, footerMarginTop: i.footerMarginTop, caretSize: i.caretSize, cornerRadius: i.cornerRadius, backgroundColor: i.backgroundColor, opacity: 0, legendColorBackground: i.multiKeyBackground } }) }, getTitle: function () { var t = this, a = t._options, i = a.callbacks, n = i.beforeTitle.apply(t, arguments), o = i.title.apply(t, arguments), r = i.afterTitle.apply(t, arguments), l = []; return l = e(l, n), l = e(l, o), l = e(l, r) }, getBeforeBody: function () { var t = this._options.callbacks.beforeBody.apply(this, arguments); return n.isArray(t) ? t : void 0 !== t ? [t] : [] }, getBody: function (t, a) { var i = this, o = i._options.callbacks, r = []; return n.each(t, function (t) { var n = { before: [], lines: [], after: [] }; e(n.before, o.beforeLabel.call(i, t, a)), e(n.lines, o.label.call(i, t, a)), e(n.after, o.afterLabel.call(i, t, a)), r.push(n) }), r }, getAfterBody: function () { var t = this._options.callbacks.afterBody.apply(this, arguments); return n.isArray(t) ? t : void 0 !== t ? [t] : [] }, getFooter: function () { var t = this, a = t._options.callbacks, i = a.beforeFooter.apply(t, arguments), n = a.footer.apply(t, arguments), o = a.afterFooter.apply(t, arguments), r = []; return r = e(r, i), r = e(r, n), r = e(r, o) }, update: function (t) { var e, o, r = this, l = r._options, s = r._model, d = r._active, u = r._data, c = r._chartInstance; if (d.length) { s.opacity = 1; var h = [], f = a(d), g = []; for (e = 0, o = d.length; o > e; ++e)g.push(i(d[e])); l.itemSort && (g = g.sort(function (t, e) { return l.itemSort(t, e, u) })), d.length > 1 && n.each(g, function (t) { h.push(l.callbacks.labelColor.call(r, t, c)) }), n.extend(s, { title: r.getTitle(g, u), beforeBody: r.getBeforeBody(g, u), body: r.getBody(g, u), afterBody: r.getAfterBody(g, u), footer: r.getFooter(g, u), x: Math.round(f.x), y: Math.round(f.y), caretPadding: n.getValueOrDefault(f.padding, 2), labelColors: h }); var p = r.getTooltipSize(s); r.determineAlignment(p), n.extend(s, r.getBackgroundPoint(s, p)) } else r._model.opacity = 0; return t && l.custom && l.custom.call(r, s), r }, getTooltipSize: function (t) { var e = this._chart.ctx, a = { height: 2 * t.yPadding, width: 0 }, i = t.body, o = i.reduce(function (t, e) { return t + e.before.length + e.lines.length + e.after.length }, 0); o += t.beforeBody.length + t.afterBody.length; var r = t.title.length, l = t.footer.length, s = t.titleFontSize, d = t.bodyFontSize, u = t.footerFontSize; a.height += r * s, a.height += (r - 1) * t.titleSpacing, a.height += r ? t.titleMarginBottom : 0, a.height += o * d, a.height += o ? (o - 1) * t.bodySpacing : 0, a.height += l ? t.footerMarginTop : 0, a.height += l * u, a.height += l ? (l - 1) * t.footerSpacing : 0; var c = 0, h = function (t) { a.width = Math.max(a.width, e.measureText(t).width + c) }; return e.font = n.fontString(s, t._titleFontStyle, t._titleFontFamily), n.each(t.title, h), e.font = n.fontString(d, t._bodyFontStyle, t._bodyFontFamily), n.each(t.beforeBody.concat(t.afterBody), h), c = i.length > 1 ? d + 2 : 0, n.each(i, function (t) { n.each(t.before, h), n.each(t.lines, h), n.each(t.after, h) }), c = 0, e.font = n.fontString(u, t._footerFontStyle, t._footerFontFamily), n.each(t.footer, h), a.width += 2 * t.xPadding, a }, determineAlignment: function (t) { var e = this, a = e._model, i = e._chart, n = e._chartInstance.chartArea; a.y < t.height ? a.yAlign = "top" : a.y > i.height - t.height && (a.yAlign = "bottom"); var o, r, l, s, d, u = (n.left + n.right) / 2, c = (n.top + n.bottom) / 2; "center" === a.yAlign ? (o = function (t) { return u >= t }, r = function (t) { return t > u }) : (o = function (e) { return e <= t.width / 2 }, r = function (e) { return e >= i.width - t.width / 2 }), l = function (e) { return e + t.width > i.width }, s = function (e) { return e - t.width < 0 }, d = function (t) { return c >= t ? "top" : "bottom" }, o(a.x) ? (a.xAlign = "left", l(a.x) && (a.xAlign = "center", a.yAlign = d(a.y))) : r(a.x) && (a.xAlign = "right", s(a.x) && (a.xAlign = "center", a.yAlign = d(a.y))) }, getBackgroundPoint: function (t, e) { var a = { x: t.x, y: t.y }, i = t.caretSize, n = t.caretPadding, o = t.cornerRadius, r = t.xAlign, l = t.yAlign, s = i + n, d = o + n; return "right" === r ? a.x -= e.width : "center" === r && (a.x -= e.width / 2), "top" === l ? a.y += s : "bottom" === l ? a.y -= e.height + s : a.y -= e.height / 2, "center" === l ? "left" === r ? a.x += s : "right" === r && (a.x -= s) : "left" === r ? a.x -= d : "right" === r && (a.x += d), a }, drawCaret: function (t, e, a) { var i, o, r, l, s, d, u = this._view, c = this._chart.ctx, h = u.caretSize, f = u.cornerRadius, g = u.xAlign, p = u.yAlign, m = t.x, b = t.y, v = e.width, x = e.height; "center" === p ? ("left" === g ? (i = m, o = i - h, r = i) : (i = m + v, o = i + h, r = i), s = b + x / 2, l = s - h, d = s + h) : ("left" === g ? (i = m + f, o = i + h, r = o + h) : "right" === g ? (i = m + v - f, o = i - h, r = o - h) : (o = m + v / 2, i = o - h, r = o + h), "top" === p ? (l = b, s = l - h, d = l) : (l = b + x, s = l + h, d = l)); var y = n.color(u.backgroundColor); c.fillStyle = y.alpha(a * y.alpha()).rgbString(), c.beginPath(), c.moveTo(i, l), c.lineTo(o, s), c.lineTo(r, d), c.closePath(), c.fill() }, drawTitle: function (t, e, a, i) { var o = e.title; if (o.length) { a.textAlign = e._titleAlign, a.textBaseline = "top"; var r = e.titleFontSize, l = e.titleSpacing, s = n.color(e.titleFontColor); a.fillStyle = s.alpha(i * s.alpha()).rgbString(), a.font = n.fontString(r, e._titleFontStyle, e._titleFontFamily); var d, u; for (d = 0, u = o.length; u > d; ++d)a.fillText(o[d], t.x, t.y), t.y += r + l, d + 1 === o.length && (t.y += e.titleMarginBottom - l) } }, drawBody: function (t, e, a, i) { var o = e.bodyFontSize, r = e.bodySpacing, l = e.body; a.textAlign = e._bodyAlign, a.textBaseline = "top"; var s = n.color(e.bodyFontColor), d = s.alpha(i * s.alpha()).rgbString(); a.fillStyle = d, a.font = n.fontString(o, e._bodyFontStyle, e._bodyFontFamily); var u = 0, c = function (e) { a.fillText(e, t.x + u, t.y), t.y += o + r }; n.each(e.beforeBody, c); var h = l.length > 1; u = h ? o + 2 : 0, n.each(l, function (r, l) { n.each(r.before, c), n.each(r.lines, function (r) { h && (a.fillStyle = n.color(e.legendColorBackground).alpha(i).rgbaString(), a.fillRect(t.x, t.y, o, o), a.strokeStyle = n.color(e.labelColors[l].borderColor).alpha(i).rgbaString(), a.strokeRect(t.x, t.y, o, o), a.fillStyle = n.color(e.labelColors[l].backgroundColor).alpha(i).rgbaString(), a.fillRect(t.x + 1, t.y + 1, o - 2, o - 2), a.fillStyle = d), c(r) }), n.each(r.after, c) }), u = 0, n.each(e.afterBody, c), t.y -= r }, drawFooter: function (t, e, a, i) { var o = e.footer; if (o.length) { t.y += e.footerMarginTop, a.textAlign = e._footerAlign, a.textBaseline = "top"; var r = n.color(e.footerFontColor); a.fillStyle = r.alpha(i * r.alpha()).rgbString(), a.font = n.fontString(e.footerFontSize, e._footerFontStyle, e._footerFontFamily), n.each(o, function (i) { a.fillText(i, t.x, t.y), t.y += e.footerFontSize + e.footerSpacing }) } }, draw: function () { var t = this._chart.ctx, e = this._view; if (0 !== e.opacity) { var a = this.getTooltipSize(e), i = { x: e.x, y: e.y }, o = Math.abs(e.opacity < .001) ? 0 : e.opacity; if (this._options.enabled) { var r = n.color(e.backgroundColor); t.fillStyle = r.alpha(o * r.alpha()).rgbString(), n.drawRoundedRectangle(t, i.x, i.y, a.width, a.height, e.cornerRadius), t.fill(), this.drawCaret(i, a, o), i.x += e.xPadding, i.y += e.yPadding, this.drawTitle(i, e, t, o), this.drawBody(i, e, t, o), this.drawFooter(i, e, t, o) } } } }) } }, {}], 35: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.helpers, a = t.defaults.global; a.elements.arc = { backgroundColor: a.defaultColor, borderColor: "#fff", borderWidth: 2 }, t.elements.Arc = t.Element.extend({ inLabelRange: function (t) { var e = this._view; return e ? Math.pow(t - e.x, 2) < Math.pow(e.radius + e.hoverRadius, 2) : !1 }, inRange: function (t, a) { var i = this._view; if (i) { for (var n = e.getAngleFromPoint(i, { x: t, y: a }), o = n.angle, r = n.distance, l = i.startAngle, s = i.endAngle; l > s;)s += 2 * Math.PI; for (; o > s;)o -= 2 * Math.PI; for (; l > o;)o += 2 * Math.PI; var d = o >= l && s >= o, u = r >= i.innerRadius && r <= i.outerRadius; return d && u } return !1 }, tooltipPosition: function () { var t = this._view, e = t.startAngle + (t.endAngle - t.startAngle) / 2, a = (t.outerRadius - t.innerRadius) / 2 + t.innerRadius; return { x: t.x + Math.cos(e) * a, y: t.y + Math.sin(e) * a } }, draw: function () { var t = this._chart.ctx, e = this._view, a = e.startAngle, i = e.endAngle; t.beginPath(), t.arc(e.x, e.y, e.outerRadius, a, i), t.arc(e.x, e.y, e.innerRadius, i, a, !0), t.closePath(), t.strokeStyle = e.borderColor, t.lineWidth = e.borderWidth, t.fillStyle = e.backgroundColor, t.fill(), t.lineJoin = "bevel", e.borderWidth && t.stroke() } }) } }, {}], 36: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.helpers, a = t.defaults.global; t.defaults.global.elements.line = { tension: .4, backgroundColor: a.defaultColor, borderWidth: 3, borderColor: a.defaultColor, borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", capBezierPoints: !0, fill: !0 }, t.elements.Line = t.Element.extend({ draw: function () { function t(t, e) { var a = e._view; e._view.steppedLine === !0 ? (s.lineTo(a.x, t._view.y), s.lineTo(a.x, a.y)) : 0 === e._view.tension ? s.lineTo(a.x, a.y) : s.bezierCurveTo(t._view.controlPointNextX, t._view.controlPointNextY, a.controlPointPreviousX, a.controlPointPreviousY, a.x, a.y) } var i = this, n = i._view, o = n.spanGaps, r = n.scaleZero, l = i._loop, s = i._chart.ctx; s.save(); var d = i._children.slice(), u = -1; l && d.length && d.push(d[0]); var c, h, f, g; if (d.length && n.fill) { for (s.beginPath(), c = 0; c < d.length; ++c)h = d[c], f = e.previousItem(d, c), g = h._view, 0 === c ? (l ? s.moveTo(r.x, r.y) : s.moveTo(g.x, r), g.skip || (u = c, s.lineTo(g.x, g.y))) : (f = -1 === u ? f : d[u], g.skip ? o || u !== c - 1 || (l ? s.lineTo(r.x, r.y) : s.lineTo(f._view.x, r)) : (u !== c - 1 ? o && -1 !== u ? t(f, h) : l ? s.lineTo(g.x, g.y) : (s.lineTo(g.x, r), s.lineTo(g.x, g.y)) : t(f, h), u = c)); l || -1 === u || s.lineTo(d[u]._view.x, r), s.fillStyle = n.backgroundColor || a.defaultColor, s.closePath(), s.fill() } var p = a.elements.line; for (s.lineCap = n.borderCapStyle || p.borderCapStyle, s.setLineDash && s.setLineDash(n.borderDash || p.borderDash), s.lineDashOffset = n.borderDashOffset || p.borderDashOffset, s.lineJoin = n.borderJoinStyle || p.borderJoinStyle, s.lineWidth = n.borderWidth || p.borderWidth, s.strokeStyle = n.borderColor || a.defaultColor, s.beginPath(), u = -1, c = 0; c < d.length; ++c)h = d[c], f = e.previousItem(d, c), g = h._view, 0 === c ? g.skip || (s.moveTo(g.x, g.y), u = c) : (f = -1 === u ? f : d[u], g.skip || (u !== c - 1 && !o || -1 === u ? s.moveTo(g.x, g.y) : t(f, h), u = c)); s.stroke(), s.restore() } }) } }, {}], 37: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.helpers, a = t.defaults.global, i = a.defaultColor; a.elements.point = { radius: 3, pointStyle: "circle", backgroundColor: i, borderWidth: 1, borderColor: i, hitRadius: 1, hoverRadius: 4, hoverBorderWidth: 1 }, t.elements.Point = t.Element.extend({ inRange: function (t, e) { var a = this._view; return a ? Math.pow(t - a.x, 2) + Math.pow(e - a.y, 2) < Math.pow(a.hitRadius + a.radius, 2) : !1 }, inLabelRange: function (t) { var e = this._view; return e ? Math.pow(t - e.x, 2) < Math.pow(e.radius + e.hitRadius, 2) : !1 }, tooltipPosition: function () { var t = this._view; return { x: t.x, y: t.y, padding: t.radius + t.borderWidth } }, draw: function () { var n = this._view, o = this._chart.ctx, r = n.pointStyle, l = n.radius, s = n.x, d = n.y; n.skip || (o.strokeStyle = n.borderColor || i, o.lineWidth = e.getValueOrDefault(n.borderWidth, a.elements.point.borderWidth), o.fillStyle = n.backgroundColor || i, t.canvasHelpers.drawPoint(o, r, l, s, d)) } }) } }, {}], 38: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.defaults.global; e.elements.rectangle = { backgroundColor: e.defaultColor, borderWidth: 0, borderColor: e.defaultColor, borderSkipped: "bottom" }, t.elements.Rectangle = t.Element.extend({ draw: function () { function t(t) { return s[(u + t) % 4] } var e = this._chart.ctx, a = this._view, i = a.width / 2, n = a.x - i, o = a.x + i, r = a.base - (a.base - a.y), l = a.borderWidth / 2; a.borderWidth && (n += l, o -= l, r += l), e.beginPath(), e.fillStyle = a.backgroundColor, e.strokeStyle = a.borderColor, e.lineWidth = a.borderWidth; var s = [[n, a.base], [n, r], [o, r], [o, a.base]], d = ["bottom", "left", "top", "right"], u = d.indexOf(a.borderSkipped, 0); -1 === u && (u = 0), e.moveTo.apply(e, t(0)); for (var c = 1; 4 > c; c++)e.lineTo.apply(e, t(c)); e.fill(), a.borderWidth && e.stroke() }, height: function () { var t = this._view; return t.base - t.y }, inRange: function (t, e) { var a = this._view; return a ? a.y < a.base ? t >= a.x - a.width / 2 && t <= a.x + a.width / 2 && e >= a.y && e <= a.base : t >= a.x - a.width / 2 && t <= a.x + a.width / 2 && e >= a.base && e <= a.y : !1 }, inLabelRange: function (t) { var e = this._view; return e ? t >= e.x - e.width / 2 && t <= e.x + e.width / 2 : !1 }, tooltipPosition: function () { var t = this._view; return { x: t.x, y: t.y } } }) } }, {}], 39: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.helpers, a = { position: "bottom" }, i = t.Scale.extend({ getLabels: function () { var t = this.chart.data; return (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels }, determineDataLimits: function () { var t = this, a = t.getLabels(); t.minIndex = 0, t.maxIndex = a.length - 1; var i; void 0 !== t.options.ticks.min && (i = e.indexOf(a, t.options.ticks.min), t.minIndex = -1 !== i ? i : t.minIndex), void 0 !== t.options.ticks.max && (i = e.indexOf(a, t.options.ticks.max), t.maxIndex = -1 !== i ? i : t.maxIndex), t.min = a[t.minIndex], t.max = a[t.maxIndex] }, buildTicks: function () { var t = this, e = t.getLabels(); t.ticks = 0 === t.minIndex && t.maxIndex === e.length - 1 ? e : e.slice(t.minIndex, t.maxIndex + 1) }, getLabelForIndex: function (t, e) { var a = this, i = a.chart.data, n = a.isHorizontal(); return i.xLabels && n || i.yLabels && !n ? a.getRightValue(i.datasets[e].data[t]) : a.ticks[t] }, getPixelForValue: function (t, e, a, i) { var n = this, o = Math.max(n.maxIndex + 1 - n.minIndex - (n.options.gridLines.offsetGridLines ? 0 : 1), 1); if (void 0 !== t && isNaN(e)) { var r = n.getLabels(), l = r.indexOf(t); e = -1 !== l ? l : e } if (n.isHorizontal()) { var s = n.width - (n.paddingLeft + n.paddingRight), d = s / o, u = d * (e - n.minIndex) + n.paddingLeft; return (n.options.gridLines.offsetGridLines && i || n.maxIndex === n.minIndex && i) && (u += d / 2), n.left + Math.round(u) } var c = n.height - (n.paddingTop + n.paddingBottom), h = c / o, f = h * (e - n.minIndex) + n.paddingTop; return n.options.gridLines.offsetGridLines && i && (f += h / 2), n.top + Math.round(f) }, getPixelForTick: function (t, e) { return this.getPixelForValue(this.ticks[t], t + this.minIndex, null, e) }, getValueForPixel: function (t) { var e, a = this, i = Math.max(a.ticks.length - (a.options.gridLines.offsetGridLines ? 0 : 1), 1), n = a.isHorizontal(), o = n ? a.width - (a.paddingLeft + a.paddingRight) : a.height - (a.paddingTop + a.paddingBottom), r = o / i; return t -= n ? a.left : a.top, a.options.gridLines.offsetGridLines && (t -= r / 2), t -= n ? a.paddingLeft : a.paddingTop, e = 0 >= t ? 0 : Math.round(t / r) }, getBasePixel: function () { return this.bottom } }); t.scaleService.registerScaleType("category", i, a) } }, {}], 40: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.helpers, a = { position: "left", ticks: { callback: function (t, a, i) { var n = i.length > 3 ? i[2] - i[1] : i[1] - i[0]; Math.abs(n) > 1 && t !== Math.floor(t) && (n = t - Math.floor(t)); var o = e.log10(Math.abs(n)), r = ""; if (0 !== t) { var l = -1 * Math.floor(o); l = Math.max(Math.min(l, 20), 0), r = t.toFixed(l) } else r = "0"; return r } } }, i = t.LinearScaleBase.extend({ determineDataLimits: function () { function t(t) { return l ? t.xAxisID === a.id : t.yAxisID === a.id } var a = this, i = a.options, n = a.chart, o = n.data, r = o.datasets, l = a.isHorizontal(); if (a.min = null, a.max = null, i.stacked) { var s = {}; e.each(r, function (o, r) { var l = n.getDatasetMeta(r); void 0 === s[l.type] && (s[l.type] = { positiveValues: [], negativeValues: [] }); var d = s[l.type].positiveValues, u = s[l.type].negativeValues; n.isDatasetVisible(r) && t(l) && e.each(o.data, function (t, e) { var n = +a.getRightValue(t); isNaN(n) || l.data[e].hidden || (d[e] = d[e] || 0, u[e] = u[e] || 0, i.relativePoints ? d[e] = 100 : 0 > n ? u[e] += n : d[e] += n) }) }), e.each(s, function (t) { var i = t.positiveValues.concat(t.negativeValues), n = e.min(i), o = e.max(i); a.min = null === a.min ? n : Math.min(a.min, n), a.max = null === a.max ? o : Math.max(a.max, o) }) } else e.each(r, function (i, o) { var r = n.getDatasetMeta(o); n.isDatasetVisible(o) && t(r) && e.each(i.data, function (t, e) { var i = +a.getRightValue(t); isNaN(i) || r.data[e].hidden || (null === a.min ? a.min = i : i < a.min && (a.min = i), null === a.max ? a.max = i : i > a.max && (a.max = i)) }) }); this.handleTickRangeOptions() }, getTickLimit: function () { var a, i = this, n = i.options.ticks; if (i.isHorizontal()) a = Math.min(n.maxTicksLimit ? n.maxTicksLimit : 11, Math.ceil(i.width / 50)); else { var o = e.getValueOrDefault(n.fontSize, t.defaults.global.defaultFontSize); a = Math.min(n.maxTicksLimit ? n.maxTicksLimit : 11, Math.ceil(i.height / (2 * o))) } return a }, handleDirectionalChanges: function () { this.isHorizontal() || this.ticks.reverse() }, getLabelForIndex: function (t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]) }, getPixelForValue: function (t) { var e, a, i = this, n = i.paddingLeft, o = i.paddingBottom, r = i.start, l = +i.getRightValue(t), s = i.end - r; return i.isHorizontal() ? (a = i.width - (n + i.paddingRight), e = i.left + a / s * (l - r), Math.round(e + n)) : (a = i.height - (i.paddingTop + o), e = i.bottom - o - a / s * (l - r), Math.round(e)) }, getValueForPixel: function (t) { var e = this, a = e.isHorizontal(), i = e.paddingLeft, n = e.paddingBottom, o = a ? e.width - (i + e.paddingRight) : e.height - (e.paddingTop + n), r = (a ? t - e.left - i : e.bottom - n - t) / o; return e.start + (e.end - e.start) * r }, getPixelForTick: function (t) { return this.getPixelForValue(this.ticksAsNumbers[t]) } }); t.scaleService.registerScaleType("linear", i, a) } }, {}], 41: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.helpers, a = e.noop; t.LinearScaleBase = t.Scale.extend({ handleTickRangeOptions: function () { var t = this, a = t.options, i = a.ticks; if (i.beginAtZero) { var n = e.sign(t.min), o = e.sign(t.max); 0 > n && 0 > o ? t.max = 0 : n > 0 && o > 0 && (t.min = 0) } void 0 !== i.min ? t.min = i.min : void 0 !== i.suggestedMin && (t.min = Math.min(t.min, i.suggestedMin)), void 0 !== i.max ? t.max = i.max : void 0 !== i.suggestedMax && (t.max = Math.max(t.max, i.suggestedMax)), t.min === t.max && (t.max++ , i.beginAtZero || t.min--) }, getTickLimit: a, handleDirectionalChanges: a, buildTicks: function () { var t = this, a = t.options, i = t.ticks = [], n = a.ticks, o = e.getValueOrDefault, r = t.getTickLimit(); r = Math.max(2, r); var l, s = n.fixedStepSize && n.fixedStepSize > 0 || n.stepSize && n.stepSize > 0; if (s) l = o(n.fixedStepSize, n.stepSize); else { var d = e.niceNum(t.max - t.min, !1); l = e.niceNum(d / (r - 1), !0) } var u = Math.floor(t.min / l) * l, c = Math.ceil(t.max / l) * l, h = (c - u) / l; h = e.almostEquals(h, Math.round(h), l / 1e3) ? Math.round(h) : Math.ceil(h), i.push(void 0 !== n.min ? n.min : u); for (var f = 1; h > f; ++f)i.push(u + f * l); i.push(void 0 !== n.max ? n.max : c), t.handleDirectionalChanges(), t.max = e.max(i), t.min = e.min(i), n.reverse ? (i.reverse(), t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max) }, convertTicksToLabels: function () { var e = this; e.ticksAsNumbers = e.ticks.slice(), e.zeroLineIndex = e.ticks.indexOf(0), t.Scale.prototype.convertTicksToLabels.call(e) } }) } }, {}], 42: [function (t, e, a) {
            "use strict"; e.exports = function (t) {
                var e = t.helpers, a = { position: "left", ticks: { callback: function (t, a, i) { var n = t / Math.pow(10, Math.floor(e.log10(t))); return 0 === t ? "0" : 1 === n || 2 === n || 5 === n || 0 === a || a === i.length - 1 ? t.toExponential() : "" } } }, i = t.Scale.extend({
                    determineDataLimits: function () {
                        function t(t) { return d ? t.xAxisID === a.id : t.yAxisID === a.id } var a = this, i = a.options, n = i.ticks, o = a.chart, r = o.data, l = r.datasets, s = e.getValueOrDefault, d = a.isHorizontal(); if (a.min = null, a.max = null, a.minNotZero = null, i.stacked) {
                            var u = {}; e.each(l, function (n, r) { var l = o.getDatasetMeta(r); o.isDatasetVisible(r) && t(l) && (void 0 === u[l.type] && (u[l.type] = []), e.each(n.data, function (t, e) { var n = u[l.type], o = +a.getRightValue(t); isNaN(o) || l.data[e].hidden || (n[e] = n[e] || 0, i.relativePoints ? n[e] = 100 : n[e] += o) })) }), e.each(u, function (t) {
                                var i = e.min(t), n = e.max(t); a.min = null === a.min ? i : Math.min(a.min, i),
                                    a.max = null === a.max ? n : Math.max(a.max, n)
                            })
                        } else e.each(l, function (i, n) { var r = o.getDatasetMeta(n); o.isDatasetVisible(n) && t(r) && e.each(i.data, function (t, e) { var i = +a.getRightValue(t); isNaN(i) || r.data[e].hidden || (null === a.min ? a.min = i : i < a.min && (a.min = i), null === a.max ? a.max = i : i > a.max && (a.max = i), 0 !== i && (null === a.minNotZero || i < a.minNotZero) && (a.minNotZero = i)) }) }); a.min = s(n.min, a.min), a.max = s(n.max, a.max), a.min === a.max && (0 !== a.min && null !== a.min ? (a.min = Math.pow(10, Math.floor(e.log10(a.min)) - 1), a.max = Math.pow(10, Math.floor(e.log10(a.max)) + 1)) : (a.min = 1, a.max = 10))
                    }, buildTicks: function () { for (var t = this, a = t.options, i = a.ticks, n = e.getValueOrDefault, o = t.ticks = [], r = n(i.min, Math.pow(10, Math.floor(e.log10(t.min)))); r < t.max;) { o.push(r); var l, s; 0 === r ? (l = Math.floor(e.log10(t.minNotZero)), s = Math.round(t.minNotZero / Math.pow(10, l))) : (l = Math.floor(e.log10(r)), s = Math.floor(r / Math.pow(10, l)) + 1), 10 === s && (s = 1, ++l), r = s * Math.pow(10, l) } var d = n(i.max, r); o.push(d), t.isHorizontal() || o.reverse(), t.max = e.max(o), t.min = e.min(o), i.reverse ? (o.reverse(), t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max) }, convertTicksToLabels: function () { this.tickValues = this.ticks.slice(), t.Scale.prototype.convertTicksToLabels.call(this) }, getLabelForIndex: function (t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]) }, getPixelForTick: function (t) { return this.getPixelForValue(this.tickValues[t]) }, getPixelForValue: function (t) { var a, i, n, o = this, r = o.start, l = +o.getRightValue(t), s = o.paddingTop, d = o.paddingBottom, u = o.paddingLeft, c = o.options, h = c.ticks; return o.isHorizontal() ? (n = e.log10(o.end) - e.log10(r), 0 === l ? i = o.left + u : (a = o.width - (u + o.paddingRight), i = o.left + a / n * (e.log10(l) - e.log10(r)), i += u)) : (a = o.height - (s + d), 0 !== r || h.reverse ? 0 === o.end && h.reverse ? (n = e.log10(o.start) - e.log10(o.minNotZero), i = l === o.end ? o.top + s : l === o.minNotZero ? o.top + s + .02 * a : o.top + s + .02 * a + .98 * a / n * (e.log10(l) - e.log10(o.minNotZero))) : (n = e.log10(o.end) - e.log10(r), a = o.height - (s + d), i = o.bottom - d - a / n * (e.log10(l) - e.log10(r))) : (n = e.log10(o.end) - e.log10(o.minNotZero), i = l === r ? o.bottom - d : l === o.minNotZero ? o.bottom - d - .02 * a : o.bottom - d - .02 * a - .98 * a / n * (e.log10(l) - e.log10(o.minNotZero)))), i }, getValueForPixel: function (t) { var a, i, n = this, o = e.log10(n.end) - e.log10(n.start); return n.isHorizontal() ? (i = n.width - (n.paddingLeft + n.paddingRight), a = n.start * Math.pow(10, (t - n.left - n.paddingLeft) * o / i)) : (i = n.height - (n.paddingTop + n.paddingBottom), a = Math.pow(10, (n.bottom - n.paddingBottom - t) * o / i) / n.start), a }
                }); t.scaleService.registerScaleType("logarithmic", i, a)
            }
        }, {}], 43: [function (t, e, a) { "use strict"; e.exports = function (t) { var e = t.helpers, a = t.defaults.global, i = { display: !0, animate: !0, lineArc: !1, position: "chartArea", angleLines: { display: !0, color: "rgba(0, 0, 0, 0.1)", lineWidth: 1 }, ticks: { showLabelBackdrop: !0, backdropColor: "rgba(255,255,255,0.75)", backdropPaddingY: 2, backdropPaddingX: 2 }, pointLabels: { fontSize: 10, callback: function (t) { return t } } }, n = t.LinearScaleBase.extend({ getValueCount: function () { return this.chart.data.labels.length }, setDimensions: function () { var t = this, i = t.options, n = i.ticks; t.width = t.maxWidth, t.height = t.maxHeight, t.xCenter = Math.round(t.width / 2), t.yCenter = Math.round(t.height / 2); var o = e.min([t.height, t.width]), r = e.getValueOrDefault(n.fontSize, a.defaultFontSize); t.drawingArea = i.display ? o / 2 - (r / 2 + n.backdropPaddingY) : o / 2 }, determineDataLimits: function () { var t = this, a = t.chart; t.min = null, t.max = null, e.each(a.data.datasets, function (i, n) { if (a.isDatasetVisible(n)) { var o = a.getDatasetMeta(n); e.each(i.data, function (e, a) { var i = +t.getRightValue(e); isNaN(i) || o.data[a].hidden || (null === t.min ? t.min = i : i < t.min && (t.min = i), null === t.max ? t.max = i : i > t.max && (t.max = i)) }) } }), t.handleTickRangeOptions() }, getTickLimit: function () { var t = this.options.ticks, i = e.getValueOrDefault(t.fontSize, a.defaultFontSize); return Math.min(t.maxTicksLimit ? t.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * i))) }, convertTicksToLabels: function () { var e = this; t.LinearScaleBase.prototype.convertTicksToLabels.call(e), e.pointLabels = e.chart.data.labels.map(e.options.pointLabels.callback, e) }, getLabelForIndex: function (t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]) }, fit: function () { var t, i, n, o, r, l, s, d, u, c, h, f, g = this.options.pointLabels, p = e.getValueOrDefault(g.fontSize, a.defaultFontSize), m = e.getValueOrDefault(g.fontStyle, a.defaultFontStyle), b = e.getValueOrDefault(g.fontFamily, a.defaultFontFamily), v = e.fontString(p, m, b), x = e.min([this.height / 2 - p - 5, this.width / 2]), y = this.width, k = 0; for (this.ctx.font = v, i = 0; i < this.getValueCount(); i++) { t = this.getPointPosition(i, x), n = this.ctx.measureText(this.pointLabels[i] ? this.pointLabels[i] : "").width + 5; var S = this.getIndexAngle(i) + Math.PI / 2, w = 360 * S / (2 * Math.PI) % 360; 0 === w || 180 === w ? (o = n / 2, t.x + o > y && (y = t.x + o, r = i), t.x - o < k && (k = t.x - o, s = i)) : 180 > w ? t.x + n > y && (y = t.x + n, r = i) : t.x - n < k && (k = t.x - n, s = i) } u = k, c = Math.ceil(y - this.width), l = this.getIndexAngle(r), d = this.getIndexAngle(s), h = c / Math.sin(l + Math.PI / 2), f = u / Math.sin(d + Math.PI / 2), h = e.isNumber(h) ? h : 0, f = e.isNumber(f) ? f : 0, this.drawingArea = Math.round(x - (f + h) / 2), this.setCenterPoint(f, h) }, setCenterPoint: function (t, e) { var a = this, i = a.width - e - a.drawingArea, n = t + a.drawingArea; a.xCenter = Math.round((n + i) / 2 + a.left), a.yCenter = Math.round(a.height / 2 + a.top) }, getIndexAngle: function (t) { var e = 2 * Math.PI / this.getValueCount(), a = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0, i = a * Math.PI * 2 / 360; return t * e - Math.PI / 2 + i }, getDistanceFromCenterForValue: function (t) { var e = this; if (null === t) return 0; var a = e.drawingArea / (e.max - e.min); return e.options.reverse ? (e.max - t) * a : (t - e.min) * a }, getPointPosition: function (t, e) { var a = this, i = a.getIndexAngle(t); return { x: Math.round(Math.cos(i) * e) + a.xCenter, y: Math.round(Math.sin(i) * e) + a.yCenter } }, getPointPositionForValue: function (t, e) { return this.getPointPosition(t, this.getDistanceFromCenterForValue(e)) }, getBasePosition: function () { var t = this, e = t.min, a = t.max; return t.getPointPositionForValue(0, t.beginAtZero ? 0 : 0 > e && 0 > a ? a : e > 0 && a > 0 ? e : 0) }, draw: function () { var t = this, i = t.options, n = i.gridLines, o = i.ticks, r = i.angleLines, l = i.pointLabels, s = e.getValueOrDefault; if (i.display) { var d = t.ctx, u = s(o.fontSize, a.defaultFontSize), c = s(o.fontStyle, a.defaultFontStyle), h = s(o.fontFamily, a.defaultFontFamily), f = e.fontString(u, c, h); if (e.each(t.ticks, function (r, l) { if (l > 0 || i.reverse) { var c = t.getDistanceFromCenterForValue(t.ticksAsNumbers[l]), h = t.yCenter - c; if (n.display && 0 !== l) if (d.strokeStyle = e.getValueAtIndexOrDefault(n.color, l - 1), d.lineWidth = e.getValueAtIndexOrDefault(n.lineWidth, l - 1), i.lineArc) d.beginPath(), d.arc(t.xCenter, t.yCenter, c, 0, 2 * Math.PI), d.closePath(), d.stroke(); else { d.beginPath(); for (var g = 0; g < t.getValueCount(); g++) { var p = t.getPointPosition(g, c); 0 === g ? d.moveTo(p.x, p.y) : d.lineTo(p.x, p.y) } d.closePath(), d.stroke() } if (o.display) { var m = s(o.fontColor, a.defaultFontColor); if (d.font = f, o.showLabelBackdrop) { var b = d.measureText(r).width; d.fillStyle = o.backdropColor, d.fillRect(t.xCenter - b / 2 - o.backdropPaddingX, h - u / 2 - o.backdropPaddingY, b + 2 * o.backdropPaddingX, u + 2 * o.backdropPaddingY) } d.textAlign = "center", d.textBaseline = "middle", d.fillStyle = m, d.fillText(r, t.xCenter, h) } } }), !i.lineArc) { d.lineWidth = r.lineWidth, d.strokeStyle = r.color; for (var g = t.getDistanceFromCenterForValue(i.reverse ? t.min : t.max), p = s(l.fontSize, a.defaultFontSize), m = s(l.fontStyle, a.defaultFontStyle), b = s(l.fontFamily, a.defaultFontFamily), v = e.fontString(p, m, b), x = t.getValueCount() - 1; x >= 0; x--) { if (r.display) { var y = t.getPointPosition(x, g); d.beginPath(), d.moveTo(t.xCenter, t.yCenter), d.lineTo(y.x, y.y), d.stroke(), d.closePath() } var k = t.getPointPosition(x, g + 5), S = s(l.fontColor, a.defaultFontColor); d.font = v, d.fillStyle = S; var w = t.pointLabels, C = this.getIndexAngle(x) + Math.PI / 2, M = 360 * C / (2 * Math.PI) % 360; 0 === M || 180 === M ? d.textAlign = "center" : 180 > M ? d.textAlign = "left" : d.textAlign = "right", 90 === M || 270 === M ? d.textBaseline = "middle" : M > 270 || 90 > M ? d.textBaseline = "bottom" : d.textBaseline = "top", d.fillText(w[x] ? w[x] : "", k.x, k.y) } } } } }); t.scaleService.registerScaleType("radialLinear", n, i) } }, {}], 44: [function (t, e, a) { "use strict"; var i = t(1); i = "function" == typeof i ? i : window.moment, e.exports = function (t) { var e = t.helpers, a = { units: [{ name: "millisecond", steps: [1, 2, 5, 10, 20, 50, 100, 250, 500] }, { name: "second", steps: [1, 2, 5, 10, 30] }, { name: "minute", steps: [1, 2, 5, 10, 30] }, { name: "hour", steps: [1, 2, 3, 6, 12] }, { name: "day", steps: [1, 2, 5] }, { name: "week", maxStep: 4 }, { name: "month", maxStep: 3 }, { name: "quarter", maxStep: 4 }, { name: "year", maxStep: !1 }] }, n = { position: "bottom", time: { parser: !1, format: !1, unit: !1, round: !1, displayFormat: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: { millisecond: "h:mm:ss.SSS a", second: "h:mm:ss a", minute: "h:mm:ss a", hour: "MMM D, hA", day: "ll", week: "ll", month: "MMM YYYY", quarter: "[Q]Q - YYYY", year: "YYYY" } }, ticks: { autoSkip: !1 } }, o = t.Scale.extend({ initialize: function () { if (!i) throw new Error("Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com"); t.Scale.prototype.initialize.call(this) }, getLabelMoment: function (t, e) { return null === t || null === e ? null : "undefined" != typeof this.labelMoments[t] ? this.labelMoments[t][e] : null }, getLabelDiff: function (t, e) { var a = this; return null === t || null === e ? null : (void 0 === a.labelDiffs && a.buildLabelDiffs(), "undefined" != typeof a.labelDiffs[t] ? a.labelDiffs[t][e] : null) }, getMomentStartOf: function (t) { var e = this; return "week" === e.options.time.unit && e.options.time.isoWeekday !== !1 ? t.clone().startOf("isoWeek").isoWeekday(e.options.time.isoWeekday) : t.clone().startOf(e.tickUnit) }, determineDataLimits: function () { var t = this; t.labelMoments = []; var a = []; t.chart.data.labels && t.chart.data.labels.length > 0 ? (e.each(t.chart.data.labels, function (e) { var i = t.parseTime(e); i.isValid() && (t.options.time.round && i.startOf(t.options.time.round), a.push(i)) }, t), t.firstTick = i.min.call(t, a), t.lastTick = i.max.call(t, a)) : (t.firstTick = null, t.lastTick = null), e.each(t.chart.data.datasets, function (n, o) { var r = [], l = t.chart.isDatasetVisible(o); "object" == typeof n.data[0] && null !== n.data[0] ? e.each(n.data, function (e) { var a = t.parseTime(t.getRightValue(e)); a.isValid() && (t.options.time.round && a.startOf(t.options.time.round), r.push(a), l && (t.firstTick = null !== t.firstTick ? i.min(t.firstTick, a) : a, t.lastTick = null !== t.lastTick ? i.max(t.lastTick, a) : a)) }, t) : r = a, t.labelMoments.push(r) }, t), t.options.time.min && (t.firstTick = t.parseTime(t.options.time.min)), t.options.time.max && (t.lastTick = t.parseTime(t.options.time.max)), t.firstTick = (t.firstTick || i()).clone(), t.lastTick = (t.lastTick || i()).clone() }, buildLabelDiffs: function () { var t = this; t.labelDiffs = []; var a = []; t.chart.data.labels && t.chart.data.labels.length > 0 && e.each(t.chart.data.labels, function (e) { var i = t.parseTime(e); i.isValid() && (t.options.time.round && i.startOf(t.options.time.round), a.push(i.diff(t.firstTick, t.tickUnit, !0))) }, t), e.each(t.chart.data.datasets, function (i) { var n = []; "object" == typeof i.data[0] && null !== i.data[0] ? e.each(i.data, function (e) { var a = t.parseTime(t.getRightValue(e)); a.isValid() && (t.options.time.round && a.startOf(t.options.time.round), n.push(a.diff(t.firstTick, t.tickUnit, !0))) }, t) : n = a, t.labelDiffs.push(n) }, t) }, buildTicks: function () { var i = this; i.ctx.save(); var n = e.getValueOrDefault(i.options.ticks.fontSize, t.defaults.global.defaultFontSize), o = e.getValueOrDefault(i.options.ticks.fontStyle, t.defaults.global.defaultFontStyle), r = e.getValueOrDefault(i.options.ticks.fontFamily, t.defaults.global.defaultFontFamily), l = e.fontString(n, o, r); if (i.ctx.font = l, i.ticks = [], i.unitScale = 1, i.scaleSizeInUnits = 0, i.options.time.unit) i.tickUnit = i.options.time.unit || "day", i.displayFormat = i.options.time.displayFormats[i.tickUnit], i.scaleSizeInUnits = i.lastTick.diff(i.firstTick, i.tickUnit, !0), i.unitScale = e.getValueOrDefault(i.options.time.unitStepSize, 1); else { var s = i.isHorizontal() ? i.width - (i.paddingLeft + i.paddingRight) : i.height - (i.paddingTop + i.paddingBottom), d = i.tickFormatFunction(i.firstTick, 0, []), u = i.ctx.measureText(d).width, c = Math.cos(e.toRadians(i.options.ticks.maxRotation)), h = Math.sin(e.toRadians(i.options.ticks.maxRotation)); u = u * c + n * h; var f = s / u; i.tickUnit = i.options.time.minUnit, i.scaleSizeInUnits = i.lastTick.diff(i.firstTick, i.tickUnit, !0), i.displayFormat = i.options.time.displayFormats[i.tickUnit]; for (var g = 0, p = a.units[g]; g < a.units.length;) { if (i.unitScale = 1, e.isArray(p.steps) && Math.ceil(i.scaleSizeInUnits / f) < e.max(p.steps)) { for (var m = 0; m < p.steps.length; ++m)if (p.steps[m] >= Math.ceil(i.scaleSizeInUnits / f)) { i.unitScale = e.getValueOrDefault(i.options.time.unitStepSize, p.steps[m]); break } break } if (p.maxStep === !1 || Math.ceil(i.scaleSizeInUnits / f) < p.maxStep) { i.unitScale = e.getValueOrDefault(i.options.time.unitStepSize, Math.ceil(i.scaleSizeInUnits / f)); break } ++g, p = a.units[g], i.tickUnit = p.name; var b = i.firstTick.diff(i.getMomentStartOf(i.firstTick), i.tickUnit, !0), v = i.getMomentStartOf(i.lastTick.clone().add(1, i.tickUnit)).diff(i.lastTick, i.tickUnit, !0); i.scaleSizeInUnits = i.lastTick.diff(i.firstTick, i.tickUnit, !0) + b + v, i.displayFormat = i.options.time.displayFormats[p.name] } } var x; if (i.options.time.min ? x = i.getMomentStartOf(i.firstTick) : (i.firstTick = i.getMomentStartOf(i.firstTick), x = i.firstTick), !i.options.time.max) { var y = i.getMomentStartOf(i.lastTick), k = y.diff(i.lastTick, i.tickUnit, !0); 0 > k ? i.lastTick = i.getMomentStartOf(i.lastTick.add(1, i.tickUnit)) : k >= 0 && (i.lastTick = y), i.scaleSizeInUnits = i.lastTick.diff(i.firstTick, i.tickUnit, !0) } i.options.time.displayFormat && (i.displayFormat = i.options.time.displayFormat), i.ticks.push(i.firstTick.clone()); for (var S = 1; S <= i.scaleSizeInUnits; ++S) { var w = x.clone().add(S, i.tickUnit); if (i.options.time.max && w.diff(i.lastTick, i.tickUnit, !0) >= 0) break; S % i.unitScale === 0 && i.ticks.push(w) } var C = i.ticks[i.ticks.length - 1].diff(i.lastTick, i.tickUnit); (0 !== C || 0 === i.scaleSizeInUnits) && (i.options.time.max ? (i.ticks.push(i.lastTick.clone()), i.scaleSizeInUnits = i.lastTick.diff(i.ticks[0], i.tickUnit, !0)) : (i.ticks.push(i.lastTick.clone()), i.scaleSizeInUnits = i.lastTick.diff(i.firstTick, i.tickUnit, !0))), i.ctx.restore(), i.labelDiffs = void 0 }, getLabelForIndex: function (t, e) { var a = this, i = a.chart.data.labels && t < a.chart.data.labels.length ? a.chart.data.labels[t] : ""; return "object" == typeof a.chart.data.datasets[e].data[0] && (i = a.getRightValue(a.chart.data.datasets[e].data[t])), a.options.time.tooltipFormat && (i = a.parseTime(i).format(a.options.time.tooltipFormat)), i }, tickFormatFunction: function (t, a, i) { var n = t.format(this.displayFormat), o = this.options.ticks, r = e.getValueOrDefault(o.callback, o.userCallback); return r ? r(n, a, i) : n }, convertTicksToLabels: function () { var t = this; t.tickMoments = t.ticks, t.ticks = t.ticks.map(t.tickFormatFunction, t) }, getPixelForValue: function (t, e, a) { var i = this, n = null; if (void 0 !== e && void 0 !== a && (n = i.getLabelDiff(a, e)), null === n && (t && t.isValid || (t = i.parseTime(i.getRightValue(t))), t && t.isValid && t.isValid() && (n = t.diff(i.firstTick, i.tickUnit, !0))), null !== n) { var o = 0 !== n ? n / i.scaleSizeInUnits : n; if (i.isHorizontal()) { var r = i.width - (i.paddingLeft + i.paddingRight), l = r * o + i.paddingLeft; return i.left + Math.round(l) } var s = i.height - (i.paddingTop + i.paddingBottom), d = s * o + i.paddingTop; return i.top + Math.round(d) } }, getPixelForTick: function (t) { return this.getPixelForValue(this.tickMoments[t], null, null) }, getValueForPixel: function (t) { var e = this, a = e.isHorizontal() ? e.width - (e.paddingLeft + e.paddingRight) : e.height - (e.paddingTop + e.paddingBottom), n = (t - (e.isHorizontal() ? e.left + e.paddingLeft : e.top + e.paddingTop)) / a; return n *= e.scaleSizeInUnits, e.firstTick.clone().add(i.duration(n, e.tickUnit).asSeconds(), "seconds") }, parseTime: function (t) { var e = this; return "string" == typeof e.options.time.parser ? i(t, e.options.time.parser) : "function" == typeof e.options.time.parser ? e.options.time.parser(t) : "function" == typeof t.getMonth || "number" == typeof t ? i(t) : t.isValid && t.isValid() ? t : "string" != typeof e.options.time.format && e.options.time.format.call ? (console.warn("options.time.format is deprecated and replaced by options.time.parser. See http://nnnick.github.io/Chart.js/docs-v2/#scales-time-scale"), e.options.time.format(t)) : i(t, e.options.time.format) } }); t.scaleService.registerScaleType("time", o, n) } }, { 1: 1 }]
    }, {}, [7])(7)
});
/*!
 * angular-chart.js - An angular.js wrapper for Chart.js
 * http://jtblin.github.io/angular-chart.js/
 * Version: 1.1.1
 *
 * Copyright 2016 Jerome Touffe-Blin
 * Released under the BSD-2-Clause license
 * https://github.com/jtblin/angular-chart.js/blob/master/LICENSE
 */
!function (t) { "use strict"; if ("object" == typeof exports) module.exports = t("undefined" != typeof angular ? angular : require("angular"), "undefined" != typeof Chart ? Chart : require("chart.js")); else if ("function" == typeof define && define.amd) define(["angular", "chart"], t); else { if ("undefined" == typeof angular) throw new Error("AngularJS framework needs to be included, see https://angularjs.org/"); if ("undefined" == typeof Chart) throw new Error("Chart.js library needs to be included, see http://jtblin.github.io/angular-chart.js/"); t(angular, Chart) } }(function (t, r) { "use strict"; function e() { var e = { responsive: !0 }, a = { Chart: r, getOptions: function (r) { var a = r && e[r] || {}; return t.extend({}, e, a) } }; this.setOptions = function (r, n) { n ? e[r] = t.merge(e[r] || {}, n) : (n = r, e = t.merge(e, n)), t.merge(a.Chart.defaults, e) }, this.$get = function () { return a } } function a(e, a) { function o(t, r, a) { var n = D(t, r); if (C(r) && k(t, r, a, n)) { var o = a[0], c = o.getContext("2d"); r.chartGetColor = y(r); var i = b(t, r); F(r), r.chart = new e.Chart(c, { type: t, data: i, options: n }), r.$emit("chart-create", r.chart), A(o, r) } } function c(t, r) { return !!(t && r && t.length && r.length) && (Array.isArray(t[0]) ? t.length === r.length && t.every(function (t, e) { return t.length === r[e].length }) : r.reduce(i, 0) > 0 && t.length === r.length) } function i(t, r) { return t + r } function u(r, e, a) { var n = { point: void 0, points: void 0 }; return function (o) { var c = r.chart.getElementAtEvent || r.chart.getPointAtEvent, i = r.chart.getElementsAtEvent || r.chart.getPointsAtEvent; if (i) { var u = i.call(r.chart, o), l = c ? c.call(r.chart, o)[0] : void 0; a !== !1 && (t.equals(n.points, u) || t.equals(n.point, l)) || (n.point = l, n.points = u, r[e](u, o, l)) } } } function l(a, n) { for (var o = t.copy(n.chartColors || e.getOptions(a).chartColors || r.defaults.global.colors), c = o.length < n.chartData.length; o.length < n.chartData.length;)o.push(n.chartGetColor()); return c && (n.chartColors = o), o.map(h) } function h(t) { return "string" == typeof t && "r" === t[0] ? f(v(t)) : "string" == typeof t && "#" === t[0] ? f(p(t.substr(1))) : "object" == typeof t && null !== t ? t : s() } function s() { var t = [d(0, 255), d(0, 255), d(0, 255)]; return f(t) } function f(t) { var r = t[3] || 1; return t = t.slice(0, 3), { backgroundColor: g(t, .2), pointBackgroundColor: g(t, r), pointHoverBackgroundColor: g(t, .8), borderColor: g(t, r), pointBorderColor: "#fff", pointHoverBorderColor: g(t, r) } } function d(t, r) { return Math.floor(Math.random() * (r - t + 1)) + t } function g(t, r) { return n ? "rgb(" + t.join(",") + ")" : "rgba(" + t.concat(r).join(",") + ")" } function p(t) { var r = parseInt(t, 16), e = r >> 16 & 255, a = r >> 8 & 255, n = 255 & r; return [e, a, n] } function v(t) { var r = t.match(/^rgba?\(([\d,.]+)\)$/); if (!r) throw new Error("Cannot parse rgb value"); return t = r[1].split(","), t.map(Number) } function C(t) { return t.chartData && t.chartData.length } function y(t) { return "function" == typeof t.chartGetColor ? t.chartGetColor : s } function b(t, r) { var e = l(t, r); return Array.isArray(r.chartData[0]) ? m(r.chartLabels, r.chartData, r.chartSeries || [], e, r.chartDatasetOverride) : w(r.chartLabels, r.chartData, e, r.chartDatasetOverride) } function m(r, e, a, n, o) { return { labels: r, datasets: e.map(function (r, e) { var c = t.extend({}, n[e], { label: a[e], data: r }); return o && o.length >= e && t.merge(c, o[e]), c }) } } function w(r, e, a, n) { var o = { labels: r, datasets: [{ data: e, backgroundColor: a.map(function (t) { return t.pointBackgroundColor }), hoverBackgroundColor: a.map(function (t) { return t.backgroundColor }) }] }; return n && t.merge(o.datasets[0], n), o } function D(r, a) { return t.extend({}, e.getOptions(r), a.chartOptions) } function A(r, e) { r.onclick = e.chartClick ? u(e, "chartClick", !1) : t.noop, r.onmousemove = e.chartHover ? u(e, "chartHover", !0) : t.noop } function B(t, r) { Array.isArray(r.chartData[0]) ? r.chart.data.datasets.forEach(function (r, e) { r.data = t[e] }) : r.chart.data.datasets[0].data = t, r.chart.update(), r.$emit("chart-update", r.chart) } function $(t) { return !t || Array.isArray(t) && !t.length || "object" == typeof t && !Object.keys(t).length } function k(t, r, e, n) { return !n.responsive || 0 !== e[0].clientHeight || (a(function () { o(t, r, e) }, 50, !1), !1) } function F(t) { t.chart && (t.chart.destroy(), t.$emit("chart-destroy", t.chart)) } return function (r) { return { restrict: "CA", scope: { chartGetColor: "=?", chartType: "=", chartData: "=?", chartLabels: "=?", chartOptions: "=?", chartSeries: "=?", chartColors: "=?", chartClick: "=?", chartHover: "=?", chartDatasetOverride: "=?" }, link: function (e, a) { function i(t, n) { if (!t || !t.length || Array.isArray(t[0]) && !t[0].length) return void F(e); var i = r || e.chartType; if (i) return e.chart && c(t, n) ? B(t, e) : void o(i, e, a) } function u(n, c) { if (!$(n) && !t.equals(n, c)) { var i = r || e.chartType; i && o(i, e, a) } } function l(r, n) { $(r) || t.equals(r, n) || o(r, e, a) } n && window.G_vmlCanvasManager.initElement(a[0]), e.$watch("chartData", i, !0), e.$watch("chartSeries", u, !0), e.$watch("chartLabels", u, !0), e.$watch("chartOptions", u, !0), e.$watch("chartColors", u, !0), e.$watch("chartDatasetOverride", u, !0), e.$watch("chartType", l, !1), e.$on("$destroy", function () { F(e) }), e.$on("$resize", function () { e.chart && e.chart.resize() }) } } } } r.defaults.global.multiTooltipTemplate = "<%if (datasetLabel){%><%=datasetLabel%>: <%}%><%= value %>", r.defaults.global.tooltips.mode = "label", r.defaults.global.elements.line.borderWidth = 2, r.defaults.global.elements.rectangle.borderWidth = 2, r.defaults.global.legend.display = !1, r.defaults.global.colors = ["#97BBCD", "#DCDCDC", "#F7464A", "#46BFBD", "#FDB45C", "#949FB1", "#4D5360"]; var n = "object" == typeof window.G_vmlCanvasManager && null !== window.G_vmlCanvasManager && "function" == typeof window.G_vmlCanvasManager.initElement; return n && (r.defaults.global.animation = !1), t.module("chart.js", []).provider("ChartJs", e).factory("ChartJsFactory", ["ChartJs", "$timeout", a]).directive("chartBase", ["ChartJsFactory", function (t) { return new t }]).directive("chartLine", ["ChartJsFactory", function (t) { return new t("line") }]).directive("chartBar", ["ChartJsFactory", function (t) { return new t("bar") }]).directive("chartHorizontalBar", ["ChartJsFactory", function (t) { return new t("horizontalBar") }]).directive("chartRadar", ["ChartJsFactory", function (t) { return new t("radar") }]).directive("chartDoughnut", ["ChartJsFactory", function (t) { return new t("doughnut") }]).directive("chartPie", ["ChartJsFactory", function (t) { return new t("pie") }]).directive("chartPolarArea", ["ChartJsFactory", function (t) { return new t("polarArea") }]).directive("chartBubble", ["ChartJsFactory", function (t) { return new t("bubble") }]).name });
//# sourceMappingURL=angular-chart.min.js.map

angular.module("uiSwitch", []).directive("switch", function () { return { restrict: "AE", replace: !0, transclude: !0, template: function (n, e) { var s = ""; return s += "<span", s += ' class="switch' + (e.class ? " " + e.class : "") + '"', s += e.ngModel ? ' ng-click="' + e.disabled + " ? " + e.ngModel + " : " + e.ngModel + "=!" + e.ngModel + (e.ngChange ? "; " + e.ngChange + '()"' : '"') : "", s += ' ng-class="{ checked:' + e.ngModel + ", disabled:" + e.disabled + ' }"', s += ">", s += "<small></small>", s += '<input type="checkbox"', s += e.id ? ' id="' + e.id + '"' : "", s += e.name ? ' name="' + e.name + '"' : "", s += e.ngModel ? ' ng-model="' + e.ngModel + '"' : "", s += ' style="display:none" />', s += '<span class="switch-text">', s += e.on ? '<span class="on">' + e.on + "</span>" : "", s += e.off ? '<span class="off">' + e.off + "</span>" : " ", s += "</span>" } } });
/*The MIT License (MIT)

Copyright (c) 2014 https://github.com/kayalshri/

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.*/

(function ($) {
    $.fn.extend({
        tableExport: function (options) {
            var defaults = {
                separator: ',',
                ignoreColumn: [],
                tableName: 'yourTableName',
                type: 'csv',
                pdfFontSize: 14,
                pdfLeftMargin: 20,
                escape: 'true',
                htmlContent: 'false',
                consoleLog: 'false'
            };

            var options = $.extend(defaults, options);
            var el = this;

            if (defaults.type == 'csv' || defaults.type == 'txt') {

                // Header
                var tdData = "";
                $(el).find('thead').find('tr').each(function () {
                    tdData += "\n";
                    $(this).filter(':visible').find('th').each(function (index, data) {
                        if ($(this).css('display') != 'none') {
                            if (defaults.ignoreColumn.indexOf(index) == -1) {
                                tdData += '"' + parseString($(this)) + '"' + defaults.separator;
                            }
                        }

                    });
                    tdData = $.trim(tdData);
                    tdData = $.trim(tdData).substring(0, tdData.length - 1);
                });

                // Row vs Column
                $(el).find('tbody').find('tr').each(function () {
                    tdData += "\n";
                    $(this).filter(':visible').find('td').each(function (index, data) {
                        if ($(this).css('display') != 'none') {
                            if (defaults.ignoreColumn.indexOf(index) == -1) {
                                tdData += '"' + parseString($(this)) + '"' + defaults.separator;
                            }
                        }
                    });
                    //tdData = $.trim(tdData);
                    tdData = $.trim(tdData).substring(0, tdData.length - 1);
                });

                //output
                if (defaults.consoleLog == 'true') {
                    console.log(tdData);
                }
                var base64data = "base64," + $.base64.encode(tdData);
                window.open('data:application/' + defaults.type + ';filename=exportData;' + base64data);
            } else if (defaults.type == 'sql') {

                // Header
                var tdData = "INSERT INTO `" + defaults.tableName + "` (";
                $(el).find('thead').find('tr').each(function () {

                    $(this).filter(':visible').find('th').each(function (index, data) {
                        if ($(this).css('display') != 'none') {
                            if (defaults.ignoreColumn.indexOf(index) == -1) {
                                tdData += '`' + parseString($(this)) + '`,';
                            }
                        }

                    });
                    tdData = $.trim(tdData);
                    tdData = $.trim(tdData).substring(0, tdData.length - 1);
                });
                tdData += ") VALUES ";
                // Row vs Column
                $(el).find('tbody').find('tr').each(function () {
                    tdData += "(";
                    $(this).filter(':visible').find('td').each(function (index, data) {
                        if ($(this).css('display') != 'none') {
                            if (defaults.ignoreColumn.indexOf(index) == -1) {
                                tdData += '"' + parseString($(this)) + '",';
                            }
                        }
                    });

                    tdData = $.trim(tdData).substring(0, tdData.length - 1);
                    tdData += "),";
                });
                tdData = $.trim(tdData).substring(0, tdData.length - 1);
                tdData += ";";

                //output
                //console.log(tdData);

                if (defaults.consoleLog == 'true') {
                    console.log(tdData);
                }

                var base64data = "base64," + $.base64.encode(tdData);
                window.open('data:application/sql;filename=exportData;' + base64data);


            } else if (defaults.type == 'json') {

                var jsonHeaderArray = [];
                $(el).find('thead').find('tr').each(function () {
                    var tdData = "";
                    var jsonArrayTd = [];

                    $(this).filter(':visible').find('th').each(function (index, data) {
                        if ($(this).css('display') != 'none') {
                            if (defaults.ignoreColumn.indexOf(index) == -1) {
                                jsonArrayTd.push(parseString($(this)));
                            }
                        }
                    });
                    jsonHeaderArray.push(jsonArrayTd);

                });

                var jsonArray = [];
                $(el).find('tbody').find('tr').each(function () {
                    var tdData = "";
                    var jsonArrayTd = [];

                    $(this).filter(':visible').find('td').each(function (index, data) {
                        if ($(this).css('display') != 'none') {
                            if (defaults.ignoreColumn.indexOf(index) == -1) {
                                jsonArrayTd.push(parseString($(this)));
                            }
                        }
                    });
                    jsonArray.push(jsonArrayTd);

                });

                var jsonExportArray = [];
                jsonExportArray.push({ header: jsonHeaderArray, data: jsonArray });

                //Return as JSON
                //console.log(JSON.stringify(jsonExportArray));

                //Return as Array
                //console.log(jsonExportArray);
                if (defaults.consoleLog == 'true') {
                    console.log(JSON.stringify(jsonExportArray));
                }
                var base64data = "base64," + $.base64.encode(JSON.stringify(jsonExportArray));
                window.open('data:application/json;filename=exportData;' + base64data);
            } else if (defaults.type == 'xml') {

                var xml = '<?xml version="1.0" encoding="utf-8"?>';
                xml += '<tabledata><fields>';

                // Header
                $(el).find('thead').find('tr').each(function () {
                    $(this).filter(':visible').find('th').each(function (index, data) {
                        if ($(this).css('display') != 'none') {
                            if (defaults.ignoreColumn.indexOf(index) == -1) {
                                xml += "<field>" + parseString($(this)) + "</field>";
                            }
                        }
                    });
                });
                xml += '</fields><data>';

                // Row Vs Column
                var rowCount = 1;
                $(el).find('tbody').find('tr').each(function () {
                    xml += '<row id="' + rowCount + '">';
                    var colCount = 0;
                    $(this).filter(':visible').find('td').each(function (index, data) {
                        if ($(this).css('display') != 'none') {
                            if (defaults.ignoreColumn.indexOf(index) == -1) {
                                xml += "<column-" + colCount + ">" + parseString($(this)) + "</column-" + colCount + ">";
                            }
                        }
                        colCount++;
                    });
                    rowCount++;
                    xml += '</row>';
                });
                xml += '</data></tabledata>'

                if (defaults.consoleLog == 'true') {
                    console.log(xml);
                }

                var base64data = "base64," + $.base64.encode(xml);
                window.open('data:application/xml;filename=exportData;' + base64data);

            } else if (defaults.type == 'excel' || defaults.type == 'doc' || defaults.type == 'powerpoint') {
                //console.log($(this).html());
                var excel = "<table>";
                // Header
                $(el).find('thead').find('tr').each(function () {
                    excel += "<tr>";
                    $(this).filter(':visible').find('th').each(function (index, data) {
                        if ($(this).css('display') != 'none') {
                            if (defaults.ignoreColumn.indexOf(index) == -1) {
                                excel += "<td>" + parseString($(this)) + "</td>";
                            }
                        }
                    });
                    excel += '</tr>';

                });


                // Row Vs Column
                var rowCount = 1;
                $(el).find('tbody').find('tr').each(function () {
                    excel += "<tr>";
                    var colCount = 0;
                    $(this).filter(':visible').find('td').each(function (index, data) {
                        if ($(this).css('display') != 'none') {
                            if (defaults.ignoreColumn.indexOf(index) == -1) {
                                excel += "<td>" + parseString($(this)) + "</td>";
                            }
                        }
                        colCount++;
                    });
                    rowCount++;
                    excel += '</tr>';
                });
                excel += '</table>'

                if (defaults.consoleLog == 'true') {
                    console.log(excel);
                }

                var excelFile = "<html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:x='urn:schemas-microsoft-com:office:" + defaults.type + "' xmlns='http://www.w3.org/TR/REC-html40'>";
                excelFile += "<head>";
                excelFile += "<!--[if gte mso 9]>";
                excelFile += "<xml>";
                excelFile += "<x:ExcelWorkbook>";
                excelFile += "<x:ExcelWorksheets>";
                excelFile += "<x:ExcelWorksheet>";
                excelFile += "<x:Name>";
                excelFile += "{worksheet}";
                excelFile += "</x:Name>";
                excelFile += "<x:WorksheetOptions>";
                excelFile += "<x:DisplayGridlines/>";
                excelFile += "</x:WorksheetOptions>";
                excelFile += "</x:ExcelWorksheet>";
                excelFile += "</x:ExcelWorksheets>";
                excelFile += "</x:ExcelWorkbook>";
                excelFile += "</xml>";
                excelFile += "<![endif]-->";
                excelFile += "</head>";
                excelFile += "<body>";
                excelFile += excel;
                excelFile += "</body>";
                excelFile += "</html>";

                var base64data = "base64," + $.base64.encode(excelFile);
                window.open('data:application/vnd.ms-' + defaults.type + ';filename=exportData.' + defaults.type + ';' + base64data);
            } else if (defaults.type == 'png') {
                html2canvas($(el), {
                    onrendered: function (canvas) {
                        var img = canvas.toDataURL("image/png");
                        window.open(img);


                    }
                });
            } else if (defaults.type == 'pdf') {

                var doc = new jsPDF('p', 'pt', 'a4', true);
                doc.setFontSize(defaults.pdfFontSize);

                // Header
                var startColPosition = defaults.pdfLeftMargin;
                $(el).find('thead').find('tr').each(function () {
                    $(this).filter(':visible').find('th').each(function (index, data) {
                        if ($(this).css('display') != 'none') {
                            if (defaults.ignoreColumn.indexOf(index) == -1) {
                                var colPosition = startColPosition + (index * 50);
                                doc.text(colPosition, 20, parseString($(this)));
                            }
                        }
                    });
                });


                // Row Vs Column
                var startRowPosition = 20; var page = 1; var rowPosition = 0;
                $(el).find('tbody').find('tr').each(function (index, data) {
                    rowCalc = index + 1;

                    if (rowCalc % 26 == 0) {
                        doc.addPage();
                        page++;
                        startRowPosition = startRowPosition + 10;
                    }
                    rowPosition = (startRowPosition + (rowCalc * 10)) - ((page - 1) * 280);

                    $(this).filter(':visible').find('td').each(function (index, data) {
                        if ($(this).css('display') != 'none') {
                            if (defaults.ignoreColumn.indexOf(index) == -1) {
                                var colPosition = startColPosition + (index * 50);
                                doc.text(colPosition, rowPosition, parseString($(this)));
                            }
                        }

                    });

                });

                // Output as Data URI
                doc.output('datauri');

            }


            function parseString(data) {

                if (defaults.htmlContent == 'true') {
                    content_data = data.html().trim();
                } else {
                    content_data = data.text().trim();
                }

                if (defaults.escape == 'true') {
                    content_data = escape(content_data);
                }



                return content_data;
            }

        }
    });
})(jQuery);


/*
  html2canvas 0.4.1 <http://html2canvas.hertzen.com>
  Copyright (c) 2013 Niklas von Hertzen

  Released under MIT License
*/

(function (window, document, undefined) {

    //"use strict";

    var _html2canvas = {},
        previousElement,
        computedCSS,
        html2canvas;

    _html2canvas.Util = {};

    _html2canvas.Util.log = function (a) {
        if (_html2canvas.logging && window.console && window.console.log) {
            window.console.log(a);
        }
    };

    _html2canvas.Util.trimText = (function (isNative) {
        return function (input) {
            return isNative ? isNative.apply(input) : ((input || '') + '').replace(/^\s+|\s+$/g, '');
        };
    })(String.prototype.trim);

    _html2canvas.Util.asFloat = function (v) {
        return parseFloat(v);
    };

    (function () {
        // TODO: support all possible length values
        var TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g;
        var TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g;
        _html2canvas.Util.parseTextShadows = function (value) {
            if (!value || value === 'none') {
                return [];
            }

            // find multiple shadow declarations
            var shadows = value.match(TEXT_SHADOW_PROPERTY),
                results = [];
            for (var i = 0; shadows && (i < shadows.length); i++) {
                var s = shadows[i].match(TEXT_SHADOW_VALUES);
                results.push({
                    color: s[0],
                    offsetX: s[1] ? s[1].replace('px', '') : 0,
                    offsetY: s[2] ? s[2].replace('px', '') : 0,
                    blur: s[3] ? s[3].replace('px', '') : 0
                });
            }
            return results;
        };
    })();

    _html2canvas.Util.parseBackgroundImage = function (value) {
        var whitespace = ' \r\n\t',
            method, definition, prefix, prefix_i, block, results = [],
            c, mode = 0, numParen = 0, quote, args;

        var appendResult = function () {
            if (method) {
                if (definition.substr(0, 1) === '"') {
                    definition = definition.substr(1, definition.length - 2);
                }
                if (definition) {
                    args.push(definition);
                }
                if (method.substr(0, 1) === '-' &&
                    (prefix_i = method.indexOf('-', 1) + 1) > 0) {
                    prefix = method.substr(0, prefix_i);
                    method = method.substr(prefix_i);
                }
                results.push({
                    prefix: prefix,
                    method: method.toLowerCase(),
                    value: block,
                    args: args
                });
            }
            args = []; //for some odd reason, setting .length = 0 didn't work in safari
            method =
                prefix =
                definition =
                block = '';
        };

        appendResult();
        for (var i = 0, ii = value.length; i < ii; i++) {
            c = value[i];
            if (mode === 0 && whitespace.indexOf(c) > -1) {
                continue;
            }
            switch (c) {
                case '"':
                    if (!quote) {
                        quote = c;
                    }
                    else if (quote === c) {
                        quote = null;
                    }
                    break;

                case '(':
                    if (quote) { break; }
                    else if (mode === 0) {
                        mode = 1;
                        block += c;
                        continue;
                    } else {
                        numParen++;
                    }
                    break;

                case ')':
                    if (quote) { break; }
                    else if (mode === 1) {
                        if (numParen === 0) {
                            mode = 0;
                            block += c;
                            appendResult();
                            continue;
                        } else {
                            numParen--;
                        }
                    }
                    break;

                case ',':
                    if (quote) { break; }
                    else if (mode === 0) {
                        appendResult();
                        continue;
                    }
                    else if (mode === 1) {
                        if (numParen === 0 && !method.match(/^url$/i)) {
                            args.push(definition);
                            definition = '';
                            block += c;
                            continue;
                        }
                    }
                    break;
            }

            block += c;
            if (mode === 0) { method += c; }
            else { definition += c; }
        }
        appendResult();

        return results;
    };

    _html2canvas.Util.Bounds = function (element) {
        var clientRect, bounds = {};

        if (element.getBoundingClientRect) {
            clientRect = element.getBoundingClientRect();

            // TODO add scroll position to bounds, so no scrolling of window necessary
            bounds.top = clientRect.top;
            bounds.bottom = clientRect.bottom || (clientRect.top + clientRect.height);
            bounds.left = clientRect.left;

            bounds.width = element.offsetWidth;
            bounds.height = element.offsetHeight;
        }

        return bounds;
    };

    // TODO ideally, we'd want everything to go through this function instead of Util.Bounds,
    // but would require further work to calculate the correct positions for elements with offsetParents
    _html2canvas.Util.OffsetBounds = function (element) {
        var parent = element.offsetParent ? _html2canvas.Util.OffsetBounds(element.offsetParent) : { top: 0, left: 0 };

        return {
            top: element.offsetTop + parent.top,
            bottom: element.offsetTop + element.offsetHeight + parent.top,
            left: element.offsetLeft + parent.left,
            width: element.offsetWidth,
            height: element.offsetHeight
        };
    };

    function toPX(element, attribute, value) {
        var rsLeft = element.runtimeStyle && element.runtimeStyle[attribute],
            left,
            style = element.style;

        // Check if we are not dealing with pixels, (Opera has issues with this)
        // Ported from jQuery css.js
        // From the awesome hack by Dean Edwards
        // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

        // If we're not dealing with a regular pixel number
        // but a number that has a weird ending, we need to convert it to pixels

        if (!/^-?[0-9]+\.?[0-9]*(?:px)?$/i.test(value) && /^-?\d/.test(value)) {
            // Remember the original values
            left = style.left;

            // Put in the new values to get a computed value out
            if (rsLeft) {
                element.runtimeStyle.left = element.currentStyle.left;
            }
            style.left = attribute === "fontSize" ? "1em" : (value || 0);
            value = style.pixelLeft + "px";

            // Revert the changed values
            style.left = left;
            if (rsLeft) {
                element.runtimeStyle.left = rsLeft;
            }
        }

        if (!/^(thin|medium|thick)$/i.test(value)) {
            return Math.round(parseFloat(value)) + "px";
        }

        return value;
    }

    function asInt(val) {
        return parseInt(val, 10);
    }

    function isPercentage(value) {
        return value.toString().indexOf("%") !== -1;
    }

    function parseBackgroundSizePosition(value, element, attribute, index) {
        value = (value || '').split(',');
        value = value[index || 0] || value[0] || 'auto';
        value = _html2canvas.Util.trimText(value).split(' ');
        if (attribute === 'backgroundSize' && (value[0] && value[0].match(/^(cover|contain|auto)$/))) {
            return value;
        } else {
            value[0] = (value[0].indexOf("%") === -1) ? toPX(element, attribute + "X", value[0]) : value[0];
            if (value[1] === undefined) {
                if (attribute === 'backgroundSize') {
                    value[1] = 'auto';
                    return value;
                } else {
                    // IE 9 doesn't return double digit always
                    value[1] = value[0];
                }
            }
            value[1] = (value[1].indexOf("%") === -1) ? toPX(element, attribute + "Y", value[1]) : value[1];
        }
        return value;
    }

    _html2canvas.Util.getCSS = function (element, attribute, index) {
        if (previousElement !== element) {
            computedCSS = document.defaultView.getComputedStyle(element, null);
        }

        var value = computedCSS[attribute];

        if (/^background(Size|Position)$/.test(attribute)) {
            return parseBackgroundSizePosition(value, element, attribute, index);
        } else if (/border(Top|Bottom)(Left|Right)Radius/.test(attribute)) {
            var arr = value.split(" ");
            if (arr.length <= 1) {
                arr[1] = arr[0];
            }
            return arr.map(asInt);
        }

        return value;
    };

    _html2canvas.Util.resizeBounds = function (current_width, current_height, target_width, target_height, stretch_mode) {
        var target_ratio = target_width / target_height,
            current_ratio = current_width / current_height,
            output_width, output_height;

        if (!stretch_mode || stretch_mode === 'auto') {
            output_width = target_width;
            output_height = target_height;
        } else if (target_ratio < current_ratio ^ stretch_mode === 'contain') {
            output_height = target_height;
            output_width = target_height * current_ratio;
        } else {
            output_width = target_width;
            output_height = target_width / current_ratio;
        }

        return {
            width: output_width,
            height: output_height
        };
    };

    _html2canvas.Util.BackgroundPosition = function (element, bounds, image, imageIndex, backgroundSize) {
        var backgroundPosition = _html2canvas.Util.getCSS(element, 'backgroundPosition', imageIndex),
            leftPosition,
            topPosition;
        if (backgroundPosition.length === 1) {
            backgroundPosition = [backgroundPosition[0], backgroundPosition[0]];
        }

        if (isPercentage(backgroundPosition[0])) {
            leftPosition = (bounds.width - (backgroundSize || image).width) * (parseFloat(backgroundPosition[0]) / 100);
        } else {
            leftPosition = parseInt(backgroundPosition[0], 10);
        }

        if (backgroundPosition[1] === 'auto') {
            topPosition = leftPosition / image.width * image.height;
        } else if (isPercentage(backgroundPosition[1])) {
            topPosition = (bounds.height - (backgroundSize || image).height) * parseFloat(backgroundPosition[1]) / 100;
        } else {
            topPosition = parseInt(backgroundPosition[1], 10);
        }

        if (backgroundPosition[0] === 'auto') {
            leftPosition = topPosition / image.height * image.width;
        }

        return { left: leftPosition, top: topPosition };
    };

    _html2canvas.Util.BackgroundSize = function (element, bounds, image, imageIndex) {
        var backgroundSize = _html2canvas.Util.getCSS(element, 'backgroundSize', imageIndex), width, height;

        if (backgroundSize.length === 1) {
            backgroundSize = [backgroundSize[0], backgroundSize[0]];
        }

        if (isPercentage(backgroundSize[0])) {
            width = bounds.width * parseFloat(backgroundSize[0]) / 100;
        } else if (/contain|cover/.test(backgroundSize[0])) {
            return _html2canvas.Util.resizeBounds(image.width, image.height, bounds.width, bounds.height, backgroundSize[0]);
        } else {
            width = parseInt(backgroundSize[0], 10);
        }

        if (backgroundSize[0] === 'auto' && backgroundSize[1] === 'auto') {
            height = image.height;
        } else if (backgroundSize[1] === 'auto') {
            height = width / image.width * image.height;
        } else if (isPercentage(backgroundSize[1])) {
            height = bounds.height * parseFloat(backgroundSize[1]) / 100;
        } else {
            height = parseInt(backgroundSize[1], 10);
        }

        if (backgroundSize[0] === 'auto') {
            width = height / image.height * image.width;
        }

        return { width: width, height: height };
    };

    _html2canvas.Util.BackgroundRepeat = function (element, imageIndex) {
        var backgroundRepeat = _html2canvas.Util.getCSS(element, "backgroundRepeat").split(",").map(_html2canvas.Util.trimText);
        return backgroundRepeat[imageIndex] || backgroundRepeat[0];
    };

    _html2canvas.Util.Extend = function (options, defaults) {
        for (var key in options) {
            if (options.hasOwnProperty(key)) {
                defaults[key] = options[key];
            }
        }
        return defaults;
    };


    /*
     * Derived from jQuery.contents()
     * Copyright 2010, John Resig
     * Dual licensed under the MIT or GPL Version 2 licenses.
     * http://jquery.org/license
     */
    _html2canvas.Util.Children = function (elem) {
        var children;
        try {
            children = (elem.nodeName && elem.nodeName.toUpperCase() === "IFRAME") ? elem.contentDocument || elem.contentWindow.document : (function (array) {
                var ret = [];
                if (array !== null) {
                    (function (first, second) {
                        var i = first.length,
                            j = 0;

                        if (typeof second.length === "number") {
                            for (var l = second.length; j < l; j++) {
                                first[i++] = second[j];
                            }
                        } else {
                            while (second[j] !== undefined) {
                                first[i++] = second[j++];
                            }
                        }

                        first.length = i;

                        return first;
                    })(ret, array);
                }
                return ret;
            })(elem.childNodes);

        } catch (ex) {
            _html2canvas.Util.log("html2canvas.Util.Children failed with exception: " + ex.message);
            children = [];
        }
        return children;
    };

    _html2canvas.Util.isTransparent = function (backgroundColor) {
        return (!backgroundColor || backgroundColor === "transparent" || backgroundColor === "rgba(0, 0, 0, 0)");
    };

    _html2canvas.Util.Font = (function () {

        var fontData = {};

        return function (font, fontSize, doc) {
            if (fontData[font + "-" + fontSize] !== undefined) {
                return fontData[font + "-" + fontSize];
            }

            var container = doc.createElement('div'),
                img = doc.createElement('img'),
                span = doc.createElement('span'),
                sampleText = 'Hidden Text',
                baseline,
                middle,
                metricsObj;

            container.style.visibility = "hidden";
            container.style.fontFamily = font;
            container.style.fontSize = fontSize;
            container.style.margin = 0;
            container.style.padding = 0;

            doc.body.appendChild(container);

            // http://probablyprogramming.com/2009/03/15/the-tiniest-gif-ever (handtinywhite.gif)
            img.src = "data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACwAAAAAAQABAAACAkQBADs=";
            img.width = 1;
            img.height = 1;

            img.style.margin = 0;
            img.style.padding = 0;
            img.style.verticalAlign = "baseline";

            span.style.fontFamily = font;
            span.style.fontSize = fontSize;
            span.style.margin = 0;
            span.style.padding = 0;

            span.appendChild(doc.createTextNode(sampleText));
            container.appendChild(span);
            container.appendChild(img);
            baseline = (img.offsetTop - span.offsetTop) + 1;

            container.removeChild(span);
            container.appendChild(doc.createTextNode(sampleText));

            container.style.lineHeight = "normal";
            img.style.verticalAlign = "super";

            middle = (img.offsetTop - container.offsetTop) + 1;
            metricsObj = {
                baseline: baseline,
                lineWidth: 1,
                middle: middle
            };

            fontData[font + "-" + fontSize] = metricsObj;

            doc.body.removeChild(container);

            return metricsObj;
        };
    })();

    (function () {
        var Util = _html2canvas.Util,
            Generate = {};

        _html2canvas.Generate = Generate;

        var reGradients = [
            /^(-webkit-linear-gradient)\(([a-z\s]+)([\w\d\.\s,%\(\)]+)\)$/,
            /^(-o-linear-gradient)\(([a-z\s]+)([\w\d\.\s,%\(\)]+)\)$/,
            /^(-webkit-gradient)\((linear|radial),\s((?:\d{1,3}%?)\s(?:\d{1,3}%?),\s(?:\d{1,3}%?)\s(?:\d{1,3}%?))([\w\d\.\s,%\(\)\-]+)\)$/,
            /^(-moz-linear-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?))([\w\d\.\s,%\(\)]+)\)$/,
            /^(-webkit-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s([a-z\-]+)([\w\d\.\s,%\(\)]+)\)$/,
            /^(-moz-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s?([a-z\-]*)([\w\d\.\s,%\(\)]+)\)$/,
            /^(-o-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s([a-z\-]+)([\w\d\.\s,%\(\)]+)\)$/
        ];

        /*
       * TODO: Add IE10 vendor prefix (-ms) support
       * TODO: Add W3C gradient (linear-gradient) support
       * TODO: Add old Webkit -webkit-gradient(radial, ...) support
       * TODO: Maybe some RegExp optimizations are possible ;o)
       */
        Generate.parseGradient = function (css, bounds) {
            var gradient, i, len = reGradients.length, m1, stop, m2, m2Len, step, m3, tl, tr, br, bl;

            for (i = 0; i < len; i += 1) {
                m1 = css.match(reGradients[i]);
                if (m1) {
                    break;
                }
            }

            if (m1) {
                switch (m1[1]) {
                    case '-webkit-linear-gradient':
                    case '-o-linear-gradient':

                        gradient = {
                            type: 'linear',
                            x0: null,
                            y0: null,
                            x1: null,
                            y1: null,
                            colorStops: []
                        };

                        // get coordinates
                        m2 = m1[2].match(/\w+/g);
                        if (m2) {
                            m2Len = m2.length;
                            for (i = 0; i < m2Len; i += 1) {
                                switch (m2[i]) {
                                    case 'top':
                                        gradient.y0 = 0;
                                        gradient.y1 = bounds.height;
                                        break;

                                    case 'right':
                                        gradient.x0 = bounds.width;
                                        gradient.x1 = 0;
                                        break;

                                    case 'bottom':
                                        gradient.y0 = bounds.height;
                                        gradient.y1 = 0;
                                        break;

                                    case 'left':
                                        gradient.x0 = 0;
                                        gradient.x1 = bounds.width;
                                        break;
                                }
                            }
                        }
                        if (gradient.x0 === null && gradient.x1 === null) { // center
                            gradient.x0 = gradient.x1 = bounds.width / 2;
                        }
                        if (gradient.y0 === null && gradient.y1 === null) { // center
                            gradient.y0 = gradient.y1 = bounds.height / 2;
                        }

                        // get colors and stops
                        m2 = m1[3].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}(?:%|px))?)+/g);
                        if (m2) {
                            m2Len = m2.length;
                            step = 1 / Math.max(m2Len - 1, 1);
                            for (i = 0; i < m2Len; i += 1) {
                                m3 = m2[i].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/);
                                if (m3[2]) {
                                    stop = parseFloat(m3[2]);
                                    if (m3[3] === '%') {
                                        stop /= 100;
                                    } else { // px - stupid opera
                                        stop /= bounds.width;
                                    }
                                } else {
                                    stop = i * step;
                                }
                                gradient.colorStops.push({
                                    color: m3[1],
                                    stop: stop
                                });
                            }
                        }
                        break;

                    case '-webkit-gradient':

                        gradient = {
                            type: m1[2] === 'radial' ? 'circle' : m1[2], // TODO: Add radial gradient support for older mozilla definitions
                            x0: 0,
                            y0: 0,
                            x1: 0,
                            y1: 0,
                            colorStops: []
                        };

                        // get coordinates
                        m2 = m1[3].match(/(\d{1,3})%?\s(\d{1,3})%?,\s(\d{1,3})%?\s(\d{1,3})%?/);
                        if (m2) {
                            gradient.x0 = (m2[1] * bounds.width) / 100;
                            gradient.y0 = (m2[2] * bounds.height) / 100;
                            gradient.x1 = (m2[3] * bounds.width) / 100;
                            gradient.y1 = (m2[4] * bounds.height) / 100;
                        }

                        // get colors and stops
                        m2 = m1[4].match(/((?:from|to|color-stop)\((?:[0-9\.]+,\s)?(?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)\))+/g);
                        if (m2) {
                            m2Len = m2.length;
                            for (i = 0; i < m2Len; i += 1) {
                                m3 = m2[i].match(/(from|to|color-stop)\(([0-9\.]+)?(?:,\s)?((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\)/);
                                stop = parseFloat(m3[2]);
                                if (m3[1] === 'from') {
                                    stop = 0.0;
                                }
                                if (m3[1] === 'to') {
                                    stop = 1.0;
                                }
                                gradient.colorStops.push({
                                    color: m3[3],
                                    stop: stop
                                });
                            }
                        }
                        break;

                    case '-moz-linear-gradient':

                        gradient = {
                            type: 'linear',
                            x0: 0,
                            y0: 0,
                            x1: 0,
                            y1: 0,
                            colorStops: []
                        };

                        // get coordinates
                        m2 = m1[2].match(/(\d{1,3})%?\s(\d{1,3})%?/);

                        // m2[1] == 0%   -> left
                        // m2[1] == 50%  -> center
                        // m2[1] == 100% -> right

                        // m2[2] == 0%   -> top
                        // m2[2] == 50%  -> center
                        // m2[2] == 100% -> bottom

                        if (m2) {
                            gradient.x0 = (m2[1] * bounds.width) / 100;
                            gradient.y0 = (m2[2] * bounds.height) / 100;
                            gradient.x1 = bounds.width - gradient.x0;
                            gradient.y1 = bounds.height - gradient.y0;
                        }

                        // get colors and stops
                        m2 = m1[3].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}%)?)+/g);
                        if (m2) {
                            m2Len = m2.length;
                            step = 1 / Math.max(m2Len - 1, 1);
                            for (i = 0; i < m2Len; i += 1) {
                                m3 = m2[i].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%)?/);
                                if (m3[2]) {
                                    stop = parseFloat(m3[2]);
                                    if (m3[3]) { // percentage
                                        stop /= 100;
                                    }
                                } else {
                                    stop = i * step;
                                }
                                gradient.colorStops.push({
                                    color: m3[1],
                                    stop: stop
                                });
                            }
                        }
                        break;

                    case '-webkit-radial-gradient':
                    case '-moz-radial-gradient':
                    case '-o-radial-gradient':

                        gradient = {
                            type: 'circle',
                            x0: 0,
                            y0: 0,
                            x1: bounds.width,
                            y1: bounds.height,
                            cx: 0,
                            cy: 0,
                            rx: 0,
                            ry: 0,
                            colorStops: []
                        };

                        // center
                        m2 = m1[2].match(/(\d{1,3})%?\s(\d{1,3})%?/);
                        if (m2) {
                            gradient.cx = (m2[1] * bounds.width) / 100;
                            gradient.cy = (m2[2] * bounds.height) / 100;
                        }

                        // size
                        m2 = m1[3].match(/\w+/);
                        m3 = m1[4].match(/[a-z\-]*/);
                        if (m2 && m3) {
                            switch (m3[0]) {
                                case 'farthest-corner':
                                case 'cover': // is equivalent to farthest-corner
                                case '': // mozilla removes "cover" from definition :(
                                    tl = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.cy, 2));
                                    tr = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                                    br = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                                    bl = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.cy, 2));
                                    gradient.rx = gradient.ry = Math.max(tl, tr, br, bl);
                                    break;
                                case 'closest-corner':
                                    tl = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.cy, 2));
                                    tr = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                                    br = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                                    bl = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.cy, 2));
                                    gradient.rx = gradient.ry = Math.min(tl, tr, br, bl);
                                    break;
                                case 'farthest-side':
                                    if (m2[0] === 'circle') {
                                        gradient.rx = gradient.ry = Math.max(
                                            gradient.cx,
                                            gradient.cy,
                                            gradient.x1 - gradient.cx,
                                            gradient.y1 - gradient.cy
                                        );
                                    } else { // ellipse

                                        gradient.type = m2[0];

                                        gradient.rx = Math.max(
                                            gradient.cx,
                                            gradient.x1 - gradient.cx
                                        );
                                        gradient.ry = Math.max(
                                            gradient.cy,
                                            gradient.y1 - gradient.cy
                                        );
                                    }
                                    break;
                                case 'closest-side':
                                case 'contain': // is equivalent to closest-side
                                    if (m2[0] === 'circle') {
                                        gradient.rx = gradient.ry = Math.min(
                                            gradient.cx,
                                            gradient.cy,
                                            gradient.x1 - gradient.cx,
                                            gradient.y1 - gradient.cy
                                        );
                                    } else { // ellipse

                                        gradient.type = m2[0];

                                        gradient.rx = Math.min(
                                            gradient.cx,
                                            gradient.x1 - gradient.cx
                                        );
                                        gradient.ry = Math.min(
                                            gradient.cy,
                                            gradient.y1 - gradient.cy
                                        );
                                    }
                                    break;

                                // TODO: add support for "30px 40px" sizes (webkit only)
                            }
                        }

                        // color stops
                        m2 = m1[5].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}(?:%|px))?)+/g);
                        if (m2) {
                            m2Len = m2.length;
                            step = 1 / Math.max(m2Len - 1, 1);
                            for (i = 0; i < m2Len; i += 1) {
                                m3 = m2[i].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/);
                                if (m3[2]) {
                                    stop = parseFloat(m3[2]);
                                    if (m3[3] === '%') {
                                        stop /= 100;
                                    } else { // px - stupid opera
                                        stop /= bounds.width;
                                    }
                                } else {
                                    stop = i * step;
                                }
                                gradient.colorStops.push({
                                    color: m3[1],
                                    stop: stop
                                });
                            }
                        }
                        break;
                }
            }

            return gradient;
        };

        function addScrollStops(grad) {
            return function (colorStop) {
                try {
                    grad.addColorStop(colorStop.stop, colorStop.color);
                }
                catch (e) {
                    Util.log(['failed to add color stop: ', e, '; tried to add: ', colorStop]);
                }
            };
        }

        Generate.Gradient = function (src, bounds) {
            if (bounds.width === 0 || bounds.height === 0) {
                return;
            }

            var canvas = document.createElement('canvas'),
                ctx = canvas.getContext('2d'),
                gradient, grad;

            canvas.width = bounds.width;
            canvas.height = bounds.height;

            // TODO: add support for multi defined background gradients
            gradient = _html2canvas.Generate.parseGradient(src, bounds);

            if (gradient) {
                switch (gradient.type) {
                    case 'linear':
                        grad = ctx.createLinearGradient(gradient.x0, gradient.y0, gradient.x1, gradient.y1);
                        gradient.colorStops.forEach(addScrollStops(grad));
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, bounds.width, bounds.height);
                        break;

                    case 'circle':
                        grad = ctx.createRadialGradient(gradient.cx, gradient.cy, 0, gradient.cx, gradient.cy, gradient.rx);
                        gradient.colorStops.forEach(addScrollStops(grad));
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, bounds.width, bounds.height);
                        break;

                    case 'ellipse':
                        var canvasRadial = document.createElement('canvas'),
                            ctxRadial = canvasRadial.getContext('2d'),
                            ri = Math.max(gradient.rx, gradient.ry),
                            di = ri * 2;

                        canvasRadial.width = canvasRadial.height = di;

                        grad = ctxRadial.createRadialGradient(gradient.rx, gradient.ry, 0, gradient.rx, gradient.ry, ri);
                        gradient.colorStops.forEach(addScrollStops(grad));

                        ctxRadial.fillStyle = grad;
                        ctxRadial.fillRect(0, 0, di, di);

                        ctx.fillStyle = gradient.colorStops[gradient.colorStops.length - 1].color;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(canvasRadial, gradient.cx - gradient.rx, gradient.cy - gradient.ry, 2 * gradient.rx, 2 * gradient.ry);
                        break;
                }
            }

            return canvas;
        };

        Generate.ListAlpha = function (number) {
            var tmp = "",
                modulus;

            do {
                modulus = number % 26;
                tmp = String.fromCharCode((modulus) + 64) + tmp;
                number = number / 26;
            } while ((number * 26) > 26);

            return tmp;
        };

        Generate.ListRoman = function (number) {
            var romanArray = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"],
                decimal = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
                roman = "",
                v,
                len = romanArray.length;

            if (number <= 0 || number >= 4000) {
                return number;
            }

            for (v = 0; v < len; v += 1) {
                while (number >= decimal[v]) {
                    number -= decimal[v];
                    roman += romanArray[v];
                }
            }

            return roman;
        };
    })();
    function h2cRenderContext(width, height) {
        var storage = [];
        return {
            storage: storage,
            width: width,
            height: height,
            clip: function () {
                storage.push({
                    type: "function",
                    name: "clip",
                    'arguments': arguments
                });
            },
            translate: function () {
                storage.push({
                    type: "function",
                    name: "translate",
                    'arguments': arguments
                });
            },
            fill: function () {
                storage.push({
                    type: "function",
                    name: "fill",
                    'arguments': arguments
                });
            },
            save: function () {
                storage.push({
                    type: "function",
                    name: "save",
                    'arguments': arguments
                });
            },
            restore: function () {
                storage.push({
                    type: "function",
                    name: "restore",
                    'arguments': arguments
                });
            },
            fillRect: function () {
                storage.push({
                    type: "function",
                    name: "fillRect",
                    'arguments': arguments
                });
            },
            createPattern: function () {
                storage.push({
                    type: "function",
                    name: "createPattern",
                    'arguments': arguments
                });
            },
            drawShape: function () {

                var shape = [];

                storage.push({
                    type: "function",
                    name: "drawShape",
                    'arguments': shape
                });

                return {
                    moveTo: function () {
                        shape.push({
                            name: "moveTo",
                            'arguments': arguments
                        });
                    },
                    lineTo: function () {
                        shape.push({
                            name: "lineTo",
                            'arguments': arguments
                        });
                    },
                    arcTo: function () {
                        shape.push({
                            name: "arcTo",
                            'arguments': arguments
                        });
                    },
                    bezierCurveTo: function () {
                        shape.push({
                            name: "bezierCurveTo",
                            'arguments': arguments
                        });
                    },
                    quadraticCurveTo: function () {
                        shape.push({
                            name: "quadraticCurveTo",
                            'arguments': arguments
                        });
                    }
                };

            },
            drawImage: function () {
                storage.push({
                    type: "function",
                    name: "drawImage",
                    'arguments': arguments
                });
            },
            fillText: function () {
                storage.push({
                    type: "function",
                    name: "fillText",
                    'arguments': arguments
                });
            },
            setVariable: function (variable, value) {
                storage.push({
                    type: "variable",
                    name: variable,
                    'arguments': value
                });
                return value;
            }
        };
    }
    _html2canvas.Parse = function (images, options, cb) {
        window.scroll(0, 0);

        var element = ((options.elements === undefined) ? document.body : options.elements[0]), // select body by default
            numDraws = 0,
            doc = element.ownerDocument,
            Util = _html2canvas.Util,
            support = Util.Support(options, doc),
            ignoreElementsRegExp = new RegExp("(" + options.ignoreElements + ")"),
            body = doc.body,
            getCSS = Util.getCSS,
            pseudoHide = "___html2canvas___pseudoelement",
            hidePseudoElementsStyles = doc.createElement('style');

        hidePseudoElementsStyles.innerHTML = '.' + pseudoHide +
            '-parent:before { content: "" !important; display: none !important; }' +
            '.' + pseudoHide + '-parent:after { content: "" !important; display: none !important; }';

        body.appendChild(hidePseudoElementsStyles);

        images = images || {};

        init();

        function init() {
            var background = getCSS(document.documentElement, "backgroundColor"),
                transparentBackground = (Util.isTransparent(background) && element === document.body),
                stack = renderElement(element, null, false, transparentBackground);

            // create pseudo elements in a single pass to prevent synchronous layouts
            addPseudoElements(element);

            parseChildren(element, stack, function () {
                if (transparentBackground) {
                    background = stack.backgroundColor;
                }

                removePseudoElements();

                Util.log('Done parsing, moving to Render.');

                cb({
                    backgroundColor: background,
                    stack: stack
                });
            });
        }

        // Given a root element, find all pseudo elements below, create elements mocking pseudo element styles
        // so we can process them as normal elements, and hide the original pseudo elements so they don't interfere
        // with layout.
        function addPseudoElements(el) {
            // These are done in discrete steps to prevent a relayout loop caused by addClass() invalidating
            // layouts & getPseudoElement calling getComputedStyle.
            var jobs = [], classes = [];
            getPseudoElementClasses();
            findPseudoElements(el);
            runJobs();

            function getPseudoElementClasses() {
                var findPsuedoEls = /:before|:after/;
                var sheets = document.styleSheets;
                for (var i = 0, j = sheets.length; i < j; i++) {
                    try {
                        var rules = sheets[i].cssRules;
                        for (var k = 0, l = rules.length; k < l; k++) {
                            if (findPsuedoEls.test(rules[k].selectorText)) {
                                classes.push(rules[k].selectorText);
                            }
                        }
                    }
                    catch (e) { // will throw security exception for style sheets loaded from external domains
                    }
                }

                // Trim off the :after and :before (or ::after and ::before)
                for (i = 0, j = classes.length; i < j; i++) {
                    classes[i] = classes[i].match(/(^[^:]*)/)[1];
                }
            }

            // Using the list of elements we know how pseudo el styles, create fake pseudo elements.
            function findPseudoElements(el) {
                var els = document.querySelectorAll(classes.join(','));
                for (var i = 0, j = els.length; i < j; i++) {
                    createPseudoElements(els[i]);
                }
            }

            // Create pseudo elements & add them to a job queue.
            function createPseudoElements(el) {
                var before = getPseudoElement(el, ':before'),
                    after = getPseudoElement(el, ':after');

                if (before) {
                    jobs.push({ type: 'before', pseudo: before, el: el });
                }

                if (after) {
                    jobs.push({ type: 'after', pseudo: after, el: el });
                }
            }

            // Adds a class to the pseudo's parent to prevent the original before/after from messing
            // with layouts.
            // Execute the inserts & addClass() calls in a batch to prevent relayouts.
            function runJobs() {
                // Add Class
                jobs.forEach(function (job) {
                    addClass(job.el, pseudoHide + "-parent");
                });

                // Insert el
                jobs.forEach(function (job) {
                    if (job.type === 'before') {
                        job.el.insertBefore(job.pseudo, job.el.firstChild);
                    } else {
                        job.el.appendChild(job.pseudo);
                    }
                });
            }
        }



        // Delete our fake pseudo elements from the DOM. This will remove those actual elements
        // and the classes on their parents that hide the actual pseudo elements.
        // Note that NodeLists are 'live' collections so you can't use a for loop here. They are
        // actually deleted from the NodeList after each iteration.
        function removePseudoElements() {
            // delete pseudo elements
            body.removeChild(hidePseudoElementsStyles);
            var pseudos = document.getElementsByClassName(pseudoHide + "-element");
            while (pseudos.length) {
                pseudos[0].parentNode.removeChild(pseudos[0]);
            }

            // Remove pseudo hiding classes
            var parents = document.getElementsByClassName(pseudoHide + "-parent");
            while (parents.length) {
                removeClass(parents[0], pseudoHide + "-parent");
            }
        }

        function addClass(el, className) {
            if (el.classList) {
                el.classList.add(className);
            } else {
                el.className = el.className + " " + className;
            }
        }

        function removeClass(el, className) {
            if (el.classList) {
                el.classList.remove(className);
            } else {
                el.className = el.className.replace(className, "").trim();
            }
        }

        function hasClass(el, className) {
            return el.className.indexOf(className) > -1;
        }

        // Note that this doesn't work in < IE8, but we don't support that anyhow
        function nodeListToArray(nodeList) {
            return Array.prototype.slice.call(nodeList);
        }

        function documentWidth() {
            return Math.max(
                Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth),
                Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth),
                Math.max(doc.body.clientWidth, doc.documentElement.clientWidth)
            );
        }

        function documentHeight() {
            return Math.max(
                Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight),
                Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight),
                Math.max(doc.body.clientHeight, doc.documentElement.clientHeight)
            );
        }

        function getCSSInt(element, attribute) {
            var val = parseInt(getCSS(element, attribute), 10);
            return (isNaN(val)) ? 0 : val; // borders in old IE are throwing 'medium' for demo.html
        }

        function renderRect(ctx, x, y, w, h, bgcolor) {
            if (bgcolor !== "transparent") {
                ctx.setVariable("fillStyle", bgcolor);
                ctx.fillRect(x, y, w, h);
                numDraws += 1;
            }
        }

        function capitalize(m, p1, p2) {
            if (m.length > 0) {
                return p1 + p2.toUpperCase();
            }
        }

        function textTransform(text, transform) {
            switch (transform) {
                case "lowercase":
                    return text.toLowerCase();
                case "capitalize":
                    return text.replace(/(^|\s|:|-|\(|\))([a-z])/g, capitalize);
                case "uppercase":
                    return text.toUpperCase();
                default:
                    return text;
            }
        }

        function noLetterSpacing(letter_spacing) {
            return (/^(normal|none|0px)$/.test(letter_spacing));
        }

        function drawText(currentText, x, y, ctx) {
            if (currentText !== null && Util.trimText(currentText).length > 0) {
                ctx.fillText(currentText, x, y);
                numDraws += 1;
            }
        }

        function setTextVariables(ctx, el, text_decoration, color) {
            var align = false,
                bold = getCSS(el, "fontWeight"),
                family = getCSS(el, "fontFamily"),
                size = getCSS(el, "fontSize"),
                shadows = Util.parseTextShadows(getCSS(el, "textShadow"));

            switch (parseInt(bold, 10)) {
                case 401:
                    bold = "bold";
                    break;
                case 400:
                    bold = "normal";
                    break;
            }

            ctx.setVariable("fillStyle", color);
            ctx.setVariable("font", [getCSS(el, "fontStyle"), getCSS(el, "fontVariant"), bold, size, family].join(" "));
            ctx.setVariable("textAlign", (align) ? "right" : "left");

            if (shadows.length) {
                // TODO: support multiple text shadows
                // apply the first text shadow
                ctx.setVariable("shadowColor", shadows[0].color);
                ctx.setVariable("shadowOffsetX", shadows[0].offsetX);
                ctx.setVariable("shadowOffsetY", shadows[0].offsetY);
                ctx.setVariable("shadowBlur", shadows[0].blur);
            }

            if (text_decoration !== "none") {
                return Util.Font(family, size, doc);
            }
        }

        function renderTextDecoration(ctx, text_decoration, bounds, metrics, color) {
            switch (text_decoration) {
                case "underline":
                    // Draws a line at the baseline of the font
                    // TODO As some browsers display the line as more than 1px if the font-size is big, need to take that into account both in position and size
                    renderRect(ctx, bounds.left, Math.round(bounds.top + metrics.baseline + metrics.lineWidth), bounds.width, 1, color);
                    break;
                case "overline":
                    renderRect(ctx, bounds.left, Math.round(bounds.top), bounds.width, 1, color);
                    break;
                case "line-through":
                    // TODO try and find exact position for line-through
                    renderRect(ctx, bounds.left, Math.ceil(bounds.top + metrics.middle + metrics.lineWidth), bounds.width, 1, color);
                    break;
            }
        }

        function getTextBounds(state, text, textDecoration, isLast, transform) {
            var bounds;
            if (support.rangeBounds && !transform) {
                if (textDecoration !== "none" || Util.trimText(text).length !== 0) {
                    bounds = textRangeBounds(text, state.node, state.textOffset);
                }
                state.textOffset += text.length;
            } else if (state.node && typeof state.node.nodeValue === "string") {
                var newTextNode = (isLast) ? state.node.splitText(text.length) : null;
                bounds = textWrapperBounds(state.node, transform);
                state.node = newTextNode;
            }
            return bounds;
        }

        function textRangeBounds(text, textNode, textOffset) {
            var range = doc.createRange();
            range.setStart(textNode, textOffset);
            range.setEnd(textNode, textOffset + text.length);
            return range.getBoundingClientRect();
        }

        function textWrapperBounds(oldTextNode, transform) {
            var parent = oldTextNode.parentNode,
                wrapElement = doc.createElement('wrapper'),
                backupText = oldTextNode.cloneNode(true);

            wrapElement.appendChild(oldTextNode.cloneNode(true));
            parent.replaceChild(wrapElement, oldTextNode);

            var bounds = transform ? Util.OffsetBounds(wrapElement) : Util.Bounds(wrapElement);
            parent.replaceChild(backupText, wrapElement);
            return bounds;
        }

        function renderText(el, textNode, stack) {
            var ctx = stack.ctx,
                color = getCSS(el, "color"),
                textDecoration = getCSS(el, "textDecoration"),
                textAlign = getCSS(el, "textAlign"),
                metrics,
                textList,
                state = {
                    node: textNode,
                    textOffset: 0
                };

            if (Util.trimText(textNode.nodeValue).length > 0) {
                textNode.nodeValue = textTransform(textNode.nodeValue, getCSS(el, "textTransform"));
                textAlign = textAlign.replace(["-webkit-auto"], ["auto"]);

                textList = (!options.letterRendering && /^(left|right|justify|auto)$/.test(textAlign) && noLetterSpacing(getCSS(el, "letterSpacing"))) ?
                    textNode.nodeValue.split(/(\b| )/)
                    : textNode.nodeValue.split("");

                metrics = setTextVariables(ctx, el, textDecoration, color);

                if (options.chinese) {
                    textList.forEach(function (word, index) {
                        if (/.*[\u4E00-\u9FA5].*$/.test(word)) {
                            word = word.split("");
                            word.unshift(index, 1);
                            textList.splice.apply(textList, word);
                        }
                    });
                }

                textList.forEach(function (text, index) {
                    var bounds = getTextBounds(state, text, textDecoration, (index < textList.length - 1), stack.transform.matrix);
                    if (bounds) {
                        drawText(text, bounds.left, bounds.bottom, ctx);
                        renderTextDecoration(ctx, textDecoration, bounds, metrics, color);
                    }
                });
            }
        }

        function listPosition(element, val) {
            var boundElement = doc.createElement("boundelement"),
                originalType,
                bounds;

            boundElement.style.display = "inline";

            originalType = element.style.listStyleType;
            element.style.listStyleType = "none";

            boundElement.appendChild(doc.createTextNode(val));

            element.insertBefore(boundElement, element.firstChild);

            bounds = Util.Bounds(boundElement);
            element.removeChild(boundElement);
            element.style.listStyleType = originalType;
            return bounds;
        }

        function elementIndex(el) {
            var i = -1,
                count = 1,
                childs = el.parentNode.childNodes;

            if (el.parentNode) {
                while (childs[++i] !== el) {
                    if (childs[i].nodeType === 1) {
                        count++;
                    }
                }
                return count;
            } else {
                return -1;
            }
        }

        function listItemText(element, type) {
            var currentIndex = elementIndex(element), text;
            switch (type) {
                case "decimal":
                    text = currentIndex;
                    break;
                case "decimal-leading-zero":
                    text = (currentIndex.toString().length === 1) ? currentIndex = "0" + currentIndex.toString() : currentIndex.toString();
                    break;
                case "upper-roman":
                    text = _html2canvas.Generate.ListRoman(currentIndex);
                    break;
                case "lower-roman":
                    text = _html2canvas.Generate.ListRoman(currentIndex).toLowerCase();
                    break;
                case "lower-alpha":
                    text = _html2canvas.Generate.ListAlpha(currentIndex).toLowerCase();
                    break;
                case "upper-alpha":
                    text = _html2canvas.Generate.ListAlpha(currentIndex);
                    break;
            }

            return text + ". ";
        }

        function renderListItem(element, stack, elBounds) {
            var x,
                text,
                ctx = stack.ctx,
                type = getCSS(element, "listStyleType"),
                listBounds;

            if (/^(decimal|decimal-leading-zero|upper-alpha|upper-latin|upper-roman|lower-alpha|lower-greek|lower-latin|lower-roman)$/i.test(type)) {
                text = listItemText(element, type);
                listBounds = listPosition(element, text);
                setTextVariables(ctx, element, "none", getCSS(element, "color"));

                if (getCSS(element, "listStylePosition") === "inside") {
                    ctx.setVariable("textAlign", "left");
                    x = elBounds.left;
                } else {
                    return;
                }

                drawText(text, x, listBounds.bottom, ctx);
            }
        }

        function loadImage(src) {
            var img = images[src];
            return (img && img.succeeded === true) ? img.img : false;
        }

        function clipBounds(src, dst) {
            var x = Math.max(src.left, dst.left),
                y = Math.max(src.top, dst.top),
                x2 = Math.min((src.left + src.width), (dst.left + dst.width)),
                y2 = Math.min((src.top + src.height), (dst.top + dst.height));

            return {
                left: x,
                top: y,
                width: x2 - x,
                height: y2 - y
            };
        }

        function setZ(element, stack, parentStack) {
            var newContext,
                isPositioned = stack.cssPosition !== 'static',
                zIndex = isPositioned ? getCSS(element, 'zIndex') : 'auto',
                opacity = getCSS(element, 'opacity'),
                isFloated = getCSS(element, 'cssFloat') !== 'none';

            // https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context
            // When a new stacking context should be created:
            // the root element (HTML),
            // positioned (absolutely or relatively) with a z-index value other than "auto",
            // elements with an opacity value less than 1. (See the specification for opacity),
            // on mobile WebKit and Chrome 22+, position: fixed always creates a new stacking context, even when z-index is "auto" (See this post)

            stack.zIndex = newContext = h2czContext(zIndex);
            newContext.isPositioned = isPositioned;
            newContext.isFloated = isFloated;
            newContext.opacity = opacity;
            newContext.ownStacking = (zIndex !== 'auto' || opacity < 1);
            newContext.depth = parentStack ? (parentStack.zIndex.depth + 1) : 0;

            if (parentStack) {
                parentStack.zIndex.children.push(stack);
            }
        }

        function h2czContext(zindex) {
            return {
                depth: 0,
                zindex: zindex,
                children: []
            };
        }

        function renderImage(ctx, element, image, bounds, borders) {

            var paddingLeft = getCSSInt(element, 'paddingLeft'),
                paddingTop = getCSSInt(element, 'paddingTop'),
                paddingRight = getCSSInt(element, 'paddingRight'),
                paddingBottom = getCSSInt(element, 'paddingBottom');

            drawImage(
                ctx,
                image,
                0, //sx
                0, //sy
                image.width, //sw
                image.height, //sh
                bounds.left + paddingLeft + borders[3].width, //dx
                bounds.top + paddingTop + borders[0].width, // dy
                bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight), //dw
                bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom) //dh
            );
        }

        function getBorderData(element) {
            return ["Top", "Right", "Bottom", "Left"].map(function (side) {
                return {
                    width: getCSSInt(element, 'border' + side + 'Width'),
                    color: getCSS(element, 'border' + side + 'Color')
                };
            });
        }

        function getBorderRadiusData(element) {
            return ["TopLeft", "TopRight", "BottomRight", "BottomLeft"].map(function (side) {
                return getCSS(element, 'border' + side + 'Radius');
            });
        }

        function getCurvePoints(x, y, r1, r2) {
            var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
            var ox = (r1) * kappa, // control point offset horizontal
                oy = (r2) * kappa, // control point offset vertical
                xm = x + r1, // x-middle
                ym = y + r2; // y-middle
            return {
                topLeft: bezierCurve({
                    x: x,
                    y: ym
                }, {
                        x: x,
                        y: ym - oy
                    }, {
                        x: xm - ox,
                        y: y
                    }, {
                        x: xm,
                        y: y
                    }),
                topRight: bezierCurve({
                    x: x,
                    y: y
                }, {
                        x: x + ox,
                        y: y
                    }, {
                        x: xm,
                        y: ym - oy
                    }, {
                        x: xm,
                        y: ym
                    }),
                bottomRight: bezierCurve({
                    x: xm,
                    y: y
                }, {
                        x: xm,
                        y: y + oy
                    }, {
                        x: x + ox,
                        y: ym
                    }, {
                        x: x,
                        y: ym
                    }),
                bottomLeft: bezierCurve({
                    x: xm,
                    y: ym
                }, {
                        x: xm - ox,
                        y: ym
                    }, {
                        x: x,
                        y: y + oy
                    }, {
                        x: x,
                        y: y
                    })
            };
        }

        function bezierCurve(start, startControl, endControl, end) {

            var lerp = function (a, b, t) {
                return {
                    x: a.x + (b.x - a.x) * t,
                    y: a.y + (b.y - a.y) * t
                };
            };

            return {
                start: start,
                startControl: startControl,
                endControl: endControl,
                end: end,
                subdivide: function (t) {
                    var ab = lerp(start, startControl, t),
                        bc = lerp(startControl, endControl, t),
                        cd = lerp(endControl, end, t),
                        abbc = lerp(ab, bc, t),
                        bccd = lerp(bc, cd, t),
                        dest = lerp(abbc, bccd, t);
                    return [bezierCurve(start, ab, abbc, dest), bezierCurve(dest, bccd, cd, end)];
                },
                curveTo: function (borderArgs) {
                    borderArgs.push(["bezierCurve", startControl.x, startControl.y, endControl.x, endControl.y, end.x, end.y]);
                },
                curveToReversed: function (borderArgs) {
                    borderArgs.push(["bezierCurve", endControl.x, endControl.y, startControl.x, startControl.y, start.x, start.y]);
                }
            };
        }

        function parseCorner(borderArgs, radius1, radius2, corner1, corner2, x, y) {
            if (radius1[0] > 0 || radius1[1] > 0) {
                borderArgs.push(["line", corner1[0].start.x, corner1[0].start.y]);
                corner1[0].curveTo(borderArgs);
                corner1[1].curveTo(borderArgs);
            } else {
                borderArgs.push(["line", x, y]);
            }

            if (radius2[0] > 0 || radius2[1] > 0) {
                borderArgs.push(["line", corner2[0].start.x, corner2[0].start.y]);
            }
        }

        function drawSide(borderData, radius1, radius2, outer1, inner1, outer2, inner2) {
            var borderArgs = [];

            if (radius1[0] > 0 || radius1[1] > 0) {
                borderArgs.push(["line", outer1[1].start.x, outer1[1].start.y]);
                outer1[1].curveTo(borderArgs);
            } else {
                borderArgs.push(["line", borderData.c1[0], borderData.c1[1]]);
            }

            if (radius2[0] > 0 || radius2[1] > 0) {
                borderArgs.push(["line", outer2[0].start.x, outer2[0].start.y]);
                outer2[0].curveTo(borderArgs);
                borderArgs.push(["line", inner2[0].end.x, inner2[0].end.y]);
                inner2[0].curveToReversed(borderArgs);
            } else {
                borderArgs.push(["line", borderData.c2[0], borderData.c2[1]]);
                borderArgs.push(["line", borderData.c3[0], borderData.c3[1]]);
            }

            if (radius1[0] > 0 || radius1[1] > 0) {
                borderArgs.push(["line", inner1[1].end.x, inner1[1].end.y]);
                inner1[1].curveToReversed(borderArgs);
            } else {
                borderArgs.push(["line", borderData.c4[0], borderData.c4[1]]);
            }

            return borderArgs;
        }

        function calculateCurvePoints(bounds, borderRadius, borders) {

            var x = bounds.left,
                y = bounds.top,
                width = bounds.width,
                height = bounds.height,

                tlh = borderRadius[0][0],
                tlv = borderRadius[0][1],
                trh = borderRadius[1][0],
                trv = borderRadius[1][1],
                brh = borderRadius[2][0],
                brv = borderRadius[2][1],
                blh = borderRadius[3][0],
                blv = borderRadius[3][1],

                topWidth = width - trh,
                rightHeight = height - brv,
                bottomWidth = width - brh,
                leftHeight = height - blv;

            return {
                topLeftOuter: getCurvePoints(
                    x,
                    y,
                    tlh,
                    tlv
                ).topLeft.subdivide(0.5),

                topLeftInner: getCurvePoints(
                    x + borders[3].width,
                    y + borders[0].width,
                    Math.max(0, tlh - borders[3].width),
                    Math.max(0, tlv - borders[0].width)
                ).topLeft.subdivide(0.5),

                topRightOuter: getCurvePoints(
                    x + topWidth,
                    y,
                    trh,
                    trv
                ).topRight.subdivide(0.5),

                topRightInner: getCurvePoints(
                    x + Math.min(topWidth, width + borders[3].width),
                    y + borders[0].width,
                    (topWidth > width + borders[3].width) ? 0 : trh - borders[3].width,
                    trv - borders[0].width
                ).topRight.subdivide(0.5),

                bottomRightOuter: getCurvePoints(
                    x + bottomWidth,
                    y + rightHeight,
                    brh,
                    brv
                ).bottomRight.subdivide(0.5),

                bottomRightInner: getCurvePoints(
                    x + Math.min(bottomWidth, width + borders[3].width),
                    y + Math.min(rightHeight, height + borders[0].width),
                    Math.max(0, brh - borders[1].width),
                    Math.max(0, brv - borders[2].width)
                ).bottomRight.subdivide(0.5),

                bottomLeftOuter: getCurvePoints(
                    x,
                    y + leftHeight,
                    blh,
                    blv
                ).bottomLeft.subdivide(0.5),

                bottomLeftInner: getCurvePoints(
                    x + borders[3].width,
                    y + leftHeight,
                    Math.max(0, blh - borders[3].width),
                    Math.max(0, blv - borders[2].width)
                ).bottomLeft.subdivide(0.5)
            };
        }

        function getBorderClip(element, borderPoints, borders, radius, bounds) {
            var backgroundClip = getCSS(element, 'backgroundClip'),
                borderArgs = [];

            switch (backgroundClip) {
                case "content-box":
                case "padding-box":
                    parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftInner, borderPoints.topRightInner, bounds.left + borders[3].width, bounds.top + borders[0].width);
                    parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightInner, borderPoints.bottomRightInner, bounds.left + bounds.width - borders[1].width, bounds.top + borders[0].width);
                    parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightInner, borderPoints.bottomLeftInner, bounds.left + bounds.width - borders[1].width, bounds.top + bounds.height - borders[2].width);
                    parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftInner, borderPoints.topLeftInner, bounds.left + borders[3].width, bounds.top + bounds.height - borders[2].width);
                    break;

                default:
                    parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topRightOuter, bounds.left, bounds.top);
                    parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.bottomRightOuter, bounds.left + bounds.width, bounds.top);
                    parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomLeftOuter, bounds.left + bounds.width, bounds.top + bounds.height);
                    parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.topLeftOuter, bounds.left, bounds.top + bounds.height);
                    break;
            }

            return borderArgs;
        }

        function parseBorders(element, bounds, borders) {
            var x = bounds.left,
                y = bounds.top,
                width = bounds.width,
                height = bounds.height,
                borderSide,
                bx,
                by,
                bw,
                bh,
                borderArgs,
                // http://www.w3.org/TR/css3-background/#the-border-radius
                borderRadius = getBorderRadiusData(element),
                borderPoints = calculateCurvePoints(bounds, borderRadius, borders),
                borderData = {
                    clip: getBorderClip(element, borderPoints, borders, borderRadius, bounds),
                    borders: []
                };

            for (borderSide = 0; borderSide < 4; borderSide++) {

                if (borders[borderSide].width > 0) {
                    bx = x;
                    by = y;
                    bw = width;
                    bh = height - (borders[2].width);

                    switch (borderSide) {
                        case 0:
                            // top border
                            bh = borders[0].width;

                            borderArgs = drawSide({
                                c1: [bx, by],
                                c2: [bx + bw, by],
                                c3: [bx + bw - borders[1].width, by + bh],
                                c4: [bx + borders[3].width, by + bh]
                            }, borderRadius[0], borderRadius[1],
                                borderPoints.topLeftOuter, borderPoints.topLeftInner, borderPoints.topRightOuter, borderPoints.topRightInner);
                            break;
                        case 1:
                            // right border
                            bx = x + width - (borders[1].width);
                            bw = borders[1].width;

                            borderArgs = drawSide({
                                c1: [bx + bw, by],
                                c2: [bx + bw, by + bh + borders[2].width],
                                c3: [bx, by + bh],
                                c4: [bx, by + borders[0].width]
                            }, borderRadius[1], borderRadius[2],
                                borderPoints.topRightOuter, borderPoints.topRightInner, borderPoints.bottomRightOuter, borderPoints.bottomRightInner);
                            break;
                        case 2:
                            // bottom border
                            by = (by + height) - (borders[2].width);
                            bh = borders[2].width;

                            borderArgs = drawSide({
                                c1: [bx + bw, by + bh],
                                c2: [bx, by + bh],
                                c3: [bx + borders[3].width, by],
                                c4: [bx + bw - borders[3].width, by]
                            }, borderRadius[2], borderRadius[3],
                                borderPoints.bottomRightOuter, borderPoints.bottomRightInner, borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner);
                            break;
                        case 3:
                            // left border
                            bw = borders[3].width;

                            borderArgs = drawSide({
                                c1: [bx, by + bh + borders[2].width],
                                c2: [bx, by],
                                c3: [bx + bw, by + borders[0].width],
                                c4: [bx + bw, by + bh]
                            }, borderRadius[3], borderRadius[0],
                                borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner, borderPoints.topLeftOuter, borderPoints.topLeftInner);
                            break;
                    }

                    borderData.borders.push({
                        args: borderArgs,
                        color: borders[borderSide].color
                    });

                }
            }

            return borderData;
        }

        function createShape(ctx, args) {
            var shape = ctx.drawShape();
            args.forEach(function (border, index) {
                shape[(index === 0) ? "moveTo" : border[0] + "To"].apply(null, border.slice(1));
            });
            return shape;
        }

        function renderBorders(ctx, borderArgs, color) {
            if (color !== "transparent") {
                ctx.setVariable("fillStyle", color);
                createShape(ctx, borderArgs);
                ctx.fill();
                numDraws += 1;
            }
        }

        function renderFormValue(el, bounds, stack) {

            var valueWrap = doc.createElement('valuewrap'),
                cssPropertyArray = ['lineHeight', 'textAlign', 'fontFamily', 'color', 'fontSize', 'paddingLeft', 'paddingTop', 'width', 'height', 'border', 'borderLeftWidth', 'borderTopWidth'],
                textValue,
                textNode;

            cssPropertyArray.forEach(function (property) {
                try {
                    valueWrap.style[property] = getCSS(el, property);
                } catch (e) {
                    // Older IE has issues with "border"
                    Util.log("html2canvas: Parse: Exception caught in renderFormValue: " + e.message);
                }
            });

            valueWrap.style.borderColor = "black";
            valueWrap.style.borderStyle = "solid";
            valueWrap.style.display = "block";
            valueWrap.style.position = "absolute";

            if (/^(submit|reset|button|text|password)$/.test(el.type) || el.nodeName === "SELECT") {
                valueWrap.style.lineHeight = getCSS(el, "height");
            }

            valueWrap.style.top = bounds.top + "px";
            valueWrap.style.left = bounds.left + "px";

            textValue = (el.nodeName === "SELECT") ? (el.options[el.selectedIndex] || 0).text : el.value;
            if (!textValue) {
                textValue = el.placeholder;
            }

            textNode = doc.createTextNode(textValue);

            valueWrap.appendChild(textNode);
            body.appendChild(valueWrap);

            renderText(el, textNode, stack);
            body.removeChild(valueWrap);
        }

        function drawImage(ctx) {
            ctx.drawImage.apply(ctx, Array.prototype.slice.call(arguments, 1));
            numDraws += 1;
        }

        function getPseudoElement(el, which) {
            var elStyle = window.getComputedStyle(el, which);
            var parentStyle = window.getComputedStyle(el);
            // If no content attribute is present, the pseudo element is hidden,
            // or the parent has a content property equal to the content on the pseudo element,
            // move along.
            if (!elStyle || !elStyle.content || elStyle.content === "none" || elStyle.content === "-moz-alt-content" ||
                elStyle.display === "none" || parentStyle.content === elStyle.content) {
                return;
            }
            var content = elStyle.content + '';

            // Strip inner quotes
            if (content[0] === "'" || content[0] === "\"") {
                content = content.replace(/(^['"])|(['"]$)/g, '');
            }

            var isImage = content.substr(0, 3) === 'url',
                elps = document.createElement(isImage ? 'img' : 'span');

            elps.className = pseudoHide + "-element ";

            Object.keys(elStyle).filter(indexedProperty).forEach(function (prop) {
                // Prevent assigning of read only CSS Rules, ex. length, parentRule
                try {
                    elps.style[prop] = elStyle[prop];
                } catch (e) {
                    Util.log(['Tried to assign readonly property ', prop, 'Error:', e]);
                }
            });

            if (isImage) {
                elps.src = Util.parseBackgroundImage(content)[0].args[0];
            } else {
                elps.innerHTML = content;
            }
            return elps;
        }

        function indexedProperty(property) {
            return (isNaN(window.parseInt(property, 10)));
        }

        function renderBackgroundRepeat(ctx, image, backgroundPosition, bounds) {
            var offsetX = Math.round(bounds.left + backgroundPosition.left),
                offsetY = Math.round(bounds.top + backgroundPosition.top);

            ctx.createPattern(image);
            ctx.translate(offsetX, offsetY);
            ctx.fill();
            ctx.translate(-offsetX, -offsetY);
        }

        function backgroundRepeatShape(ctx, image, backgroundPosition, bounds, left, top, width, height) {
            var args = [];
            args.push(["line", Math.round(left), Math.round(top)]);
            args.push(["line", Math.round(left + width), Math.round(top)]);
            args.push(["line", Math.round(left + width), Math.round(height + top)]);
            args.push(["line", Math.round(left), Math.round(height + top)]);
            createShape(ctx, args);
            ctx.save();
            ctx.clip();
            renderBackgroundRepeat(ctx, image, backgroundPosition, bounds);
            ctx.restore();
        }

        function renderBackgroundColor(ctx, backgroundBounds, bgcolor) {
            renderRect(
                ctx,
                backgroundBounds.left,
                backgroundBounds.top,
                backgroundBounds.width,
                backgroundBounds.height,
                bgcolor
            );
        }

        function renderBackgroundRepeating(el, bounds, ctx, image, imageIndex) {
            var backgroundSize = Util.BackgroundSize(el, bounds, image, imageIndex),
                backgroundPosition = Util.BackgroundPosition(el, bounds, image, imageIndex, backgroundSize),
                backgroundRepeat = Util.BackgroundRepeat(el, imageIndex);

            image = resizeImage(image, backgroundSize);

            switch (backgroundRepeat) {
                case "repeat-x":
                case "repeat no-repeat":
                    backgroundRepeatShape(ctx, image, backgroundPosition, bounds,
                        bounds.left, bounds.top + backgroundPosition.top, 99999, image.height);
                    break;
                case "repeat-y":
                case "no-repeat repeat":
                    backgroundRepeatShape(ctx, image, backgroundPosition, bounds,
                        bounds.left + backgroundPosition.left, bounds.top, image.width, 99999);
                    break;
                case "no-repeat":
                    backgroundRepeatShape(ctx, image, backgroundPosition, bounds,
                        bounds.left + backgroundPosition.left, bounds.top + backgroundPosition.top, image.width, image.height);
                    break;
                default:
                    renderBackgroundRepeat(ctx, image, backgroundPosition, {
                        top: bounds.top,
                        left: bounds.left,
                        width: image.width,
                        height: image.height
                    });
                    break;
            }
        }

        function renderBackgroundImage(element, bounds, ctx) {
            var backgroundImage = getCSS(element, "backgroundImage"),
                backgroundImages = Util.parseBackgroundImage(backgroundImage),
                image,
                imageIndex = backgroundImages.length;

            while (imageIndex--) {
                backgroundImage = backgroundImages[imageIndex];

                if (!backgroundImage.args || backgroundImage.args.length === 0) {
                    continue;
                }

                var key = backgroundImage.method === 'url' ?
                    backgroundImage.args[0] :
                    backgroundImage.value;

                image = loadImage(key);

                // TODO add support for background-origin
                if (image) {
                    renderBackgroundRepeating(element, bounds, ctx, image, imageIndex);
                } else {
                    Util.log("html2canvas: Error loading background:", backgroundImage);
                }
            }
        }

        function resizeImage(image, bounds) {
            if (image.width === bounds.width && image.height === bounds.height) {
                return image;
            }

            var ctx, canvas = doc.createElement('canvas');
            canvas.width = bounds.width;
            canvas.height = bounds.height;
            ctx = canvas.getContext("2d");
            drawImage(ctx, image, 0, 0, image.width, image.height, 0, 0, bounds.width, bounds.height);
            return canvas;
        }

        function setOpacity(ctx, element, parentStack) {
            return ctx.setVariable("globalAlpha", getCSS(element, "opacity") * ((parentStack) ? parentStack.opacity : 1));
        }

        function removePx(str) {
            return str.replace("px", "");
        }

        function getTransform(element, parentStack) {
            var transformRegExp = /(matrix)\((.+)\)/;
            var transform = getCSS(element, "transform") || getCSS(element, "-webkit-transform") || getCSS(element, "-moz-transform") || getCSS(element, "-ms-transform") || getCSS(element, "-o-transform");
            var transformOrigin = getCSS(element, "transform-origin") || getCSS(element, "-webkit-transform-origin") || getCSS(element, "-moz-transform-origin") || getCSS(element, "-ms-transform-origin") || getCSS(element, "-o-transform-origin") || "0px 0px";

            transformOrigin = transformOrigin.split(" ").map(removePx).map(Util.asFloat);

            var matrix;
            if (transform && transform !== "none") {
                var match = transform.match(transformRegExp);
                if (match) {
                    switch (match[1]) {
                        case "matrix":
                            matrix = match[2].split(",").map(Util.trimText).map(Util.asFloat);
                            break;
                    }
                }
            }

            return {
                origin: transformOrigin,
                matrix: matrix
            };
        }

        function createStack(element, parentStack, bounds, transform) {
            var ctx = h2cRenderContext((!parentStack) ? documentWidth() : bounds.width, (!parentStack) ? documentHeight() : bounds.height),
                stack = {
                    ctx: ctx,
                    opacity: setOpacity(ctx, element, parentStack),
                    cssPosition: getCSS(element, "position"),
                    borders: getBorderData(element),
                    transform: transform,
                    clip: (parentStack && parentStack.clip) ? Util.Extend({}, parentStack.clip) : null
                };

            setZ(element, stack, parentStack);

            // TODO correct overflow for absolute content residing under a static position
            if (options.useOverflow === true && /(hidden|scroll|auto)/.test(getCSS(element, "overflow")) === true && /(BODY)/i.test(element.nodeName) === false) {
                stack.clip = (stack.clip) ? clipBounds(stack.clip, bounds) : bounds;
            }

            return stack;
        }

        function getBackgroundBounds(borders, bounds, clip) {
            var backgroundBounds = {
                left: bounds.left + borders[3].width,
                top: bounds.top + borders[0].width,
                width: bounds.width - (borders[1].width + borders[3].width),
                height: bounds.height - (borders[0].width + borders[2].width)
            };

            if (clip) {
                backgroundBounds = clipBounds(backgroundBounds, clip);
            }

            return backgroundBounds;
        }

        function getBounds(element, transform) {
            var bounds = (transform.matrix) ? Util.OffsetBounds(element) : Util.Bounds(element);
            transform.origin[0] += bounds.left;
            transform.origin[1] += bounds.top;
            return bounds;
        }

        function renderElement(element, parentStack, ignoreBackground) {
            var transform = getTransform(element, parentStack),
                bounds = getBounds(element, transform),
                image,
                stack = createStack(element, parentStack, bounds, transform),
                borders = stack.borders,
                ctx = stack.ctx,
                backgroundBounds = getBackgroundBounds(borders, bounds, stack.clip),
                borderData = parseBorders(element, bounds, borders),
                backgroundColor = (ignoreElementsRegExp.test(element.nodeName)) ? "#efefef" : getCSS(element, "backgroundColor");


            createShape(ctx, borderData.clip);

            ctx.save();
            ctx.clip();

            if (backgroundBounds.height > 0 && backgroundBounds.width > 0 && !ignoreBackground) {
                renderBackgroundColor(ctx, bounds, backgroundColor);
                renderBackgroundImage(element, backgroundBounds, ctx);
            } else if (ignoreBackground) {
                stack.backgroundColor = backgroundColor;
            }

            ctx.restore();

            borderData.borders.forEach(function (border) {
                renderBorders(ctx, border.args, border.color);
            });

            switch (element.nodeName) {
                case "IMG":
                    if ((image = loadImage(element.getAttribute('src')))) {
                        renderImage(ctx, element, image, bounds, borders);
                    } else {
                        Util.log("html2canvas: Error loading <img>:" + element.getAttribute('src'));
                    }
                    break;
                case "INPUT":
                    // TODO add all relevant type's, i.e. HTML5 new stuff
                    // todo add support for placeholder attribute for browsers which support it
                    if (/^(text|url|email|submit|button|reset)$/.test(element.type) && (element.value || element.placeholder || "").length > 0) {
                        renderFormValue(element, bounds, stack);
                    }
                    break;
                case "TEXTAREA":
                    if ((element.value || element.placeholder || "").length > 0) {
                        renderFormValue(element, bounds, stack);
                    }
                    break;
                case "SELECT":
                    if ((element.options || element.placeholder || "").length > 0) {
                        renderFormValue(element, bounds, stack);
                    }
                    break;
                case "LI":
                    renderListItem(element, stack, backgroundBounds);
                    break;
                case "CANVAS":
                    renderImage(ctx, element, element, bounds, borders);
                    break;
            }

            return stack;
        }

        function isElementVisible(element) {
            return (getCSS(element, 'display') !== "none" && getCSS(element, 'visibility') !== "hidden" && !element.hasAttribute("data-html2canvas-ignore"));
        }

        function parseElement(element, stack, cb) {
            if (!cb) {
                cb = function () { };
            }
            if (isElementVisible(element)) {
                stack = renderElement(element, stack, false) || stack;
                if (!ignoreElementsRegExp.test(element.nodeName)) {
                    return parseChildren(element, stack, cb);
                }
            }
            cb();
        }

        function parseChildren(element, stack, cb) {
            var children = Util.Children(element);
            // After all nodes have processed, finished() will call the cb.
            // We add one and kick it off so this will still work when children.length === 0.
            // Note that unless async is true, this will happen synchronously, just will callbacks.
            var jobs = children.length + 1;
            finished();

            if (options.async) {
                children.forEach(function (node) {
                    // Don't block the page from rendering
                    setTimeout(function () { parseNode(node); }, 0);
                });
            } else {
                children.forEach(parseNode);
            }

            function parseNode(node) {
                if (node.nodeType === node.ELEMENT_NODE) {
                    parseElement(node, stack, finished);
                } else if (node.nodeType === node.TEXT_NODE) {
                    renderText(element, node, stack);
                    finished();
                } else {
                    finished();
                }
            }
            function finished(el) {
                if (--jobs <= 0) {
                    Util.log("finished rendering " + children.length + " children.");
                    cb();
                }
            }
        }
    };
    _html2canvas.Preload = function (options) {

        var images = {
            numLoaded: 0,   // also failed are counted here
            numFailed: 0,
            numTotal: 0,
            cleanupDone: false
        },
            pageOrigin,
            Util = _html2canvas.Util,
            methods,
            i,
            count = 0,
            element = options.elements[0] || document.body,
            doc = element.ownerDocument,
            domImages = element.getElementsByTagName('img'), // Fetch images of the present element only
            imgLen = domImages.length,
            link = doc.createElement("a"),
            supportCORS = (function (img) {
                return (img.crossOrigin !== undefined);
            })(new Image()),
            timeoutTimer;

        link.href = window.location.href;
        pageOrigin = link.protocol + link.host;

        function isSameOrigin(url) {
            link.href = url;
            link.href = link.href; // YES, BELIEVE IT OR NOT, that is required for IE9 - http://jsfiddle.net/niklasvh/2e48b/
            var origin = link.protocol + link.host;
            return (origin === pageOrigin);
        }

        function start() {
            Util.log("html2canvas: start: images: " + images.numLoaded + " / " + images.numTotal + " (failed: " + images.numFailed + ")");
            if (!images.firstRun && images.numLoaded >= images.numTotal) {
                Util.log("Finished loading images: # " + images.numTotal + " (failed: " + images.numFailed + ")");

                if (typeof options.complete === "function") {
                    options.complete(images);
                }

            }
        }

        // TODO modify proxy to serve images with CORS enabled, where available
        function proxyGetImage(url, img, imageObj) {
            var callback_name,
                scriptUrl = options.proxy,
                script;

            link.href = url;
            url = link.href; // work around for pages with base href="" set - WARNING: this may change the url

            callback_name = 'html2canvas_' + (count++);
            imageObj.callbackname = callback_name;

            if (scriptUrl.indexOf("?") > -1) {
                scriptUrl += "&";
            } else {
                scriptUrl += "?";
            }
            scriptUrl += 'url=' + encodeURIComponent(url) + '&callback=' + callback_name;
            script = doc.createElement("script");

            window[callback_name] = function (a) {
                if (a.substring(0, 6) === "error:") {
                    imageObj.succeeded = false;
                    images.numLoaded++;
                    images.numFailed++;
                    start();
                } else {
                    setImageLoadHandlers(img, imageObj);
                    img.src = a;
                }
                window[callback_name] = undefined; // to work with IE<9  // NOTE: that the undefined callback property-name still exists on the window object (for IE<9)
                try {
                    delete window[callback_name];  // for all browser that support this
                } catch (ex) { }
                script.parentNode.removeChild(script);
                script = null;
                delete imageObj.script;
                delete imageObj.callbackname;
            };

            script.setAttribute("type", "text/javascript");
            script.setAttribute("src", scriptUrl);
            imageObj.script = script;
            window.document.body.appendChild(script);

        }

        function loadPseudoElement(element, type) {
            var style = window.getComputedStyle(element, type),
                content = style.content;
            if (content.substr(0, 3) === 'url') {
                methods.loadImage(_html2canvas.Util.parseBackgroundImage(content)[0].args[0]);
            }
            loadBackgroundImages(style.backgroundImage, element);
        }

        function loadPseudoElementImages(element) {
            loadPseudoElement(element, ":before");
            loadPseudoElement(element, ":after");
        }

        function loadGradientImage(backgroundImage, bounds) {
            var img = _html2canvas.Generate.Gradient(backgroundImage, bounds);

            if (img !== undefined) {
                images[backgroundImage] = {
                    img: img,
                    succeeded: true
                };
                images.numTotal++;
                images.numLoaded++;
                start();
            }
        }

        function invalidBackgrounds(background_image) {
            return (background_image && background_image.method && background_image.args && background_image.args.length > 0);
        }

        function loadBackgroundImages(background_image, el) {
            var bounds;

            _html2canvas.Util.parseBackgroundImage(background_image).filter(invalidBackgrounds).forEach(function (background_image) {
                if (background_image.method === 'url') {
                    methods.loadImage(background_image.args[0]);
                } else if (background_image.method.match(/\-?gradient$/)) {
                    if (bounds === undefined) {
                        bounds = _html2canvas.Util.Bounds(el);
                    }
                    loadGradientImage(background_image.value, bounds);
                }
            });
        }

        function getImages(el) {
            var elNodeType = false;

            // Firefox fails with permission denied on pages with iframes
            try {
                Util.Children(el).forEach(getImages);
            }
            catch (e) { }

            try {
                elNodeType = el.nodeType;
            } catch (ex) {
                elNodeType = false;
                Util.log("html2canvas: failed to access some element's nodeType - Exception: " + ex.message);
            }

            if (elNodeType === 1 || elNodeType === undefined) {
                loadPseudoElementImages(el);
                try {
                    loadBackgroundImages(Util.getCSS(el, 'backgroundImage'), el);
                } catch (e) {
                    Util.log("html2canvas: failed to get background-image - Exception: " + e.message);
                }
                loadBackgroundImages(el);
            }
        }

        function setImageLoadHandlers(img, imageObj) {
            img.onload = function () {
                if (imageObj.timer !== undefined) {
                    // CORS succeeded
                    window.clearTimeout(imageObj.timer);
                }

                images.numLoaded++;
                imageObj.succeeded = true;
                img.onerror = img.onload = null;
                start();
            };
            img.onerror = function () {
                if (img.crossOrigin === "anonymous") {
                    // CORS failed
                    window.clearTimeout(imageObj.timer);

                    // let's try with proxy instead
                    if (options.proxy) {
                        var src = img.src;
                        img = new Image();
                        imageObj.img = img;
                        img.src = src;

                        proxyGetImage(img.src, img, imageObj);
                        return;
                    }
                }

                images.numLoaded++;
                images.numFailed++;
                imageObj.succeeded = false;
                img.onerror = img.onload = null;
                start();
            };
        }

        methods = {
            loadImage: function (src) {
                var img, imageObj;
                if (src && images[src] === undefined) {
                    img = new Image();
                    if (src.match(/data:image\/.*;base64,/i)) {
                        img.src = src.replace(/url\(['"]{0,}|['"]{0,}\)$/ig, '');
                        imageObj = images[src] = {
                            img: img
                        };
                        images.numTotal++;
                        setImageLoadHandlers(img, imageObj);
                    } else if (isSameOrigin(src) || options.allowTaint === true) {
                        imageObj = images[src] = {
                            img: img
                        };
                        images.numTotal++;
                        setImageLoadHandlers(img, imageObj);
                        img.src = src;
                    } else if (supportCORS && !options.allowTaint && options.useCORS) {
                        // attempt to load with CORS

                        img.crossOrigin = "anonymous";
                        imageObj = images[src] = {
                            img: img
                        };
                        images.numTotal++;
                        setImageLoadHandlers(img, imageObj);
                        img.src = src;
                    } else if (options.proxy) {
                        imageObj = images[src] = {
                            img: img
                        };
                        images.numTotal++;
                        proxyGetImage(src, img, imageObj);
                    }
                }

            },
            cleanupDOM: function (cause) {
                var img, src;
                if (!images.cleanupDone) {
                    if (cause && typeof cause === "string") {
                        Util.log("html2canvas: Cleanup because: " + cause);
                    } else {
                        Util.log("html2canvas: Cleanup after timeout: " + options.timeout + " ms.");
                    }

                    for (src in images) {
                        if (images.hasOwnProperty(src)) {
                            img = images[src];
                            if (typeof img === "object" && img.callbackname && img.succeeded === undefined) {
                                // cancel proxy image request
                                window[img.callbackname] = undefined; // to work with IE<9  // NOTE: that the undefined callback property-name still exists on the window object (for IE<9)
                                try {
                                    delete window[img.callbackname];  // for all browser that support this
                                } catch (ex) { }
                                if (img.script && img.script.parentNode) {
                                    img.script.setAttribute("src", "about:blank");  // try to cancel running request
                                    img.script.parentNode.removeChild(img.script);
                                }
                                images.numLoaded++;
                                images.numFailed++;
                                Util.log("html2canvas: Cleaned up failed img: '" + src + "' Steps: " + images.numLoaded + " / " + images.numTotal);
                            }
                        }
                    }

                    // cancel any pending requests
                    if (window.stop !== undefined) {
                        window.stop();
                    } else if (document.execCommand !== undefined) {
                        document.execCommand("Stop", false);
                    }
                    if (document.close !== undefined) {
                        document.close();
                    }
                    images.cleanupDone = true;
                    if (!(cause && typeof cause === "string")) {
                        start();
                    }
                }
            },

            renderingDone: function () {
                if (timeoutTimer) {
                    window.clearTimeout(timeoutTimer);
                }
            }
        };

        if (options.timeout > 0) {
            timeoutTimer = window.setTimeout(methods.cleanupDOM, options.timeout);
        }

        Util.log('html2canvas: Preload starts: finding background-images');
        images.firstRun = true;

        getImages(element);

        Util.log('html2canvas: Preload: Finding images');
        // load <img> images
        for (i = 0; i < imgLen; i += 1) {
            methods.loadImage(domImages[i].getAttribute("src"));
        }

        images.firstRun = false;
        Util.log('html2canvas: Preload: Done.');
        if (images.numTotal === images.numLoaded) {
            start();
        }

        return methods;
    };

    _html2canvas.Renderer = function (parseQueue, options) {
        function sortZindex(a, b) {
            if (a === 'children') {
                return -1;
            } else if (b === 'children') {
                return 1;
            } else {
                return a - b;
            }
        }

        // http://www.w3.org/TR/CSS21/zindex.html
        function createRenderQueue(parseQueue) {
            var queue = [],
                rootContext;

            rootContext = (function buildStackingContext(rootNode) {
                var rootContext = {};
                function insert(context, node, specialParent) {
                    var zi = (node.zIndex.zindex === 'auto') ? 0 : Number(node.zIndex.zindex),
                        contextForChildren = context, // the stacking context for children
                        isPositioned = node.zIndex.isPositioned,
                        isFloated = node.zIndex.isFloated,
                        stub = { node: node },
                        childrenDest = specialParent; // where children without z-index should be pushed into

                    if (node.zIndex.ownStacking) {
                        contextForChildren = stub.context = {
                            children: [{ node: node, children: [] }]
                        };
                        childrenDest = undefined;
                    } else if (isPositioned || isFloated) {
                        childrenDest = stub.children = [];
                    }

                    if (zi === 0 && specialParent) {
                        specialParent.push(stub);
                    } else {
                        if (!context[zi]) { context[zi] = []; }
                        context[zi].push(stub);
                    }

                    node.zIndex.children.forEach(function (childNode) {
                        insert(contextForChildren, childNode, childrenDest);
                    });
                }
                insert(rootContext, rootNode);
                return rootContext;
            })(parseQueue);

            function sortZ(context) {
                Object.keys(context).sort(sortZindex).forEach(function (zi) {
                    var nonPositioned = [],
                        floated = [],
                        positioned = [],
                        list = [];

                    // positioned after static
                    context[zi].forEach(function (v) {
                        if (v.node.zIndex.isPositioned || v.node.zIndex.opacity < 1) {
                            // http://www.w3.org/TR/css3-color/#transparency
                            // non-positioned element with opactiy < 1 should be stacked as if it were a positioned element with ‘z-index: 0’ and ‘opacity: 1’.
                            positioned.push(v);
                        } else if (v.node.zIndex.isFloated) {
                            floated.push(v);
                        } else {
                            nonPositioned.push(v);
                        }
                    });

                    (function walk(arr) {
                        arr.forEach(function (v) {
                            list.push(v);
                            if (v.children) { walk(v.children); }
                        });
                    })(nonPositioned.concat(floated, positioned));

                    list.forEach(function (v) {
                        if (v.context) {
                            sortZ(v.context);
                        } else {
                            queue.push(v.node);
                        }
                    });
                });
            }

            sortZ(rootContext);

            return queue;
        }

        function getRenderer(rendererName) {
            var renderer;

            if (typeof options.renderer === "string" && _html2canvas.Renderer[rendererName] !== undefined) {
                renderer = _html2canvas.Renderer[rendererName](options);
            } else if (typeof rendererName === "function") {
                renderer = rendererName(options);
            } else {
                throw new Error("Unknown renderer");
            }

            if (typeof renderer !== "function") {
                throw new Error("Invalid renderer defined");
            }
            return renderer;
        }

        return getRenderer(options.renderer)(parseQueue, options, document, createRenderQueue(parseQueue.stack), _html2canvas);
    };

    _html2canvas.Util.Support = function (options, doc) {

        function supportSVGRendering() {
            var img = new Image(),
                canvas = doc.createElement("canvas"),
                ctx = (canvas.getContext === undefined) ? false : canvas.getContext("2d");
            if (ctx === false) {
                return false;
            }
            canvas.width = canvas.height = 10;
            img.src = [
                "data:image/svg+xml,",
                "<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'>",
                "<foreignObject width='10' height='10'>",
                "<div xmlns='http://www.w3.org/1999/xhtml' style='width:10;height:10;'>",
                "sup",
                "</div>",
                "</foreignObject>",
                "</svg>"
            ].join("");
            try {
                ctx.drawImage(img, 0, 0);
                canvas.toDataURL();
            } catch (e) {
                return false;
            }
            _html2canvas.Util.log('html2canvas: Parse: SVG powered rendering available');
            return true;
        }

        // Test whether we can use ranges to measure bounding boxes
        // Opera doesn't provide valid bounds.height/bottom even though it supports the method.

        function supportRangeBounds() {
            var r, testElement, rangeBounds, rangeHeight, support = false;

            if (doc.createRange) {
                r = doc.createRange();
                if (r.getBoundingClientRect) {
                    testElement = doc.createElement('boundtest');
                    testElement.style.height = "123px";
                    testElement.style.display = "block";
                    doc.body.appendChild(testElement);

                    r.selectNode(testElement);
                    rangeBounds = r.getBoundingClientRect();
                    rangeHeight = rangeBounds.height;

                    if (rangeHeight === 123) {
                        support = true;
                    }
                    doc.body.removeChild(testElement);
                }
            }

            return support;
        }

        return {
            rangeBounds: supportRangeBounds(),
            svgRendering: options.svgRendering && supportSVGRendering()
        };
    };
    window.html2canvas = function (elements, opts) {
        elements = (elements.length) ? elements : [elements];
        var queue,
            canvas,
            options = {
                // general
                logging: false,
                elements: elements,
                background: "#fff",

                // preload options
                proxy: null,
                timeout: 0,    // no timeout
                useCORS: false, // try to load images as CORS (where available), before falling back to proxy
                allowTaint: false, // whether to allow images to taint the canvas, won't need proxy if set to true

                // parse options
                svgRendering: false, // use svg powered rendering where available (FF11+)
                ignoreElements: "IFRAME|OBJECT|PARAM",
                useOverflow: true,
                letterRendering: false,
                chinese: false,
                async: false, // If true, parsing will not block, but if the user scrolls during parse the image can get weird

                // render options
                width: null,
                height: null,
                taintTest: true, // do a taint test with all images before applying to canvas
                renderer: "Canvas"
            };

        options = _html2canvas.Util.Extend(opts, options);

        _html2canvas.logging = options.logging;
        options.complete = function (images) {

            if (typeof options.onpreloaded === "function") {
                if (options.onpreloaded(images) === false) {
                    return;
                }
            }
            _html2canvas.Parse(images, options, function (queue) {
                if (typeof options.onparsed === "function") {
                    if (options.onparsed(queue) === false) {
                        return;
                    }
                }

                canvas = _html2canvas.Renderer(queue, options);

                if (typeof options.onrendered === "function") {
                    options.onrendered(canvas);
                }
            });
        };

        // for pages without images, we still want this to be async, i.e. return methods before executing
        window.setTimeout(function () {
            _html2canvas.Preload(options);
        }, 0);

        return {
            render: function (queue, opts) {
                return _html2canvas.Renderer(queue, _html2canvas.Util.Extend(opts, options));
            },
            parse: function (images, opts) {
                return _html2canvas.Parse(images, _html2canvas.Util.Extend(opts, options));
            },
            preload: function (opts) {
                return _html2canvas.Preload(_html2canvas.Util.Extend(opts, options));
            },
            log: _html2canvas.Util.log
        };
    };

    window.html2canvas.log = _html2canvas.Util.log; // for renderers
    window.html2canvas.Renderer = {
        Canvas: undefined // We are assuming this will be used
    };
    _html2canvas.Renderer.Canvas = function (options) {
        options = options || {};

        var doc = document,
            safeImages = [],
            testCanvas = document.createElement("canvas"),
            testctx = testCanvas.getContext("2d"),
            Util = _html2canvas.Util,
            canvas = options.canvas || doc.createElement('canvas');

        function createShape(ctx, args) {
            ctx.beginPath();
            args.forEach(function (arg) {
                ctx[arg.name].apply(ctx, arg['arguments']);
            });
            ctx.closePath();
        }

        function safeImage(item) {
            if (safeImages.indexOf(item['arguments'][0].src) === -1) {
                testctx.drawImage(item['arguments'][0], 0, 0);
                try {
                    testctx.getImageData(0, 0, 1, 1);
                } catch (e) {
                    testCanvas = doc.createElement("canvas");
                    testctx = testCanvas.getContext("2d");
                    return false;
                }
                safeImages.push(item['arguments'][0].src);
            }
            return true;
        }

        function renderItem(ctx, item) {
            switch (item.type) {
                case "variable":
                    ctx[item.name] = item['arguments'];
                    break;
                case "function":
                    switch (item.name) {
                        case "createPattern":
                            if (item['arguments'][0].width > 0 && item['arguments'][0].height > 0) {
                                try {
                                    ctx.fillStyle = ctx.createPattern(item['arguments'][0], "repeat");
                                } catch (e) {
                                    Util.log("html2canvas: Renderer: Error creating pattern", e.message);
                                }
                            }
                            break;
                        case "drawShape":
                            createShape(ctx, item['arguments']);
                            break;
                        case "drawImage":
                            if (item['arguments'][8] > 0 && item['arguments'][7] > 0) {
                                if (!options.taintTest || (options.taintTest && safeImage(item))) {
                                    ctx.drawImage.apply(ctx, item['arguments']);
                                }
                            }
                            break;
                        default:
                            ctx[item.name].apply(ctx, item['arguments']);
                    }
                    break;
            }
        }

        return function (parsedData, options, document, queue, _html2canvas) {
            var ctx = canvas.getContext("2d"),
                newCanvas,
                bounds,
                fstyle,
                zStack = parsedData.stack;

            canvas.width = canvas.style.width = options.width || zStack.ctx.width;
            canvas.height = canvas.style.height = options.height || zStack.ctx.height;

            fstyle = ctx.fillStyle;
            ctx.fillStyle = (Util.isTransparent(parsedData.backgroundColor) && options.background !== undefined) ? options.background : parsedData.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = fstyle;
            queue.forEach(function (storageContext) {
                // set common settings for canvas
                ctx.textBaseline = "bottom";
                ctx.save();

                if (storageContext.transform.matrix) {
                    ctx.translate(storageContext.transform.origin[0], storageContext.transform.origin[1]);
                    ctx.transform.apply(ctx, storageContext.transform.matrix);
                    ctx.translate(-storageContext.transform.origin[0], -storageContext.transform.origin[1]);
                }

                if (storageContext.clip) {
                    ctx.beginPath();
                    ctx.rect(storageContext.clip.left, storageContext.clip.top, storageContext.clip.width, storageContext.clip.height);
                    ctx.clip();
                }

                if (storageContext.ctx.storage) {
                    storageContext.ctx.storage.forEach(function (item) {
                        renderItem(ctx, item);
                    });
                }

                ctx.restore();
            });

            Util.log("html2canvas: Renderer: Canvas renderer done - returning canvas obj");

            if (options.elements.length === 1) {
                if (typeof options.elements[0] === "object" && options.elements[0].nodeName !== "BODY") {
                    // crop image to the bounds of selected (single) element
                    bounds = _html2canvas.Util.Bounds(options.elements[0]);
                    newCanvas = document.createElement('canvas');


                    newCanvas.width = Math.ceil(bounds.width);
                    newCanvas.height = Math.ceil(bounds.height);

                    ctx = newCanvas.getContext("2d");
                    ctx.drawImage(canvas, bounds.left, bounds.top, bounds.width, bounds.height, 0, 0, bounds.width, bounds.height);



                    canvas = null;
                    return newCanvas;
                }
            }

            return canvas;
        };
    };
})(window, document);

/*jslint adsafe: false, bitwise: true, browser: true, cap: false, css: false,
  debug: false, devel: true, eqeqeq: true, es5: false, evil: false,
  forin: false, fragment: false, immed: true, laxbreak: false, newcap: true,
  nomen: false, on: false, onevar: true, passfail: false, plusplus: true,
  regexp: false, rhino: true, safe: false, strict: false, sub: false,
  undef: true, white: false, widget: false, windows: false */
/*global jQuery: false, window: false */
//"use strict";

/*
 * Original code (c) 2010 Nick Galbreath
 * http://code.google.com/p/stringencoders/source/browse/#svn/trunk/javascript
 *
 * jQuery port (c) 2010 Carlo Zottmann
 * http://github.com/carlo/jquery-base64
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
*/

/* base64 encode/decode compatible with window.btoa/atob
 *
 * window.atob/btoa is a Firefox extension to convert binary data (the "b")
 * to base64 (ascii, the "a").
 *
 * It is also found in Safari and Chrome.  It is not available in IE.
 *
 * if (!window.btoa) window.btoa = $.base64.encode
 * if (!window.atob) window.atob = $.base64.decode
 *
 * The original spec's for atob/btoa are a bit lacking
 * https://developer.mozilla.org/en/DOM/window.atob
 * https://developer.mozilla.org/en/DOM/window.btoa
 *
 * window.btoa and $.base64.encode takes a string where charCodeAt is [0,255]
 * If any character is not [0,255], then an exception is thrown.
 *
 * window.atob and $.base64.decode take a base64-encoded string
 * If the input length is not a multiple of 4, or contains invalid characters
 *   then an exception is thrown.
 */

jQuery.base64 = (function ($) {

    var _PADCHAR = "=",
        _ALPHA = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        _VERSION = "1.0";


    function _getbyte64(s, i) {
        // This is oddly fast, except on Chrome/V8.
        // Minimal or no improvement in performance by using a
        // object with properties mapping chars to value (eg. 'A': 0)

        var idx = _ALPHA.indexOf(s.charAt(i));

        if (idx === -1) {
            throw "Cannot decode base64";
        }

        return idx;
    }


    function _decode(s) {
        var pads = 0,
            i,
            b10,
            imax = s.length,
            x = [];

        s = String(s);

        if (imax === 0) {
            return s;
        }

        if (imax % 4 !== 0) {
            throw "Cannot decode base64";
        }

        if (s.charAt(imax - 1) === _PADCHAR) {
            pads = 1;

            if (s.charAt(imax - 2) === _PADCHAR) {
                pads = 2;
            }

            // either way, we want to ignore this last block
            imax -= 4;
        }

        for (i = 0; i < imax; i += 4) {
            b10 = (_getbyte64(s, i) << 18) | (_getbyte64(s, i + 1) << 12) | (_getbyte64(s, i + 2) << 6) | _getbyte64(s, i + 3);
            x.push(String.fromCharCode(b10 >> 16, (b10 >> 8) & 0xff, b10 & 0xff));
        }

        switch (pads) {
            case 1:
                b10 = (_getbyte64(s, i) << 18) | (_getbyte64(s, i + 1) << 12) | (_getbyte64(s, i + 2) << 6);
                x.push(String.fromCharCode(b10 >> 16, (b10 >> 8) & 0xff));
                break;

            case 2:
                b10 = (_getbyte64(s, i) << 18) | (_getbyte64(s, i + 1) << 12);
                x.push(String.fromCharCode(b10 >> 16));
                break;
        }

        return x.join("");
    }


    function _getbyte(s, i) {
        var x = s.charCodeAt(i);

        if (x > 255) {
            throw "INVALID_CHARACTER_ERR: DOM Exception 5";
        }

        return x;
    }


    function _encode(s) {
        if (arguments.length !== 1) {
            throw "SyntaxError: exactly one argument required";
        }

        s = String(s);

        var i,
            b10,
            x = [],
            imax = s.length - s.length % 3;

        if (s.length === 0) {
            return s;
        }

        for (i = 0; i < imax; i += 3) {
            b10 = (_getbyte(s, i) << 16) | (_getbyte(s, i + 1) << 8) | _getbyte(s, i + 2);
            x.push(_ALPHA.charAt(b10 >> 18));
            x.push(_ALPHA.charAt((b10 >> 12) & 0x3F));
            x.push(_ALPHA.charAt((b10 >> 6) & 0x3f));
            x.push(_ALPHA.charAt(b10 & 0x3f));
        }

        switch (s.length - imax) {
            case 1:
                b10 = _getbyte(s, i) << 16;
                x.push(_ALPHA.charAt(b10 >> 18) + _ALPHA.charAt((b10 >> 12) & 0x3F) + _PADCHAR + _PADCHAR);
                break;

            case 2:
                b10 = (_getbyte(s, i) << 16) | (_getbyte(s, i + 1) << 8);
                x.push(_ALPHA.charAt(b10 >> 18) + _ALPHA.charAt((b10 >> 12) & 0x3F) + _ALPHA.charAt((b10 >> 6) & 0x3f) + _PADCHAR);
                break;
        }

        return x.join("");
    }


    return {
        decode: _decode,
        encode: _encode,
        VERSION: _VERSION
    };

}(jQuery));

